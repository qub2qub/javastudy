Шаблоны -- это наборы типовых проблем и их решений.
Работа с шаблоном идёт на уровне абстракций.
Их можно повторно использовать или дорабатывать.

Типа шаблонов:
1) Порождающие-Creational == отвечают за создание объектов
	1.1) Singleton - одиночка
	1.2) Factory Method - Фабричный метод (Виртуальный конструктор)
	1.3) Abstract Factory - Абстрактная фабрика

2) Структурные-Structural == отвечают за изменение и доработку существующих интерфейсов. (изменяют структуру уже созданного объекта)
		2.1) Decorator - Декоратор (WRAPPER - ОБЁРТКА)
		2.2) Adapter - Адаптер
		2.3) Facade - Фасад

3) Поведенческие-Behavioral == отвечают за взаимодейсвие между объектами, после их применение уменьшается кол-во связей между объектами.
	3.1) STATE - СОСТОЯНИЕ
	3.2) STRATEGY - СТРАТЕГИЯ
	3.3) OBSERVER - НАБЛЮДАТЕЛЬ

****************************************************
3.1) STATE - СОСТОЯНИЕ
__Объект меняет своё поведение в зависимости от своего состояния
__Можно создавать разые состояние одного и того же объекта, и в зависимости от того состояния, в котором нах-ся объект, он будет делать действия по-разному.
__Позволяет избежать многочисленных условий if
__[Состояние присуще объекту, т.е. состояние хранится в объекте]
Объект содержит в себе (инкапсулирует) "объект состояния"  и предоставляет клиенту API=метод, в котором ис-ет состояние, т.е. в [своём public API методе] вызывает [абстракный метод из интерфейса-состояния] (для подсчёта цены, например), а по факту будет вызвана логика того состояния, которое было передано/хранится.

Т.е. есть общий-абстрактный интерфейс, который описывает какое-то абстрактное действие. Клиент использует этот дейтсвие. 
Но конкретный результат действия быдут разным, в зависимости от переданного ему состояния.

Например,
1) у трансфомера есть метод action(), если  состояние=машина - он едет, если состояние=робот - стреляет.
2) у товара есть метод рассчитатьСтоимость(), если товар в обычном состоянии -- цена стандартна, если товар на скидке - цена будет меньше.

Т.е. у клинта в распоряжении какое-то 1 действие. И он в различное время его вызывает.
Например, у генерала есть личинка бабочки.
Он ей 3 раза через неделю командует -- пой и УХОДИ !! и при этом кормит/воздействует на неё.
1) сначала личинкой они ничего не может делать.
2) через неделю гусеницей -- она ползёт, но петь не может.
3) через неделю бабочкой -- она летит, но петь не может.
4) если бы потом бабочка трансформировалась в кузнечика -- она бы могла прагать и петь=стрекотать.

Объекту нужно перейти в это состояние,
т.е. передать "объект состояния", который будет храниться в классе.
например,
Есть человек (интерфейс БОЕЦ), который учиться драться.
и есть различные состояния, в которых он может драться:
1) сначала он учился каратэ (как каратист)
2) потом борьбе (как борец)
3) потом на любки

Будет интерфейс ТРЕНЕР, который на экзамене проверяет 4 способности (разные=много, т.е. не 1 действие, а много различных действий из 1 текущего состояния):
1-удар рукой, 2-удар ногой, 3-блок, 4-присед
а разные состояния, по-разному будут делать эти действия.

Тренер учит бойца, переводя из состояния в состояние, и каждую неделю проверяет на экзамене, как он может делать свои 4 способности.

но проектировать драгу можно общими понятиями -- 
1-ударить рукой, 2-блок, 3-удар ногой, 4-присед.
Каждый сделает эту постановку, но в своей технике.

****************************************************
3.2) STRATEGY - СТРАТЕГИЯ
Есть заданное действие, но его можно выполнить разными способами.
Например, Collections.sort(), в зависимости от Comparetor будут разные способы выполнения.
__Значит, выбор одного алгоритма действия из семейства алгоритмов для достижения той же цели.
__Не зависит от конкретных реализаций, потому что он ис-ет интерфейсы.
__Смысл действия = один и тот же, а реализации действия - разные.

Для работы, нужно минимум 3-4 класса:
1) есть интерфейс для сервиса с требуемым действием-методом. (стратегическое направление действия).
Например, AuthStrategy::checkLogin(name, pwd).
2) Есть различные реализации этой стратегии (интерфейса), они реализуют этот метод (достигают результат данной стратегии). 
Это семейство алгоритмов для цели=стратегии из п.1.
3) есть интерфейс для клиента, который ис-ет сервис из п.1., и в к-й надо передать конкретый алгоритм из семейства.
Т.е. клиент вызывает стратегию=цель=метод интерфейса-сервиса, и задаёт конкретный способ достижения (по факту выполнится конкретная реализация).

ОТЛИЧИЯ ОТ ШАБЛОНА "СОСТОЯНИЕ" STATE:
1) Не хранит ссылку на объект стратегии
2) Одноразовое действие и только одно действие (и при кадом вызове надо передавать конкретную реализацию алгоритма стратегии)
[при STATE объект может МНОГО РАЗ делать РАЗНЫЕ ДЕЙСТВИЯ для данного состояния].


Например, есть стартегия = "вырыть ров";
Семейство, алгоритмы, реализации = 
1) экскаватором (быстро-глубоко),  
2) лопатой (долго-неглубоко),  
3) взорвать (быстро-неточно).
Генерал говорит, ЧТО надо "вырыть ров", и говорит ЧЕМ "лопатой". 
И, если надо, говорит КАК собрать лопату, или как завести экскаватор или где взять взрывчатку.

Или есть интерфейс БОЕЦ, у которого есть метод блок (п.1),
И должен быть тренер, который скажет бойцу, как именно делать блок. 
есть разные виды блоков (из семейства блоков) для этого интерфейса (п.2 - это различные реализации п.1):
1-нож, 2-палка, 3-кирпич, 4-по умолчанию, ничего, будет блок руками.

При проектировании драки, используем базовый метод блок (в который необходимо передать предмет).
Результат (что удар будет заблокирован) будет достигнут в любом случае.

Или когда для аутентификации ис-ть разные источники:
1-веб сервис, 2-файл, 3-БД.

Будет доп интерфейс с методом(который вернёт - был ли юзер осентикэйтед), куда надо передать стратегию проверки, а в неё передать логин и пароль.

****************************************************
3.3) OBSERVER - НАБЛЮДАТЕЛЬ
Поведенческий.
Слушает некоторое поведение и реагирует на некоторые события.
  _3.1) представляет собой связь по принципу pusblisher/subscriber
(например, подписки в инете. swing onClickListener())
  _3.2) наблюдатель ждёт наступление определённого события и оповещает о нём всех слушателей.
  _3.3) Делает слабую зависимость low coupling.

паблишер не знает подписчиков, а только предоставляет интерфейс для оповещения. 

В интерфейсе pusblisher должны методы для добавления/удаления определённых Listener-ов, и метод для оповещения всех подпищиков.
У Listener-ов тоже должен быть свой интерфейс, в нём метод, который будет вызываться паблишером по событию.
__Т.е. в паблишере отдельно генерируется какое-то событие, и в этом месте также дополнительно вызывается метод, который даст знать всем подписчикам, что событие произошло.

Например, как звонить в колокол каждый час.
паблишер/observer -- это колокол, который звонит, и при этом к бойку можно привязать верёвочки (лиснеров/subscriber) к другим объектам. 
При новом часе, происходит событие, колокол бьёт, верёвочки дёргаются и узнают что произошло событие.
Разные колокола = разные события.
1 объект можно привязять к несколькиим разным колоколам, для обработки разных событий (если удовлетворены условия, что например к 1му колоколу можно привязаться только синей верёвочкой, а ко 2му - красной --- и у объекта есть все эти верёвочки.)
Или у объекта есть много одинаковых верёвовочек, и к разным колоколам можно привязаться этим типом верёвочек.


****************************************************
1.1) Singleton - одиночка
   _1) Для создания объекта в единственном экземпляре.
   _2) Как правило с глобальным доступом к нему.
   _3) Можно управлять кол-вом экземпляров объекта. (например, нужно 2 объекта)
   _4) Есть единая точка доступа к синглтону.

****************************************************
1.2) Factory Method  - Фабричный метод (Виртуальный конструктор)
Используется когда:
	_1) Известен интерфей, но заранее неизвестно, какая из реализаций будет ис-ся.
	_2) Получение ссылки на объект в зависимости от входных условий.
Например, есть интерфейс авто, с методами ехать() и остановиться().
И разные реализации для разных машин: спорт, джип, трактор.

Ис-ся чтобы сделать создание объектов более гибким. 
Т.е. есть "Фабрика по созданию всех видов авто", и "у неё есть метод", который их непосредственно и создаёт, В ЗАВИСИМОСТИ ОТ ВХОДНЫХ ПАРАМЕТРОВ.
Сама фабрика -- "типа синглтон". Т.е. 1 экземпляр на всю прилагу.

Т.е. если для данного параметра нужно будет возвращать другой тип объектов - то нужно будет ТОЛЬКО В ФАБРИЧНОМ МЕТОДЕ поменять возвращаемый объект.

Например, сервис для сохранения данных в разные места: ДБ, файл, сайт.
И если на вход пришёл параметр: 
URL - то возвращаем сайт,
ДБ_ссылка - возвращаем БД, 
путь на диске -- возвращаем файл.

****************************************************
1.3) Abstract Factory - Абстрактная фабрика
Он более объёмный и чаще используемый, чем Фабричный метод.
	_1) Фабрика по созданию семейства объектов разных типов (в отличие от "Фабричный метод", где возвращается экземпляр всегда одного и того же типа.)
	_2) Т.е. это более расширенный вариант шаблона "Фабричный метод".
	_3) Объекты внутри фабрики связаны по смыслу или задаче (но не связаны по типу).
__Т.е. есть набор разных объектов для конкретной цели/задачи,
но все объекты целиком могут быть разных реализаций/видов (в зависимости от каких-то условий).
И для каждого условия будет своя отдельная фабрика, которая будет произвоить весь набор всех этих объектов под эти конкретные условия.
__Какая фабрика будет выбрана -- зависит от конфига при старте прилаги.
Т.е. какие ИМЕННО объекты будут созданы -- зависит от конфига.

Например, есть фабрика по создание любых транспортных средств, в т.ч. самолёты, пароходы, машины, и др.
Но разделение будет например, по назначению ТС или использованию,
например, 
	военные ТС, 
	гражданские -- городские или сельские,
	спец назначения -- пожарные, скорой помощи, милиции, президентские.
------ или про другому типу:
	по принадлежности завода -- российские, китайские, американские..
	а в них уже можно делить по назначению ТС.
	т.е. будут как бы 2 вложенные фабрики.

Или кнопки для интерфейса, и для разных ОС будут разные наборы всех UI элементов.
И логика будет строиться на основе абстракций, конкретные реализации будут подставлени после старта прилаги.

****************************************************
2.1) Decorator - Декоратор (WRAPPER - ОБЁРТКА)
Делает возможным:
   _1) Расширение функционала объекта без создания дочерних классов (альтернатива наследованию)
   _2) Гибкий способ добавить ЛЮБОЕ КОЛ-ВО нового функционала к ЛЮБОМУ существующему объекту.
   _3) Можно ВЛК/ВЫКЛ этого нового поведения у любого объекта в любое время
   _4) Когда невозможно наследоваться, но надо добавить новое поведение (к-е может быть не связано по смыслу)
   _5) Декораторы можно вкладывать друг в друга.
   _5) Одни и те же Декораторы(любую комбинацию декораторов) можно применять ко всем/любым объектам данного типа.
Для наследования желательно поддреживать связь "является" (is a).

Например, есть интерфейс Компонент, у к-го 1 метод "нарисоваться()".
И надо к каждому компоненту добавить рамку и возможность изменения цвета.
Например, Сначала создаём абстрактный класс декоратор, который реализует исходный интерфейс Компонент. 
абстрактный метод -- это наш доп функционал, его будут реализовывать наши декораторы.

В декораторе надо сделать:
 1) реализовать исходный интерфейс объекта.
 2) через композицию вставляем исходный компонент(при создании декоратора через его конструктор передаём оборачиваемый объект), 
 3) преопределям методы интрефейса, и в них добавляем:
 		3.1) вызов методов исходного инкапсулированного объекта
 		3.2) вызов своего функционала (над инкапсулированным объектом)
 4) релизуем логику своего доп. функционала

****************************************************
2.2) Adapter - Адаптер
Помогает двум разным интерфейсам работать вместе.
Реализуется композицией или наследованием.
!!! Т.е. АДАПТЕР СОВМЕЩАЕТ ЖЕЛАНИЯ КЛИЕНТА И ВОЗМОЖНОСТИ БИБЛИОТЕКИ.

Например, в библиотеке есть класс, который петает только 1 строку.
А надо напечатать все строки из списка.

1) Создаём новый интерфейс, в нём определяем метод для клиента.
2) Реализуем интерфейс: 
		2.1) композицией вставляем класс из библ,
		2.2) реализуем клиентский метод ис-я этот инкапсулированный класс.

****************************************************
2.3) Facade - Фасад
Ис-ся когда нужно:
 _1) Скрыть сложную внутреннюю реализацию и предоставить простой интерфейс
 _2) Т.е. для упрощения взаимодейсвия с объектами системы (или нескольких систем)
 _3) Иногда, Можно обращаться и к самим внутренним объектам без фасада.

Например, для составных действий, чтобы юзер не создавал/вызывал каждое действие самостоятельно, а вызвал 1 метод из фасада, который всё это сделает.