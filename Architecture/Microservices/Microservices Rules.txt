КОМПОНЕНТ — это единица программного обеспечения, которая может быть независимо заменена или обновлена.

Ключевое свойство компонента — это независимость его замены или обновления, что подразумевает наличие ситуаций когда его можно переписать с нуля без затрагивания взаимодействующих с ним компонентов. 

МОДУЛЬНОСТЬ определяется скоростью изменения функционала. 
Вещи, которые изменяются вместе, должны храниться в одном модуле. 
Части системы, изменяемые редко, не должны находиться вместе с быстроэволюционирующими сервисами.
Если вы регулярно меняете два сервиса вместе, задумайтесь над тем, что возможно их следует объединить.

***************************
1) Object Oriented Programming (OOP)—a modern programming paradigm (see also SOLID)
2) Web service / API—a way to expose the functionality of your application to others, without a user interface
3) Service Oriented Architecture (SOA)—a way of structuring many related applications to work together, rather than trying to solve all problems in one application
4) Systems—in the general sense, meaning any collection of parts that can work together for a wider purpose
5) Single Responsibility Principle (SRP)—the idea of code with one focus
6) Interface Segregation Principle (ISP)—the idea of code with defined boundaries.
***************************
the crucial advantage of microservice architecture is not that we never share business rules/processes/policies, but that we push them into discrete packages, aligned to business needs.  Not only does this mean that policy is distributed, but it also means that you can change your business processes without risk.
***************************
____________ Pros ____________
1) Microservice architecture gives developers the freedom to independently develop and deploy services
2) A microservice can be developed by a fairly small team
3) Code for different services can be written in different languages (though many practitioners discourage it)
4) Easy integration and automatic deployment (using open-source continuous integration tools such as Jenkins, Hudson, etc.)
5) Easy to understand and modify for developers, thus can help a new team member become productive quickly
6) The developers can make use of the latest technologies
7) The code is organized around business capabilities
8) Starts the web container more quickly, so the deployment is also faster
9) When change is required in a certain part of the application, only the related service can be modified and redeployed—no need to modify and redeploy the entire application
10) Better fault isolation: if one microservice fails, the other will continue to work (although one problematic area of a monolith application can jeopardize the entire system)
11) Easy to scale and integrate with third-party services
12) No long-term commitment to technology stack

__________ Cons ____________
1) Due to distributed deployment, testing can become complicated and tedious
2) Increasing number of services can result in information barriers
3) The architecture brings additional complexity as the developers have to mitigate fault tolerance, network latency, and deal with a variety of message formats as well as load balancing
4) Being a distributed system, it can result in duplication of effort
5) When number of services increases, integration and managing whole products can become complicated
6) In addition to several complexities of monolithic architecture, the developers have to deal with the additional complexity of a distributed system
7) Developers have to put additional effort into implementing the mechanism of communication between the services
8) Handling use cases that span more than one service without using distributed transactions is not only tough but also requires communication and cooperation between different teams
9) The architecture usually results in increased memory consumption
10) Partitioning the application into microservices is very much an art

***************************

Плюсы и минусы и решение для микросервисов:

(1) --------- сервисы вместо библиотек ---------
Главная причина использования сервисов вместо библиотек — это независимое развертывание. 
(-) Если вы разрабатываете приложение, состоящее из нескольких библиотек, работающих в одном процессе, любое изменение в этих библиотеках приводит к переразвертыванию всего приложения. 
(+) Но если ваше приложение разбито на несколько сервисов, то изменения, затрагивающие какой-либо из них, потребуют переразвертывания только изменившегося сервиса.
(*) Конечно, какие-то изменения будут затрагивать интерфейсы, что, в свою очередь, потребует некоторой координации между разными сервисами, 

(2) --------- сервисы как компоненты ---------
(+) более явный интерфейс между компонентами. 
(-) Большинство языков программирования не имеют хорошего механизма для объявления Published Interface. 
(-) Удаленные вызовы работают медленнее, чем вызовы в рамках процесса, и поэтому API должен быть менее детализированным (coarser-grained), что часто приводит к неудобству в использовании.
(*) в сервисах - через использование явного механизма удаленных вызовов.

(3) --------- кол-во процессов в 1 сервисе? ---------
(*) сервисы соотносятся с процессами как один к одному. На самом деле сервис может содержать множество процессов, которые всегда будут разрабатываться и развертываться совместно. Например, процесс приложения и процесс базы данных, которую использует только это приложение.

(4) --------- приложение разбивается на части ---------
(*) Микросервисный подход к разбиению подразумевает раазбиение на сервисы в соответствии с потребностями бизнеса. Такие сервисы включают в себя полный набор технологий, необходимых для этой бизнес-потребности, в том числе пользовательский интерфейс, хранилице данных и любые внешние взаимодействия.
(-) Крупные монолитные приложения тоже могут быть разбиты на модули вокруг бизнес потребностей, хотя обычно этого не происходит. 

(5) --------- размер команды для микросервиса ---------
(*)  На данный момент мы считаем, что оба этих подхода к построению команд (1 сервис на 12 человек и 1 сервис на 1 человека) подходят под описание микросервисной архитектуры, но возможно мы изменим свое мнение в будущем. (прим. перев.: со времен статьи появилось множество других статей, развивающих эту тему; наиболее популярным сейчас считается мнение о том, что сервис должен быть настолько большим, чтобы он мог полностью «уместиться в голове разработчика», независимо от количества строк кода).

(6) --------- продукты ---------
(*) команда должна владеть продуктом на протяжении всего срока его жизни. 

(7) --------- выстраивании коммуникаций между процессами ---------
(-) в механизмы передачи данных помещалась существенная часть логики.
(+) для микросервисов -- умные приемники сообщений и глупые каналы передачи. [Smart endpoints and dumb pipes]
Микросервисы содержат собственную доменную логику и выступают больше в качестве фильтров в классическом Unix-овом смысле — получают запросы, применяют логику и отправляют ответ. 
(+) Второй часто используемый инструмент коммуникации — легковесная шина сообщений.
(*) В монолитном приложении компоненты работают в одном процессе и коммуницируют между собой через вызов методов. Наибольшая проблема в смене монолита на микросервисы лежит в изменении шаблона коммуникации. 

(8) --------- Децентрализация реализаций  ---------
(+) Разбивая монолит на сервисы, мы имеем выбор, как построить каждый из них.
(*) Комьюнити микросервисов ценит сервисные контракты, но не любит оверхеды и поэтому использует различные пути управления этими контрактами.

(9) --------- Микросервисы и SOA ---------
(-) Service Oriented Architecture (SOA) имеет разные значения. 
(*) некоторые сторонники микросервисов отказываются от термина «SOA», хотя другие при этом считают микросервисы одной из форм SOA

(10) --------- Децентрализованное управление данными ---------
(+)  концептуальная модель мира у разных систем будет отличаться. 
(*) Эту проблему хорошо решает понятие Bounded Context из Domain-Driven Design (DDD). DDD предлагает делить сложную предметную область на несколько контекстов и мапить отношения между ними. 
(-) монолитные приложения склонны к использованию единственной БД,
Микросервисы предпочитают давать возможность каждому сервису управлять собственной базой данных: как создавать отдельные инстансы общей для компании СУБД, так и использовать нестандартные виды баз данных. Этот подход называется Polyglot Persistence. 
(-) проблемы с консистентностью данных, реализации распределённых транзакций.

(11) --------- Проектирование под отказ (Design for failure) ---------
(*) Следствием использования сервисов как компонентов является необходимость проектирования приложений так, чтобы они могли работать при отказе отдельных сервисов.
Очень важно иметь возможность быстро обнаружить неполадки и, если возможно, автоматически восстановить работоспособность сервиса. Микросервисная архитектура делает большой акцент на мониторинге приложения в режиме реального времени, проверке как технических элементов (например, как много запросов в секунду получает база данных), так и бизнес-метрик (например, как много заказов в минуту получает приложение). Семантический мониторинг может предоставить систему раннего предупреждения проблемных ситуаций, позволяя команде разработке подключиться к исследованию проблемы на самых ранних стадиях.
(-) Это особенно важно с случае с микросервисной архитектурой, т.к. разбиение на отдельные процессы и коммуникация через события приводит к неожиданному поведению.

(12) --------- Синхронные вызовы ---------
Синхронные вызовы считаются опасными.
(-) Каждый раз когда вы имеете набор синхронных вызовов между сервисами, вы сталкиваетесь с эффектом мультипликации времени простоя (downtime). Время простоя вашей системы становится произведением времени простоя индивидуальных компонент системы.

(13) --------- эволюция Evolutionary design ---------
(+) Веб-сайт Guardian — хороший пример приложения, которое было спроектировано и построено как монолит, но затем эволюционировало в сторону микросервисов. Ядро сайта все еще остается монолитом, но новые фичи добавляются путем построения микросервисов, которые используют API монолита. Такой подход особенно полезен для функциональности, которая по сути своей является временной.

(14) --------- деплой и интеграция ------------
(+) Помещение компонент в сервисы добавляет возможность более точного (granular) планирования релиза. 
С монолитом любые изменения требуют пересборки и развертывания всего приложения. 
С микросервисами вам нужно развернуть (redeploy) только те сервисы, что изменились.

(-) Недостаток такого подхода в том, что вам приходится волноваться насчет того, что изменения в одном сервисе сломают сервисы, обращающиеся к нему. 

(*) Традиционный подход к интеграции заключается в том, чтобы решать такие проблемы путем версионности, но микросервисы предпочитают использовать версионность только в случае крайней необходимости. Мы можем избежать версионности путем проектирования сервисов так, чтобы они были настолько толерантны к изменениям соседних сервисов, насколько возможно.

(15) ------------ минус рефакторинга и тестирования ------------
Когда ваши компоненты являются сервисами, общающимися между собой удаленно, проводить рефакторинг намного сложнее, чем в случае с библиотеками, работающими в одном процессе. Перемещение кода между границами сервисов, изменение интерфейсов должны быть скоординированы между разными командами. Необходимо добавлять слои для поддержки обратной совместимости. Все это также усложняет процесс тестирования.

(16) ------ минус спрятанной сложности ------ 
Если компоненты не подобраны достаточно чисто, происходит перенос сложности из компонент на связи между компонентами. 
Создается ложное ощущение простоты отдельных компонент, в то время как вся сложность находится в местах, которые труднее контролировать.

(17) ------ Слабые команды всегда создают слабые системы ----

*******************************************************