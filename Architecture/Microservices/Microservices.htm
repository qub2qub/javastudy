<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Microservices</title>
    <link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
<a href="http://eax.me/micro-service-architecture/">src</a>
<div class="post" id="post-26618">
                <div class="post-top">
                    <div class="post-title">
                        <div class="left">
                          <h2>Преимущества и недостатки микросервисной архитектуры</h2>
                          <div style="float: left;">
                          <p>27 января 2014</p>
                          </div>
                          <div style="float: right;"></div>
                          <div style="clear: both;"></div>
                        </div>
                    </div>
                </div>
				<div class="entry">
					<p>Если вкратце, микросервисная архитектура (Micro Service Architecture, MSA), это когда ваше приложение представляет собой много-много небольших (буквально несколько сотен строк кода) сервисов, взаимодействующих между собой путем обмена сообщениями. Это могут быть сообщения <a href="http://eax.me/erlang/">Erlang</a>‘а, <a href="http://eax.me/cloud-haskell/">Cloud Haskell</a>‘я, Akka, или же REST API, Protobuf, <a href="http://eax.me/haskell-messagepack/">MessagePack</a> и так далее. Давайте же попытаемся понять, в каких задачах может быть целесообразно использовать такой подход, чем он хорош, и, конечно же, чем он плох. <span id="more-26618"></span></p>
<p>Но сначала остановимся немного поподробнее на вопросе «что такое MSA».</p>
<p>В действительности, идея не особо нова. Есть такая штука, как <a href="http://en.wikipedia.org/wiki/Service-oriented_architecture">SOA (Service-oriented architecture)</a>. По всей видимости, все отличие SOA от MSA заключается в размере сервисов. В случае с MSA исходный код каждого отдельного сервиса не должен превышать нескольких сотен строк кода. SOA же такого ограничения вроде бы не накладывает, поэтому в каждом сервисе могут быть десятки или сотни тысяч строк кода. Видимо, MSA — это частный случай SOA.</p>
<p>Идеи, заложенные в MSA, давно знакомы программистам на Erlang. И&nbsp;вправду, редкий <a href="http://eax.me/erlang-gen-server/">gen_server</a> содержит в себе более нескольких сотен строк кода. И общение с внешним миром действительно производится путем обмена сообщениями. Erlang даже позволяет нам обновить код gen_server’а, не повлияв при этом на другие процессы в системе. Однако MSA предполагает, что каждый сервис представляет собой совершенно независимое приложение. Сервисы в системе могут быть написаны на различных языках программирования и общаться между собой, используя различные протоколы. С высокой степенью точности можно сказать, что процессы и сообщения, предлагаемые Erlang’ом — это частный случай MSA.</p>
<p>Наконец, есть такая давно известная и проверенная временем штуковина, как <a href="http://eax.me/unix-way/">философия UNIX</a>. Она <a href="http://www.faqs.org/docs/artu/ch01s06.html">гласит</a> следующее. Пишите программы, которые делают одну вещь и делают ее хорошо. Пишите программы, которые работают вместе. Пишите программы, работающие с текстовыми потоками данных, потому что это универсальный интерфейс. Фактически, MSA, использующий REST, представляет собой философию UNIX, перенесенную на <a href="http://eax.me/server-side/">серверсайд</a>.</p>
<p>Чтобы не возникало каши в голове, отметим, что: 
<ul>
	<li>Erlang — это такой прикольный язык программирования, </li>
	<li><a href="http://eax.me/akka-basics/">Akka</a> и Cloud Haskell — библиотеки,</li>
	<li>модель акторов — это математическая модель, </li>
	<li>MSA — это архитектура.</li>
</ul>
Идея примерно одна и та же, но слова и кое-какие детали меняются, в зависимости от того, с кем и на каком уровне абстракции вы общаетесь.</p>
<p>Чем же так хороша микросервисная архитектура?</p>
<ol>
<br><li> - Писать и поддерживать небольшие сервисы всегда проще, чем большие. Чем меньше кода, тем легче уместить его в голове;</li>
<br><li> - Если вы решили использовать REST API, то получаете все присущие ему преимущества. Подробности можно найти в <a href="http://eax.me/rest/">этой</a> и <a href="http://eax.me/distributed-erlang/">этой</a> заметках;</li>
<br><li> - Поскольку каждый микросервис представляет собой отдельный проект, вы можете практически как угодно распределить их между командами разработчиков. Вы можете строить иерархии из сервисов. То есть, некие сервисы будут использованы только парой сервисов, предоставляющих внешний API для других сервисов. Это масштабируемый подход, то есть, над системой могут одновременно трудиться многие десятки программистов. И никаких проблем с разрешением конфликтов или поиском сложных логических ошибок, появляющихся в результате двух коммитов, сделанных разными программистами;</li>
<br><li> - Если вы что-то помните о бизнес-моделировании и EPC-диаграммах, то можете к своему удивлению обнаружить, что бизнес-процессы хорошо ложатся на MSA;</li>
<br><li> - Для каждого сервиса можно выбрать язык и библиотеки, подходящие конкретно для решаемой этим сервисом задачи. Если нужна скорость, берем C++, если просто гоняем туда-сюда данные, берем Erlang, если нужна какая-то необычная библиотека, берем <a href="http://eax.me/eaxcast-s02e05/">Clojure</a>;</li>
<br><li> - Практически из коробки получаем горизонтально масштабируемый и отказоустойчивый код, да и к тому же с конвейерным параллелизмом. Даже если вы пишите на Python или OCaml. При «монолитном» же подходе часто <a href="http://eax.me/effective-optimization/">в целях оптимизации</a> хочется по-быстрому впилить тут кэшик, там кэшек, и в итоге система становится не масштабируемой. Потому что кэши так просто выпилить нельзя, а поддерживать их в актуальном состоянии, когда в системе N копий одного сервиса, не <span style="white-space: nowrap;">так-то</span> просто. Горизонтальное масштабирование, как известно, приводит к&nbsp;экономии денег, так как система может работать на множестве сравнительно недорогих машин. Более того, под каждый конкретный микросервис можно подобрать железо подходящей конфигурации;</li>
<br><li> - Если в программе всего лишь несколько сотен строк кода, в ней не <span style="white-space: nowrap;">так-то</span> просто сделать ошибку. Необходимость <a href="http://eax.me/unit-testing/">юниттестов</a> становится сомнительной, а использовать языки с <a href="http://eax.me/dynamic-typing/">динамической типизацией</a> уже вроде как и не страшно. Упрощается тестирование, ибо полностью покрыть тестами API одного сервиса не представляет большого труда. Можно с легкостью замокать внешние сервисы. Зачем это нужно, подробнейшим образом <a href="http://eao197.blogspot.ru/2010/02/work-prog.html">расписано у eao197</a>. Понятно, что один <span style="white-space: nowrap;">мок-сервис</span> можно повторно использовать при тестировании других зависящих от него сервисов. Не требуется специальное тестовое окружение, сервис можно разрабатывать прямо у себя на макбуке;</li>
<br><li> - Никто не говорил, что абсолютно все сервисы нужно обязательно писать самому. Всякие там <a href="http://eax.me/graphite/">Graphite</a>, <a href="http://eax.me/rabbitmq/">RabbitMQ</a>, <a href="http://eax.me/riak/">Riak</a>, <a href="http://eax.me/postgresql-vs-mysql/">PostgreSQL и MySQL</a>, или даже <a href="http://eax.me/nginx/">Nginx, отдающий статику</a> с JavaScript, который ходит в наш REST API, также можно рассматривать, как сервисы, являющиеся частью системы. Хотя, конечно же, в них далеко не пара сотен строк кода;</li>
<br><li> - Модульность. Захотел сделать апдейт — катишь сервис. Если <a href="http://eax.me/akka-kamon/">по метрикам видишь</a>, что что-то не так, откатываешь. В какой-то момент заметили, что в сервис больше никто не ходит — просто выключаем его. Вместо рефакторинга проще выбросить сервис и написать его с нуля. Если где-то в системе крутится ужасный легаси говнокод, но при этом он работает, пускай себе работает, глаза при этом он никому не мозолит;</li>
<br><li> - Нетрудно отследить зависимости между сервисами. Если все сервисы зависят друг от друга, наверное, что-то в архитектуре вашей системы не так. Если количество связей не намного превышает количество узлов, значит вы на верном пути. Также нетрудно найти критические пути, единые точки отказа и так далее;</li>
<br><li> - Не страшно экспериментировать с новыми технологиями. Захотел попробовать новый веб-фреймворк, ORM или, например, <a href="http://eax.me/avoid-new-toys/">протащить в проект Haskell</a> — переписываешь существующий сервис и смотришь, насколько это будет работать. Если не работает, откатываешь к старой версии. Попробуйте так просто взять и перейти с Django на другой фреймворк в «монолитном» проекте;</li>
<br><li> - Сравнительно нетрудно переписать легаси систему в соответствии с MSA. Ставим перед системой зонтик/прокси. Затем потихоньку выносим компоненты системы в сервисы, а прокси следит за тем, чтобы клиенты ходили туда, куда нужно;</li>
<br><li> - Даже если ты пилишь тупо сайтик, с MSA чувствуешь себя крутым разработчиком распределенной системы :)</li>
</ol>
<p><b>Очевидный недостаток всего этого хозяйства заключается в необходимости гонять данные между микросервисами</b>. Если накладные расходы на обмен сообщениями, а также их сериализацию и десериализацию, слишком велики, нужно либо оптимизировать протокол, либо подвинуть взаимодействующие сервисы друг к другу поближе, либо объединить их в один микросервис. Не так-то просто все это админить, хотя, если ваши админы осилили <a href="http://en.wikipedia.org/wiki/Chef_(software)">Chef</a>, то, скорее всего, особых проблем быть не должно. Очевидно, при использовании MSA следует <a href="http://eax.me/haskell-hslogger/">серьезно отнестись к логированию</a> (вероятно, в отдельный пул сервисов) и <a href="http://eax.me/nagios/">мониторингу</a>. Притом те, кто используют MSA, рекомендуют в первую очередь собирать бизнес метрики — количество продаж, результаты А/Б тестирования и так далее. Все это, впрочем, справедливо в отношении любой серьезной системы.</p>
<p>Если ваши микросервисы используют какую-нибудь общую библиотеку, а в этой библиотеке, например, обнаружилась бага, то нужно обновить версию библиотеки во всех сервисах, а потом все их раскатить. Поэтому при использовании MSA общего кода должно быть как можно меньше. Общий код должен быть либо предельно простым, либо меняться крайне редко. Иногда, если сервисы делают похожие вещи, код лучше скопипастить, потому что в будущем эти вещи могут стать не такими уж и похожими. Ну и, конечно же, ни в коем случае не используйте <span style="white-space: nowrap;">какие-нибудь</span> общие инклудники с объявлениями record’ов, как это порой делают в&nbsp;Erlang.</p>
<p>Ссылки по теме:</p>
<ul>
<li>Пост <a href="http://yobriefca.se/blog/2013/04/29/micro-service-architecture/">Micro Service Architecture</a> в блоге James Hughes;</li>
<li>Длинный, но <a href="https://plus.google.com/+RipRowan/posts/eVeouesvaVX">преинтереснейший пост</a> о платформах, SOA, Amazon, Microsoft, Facebook и Google;</li>
<li><a href="http://www.slideshare.net/eduardsi/micro-service-architecture">Micro Service Architecture</a>, презентация Eduards Sizovs;</li>
<li>Fred George <a href="http://www.youtube.com/watch?v=2rKEveL55TY">рассказывает о MSA, Clojure, Kafka</a> и утверждает, что можно катить микросервисы в продакшн каждые 10 минут (каждый прогер — дважды в день). Слабо верится, но звучит интересно. Также из этого доклада вы узнаете о хороших практиках MSA, например, что каждый сервис должен отдавать информацию о своем текущем состоянии;</li>
<li>Доклад James Lewis под названием <a href="http://www.infoq.com/presentations/Micro-Services">Micro Services: Java, the Unix Way</a>. Субъективно послабее, чем у Fred George, но также заслуживает внимания. Вся суть начинается где-то с 21-ой минуты;</li>
</ul>
<p>Мне что-то не очень верится в идею «несколько сотен строк кода не сервис», даже с учетом кучи готовых фреймворков и библиотек. Вот пара тысяч строк на сервис звучит более реалистично.</p>
<p>Скорее всего, не во всякой задаче можно или нужно использовать микросервисную архитектуру. Но там, где есть такая возможность, как мне кажется, преимущества существенно перевешивают недостатки.</p>
<p><em>Дополнение:</em> <a href="http://eax.me/microservices-vs-monolithic/">Когда использовать монолиты, а когда микросервисы</a></p>


				</div>
			</div>
<br><hr>

<a href="https://habrahabr.ru/post/249183/">src</a>
<h2>Микросервисы</h2>
<div class="content html_format cye-lm-tag"><i>От переводчика: некоторые скорее всего уже читали этот титанический труд от Мартина Фаулера и его коллеги Джеймса Льюиса, но я все же решил сделать перевод этой статьи. Тренд микросервисов набирает обороты в мире enterprise разработки, и эта статья является ценнейшим источником знаний, по сути выжимкой существующего опыта работы с ними.<br>
</i><br>
<i>Термин «Microservice Architecture» получил распространение в последние несколько лет как описание способа дизайна приложений в виде набора независимо развертываемых сервисов. В то время как нет точного описания этого архитектурного стиля, существует некий общий набор характеристик: организация сервисов вокруг бизнес-потребностей, автоматическое развертывание, перенос логики от шины сообщений к приемникам (endpoints) и децентрализованный контроль над языками и данными.</i><br>
<a name="habracut"></a><br>
«Микросервисы» — еще один новый термир на шумных улицах разработки ПО. И хотя мы обычно довольно настороженно относимся ко всем подобным новинкам, конкретно этот термин описывает стиль разработки ПО, который мы находим все более и более привлекательным. За последние несколько лет мы видели множество проектов, использующих этот стиль, и результаты со сих пор были весьма позитивными. Настолько, что для большинства наших коллег этот стиль становится основным стилем разработки ПО. К сожалению, существует не так много информации, которая описывает, чем же являются микросервисы и как применять их.<br>
<br>
Если коротко, то архитектурный стиль микросервисов — это подход, при котором единое приложение строится как набор небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя легковесные механизмы, как правило HTTP. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо с использованием полностью автоматизированной среды. Существует абсолютный минимум централизованного управления этими сервисами. Сами по себе эти сервисы могут быть написаны на разных языках и использовать разные технологии хранения данных.<br>
<br>
Для того, чтобы начать рассказ о стиле микросервисов, лучше всего сравнить его с монолитом (monolithic style): приложением, построенном как единое целое. Enterprise приложения часто включают три основные части: пользовательский интерфейс (состоящий как правило из HTML страниц и javascript-а), база данных (как правило реляционной, со множеством таблиц) и сервер. Серверная часть обрабатывает HTTP запросы, выполняет доменную логику, запрашивает и обновляет данные в БД, заполняет HTML страницы, которые затем отправляются браузеру клиента. Любое изменение в системе приводит к пересборке и развертыванию новой версии серверной части приложения.<br>
<br>
Монолитный сервер — довольно очевидный способ построения подобных систем. Вся логика по обработке запросов выполняется в единственном процессе, при этом вы можете использовать возможности вашего языка программирования для разделения приложения на классы, функции и namespace-ы. Вы можете запускать и тестировать приложение на машине разработчика и использовать стандартный процесс развертывания для проверки изменений перед выкладыванием их в продакшн. Вы можете масштабировать монолитное приложения горизонтально путем запуска нескольких физических серверов за балансировщиком нагрузки.<br>
<br>
Монолитные приложения могут быть успешными, но все больше людей разочаровываются в них, особенно в свете того, что все больше приложений развертываются в облаке. Любые изменения, даже самые небольшие, требуют пересборки и развертывания всего монолита. С течением времени, становится труднее сохранять хорошую модульную структуру, изменения логики одного модуля имеют тенденцию влиять на код других модулей. Масштабировать приходится все приложение целиком, даже если это требуется только для одного модуля этого приложения.<br>
<br>
<img src="./micro_pics_files/b630bc1ca0432219f198a7d11b08a12b.png" alt="image"><br>
<br>
Эти неудобства привели к архитектурному стилю микросервисов: построению приложений в виде набора сервисов. В дополнение к возможности независимого развертывания и масштабирования каждый сервис также получает четкую физическую границу, которая позволяет разным сервисам быть написанными на разных языках программирования. Они также могут разрабатываться разными командами.<br>
<br>
Мы не утверждаем, что стиль микросервисов это инновация. Его корни уходят далеко в прошлое, как минимум к принципам проектирования, использованным в Unix. Но мы тем не менее считаем, что недостаточно людей принимают во внимание этот стиль и что многие приложения получат преимущества если начнут применять этот стиль.<br>
<br>
<h4>Свойства архитектуры микросервисов</h4><br>
Мы не можем сказать, что существует формальное определение стиля микросервисов, но мы можем попытаться описать то, что мы считаем общими характеристиками приложений, использующих этот стиль. Не всегда они встречаются в одном приложении все сразу, но, как правило, каждое подобное приложение включает в себя большинство этих характеристик. Мы попробуем описать то, что мы видим в наших собственных разработках и в разработках известных нам команд.<br>
<br>
<h5>Разбиение через сервисы</h5><br>
В течение всего срока нашего пребывания в индустрии мы видим желание строить системы путем соединения вместе различных компонент, во многом так же, как это происходит в реальном мире. За последние пару десятков лет мы видели большой рост набора библиотек, используемых в большистве языков программирования.<br>
<br>
Говоря о компонентах, мы сталкиваемся с трудностями определения того, что такое компонент. Наше определение такого: компонент — это единица программного обеспечения, которая может быть независимо заменена или обновлена.<br>
<br>
Архитектура микросервисов использует библиотеки, но их основной способ разбиения приложения — путем деления его на сервисы. Мы определяем библиотеки как компоненты, которые подключаются к программе и вызываются ею в том же процессе, в то время как сервисы — это компоненты, выполняемые в отдельном процессе и коммуницирующие между собой через веб-запросы или remote procedure call (RPS).<br>
<br>
Главная причина использования сервисов вместо библиотек — это независимое развертывание. Если вы разрабатываете приложение, состоящее из нескольких библиотек, работающих в одном процессе, любое изменение в этих библиотеках приводит к переразвертыванию всего приложения. Но если ваше приложение разбито на несколько сервисов, то изменения, затрагивающие какой-либо из них, потребуют переразвертывания только изменившегося сервиса. Конечно, какие-то изменения будут затрагивать интерфейсы, что, в свою очередь, потребует некоторой координации между разными сервисами, но цель хорошей архитектуры микросервисов — минимизировать необходимость в такой координации путем установки правильных границ между микросервисами, а также механизма эволюции контрактов сервисов.<br>
<br>
Другое следствие использования сервисов как компонент — более явный интерфейс между ними. Большинство языков программирования не имеют хорошего механизма для объявления <a href="http://martinfowler.com/bliki/PublishedInterface.html">Published Interface</a>. Часто только документация и дисциплина предотвращают нарушение инкапсуляции компонентов. Сервисы позволяют избежать этого через использование явного механизма удаленных вызовов.<br>
<br>
Тем не менее, использование сервисов подобным образом имеет свои недостатки. Удаленные вызовы работают медленнее, чем вызовы в рамках процесса, и поэтому API должен быть менее детализированным (coarser-grained), что часто приводит к неудобству в использовании. Если вам нужно изменить набор ответственностей между компонентами, сделать это сложнее из-за того, что вам нужно пересекать границы процессов.<br>
<br>
В первом приближении мы можем наблюдать, что сервисы соотносятся с процессами как один к одному. На самом деле сервис может содержать множество процессов, которые всегда будут разрабатываться и развертываться совместно. Например, процесс приложения и процесс базы данных, которую использует только это приложение.<br>
<br>
<h5>Организация вокруг потребностей бизнеса</h5><br>
Когда большое приложение разбивается на части, часто менеджмент фокусируется на технологиях, что приводит к образованию UI команды, серверной команды и БД команды. Когда команды разбиты подобным образом, даже небольшые изменения отнимают много времени из-за необходимости кросс-командного взаимодействия. Это приводит к тому, что команды размещают любую логику на тех слоях, к которым имеют доступ. Закон Конвея (Conway's Law) в действии.<br>
<br>
«Любая организация, которая проектирует какую-то систему (в широком смысле) получит дизайн, чья структура копирует структуру команд в этой организация»<br>
 — Melvyn Conway, 1967<br>
<br>
<img src="./micro_pics_files/6f78642d17d2b7fee4d3610a1d2aab3e.png" alt="image"><br>
Закон Конвея (Conway's Law) в действии<br>
<br>
Микросервисный подход к разбиению подразумевает раазбиение на сервисы в соответствии с <b>потребностями бизнеса</b>. Такие сервисы включают в себя полный набор технологий, необходимых для этой бизнес-потребности, в том числе пользовательский интерфейс, хранилице данных и любые внешние взаимодействия. Это приводит к формированию кросс-функциональных команд, имеющих полный набор необходимых навыков: user-experience, базы данных и project management.<br>
<br>
<img src="./micro_pics_files/5cccb4f76190401ca0b5f2df78518932.png" alt="image"><br>
Сервисные границы, подкрепленные границами команд<br>
<br>
Одна из компаний, организованных в этом стиле — <a href="http://www.comparethemarket.com/">www.comparethemarket.com</a>. Кросс-фунциональные команды отвечают за построение и функционирование каждого продукта и каждый продукт разбит на несколько отдельных сервисов, общающихся между собой через шину сообщений.<br>
<br>
Крупные монолитные приложения тоже могут быть разбиты на модули вокруг бизнес потребностей, хотя обычно этого не происходит. Безусловно, мы рекомендуем большим командам строить монолитные приложения именно таким образом. Основная проблема здесь в том, что такие приложения имеют тенденцию к организации вокруг слишком большого количества контекстов. Если монолит охватывает множество контекстов, отдельным членам команд становится слишком сложно работать с ними из-за их большого размера. Кроме того, соблюдение модульных границ в монолитном приложении требует существенной дисциплины. Явно очерченные границы компонент микросервисов упрощает поддержку этих границ.<br>
<br>
<h5>Насколько большими должны быть микросервисы?</h5><br>
Хотя термин «Микросервис» стал популярным названием для этого архитектурного стиля, само имя приводит к чрезмерному фокусу на размере сервисов и спорам о том, что означает приставка «микро». В наших разговорах с теми, кто занимался разбиением ПО на микросервисы, мы видели разные размеры. Наибольший размер был у компаний, следовавших правилу «Команда двух пицц» (команда, которую можно накормить двумя пиццами), т.е. не более 12 человек (<i>прим. перев.: следуя этому правилу, я в команде должен быть один</i>). В других компаниях мы видели команды, в которых шестеро человек поддерживали шесть сервисов.<br>
<br>
Это приводит к вопросу о том, есть ли существенная разница в том, сколько человек должно работать на одном сервисе. На данный момент мы считаем, что оба этих подхода к построению команд (1 сервис на 12 человек и 1 сервис на 1 человека) подходят под описание микросервисной архитектуры, но возможно мы изменим свое мнение в будущем. (<i>прим. перев.: со времен статьи появилось множество других статей, развивающих эту тему; наиболее популярным сейчас считается мнение о том, что сервис должен быть настолько большим, чтобы он мог полностью «уместиться в голове разработчика», независимо от количества строк кода</i>).<br>
<br>
<h5>Продукты, а не проекты</h5><br>
Большиство компаний по разработке ПО, которые мы видим, используют проектную модель, в которой целью является разработка некой части функциональности, которая после этого считается завершенной. После завершения эта часть передается команде поддержки и проектная команда распускается.<br>
<br>
Сторонники микросервисов сторонятся этой модели, утверждая, что команда должна владеть продуктом на протяжении всего срока его жизни. Корни этого подхода уходят к Амазону, у компании есть правило "<a href="https://queue.acm.org/detail.cfm?id=1142065">вы разработали, вам и поддерживать</a>", при котором команда разработки берет полную ответственность за ПО в продакшне. Это приводит к тому, что разработчики регулярно наблюдают за тем, как их продукт ведет себя в продакшне, и больше контактируют с пользователями, т.к. им приходится брать на себя как минимум часть обязанностей по поддержке.<br>
<br>
Мышление в терминах продукта устанавливает связь с потребностями бизнеса. Продукт — это не просто набор фич, которые необходимо реализовать. Это постоянные отношения, цель которых — помочь пользователям увеличить их бизнес-возможности.<br>
<br>
Конечно, этого можно также достичь и в случае с монолитным приложением, но высокая гранулярность сервисов упрощает установку персональных отношений между разработчиками сервиса и его пользователями.<br>
<br>
<h5>Умные приемники и глупые каналы передачи данных (Smart endpoints and dumb pipes)</h5><br>
При выстраивании коммуникаций между процессами мы много раз были свидетелями того, как в механизмы передачи данных помещалась существенная часть логики. Хорошим примером здесь является Enterprise Service Bus (ESB). ESB-продукты часто включают в себя изощренные возможности по передаче, оркестровке и трансформации сообщений, а также применению бизнес-правил.<br>
<br>
Комьюнити микросервисов предпочитает альтернативный подход: умные приемники сообщений и глупые каналы передачи. Приложения, построенные с использованием микросервисной архитектуры, стремятся быть настолько незавимыми (decoupled) и сфокусировнными (cohesive), насколько возможно: они содержат собственную доменную логику и выступают больше в качестве фильтров в классическом Unix-овом смысле — получают запросы, применяют логику и отправляют ответ. Вместо сложных протоколов, таких как WS-* или BPEL, они используют простые REST-овые протоколы.<br>
<br>
Два наиболее часто используемых протокола — это HTTP запросы через API ресурса и легковесный месседжинг. Лучшее выражение первому дал <a href="http://www.amazon.com/gp/product/0596805829">Ian Robinson</a>: «Be of the web, not behind the web».<br>
<br>
Команды, практикующие микросервисную архитектуру, используют те же принципы и протоколы, на которых построена всемирная паутина (и, по сути, Unix). Часто используемые ресурсы могут быть закешированы с очень небольшими усилиями со стороны разработчиков или IT-администраторов.<br>
<br>
Второй часто используемый инструмент коммуникации — легковесная шина сообщений. Такая инфраструктура как правило не содержит доменной логики — простые реализации типа RabbitMQ или ZeroMQ не делают ничего кроме предоставления асинхронной фабрики. Логика при этом существует на концах этой шины — в сервисах, которые отправляют и принимают сообщения.<br>
<br>
В монолитном приложении компоненты работают в одном процессе и коммуницируют между собой через вызов методов. Наибольшая проблема в смене монолита на микросервисы лежит в изменении шаблона коммуникации. Наивное портирование один к одному приводит к «болтливым» коммуникациям, которые работают не слишком хорошо. Вместо этого вы должны уменьшить количество коммуникаций между модулями.<br>
<br>
<h5>Децентрализованное управление</h5><br>
Одним из следствий централизованного управления является тенденция к стандартизации используемых платформ. Опыт показывает, что такой подход слишком сильно ограничивает выбор — не всякая проблема является гвоздем и не всякое решение является молотком. Мы предпочитаем использовать правильный инструмент для каждой конкретной работы. И хотя монолитные приложения тоже в некоторых случаях могут быть написаны с использованием разных языков, это не является стандартной практикой.<br>
<br>
Разбивая монолит на сервисы, мы имеем выбор, как построить каждый из них. Хотите использовать Node.js для простых страничек с отчетами? Пожалуйста. C++ для real-time приложений? Отлично. Хотите заменить БД на ту, которая лучше подходит для операций чтения вашего компонента? Ради бога.<br>
<br>
Конечно, только потому что вы можете делать что-то, не значит что вы должны это делать. Но разбиение системы подобным образом дает вам возможность выбора.<br>
<br>
Команды, разрабатывающие микросервисы, также предпочитают иной подход к стандартизации. Вместо того, чтобы использовать набор предопределенных стандартов, написанных кем-то, они предпочитают идею построения полезных инструментов, которые остальные девелоперы могут использовать для решения похожих проблем. Эти инструменты как правило вычленены из кода одного из проектов и расшарены между разными командами, иногда используя при этом модель внутреннего опен-сорса. Теперь, когда git и github стали де-факто стандартной системой контроля версий, опен-сорсные практики становятся все более и более популярными во внутренних проектах компаний.<br>
<br>
Netflix — хороший пример организации, которая следует этой философии. Расшаривание полезного и, более того, протестированного на боевых серверах кода в виде библиотек побуждает остальных разработчиков решать схожие проблемы схожим путем, оставляя тем не менее возможность выбора другого подхода при необходимости. Общие библиотеки имеют тенденцию быть сфокусированными на общих проблемах, связанных с хранением данных, межпроцессорным взаимодействием и автоматизацией инфраструктуры.<br>
<br>
Комьюнити микросервисов ценит сервисные контракты, но не любит оверхеды и поэтому использует различные пути управления этими контрактами. Такие шаблоны как <a href="http://martinfowler.com/bliki/TolerantReader.html">Tolerant Reader</a> и <a href="http://martinfowler.com/articles/consumerDrivenContracts.html">Consumer-Driven Contracts </a>часто используются в микросервисах, что позволяет им эволюционировать независимо. Проверка Consumer-Driven контрактов как часть билда увеличивает уверенность в правильности функционирование сервисов. Мы знаем команду из Австралии, которая использует этот подход для проверки контрактов. Это стало частью их процесса сборки: сервис собирается только до того момента, который удовлетворяет требованиям контракта — элегантный способ обойти диллему YAGNI.<br>
<br>
Пожалуй наивысшая точка в практике децентрализованного управления — это метод, популизированный Амазоном. Команды отвечают за все аспекты ПО, которое они разрабатывают, включая поддержку его в режиме 24/7. Подобная деволюция уровня ответственности совершенно точно не является нормой, но мы видим все больше и больше компаний, передающий ответственность командам разработчиков. Netflix — еще одна компания, практикующая это. Пробуждение в 3 часа ночи — очень сильный стимул к тому, чтобы уделять большое внимание качеству написанного кода.<br>
<br>
<h5>Микросервисы и SOA</h5><br>
Когда мы разговариваем о микросервисах, обычно возникает вопрос о том, не является ли это обычным Service Oriented Architecture (SOA), который мы видели десять лет назад. В этом вопросе есть здравое зерно, т.к. стиль микросервисов очень похож на то, что продвигают некоторые сторонники SOA. Проблема, тем не менее, в том, что <a href="http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html">термин SOA имеет сликом много разных значений</a> и, как правило, то, что люди называют «SOA» существенно отличается от стиля, описанного здесь, обычно из-за чрезмерного фокуса на ESB, используемом для интеграции монолитных приложений.<br>
<br>
В частности, мы видели так много неудачных реализаций SOA (начиная с тенденции прятать сложность за ESB, заканчивая провалившимися инциативами длительностью несколько лет, которые стоили миллионы долларов и не принесли никакой пользы), что порой слишком сложно абстрагироваться от этих проблем.<br>
<br>
Безусловно, многие практики, используемые в микросервисах, пришли из опыта интеграции сервисов в крупных организациях. Шаблон <a href="http://martinfowler.com/bliki/TolerantReader.html">Tolerant Reader</a> — один из примеров. Другой пример — использование простых протоколов — возник как реакция на централизованные стандарты, сложность которых просто <a href="http://wiki.apache.org/ws/WebServiceSpecifications">захватывает дух</a>. <br>
<br>
Эти проблемы SOA привели к тому, что некоторые сторонники микросервисов отказываются от термина «SOA», хотя другие при этом считают микросервисы одной из форм SOA, или, возможно, правильной реализацией SOA. В любом случае, тот факт, что SOA имеет разные значения, означает, что полезно иметь отдельный термин для обозначения этого архитектурного стиля.<br>
<br>
<h5>Множество языков, множество возможностей</h5><br>
Рост платформы JVM — один из последних примеров смешивания языков в рамках единой платформы. Переход к более высокоуровневым языкам для получения преимуществ, связанных с использованием высокоуровневых абстракций, был распространенной практикой в течение десятилетий. Точно так же, как и переход «к железу» для написания высокопроизводительного кода.<br>
<br>
Тем не менее, множество монолитных приложений не требуют такого уровня оптимизации производительности и высокоуровневых возможностей DSL-подобных языков. Вместо этого, монолиты как правило используют единый язык и склонны к ограничению количества используемых технологий.<br>
<br>
<h5>Децентрализованное управление данными</h5><br>
Децентрализованное управление данными предстает в различном виде. В наиболее абстрактном смысле это означает, что концептуальная модель мира у разных систем будет отличаться. Это обычная проблема, возникающая при интеграции разных частей больших enterprise-приложений: точка зрения на понятие «Клиент» у продажников будет отличаться от таковой у команды техподдержки. Некоторые атрибуты «Клиента» могут присутствовать в контексте продажников и отсутствовать в контексте техподдержки. Более того, атрибуты с одинаковым названием могут иметь разное значение.<br>
<br>
Эта проблема встречается не только у разных приложений, но также и в рамках единого приложения, особенно в тех случаях когда это приложение разделено на отдельные компоненты. Эту проблему хорошо решает понятие <a href="http://martinfowler.com/bliki/BoundedContext.html">Bounded Context</a> из Domain-Driven Design (DDD). DDD предлагает делить сложную предметную область на несколько контекстов и мапить отношения между ними. Этот процесс полезен как для монолитной, так и для микросервисной архитектур, но между сервисами и контекстами существует естественная связь, которая помогает прояснять и поддерживать границы контекстов.<br>
<br>
Кроме децентрализации принятия решений о моделировании предметной области, микросервисы также способствуют децентрализации способов хранения данных. В то время как монолитные приложения склонны к использованию единственной БД для хранения данных, компании часто предпочитают использовать единую БД для целого набора приложений. Такие решения, как правило, вызваны моделью лицензирования баз данных. Микросервисы предпочитают давать возможность каждому сервису управлять собственной базой данных: как создавать отдельные инстансы общей для компании СУБД, так и использовать нестандартные виды баз данных. Этот подход называется <a href="http://martinfowler.com/bliki/PolyglotPersistence.html">Polyglot Persistence</a>. Вы также можете применять Polyglot Persistence в монолитных приложениях, но в микросервисах такой подход встречается чаще.<br>
<br>
<img src="./micro_pics_files/276b6976199983e0329e7a45e84bbc03.png" alt="image"><br>
<br>
Децентрализация ответственности за данные среди микросервисов оказывает влияние на то, как эти данные изменяются. Обычный подход к изменению данных заключается в использовании транзакций для гарантирования консистентности при изменении данных, находящихся на нескольких ресурсах. Такой подход часто используется в монолитных приложениях.<br>
<br>
Подобное использование транзакций гарантирует консистентность, но приводит к существенной временн<i><b>о</b></i>й зависимости (temporal coupling), которая, в свою очередь, приводит к проблемамм при работе с множеством сервисов. Распределенные транзакции невероятно сложны в реализации и, как следствие, микросервисная архитектура придает особое значению координации между сервисами <a href="http://www.eaipatterns.com/ramblings/18_starbucks.html">без использования транзакций</a> с явным обозначением того, что консистентность может быть только итоговой (eventual consistency) и возникающие проблемы решаются операциями компенсации.<br>
<br>
Управление несогласованностями подобным образом — новый вызов для многих команд разработки, но это часто соответствует практикам бизнеса. Часто компании стремятся как можно быстрее реагировать на действия пользователя и имеют процессы, позвояющие отменить действия пользователей в случае ошибки. Компромисс стоит того до тех пор, пока стоимость исправления ошибки меньше стоимости потерь бизнеса при использовании сценариев, гарантирующих консистентность.<br>
<br>
<h5>Стандартны, проверенные в бою, vs навязанные стандарты</h5><br>
Команды, использующие микросервисную архитектуру, склонны избегать жестких стандартов, установленных группами системных архитекторов. Они также склонны использовать и даже продвигать открытые стандарты типа HTTP и ATOM.<br>
<br>
Ключевое отличие в том, как эти стандарты разрабатываются и как они проводятся в жизнь. Стандарты, управляемые группами вроде IETF, становятся стандартами только тогда, когда находятся несколько реализаций в успешных open-source проектах.<br>
<br>
Это отличает их от стандартов в корпоративном мире, которые часто разрабатываются группами людей с небольшим опытом реальной разработки или имеют слишком сильное влияние, оказываемое вендорами.<br>
<br>
<h5>Автоматизация инфраструктуры</h5><br>
Техники автоматизации инфраструктуры сильно эволюционировали за последние несколько лет. Эволюция облака в целом и AWS в частности уменьшила операционную сложность построения, разворачивания и функционирования микросервисов.<br>
<br>
Множество продуктов и систем, использующих микросервисную архитектуру, были построены командами с обширным опытом в <a href="http://martinfowler.com/bliki/ContinuousDelivery.html">Continuous Delivery</a> и <a href="http://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a>. Команды, строящие приложения подобнымм образом, интенсивно используют техники автоматизации инфраструктуры. Это проиллюстрировано на картинке ниже.<br>
<br>
<img src="./micro_pics_files/590e7cb4c79706fc5c2c10a1c9ddd379.png" alt="image"><br>
<br>
Так как эта статья не про Continuous Delivery, мы уделим внимание лишь паре его ключевых моментов. Мы хотим получать как можно больше уверенности в том, что наше приложение работает, поэтому мы запускаем множество автоматических тестов. Для выполнения каждого шага автоматического тестирования приложение разворачивается в отдельной среде, для чего используется автоматического развертывание (automated deployment).<br>
<br>
После того как вы инвестировали время и деньги в автоматизацию процесса развертывания монолита, развертывание большего количества приложений (сервисов) уже не видится таким пугающим. Вспомните, что одна из целей Continuous Delivery — это сделать развертывание скучным, так что одно это приложение или три не имеет большого значения.<br>
<br>
Другая область, где команды используют интенсивную автоматизацию инфраструктуры, — это управление микросервисами в продакшне. В отличие от процесса развертывания, который, как описано выше, у монолитных приложений не сильно отличается от такового у микросервисов, их способ фунционирования может существенно различаться.<br>
<br>
<img src="./micro_pics_files/9651675bc9ef525f2c9ccea62d411bfd.png" alt="image"><br>
<br>
Одним из побочных эффектов автоматизации процесса развертывания является создание удобных инструментов для помощи разработчикам и администраторам (operations folk). Инструменты для управления кодом, развертывания простых сервисов, мониторинга и логирования сейчас довольно распространены. Возможно наилучший пример, который можно найти в сети, — это набор open source инструментов от <a href="http://netflix.github.io/">Netflix</a>, но существуют и другие, к примеру <a href="https://dropwizard.github.io/dropwizard/">Dropwizard</a>, который мы довольно интенсивно используем.<br>
<br>
<h5>Проектирование под отказ (Design for failure)</h5><br>
Следствием использования сервисов как компонентов является необходимость проектирования приложений так, чтобы они могли работать при отказе отдельных сервисов. Любое обращение к сервису может не сработать из-за его недоступности. Клиент должен реагировать на это настолько терпимо, насколько возможно. Это является недостатоком микросервисов по сравнению с монолитом, т.к. это вносит дополнительную сложность в приложение. Как следствие, команды микросервисов постоянно думают на тем, как недоступность сервисов должна влиять на user experience. <a href="https://github.com/Netflix/SimianArmy">Simian Army</a> от Netflix искуственно вызывает (симулирует) отказы сервисов и даже датацентров в течение рабочего дня для тестирования отказоустойчивости приложения и служб мониторинга.<br>
<br>
Подобный вид автоматического тестирования в продакшне позволяет сэмулировать стресс, который ложится на администраторов и часто приводит к работе по выходным. Мы не хотим сказать, что для монолитных приложений не могут быть разработаны изощренные системы мониторинга, только то, что такое встречается реже.<br>
<br>
Так как сервисы могут отказать в любое время, очень важно иметь возможность быстро обнаружить неполадки и, если возможно, автоматически восстановить работоспособность сервиса. Микросервисная архитектура делает большой акцент на мониторинге приложения в режиме реального времени, проверке как технических элементов (например, как много запросов в секунду получает база данных), так и бизнес-метрик (например, как много заказов в минуту получает приложение). Семантический мониторинг может предоставить систему раннего предупреждения проблемных ситуаций, позволяя команде разработке подключиться к исследованию проблемы на самых ранних стадиях.<br>
<br>
Это особенно важно с случае с микросервисной архитектурой, т.к. разбиение на отдельные процессы и <a href="http://martinfowler.com/eaaDev/EventCollaboration.html">коммуникация через события</a> приводит к неожиданному поведению. Мониторинг крайне важен для выявления нежелательных случаев такого поведения и быстрого их устранения.<br>
<br>
Монолиты могут быть построены так же прозначно, как и микросервисы. На самом деле, так они и должны строиться. Разница в том, что знать, когда сервисы, работающие в разных процессах, перестали корректно взаимодействовать между собой, намного более критично. В случае с библиотеками, расположенными в одном процессе, такой вид прозрачности скорее всего будет не так полезен.<br>
<br>
Команды микросервисов, как правило, создают изощренные системы мониторинга и логирования для каждого индивидуального сервиса. Примером может служить консоль, показывающая статус (онлайн/офлайн) сервиса и различные технические и бизнес-метрики: текущая пропускная способность, время обработки запроса и т.п.<br>
<br>
<h5>Синхронные вызовы считаются опасными</h5><br>
Каждый раз когда вы имеете набор синхронных вызовов между сервисами, вы сталкиваетесь с эффектом мультипликации времени простоя (downtime). Время простоя вашей системы становится произведением времени простоя индивидуальных компонент системы. Вы сталкиваетесь с выбором: либо сделать ваши вызовы асинхронными, либо мириться с простоями. К примеру, в <a href="http://www.guardian.co.uk/">www.guardian.co.uk</a> разработчики ввели простое правило — один синхронный вызов на один запрос пользователя. В Netflix же вообще все API являются асинхронными.<br>
<br>
<h5>Эволюционный дизайн</h5><br>
Те, кто практикует микросервисную архитектуру, обычно много работали с эволюционным дизайном и рассматривают декомпозицию сервисов как дальнейшую возможность дать разработчикам контроль над изменениями (рефакторингом) их приложения без замедления самого процесса разработки. Контроль над изменениями не обязательно означает уменьшение изменений: с правильным подходом и набором инструментов вы можно делать частые, быстрые, хорошо контролируемые изменения.<br>
<br>
Каждый раз когда вы пытаетесь разбить приложение на компоненты, вы сталкиваетесь с необходимостью принять решение, как именно делить приложение. Есть ли какие-то принципы, указывающие, как наилучшим способом «нарезать» наше приложение? Ключевое свойство компонента — это независимость его замены или обновления, что подразумевает наличие ситуаций когда его можно переписать с нуля без затрагивания взаимодействующих с ним компонентов. Многие команды разработчиков идут еще дальше: они явным образом планируют, что множество сервисов в долгосрочной перспективе не будет эволюционировать, а будут просто выброшены на свалку.<br>
<br>
Веб-сайт Guardian — хороший пример приложения, которое было спроектировано и построено как монолит, но затем эволюционировало в сторону микросервисов. Ядро сайта все еще остается монолитом, но новые фичи добавляются путем построения микросервисов, которые используют API монолита. Такой подход особенно полезен для функциональности, которая по сути своей является временной. Пример такой функциональности — специализированные страницы для освещения спортивных событий. Такие части сайта могут быть быстро собраны вместе с использованием быстрых языков программирования и удалены как только событие закончится. Мы видели похожий подход в финансовых системах, где новые сервисы добавлялись под открывшиеся рыночные возможности и удалялись через несколько месяцев или даже недель после создания.<br>
<br>
Такой упор на заменяемости — частный случай более общего принципа модульного дизайна, который заключается в том, что модульность определяется скоростью изменения функционала. Вещи, которые изменяются вместе, должны храниться в одном модуле. Части системы, изменяемые редко, не должны находиться вместе с быстроэволюционирующими сервисами. Если вы регулярно меняете два сервиса вместе, задумайтесь над тем, что возможно их следует объединить.<br>
<br>
Помещение компонент в сервисы добавляет возможность более точного (granular) планирования релиза. С монолитом любые изменения требуют пересборки и развертывания всего приложения. С микросервисами вам нужно развернуть (redeploy) только те сервисы, что изменились. Это позволяет упростить и ускорить процесс релиза. Недостаток такого подхода в том, что вам приходится волноваться насчет того, что изменения в одном сервисе сломают сервисы, обращающиеся к нему. Традиционный подход к интеграции заключается в том, чтобы решать такие проблемы путем версионности, но микросервисы предпочитают использовать версионность только в случае <a href="http://martinfowler.com/articles/enterpriseREST.html#versioning">крайней необходимости</a>. Мы можем избежать версионности путем проектирования сервисов так, чтобы они были настолько толерантны к изменениям соседних сервисов, насколько возможно.<br>
<br>
<h4>За микросервисами будущее?</h4><br>
Наша основная цель при написании этой статьи заключалась в том, чтобы объяснить основные идеи и принципы микросервисной архиктуры. Мы считаем, что микросервисный стиль — важная идея, стоящая рассмотрения для enterprise приложений. Не так давно мы разработали несколько систем используя этот стиль и знаем несколько других команд, которые используют этот подход.<br>
<br>
Известные нам пионеры этого архитектурного стиля — это такие компании как Amazon, Netflix, The Guardian, the UK Government Digital Service, realestate.com.au, Forward и comparethemarket.com. Конференции 2013 года были полны примеров команий, движущихся в направлении, которое можно классифицировать как микросервисы, например, Travis CI. К тому же, существует множество организаций, которые уже давно используют то, что мы называем микросервисами, но не используют это название. (Часто это называется SOA, хотя, как мы уже говорили, SOA может являться в самых разных и, зачастую, противоречивых формах.)<br>
<br>
Несмотря на весь этот положительный опыт, мы не утверждаем, что микросервисы — это будущее проектирования ПО. И хотя наш опыт пока что весьма позитивен по сравнению с опытом использования монолитной архитектуры, мы подходим осознанно к тому факту, что прошло еще недостаточно времени для того, чтобы выносить такое суждение.<br>
<br>
Часто настоящие последствия ваших архитектурных решений становятся видно только спустя несколько лет после того, как вы сделали их. Мы видели проекты, в которых хорошие команды с сильным стремлением к модульности разработали монолитные приложения, полностью «прогнившие» по прошествию нескольких лет. Многие считают, что такой результат менее вероятен в случае с микросервисами, т.к. границы между сервисами являются физическими и их сложно нарушить. Тем не менее, до тех пока мы не увидим достаточного количества проверенных временем систем, использующих этот подход, мы не можем с уверенностью утверждать, насколько микросервисная архитектура является зрелой.<br>
<br>
Определенно существуют причины, по которым кто-то может считать микросервисную архитектуру недостаточно зрелой. Успех любых попыток построить компонентную систему зависит от того, насколько хорошо компоненты подходят приложению. Сложно понять где именно должны лежать границы компонентов. Эволюционный дизайн осознает сложности проведения правильных границ и важность легкого их изменения. Когда ваши компоненты являются сервисами, общающимися между собой удаленно, проводить рефакторинг намного сложнее, чем в случае с библиотеками, работающими в одном процессе. Перемещение кода между границами сервисов, изменение интерфейсов должны быть скоординированы между разными командами. Необходимо добавлять слои для поддержки обратной совместимости. Все это также усложняет процесс тестирования.<br>
<br>
Еще одна проблема состоит в том, что если компоненты не подобраны достаточно чисто, происходит перенос сложности из компонент на связи между компонентами. Создается ложное ощущение простоты отдельных компонент, в то время как вся сложность находится в местах, которые труднее контролировать.<br>
<br>
Также существует фактор уровня команды. Новые техники как правило принимаются более сильными командами, но техники, которые являются более эффективными для более сильных команд, необязательно являются таковыми для менее сильных групп разработчиков. Мы видели множество случаев, когда слабые команды разрабатывали запутанные, неудачные архитектуры монолитных приложений, но пройдет время прежде чем мы увидим чем это закончится в случае с микросервисной архитектурой. Слабые команды всегда создают слабые системы, сложно сказать улучшат ли микросервисы эту ситуацию или ухудшат.<br>
<br>
Один из разумных аргументов, которые мы слышали, состоит в том, что вам не следует начинать разработку с микросервисной архитектуры. Начните с монолита, сохраняйте его модульным и разбейте на микросервисы когда монолит станет проблемой. (И все же этот совет не является идеальным, т.к. хорошие интерфейсы для сообщения внутри процесса не являются таковыми в случае с межсервисным сообщением.)<br>
<br>
Итого, мы пишем это с разумным оптимизмом. К этому моменту мы видели достаточно примеров микросервисного стиля чтобы осознавать, что он является стоящим путем развития. Нельзя сказать с уверенностью к чему это приведет, но одна из особенностей разработки ПО заключается в том, что нам приходится принимать решения на основе той, зачастую неполной, информации, к который мы имеет доступ в данный момент.<br>
<br>
</div>

<a href="https://martinfowler.com/articles/microservices.html">src</a>
<h2>Microservices</h2>
<div class="paperBody">
<p>"Microservices" - yet another new term on the crowded streets
    of software architecture. Although our natural inclination is to
    pass such things by with a contemptuous glance, this bit of
    terminology describes a style of software systems that we are
    finding more and more appealing. We've seen many projects use this
    style in the last few years, and results so far have been
    positive, so much so that for many of our colleagues this is
    becoming the default style for building enterprise
    applications. Sadly, however, there's not much information that
    outlines what the microservice style is and how to do it.</p>

<p>In short, the microservice architectural style <a href="#footnote-etymology">[1]</a> is an approach
    to developing a single application as a suite of small services,
    each running in its own process and communicating with lightweight
    mechanisms, often an HTTP resource API. These services are built
    around business capabilities and independently deployable by fully
    automated deployment machinery. There is a bare minimum of
    centralized management of these services, which may be written in
    different programming languages and use different data storage
    technologies. </p>

<p>To start explaining the microservice style it's useful to
    compare it to the monolithic style: a monolithic application built
    as a single unit. Enterprise Applications are often built in three main parts: a
    client-side user interface (consisting of HTML pages and
    javascript running in a browser on the user's machine) a database
    (consisting of many tables inserted into a common, and usually
    relational, database management system), and a server-side
    application. The server-side application will handle HTTP
    requests, execute domain logic, retrieve and update data from the
    database, and select and populate HTML views to be sent to the
    browser. This server-side application is a <i>monolith</i> - a single
    logical executable<a href="#footnote-monolith">[2]</a>. Any changes to the
    system involve building and deploying a new version of the
    server-side application. </p>

<p>Such a monolithic server is a natural way to approach building
    such a system. All your logic for handling a request runs in a
    single process, allowing you to use the basic features of your
    language to divide up the application into classes, functions, and
    namespaces. With some care, you can run and test the application
    on a developer's laptop, and use a deployment pipeline to ensure
    that changes are properly tested and deployed into production. You
    can horizontally scale the monolith by running many instances
    behind a load-balancer.</p>

<p>Monolithic applications can be successful, but increasingly
    people are feeling frustrations with them - especially as more
    applications are being deployed to the cloud . Change cycles are
    tied together - a change made to a small part of the application,
    requires the entire monolith to be rebuilt and deployed. Over time
    it's often hard to keep a good modular structure, making it harder
    to keep changes that ought to only affect one module within that
    module. Scaling requires scaling of the entire application rather
    than parts of it that require greater resource. </p>

<div class="figure">
<p class="figureImage"><a name="microservices_images_sketch.png"></a><img alt="Figure 1" src="microservices/images/sketch.png" style=""></p>

<p class="figureCaption">Figure 1: Monoliths
    and Microservices</p>
</div>

<p>These frustrations have led to the microservice architectural
    style: building applications as suites of services. As well as the
    fact that services are independently deployable and scalable, each
    service also provides a firm module boundary, even allowing for
    different services to be written in different programming
    languages. They can also be managed by different teams .</p>

<p>We do not claim that the microservice style is novel
    or innovative, its roots go back at least to the design principles
    of Unix. But we do think that not enough people consider a
    microservice architecture and that many software developments
    would be better off if they used it.</p>

<div id="CharacteristicsOfAMicroserviceArchitecture"><hr class="topSection">
<h2>Characteristics of a Microservice Architecture</h2>

<p>We cannot say there is a formal definition of the
      microservices architectural style, but we can attempt to
      describe what we see as common characteristics for architectures
      that fit the label. As with any definition that outlines common
      characteristics, not all microservice architectures have all the
      characteristics, but we do expect that most microservice
      architectures exhibit most characteristics. While we authors
      have been active members of this rather loose community, our
      intention is to attempt a description of what we see in our own
      work and in similar efforts by teams we know of. In particular
      we are not laying down some definition to conform to. </p>

<div id="ComponentizationViaServices">
<h3>Componentization via Services</h3>

<p>For as long as we've been involved in the software
        industry, there's been a desire to build systems by plugging
        together components, much in the way we see things are made in
        the physical world. During the last couple of decades we've
        seen considerable progress with large compendiums of common
        libraries that are part of most language platforms.</p>

<p>When talking about components we run into the difficult
        definition of what makes a component. Our definition is that a
        <b>component</b> is a unit of software that is
        independently replaceable and upgradeable.</p>

<p>Microservice architectures will use libraries, but their
        primary way of componentizing their own software is by
        breaking down into services. We define <b>libraries</b>
        as components that are linked into a program and called using
        in-memory function calls, while <b>services</b> are
        out-of-process components who communicate with a mechanism such
        as a web service request, or remote procedure call. (This is a
        different concept to that of a service object in many OO
        programs <a href="#footnote-service-object">[3]</a>.)</p>

<p>One main reason for using services as components (rather
        than libraries) is that services are independently deployable.
        If you have an application <a href="#footnote-application">[4]</a> that consists of a multiple
        libraries in a single process, a change to any single component
        results in having to redeploy the entire application. But if
        that application is decomposed into multiple services, you can
        expect many single service changes to only require
        that service to be redeployed. That's not an absolute, some
        changes will change service interfaces resulting in some
        coordination, but the aim of a good microservice architecture is
        to minimize these through cohesive service boundaries and
        evolution mechanisms in the service contracts.</p>

<p>Another consequence of using services as components is a
        more explicit component interface. Most languages do not have
        a good mechanism for defining an explicit <a href="/bliki/PublishedInterface.html">Published Interface</a>. Often it's only documentation and
        discipline that prevents clients breaking a component's
        encapsulation, leading to overly-tight coupling between
        components. Services make it easier to avoid this by using
        explicit remote call mechanisms.</p>

<p>Using services like this does have downsides. Remote calls
        are more expensive than in-process calls, and thus remote APIs
        need to be coarser-grained, which is often more awkward to
        use. If you need to change the allocation of responsibilities
        between components, such movements of behavior are harder to
        do when you're crossing process boundaries.</p>

<p>At a first approximation, we can observe that services map
        to runtime processes, but that is only a first approximation.
        A service may consist of multiple processes that will always
        be developed and deployed together, such as an application
        process and a database that's only used by that service. </p>
</div>

<div id="OrganizedAroundBusinessCapabilities">
<h3>Organized around Business Capabilities</h3>

<p>When looking to split a large application into parts,
        often management focuses on the technology layer, leading to
        UI teams, server-side logic teams, and database teams. When
        teams are separated along these lines, even simple changes can
        lead to a cross-team project taking time and budgetary approval. A smart team will
        optimise around this and plump for the lesser of two evils -
        just force the logic into whichever application they have
        access to. Logic everywhere in other words. This is an example
        of Conway's Law<a href="#footnote-conwayslaw">[5]</a> in action.</p>

<blockquote>
<p>Any organization that designs a system (defined broadly)
          will produce a design whose structure is a copy of the
          organization's communication structure.</p>

<p class="quote-attribution">-- Melvyn Conway, 1967</p>
</blockquote>

<div class="figure">
<p class="figureImage"><a name="microservices_images_conways-law.png"></a><img alt="Figure 2" src="microservices/images/conways-law.png" style=""></p>

<p class="figureCaption">Figure 2: Conway's
        Law in action</p>
</div>

<p>The microservice approach to division is different,
        splitting up into services organized around
        <b>business capability</b>. Such services take a
        broad-stack implementation of software for that business area,
        including user-interface, persistant storage, and any external
        collaborations. Consequently the teams are cross-functional,
        including the full range of skills required for the
        development: user-experience, database, and project
        management. </p>

<div class="figure">
<p class="figureImage"><a name="microservices_images_PreferFunctionalStaffOrganization.png"></a><img alt="Figure 3" src="microservices/images/PreferFunctionalStaffOrganization.png" style=""></p>

<p class="figureCaption">Figure 3: Service
        boundaries reinforced by team boundaries</p>
</div>

<div class="sidebar" id="HowBigIsAMicroservice">
<h3>How big is a microservice?</h3>

<p>Although “microservice” has become a popular name for this
          architectural style, its name does lead to an unfortunate
          focus on the size of service, and arguments about what
          constitutes “micro”. In our conversations with microservice
          practitioners, we see a range of sizes of services. The
          largest sizes reported follow Amazon's notion of the Two
          Pizza Team (i.e. the whole team can be fed by two pizzas),
          meaning no more than a dozen people. On the smaller size
          scale we've seen setups where a team of half-a-dozen would
          support half-a-dozen services.</p>

<p>This leads to the question of whether there are
          sufficiently large differences within this size range that
          the service-per-dozen-people and service-per-person sizes
          shouldn't be lumped under one microservices label. At the
          moment we think it's better to group them together, but
          it's certainly possible that we'll change our mind as we
          explore this style further.</p>
</div>

<p>One company organised in this way is <a href="http://www.comparethemarket.com">www.comparethemarket.com</a>.
        Cross functional teams are responsible for building and operating
        each product and each product is split out into a number of
        individual services communicating via a message bus.</p>

<p>Large monolithic applications can always be modularized
        around business capabilities too, although that's not the
        common case. Certainly we would urge a large team building a
        monolithic application to divide itself along business lines.
        The main issue we have seen here, is that they tend to be
        organised around <i>too many</i> contexts. If the monolith
        spans many of these modular boundaries it can be difficult for individual
        members of a team to fit them into their short-term
        memory. Additionally we see that the modular
        lines require a great deal of discipline to enforce. The
        necessarily more explicit separation required by service
        components makes it easier to keep the team boundaries clear.</p>
</div>

<div id="ProductsNotProjects">
<h3>Products not Projects</h3>

<p>Most application development efforts that we see use a
        project model: where the aim is to deliver some piece of
        software which is then considered to be completed. On
        completion the software is handed over to a
        maintenance organization and the project team that built it is
        disbanded.</p>

<p>Microservice proponents tend to avoid this model,
        preferring instead the notion that a team should own a product
        over its full lifetime. A common inspiration for this is
        Amazon's notion of <a href="https://queue.acm.org/detail.cfm?id=1142065">"you build, you
        run it"</a> where a development team takes full responsibility
        for the software in production. This brings developers into
        day-to-day contact with how their software behaves in
        production and increases contact with their users, as they
        have to take on at least some of the support burden.</p>

<p>The product mentality, ties in with the linkage to business
        capabilities. Rather than looking at the software as a set of
        functionality to be completed, there is an on-going
        relationship where the question is how can software assist its
        users to enhance the business capability.</p>

<p>There's no reason why this same approach can't be taken
        with monolithic applications, but the smaller granularity of
        services can make it easier to create the personal
        relationships between service developers and their users.</p>
</div>

<div id="SmartEndpointsAndDumbPipes">
<h3>Smart endpoints and dumb pipes</h3>

<p>When building communication structures between different
          processes, we've seen many products and approaches that stress
          putting significant smarts into the communication mechanism
          itself. A good example of this is the Enterprise Service Bus
          (ESB), where ESB products often include sophisticated
          facilities for message routing, choreography, transformation,
          and applying business rules.</p>

<p>The microservice community favours an alternative approach:
          <i>smart endpoints and dumb pipes</i>. Applications
          built from microservices aim to be as decoupled and as
          cohesive as possible - they own their own domain logic and act
          more as filters in the classical Unix sense - receiving a
          request, applying logic as appropriate and producing a
          response. These are choreographed using simple RESTish protocols rather
          than complex protocols such as WS-Choreography or BPEL or
          orchestration by a central tool.</p>

<p>The two protocols used most commonly are HTTP
          request-response with resource API's and lightweight
          messaging<a href="#footnote-protobufs">[6]</a>. The best expression of
          the first is</p>

<blockquote>
<p>Be of the web, not behind the web </p>

<p class="quote-attribution"><a href="https://www.amazon.com/gp/product/0596805829?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596805829">-- Ian Robinson</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></p>
</blockquote>

<p>Microservice teams use the principles and
          protocols that the world wide web (and to a large extent,
          Unix) is built on. Often used resources can be cached with very
          little effort on the part of developers or operations
          folk. </p>

<p>The second approach in common use is messaging over a
          lightweight message bus. The infrastructure chosen is
          typically dumb (dumb as in acts as a message router only) -
          simple implementations such as RabbitMQ or ZeroMQ don't do
          much more than provide a reliable asynchronous fabric - the
          smarts still live in the end points that are producing and
          consuming messages; in the services.</p>

<p>In a monolith, the components are executing in-process and
          communication between them is via either method invocation or
          function call. The biggest issue in changing a monolith into
          microservices lies in changing the communication pattern. A
          naive conversion from in-memory method calls to RPC leads to
          chatty communications which don't perform well. Instead you
          need to replace the fine-grained communication with a coarser
          -grained approach.</p>
</div>

<div id="DecentralizedGovernance">
<h3>Decentralized Governance</h3>

<p>One of the consequences of centralised governance is the
        tendency to standardise on single technology
        platforms. Experience shows that this approach is constricting
        - not every problem is a nail and not every solution a
        hammer. We prefer using the right tool for the job and
        while monolithic applications can take advantage of different
        languages to a certain extent, it isn't that common.</p>

<div class="sidebar" id="MicroservicesAndSoa">
<h3>Microservices and SOA</h3>

<p>When we've talked about microservices a common question is
      whether this is just Service Oriented Architecture (SOA) that we
      saw a decade ago. There is merit to this point, because the
      microservice style is very similar to what some advocates of SOA
      have been in favor of. The problem, however, is that SOA means <a href="/bliki/ServiceOrientedAmbiguity.html">too
      many different things</a>, and that most of the time that we come
      across something called "SOA" it's significantly different to the
      style we're describing here, usually due to a focus on ESBs used
      to integrate monolithic applications.</p>

<p>In particular we have seen so many botched implementations of
      service orientation - from the tendency to hide complexity away
      in ESB's <a href="#footnote-esb">[7]</a>, to failed multi-year initiatives
      that cost millions and deliver no value, to centralised
      governance models that actively inhibit change, that it is
      sometimes difficult to see past these problems.</p>

<p>Certainly, many of the techniques in use in the microservice
      community have grown from the experiences of developers
      integrating services in large organisations. The <a href="/bliki/TolerantReader.html">Tolerant Reader</a> pattern is an example of this. Efforts
      to use the web have contributed, using simple protocols is
      another approach derived from these experiences - a reaction
      away from central standards that have reached a complexity that
      is, <a href="http://wiki.apache.org/ws/WebServiceSpecifications">frankly,
      breathtaking</a>. (Any time you need an ontology to manage your
      ontologies you know you are in deep trouble.)</p>

<p>This common manifestation of SOA has led some microservice
      advocates to reject the SOA label entirely, although others
      consider microservices to be one form of SOA <a href="#footnote-fine-grained">[8]</a>, perhaps <i>service orientation done
      right</i>. Either way, the fact that SOA means such different
      things means it's valuable to have a term that more crisply
      defines this architectural style.</p>
</div>

<p>Splitting the monolith's components out into services we
        have a choice when building each of them. You want to use
        Node.js to standup a simple reports page? Go for it. C++ for a
        particularly gnarly near-real-time component? Fine. You want
        to swap in a different flavour of database that better suits
        the read behaviour of one component? We have the technology to
        rebuild him.</p>

<p>Of course, just because you <i>can</i> do something,
        doesn't mean you <i>should</i> - but partitioning your system
        in this way means you have the option.</p>

<p>Teams building microservices prefer a different approach to
        standards too. Rather than use a set of defined standards
        written down somewhere on paper they prefer the idea of
        producing useful tools that other developers can use to solve
        similar problems to the ones they are facing. These tools are
        usually harvested from implementations and shared with a wider
        group, sometimes, but not exclusively using an internal open
        source model. Now that git and github have become the de facto
        version control system of choice, open source practices are
        becoming more and more common in-house .</p>

<p>Netflix is a good example of an organisation that follows
        this philosophy. Sharing useful and, above all, battle-tested
        code as libraries encourages other developers to solve similar
        problems in similar ways yet leaves the door open to picking a
        different approach if required. Shared libraries tend to be
        focused on common problems of data storage, inter-process
        communication and as we discuss further below, infrastructure
        automation.</p>

<p>For the microservice community, overheads are particularly
        unattractive. That isn't to say that the community doesn't
        value service contracts. Quite the opposite, since there tend
        to be many more of them. It's just that they are looking at
        different ways of managing those contracts. Patterns like
        <a href="/bliki/TolerantReader.html">Tolerant Reader</a> and <a href="/articles/consumerDrivenContracts.html">Consumer-Driven
        Contracts</a> are often applied to microservices. These aid
        service contracts in evolving independently. Executing
        consumer driven contracts as part of your build increases
        confidence and provides fast feedback on whether your services
        are functioning. Indeed we know of a team in Australia who
        drive the build of new services with consumer driven
        contracts. They use simple tools that allow them to define the
        contract for a service. This becomes part of the automated
        build before code for the new service is even written. The
        service is then built out only to the point where it satisfies
        the contract - an elegant approach to avoid the
        'YAGNI'<a href="#footnote-YAGNI">[9]</a> dilemma when building new
        software. These techniques and the tooling growing up around
        them, limit the need for central contract management by
        decreasing the temporal coupling between services. </p>

<div class="sidebar" id="ManyLanguagesManyOptions">
<h3>Many languages, many options</h3>

<p>The growth of JVM as a platform is just the latest
          example of
          mixing languages within a common platform. It's been common
          practice to shell-out to a higher level language to take advantage
          of higher level abstractions for decades. As is dropping down to
          the metal and writing performance sensitive code in a lower level
          one. However, many monoliths don't need this level of performance
          optimisation nor are DSL's and higher level abstractions that
          common (to our dismay). Instead monoliths are usually single
          language and the tendency is to limit the number of technologies
          in use <a href="#footnote-many-languages">[10]</a>.</p>
</div>

<p>Perhaps the apogee of decentralised governance is the build
        it / run it ethos popularised by Amazon. Teams are responsible
        for all aspects of the software they build including operating
        the software 24/7. Devolution of this level of responsibility
        is definitely not the norm but we do see more and more
        companies pushing responsibility to the development
        teams. Netflix is another organisation that has adopted this
        ethos<a href="#footnote-netflix-flowcon">[11]</a>. Being woken up at 3am
        every night by your pager is certainly a powerful incentive to
        focus on quality when writing your code. These ideas are about
        as far away from the traditional centralized governance model
        as it is possible to be.</p>
</div>

<div id="DecentralizedDataManagement">
<h3>Decentralized Data Management</h3>

<p>Decentralization of data management presents in a number of
        different ways. At the most abstract level, it means that the
        conceptual model of the world will differ between systems.
        This is a common issue when integrating across a large
        enterprise, the sales view of a customer will differ from the
        support view. Some things that are called customers in the
        sales view may not appear at all in the support view. Those
        that do may have different attributes and (worse) common
        attributes with subtly different semantics.</p>

<div class="sidebar" id="Battle-testedStandardsAndEnforcedStandards">
<h3>Battle-tested standards and enforced standards</h3>

<p>It's a bit of a dichotomy that microservice teams tend to
          eschew the kind of rigid enforced standards laid down by
          enterprise architecture groups but will happily use and even
          evangelise the use of open standards such as HTTP, ATOM and
          other microformats.</p>

<p>The key difference is how the standards are developed and
          how they are enforced. Standards managed by groups such as
          the IETF only <i>become</i> standards when there are several
          live implementations of them in the wider world and which
          often grow from successful open-source projects.</p>

<p>These standards are a world apart from many in a
          corporate world, which are often developed by groups that
          have little recent programming experience or overly influenced
          by vendors.</p>
</div>

<p>This issue is common between applications, but can also
        occur <i>within</i> applications, particular when that
        application is divided into separate components. A useful way
        of thinking about this is the Domain-Driven Design notion of
        <a href="/bliki/BoundedContext.html">Bounded Context</a>. DDD divides a complex
        domain up into multiple bounded contexts and maps out the
        relationships between them. This process is useful
        for both monolithic and microservice architectures, but there
        is a natural correlation between service and context
        boundaries that helps clarify, and as we describe in the
        section on business capabilities, reinforce the
        separations.</p>

<p>As well as decentralizing decisions about conceptual
        models, microservices also decentralize data storage
        decisions. While monolithic applications prefer a single logical
        database for persistant data, enterprises often prefer a
        single database across a range of applications - many of these
        decisions driven through vendor's commercial models around
        licensing.  Microservices prefer letting each service manage
        its own database, either different instances of the same
        database technology, or entirely different database systems -
        an approach called <a href="/bliki/PolyglotPersistence.html">Polyglot Persistence</a>. You
        can use polyglot persistence in a monolith, but it appears
        more frequently with microservices.</p>

<div class="figure">
<p class="figureImage"><a name="microservices_images_decentralised-data.png"></a><img alt="Figure 4" src="microservices/images/decentralised-data.png" style=""></p>
</div>

<p>Decentralizing responsibility for data across microservices
        has implications for managing updates. The common
        approach to dealing with updates has been to use transactions
        to guarantee consistency when updating multiple resources.
        This approach is often used within monoliths.</p>

<p>Using transactions like this helps with consistency, but
        imposes significant temporal coupling, which is problematic
        across multiple services. Distributed transactions are
        notoriously difficult to implement and and as a consequence
        microservice architectures <a href="http://www.eaipatterns.com/ramblings/18_starbucks.html">emphasize
        transactionless coordination between services</a>, with
        explicit recognition that consistency may only be eventual
        consistency and problems are dealt with by compensating
        operations.</p>

<p>Choosing to manage inconsistencies in this way is a new
  challenge for many development teams, but it is one that often
  matches business practice. Often businesses handle a degree of
  inconsistency in order to respond quickly to demand, while
  having some kind of reversal process to deal with
  mistakes. The trade-off is worth it as long as the cost of
  fixing mistakes is less than the cost of lost business under
  greater consistency.</p>
</div>

<div id="InfrastructureAutomation">
<h3>Infrastructure Automation</h3>

<p>Infrastructure automation techniques have evolved
        enormously over the last few years - the evolution of the
        cloud and AWS in particular has reduced the operational
        complexity of building, deploying and operating
        microservices.</p>

<p>Many of the products or systems being build with
        microservices are being built by teams with extensive
        experience of <a href="/bliki/ContinuousDelivery.html">Continuous Delivery</a> and it's
        precursor, <a href="/articles/continuousIntegration.html">Continuous
        Integration</a>. Teams building software this way make
  extensive use of infrastructure automation techniques. This is
  illustrated in the build pipeline shown below.</p>

<div class="figure">
<p class="figureImage"><a name="microservices_images_basic-pipeline.png"></a><img alt="Figure 5" src="microservices/images/basic-pipeline.png" style=""></p>

<p class="figureCaption">Figure 5: basic
        build pipeline</p>
</div>

<p>Since this isn't an article on Continuous Delivery we will
        call attention to just a couple of key features here. We want
        as much confidence as possible that our software is working,
        so we run lots of <b>automated tests</b>. Promotion of working
        software 'up' the pipeline means we <b>automate deployment</b>
        to each new environment.</p>

<div class="sidebar" id="MakeItEasyToDoTheRightThing">
<h3>Make it easy to do the right thing</h3>

<p>One side effect we have found of increased automation as
          a consequence of continuous delivery and deployment is the
          creation of useful tools to help developers and operations
          folk. Tooling for creating artefacts, managing codebases,
          standing up simple services or for adding standard
          monitoring and logging are pretty common now. The best
          example on the web is probably <a href="http://netflix.github.io/">Netflix's set of open
          source tools</a>, but there are others including <a href="http://dropwizard.codahale.com/">Dropwizard</a> which
          we have used extensively.</p>
</div>

<p>A monolithic application will be built, tested and pushed
        through these environments quite happlily. It turns out that
        once you have invested in automating the path to production
        for a monolith, then deploying <i>more</i> applications
        doesn't seem so scary any more. Remember, one of the aims of
        CD is to make deployment boring, so whether its one or three
        applications, as long as its still boring it doesn't
        matter<a href="#footnote-trickycd">[12]</a>. </p>

<p>Another area where we see teams using extensive
        infrastructure automation is when managing microservices in
        production. In contrast to our assertion above that as long as
        deployment is boring there isn't that much difference between
        monoliths and microservices, the operational landscape for
        each can be strikingly different.</p>

<div class="figure">
<p class="figureImage"><a name="microservices_images_micro-deployment.png"></a><img alt="Figure 6" src="microservices/images/micro-deployment.png" style=""></p>

<p class="figureCaption">Figure 6: Module
        deployment often differs</p>
</div>
</div>

<div id="DesignForFailure">
<h3>Design for failure</h3>

<p>A consequence of using services as components, is that
        applications need to be designed so that they can tolerate the
        failure of services. Any service call could fail due to
        unavailability of the supplier, the client has to respond to
        this as gracefully as possible. This is a disadvantage
        compared to a monolithic design as it introduces additional
        complexity to handle it. The consequence is that microservice
        teams constantly reflect on how service failures affect the
        user experience. Netflix's <a href="https://github.com/Netflix/SimianArmy">Simian Army</a>
        induces failures of services and even datacenters during the
        working day to test both the application's resilience and
        monitoring.</p>

<div class="sidebar" id="TheCircuitBreakerAndProductionReadyCode">
<h3>The circuit breaker and production ready code</h3>

<p><a href="/bliki/CircuitBreaker.html">Circuit Breaker</a> appears in <a href="https://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00A32NXZO">Release It!</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""> alongside other
    patterns such as Bulkhead and Timeout. Implemented together,
    these patterns are crucially important when building
    communicating applications. This <a href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html">Netflix
    blog entry</a> does a great job of explaining their
    application of them.</p>
</div>

<p>This kind of automated testing in production would be
        enough to give most operation groups the kind of shivers
        usually preceding a week off work. This isn't to say that
        monolithic architectural styles aren't capable of
        sophisticated monitoring setups - it's just less common in our
        experience.</p>

<p>Since services can fail at any time, it's important to be
        able to detect the failures quickly and, if possible,
        automatically restore service. Microservice applications put a
        lot of emphasis on real-time monitoring of the application,
        checking both architectural elements (how many requests per
        second is the database getting) and business relevant metrics
        (such as how many orders per minute are received). Semantic
        monitoring can provide an early warning system of something
        going wrong that triggers development teams to follow up and
        investigate.</p>

<p>This is particularly important to a microservices
        architecture because the microservice preference towards
        choreography and <a href="/eaaDev/EventCollaboration.html">event collaboration</a>
        leads to emergent behavior. While many pundits praise the
        value of serendipitous emergence, the truth is that emergent
        behavior can sometimes be a bad thing. Monitoring is vital to
        spot bad emergent behavior quickly so it can be fixed.</p>

<div class="sidebar" id="SynchronousCallsConsideredHarmful">
<h3>Synchronous calls considered harmful</h3>

<p>Any time you have a number of synchronous calls between services you will
    encounter the multiplicative effect of downtime. Simply,
    this is when the downtime of your system becomes the product
    of the downtimes of the individual components. You face a
    choice, making your calls asynchronous or managing
    the downtime. At www.guardian.co.uk they have implemented a
    simple rule on the new platform - one synchronous call per
    user request while at Netflix, their platform API redesign
    has built asynchronicity into the API fabric.</p>
</div>

<p>Monoliths can be built to be as transparent as a
        microservice - in fact, they should be. The difference is that
        you absolutely need to know when services running in different
        processes are disconnected. With libraries within the same
        process this kind of transparency is less likely to be
        useful.</p>

<p>Microservice teams would expect to see sophisticated
        monitoring and logging setups for each individual
        service such as dashboards showing up/down status and a variety of
        operational and business relevant metrics. Details on circuit
        breaker status, current throughput and latency are other
        examples we often encounter in the wild.</p>
</div>

<div id="EvolutionaryDesign">
<h3>Evolutionary Design</h3>

<p>Microservice practitioners, usually have come from
        an evolutionary design background and see service
        decomposition as a further tool to enable application
        developers to control changes in their application without
        slowing down change. Change control doesn't necessarily mean
        change reduction - with the right attitudes and tools you can
        make frequent, fast, and well-controlled changes to
        software.</p>

<p>Whenever you try to break a software system into
        components, you're faced with the decision of how to divide up
        the pieces - what are the principles on which we decide to
        slice up our application? The key property of a component is
        the notion of independent replacement and
        upgradeability<a href="#footnote-RCA">[13]</a> - which implies we look for
        points where we can imagine rewriting a component without
        affecting its collaborators.  Indeed many microservice groups
        take this further by explicitly expecting many services to be
        scrapped rather than evolved in the longer term.</p>

<p>The Guardian website is a good example of an application
        that was designed and built as a monolith, but has been
        evolving in a microservice direction. The monolith still is
        the core of the website, but they prefer to add new features
        by building microservices that use the monolith's API. This
        approach is particularly handy for features that are
        inherently temporary, such as specialized pages to handle a
        sporting event. Such a part of the website can quickly be put
        together using rapid development languages, and removed once
        the event is over. We've seen similar approaches at a
        financial institution where new services are added for a
        market opportunity and discarded after a few months or even
        weeks.</p>

<p>This emphasis on replaceability is a special case of a more
        general principle of modular design, which is to drive
        modularity through the pattern of change <a href="#footnote-beck-rate-of-change">[14]</a>. You want to keep things that change
        at the same time in the same module. Parts of a system that
        change rarely should be in different services to those that
        are currently undergoing lots of churn. If you find yourself
        repeatedly changing two services together, that's a sign that
        they should be merged.</p>

<p>Putting components into services adds an opportunity for
        more granular release planning. With a monolith any changes
        require a full build and deployment of the entire
        application. With microservices, however, you only need to
        redeploy the service(s) you modified. This can simplify and
        speed up the release process. The downside is that you have to
        worry about changes to one service breaking its
        consumers. The traditional integration approach is to try to deal
        with this problem using versioning, but the preference in the
        microservice world is to <a href="/articles/enterpriseREST.html#versioning">only
        use versioning as a last resort</a>. We can avoid a lot of
        versioning by designing services to be as tolerant as possible
        to changes in their suppliers.</p>
</div>
</div>

<div id="AreMicroservicesTheFuture"><hr class="topSection">
<h2>Are Microservices the Future?</h2>

<p>Our main aim in writing this article is to explain the major
      ideas and principles of microservices. By taking the time to do
      this we clearly think that the microservices architectural style
      is an important idea - one worth serious consideration for
      enterprise applications. We have recently built several systems
      using the style and know of others who have used and favor this
      approach.</p>

<p>Those we know about who are in some way pioneering the
      architectural style include Amazon, Netflix, <a href="http://www.theguardian.com">The Guardian</a>, the <a href="https://gds.blog.gov.uk/">UK Government Digital Service</a>, <a href="realestate.com.au">realestate.com.au</a>, Forward and <a href="http://www.comparethemarket.com/">comparethemarket.com</a>. The
      conference circuit in 2013 was full of examples of companies
      that are moving to something that would class as microservices -
      including Travis CI. In addition there are plenty of
      organizations that have long been doing what we would class as
      microservices, but without ever using the name. (Often this is
      labelled as SOA - although, as we've said, SOA comes in many
      contradictory forms. <a href="#footnote-already">[15]</a>) </p>

<p>Despite these positive experiences, however, we aren't
      arguing that we are certain that microservices are the future
      direction for software architectures. While our experiences so
      far are positive compared to monolithic applications, we're
      conscious of the fact that not enough time has passed for us to
      make a full judgement.</p>

<div class="book sidebar">
<p><a href="https://www.amazon.com/gp/product/1491950358?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491950358"><img src="microservices/images/sam-book.jpg"></a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></p>

<p>Our colleague Sam Newman spent most of 2014 working on a
        <a href="https://www.amazon.com/gp/product/1491950358?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491950358">book that captures our experiences with building
        microservices</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden="">. This should be your next step if you want a deeper
        dive into the topic.</p>
</div>

<p>Often the true consequences of your architectural decisions
      are only evident several years after you made them. We have seen
      projects where a good team, with a strong desire for
      modularity, has built a monolithic architecture that has
      decayed over the years. Many people believe that such decay is
      less likely with microservices, since the service boundaries are
      explicit and hard to patch around. Yet until we see enough
      systems with enough age, we can't truly assess how microservice
      architectures mature.</p>

<p>There are certainly reasons why one might expect
      microservices to mature poorly. In any effort at
      componentization, success depends on how well the software fits
      into components. It's hard to figure out exactly where the
      component boundaries should lie. Evolutionary design recognizes
      the difficulties of getting boundaries right and thus the
      importance of it being easy to refactor them. But when your
      components are services with remote communications, then
      refactoring is much harder than with in-process libraries.
      Moving code is difficult across service boundaries, any
      interface changes need to be coordinated between participants,
      layers of backwards compatibility need to be added, and testing
      is made more complicated.</p>

<p>Another issue is If the components do not compose cleanly, then
      all you are doing is shifting complexity from inside a component
      to the connections between components. Not just does this just
      move complexity around, it moves it to a place that's less
      explicit and harder to control. It's easy to think things are
      better when you are looking at the inside of a small, simple
      component, while missing messy connections between services.</p>

<p>Finally, there is the factor of team skill. New techniques
      tend to be adopted by more skillful teams. But a technique that
      is more effective for a more skillful team isn't necessarily
      going to work for less skillful teams. We've seen plenty of
      cases of less skillful teams building messy monolithic
      architectures, but it takes time to see what happens when this
      kind of mess occurs with microservices. A poor team will always
      create a poor system - it's very hard to tell if microservices
      reduce the mess in this case or make it worse.</p>

<p>One reasonable argument we've heard is that you shouldn't
      start with a microservices architecture. Instead
      <a href="/bliki/MonolithFirst.html">begin with a monolith</a>,
      keep it modular, and split it into microservices once the
      monolith becomes a problem. (Although
      <a href="/articles/dont-start-monolith.html">this advice isn't ideal</a>,
      since a good in-process interface is usually not a good service interface.)</p>

<p>So we write this with cautious optimism. So far, we've seen
      enough about the microservice style to feel that it can be
      <a href="/microservices/">a worthwhile road to tread</a>.
      We can't say for sure where we'll end
      up, but one of the challenges of software development is that
      you can only make decisions based on the imperfect information
      that you currently have to hand.</p>
</div>

<hr class="bodySep">

</div>
<div class="appendix">
<div class="footnote-list">
<h2>Footnotes</h2>

<div class="footnote-list-item" id="footnote-etymology">
<p><span class="num">1: </span>
      The term "microservice" was discussed at a workshop of software
      architects near Venice in May, 2011 to describe what the
      participants saw as a common architectural style that many of
      them had been recently exploring. In May 2012, the same group decided on
      "microservices" as the most appropriate name. James presented some of these
      ideas as a case study in March 2012 at 33rd Degree in Krakow in
      <a href="http://2012.33degree.org/talk/show/67">Microservices
      - Java, the Unix Way</a> as did Fred George <a href="http://www.slideshare.net/fredgeorge/micro-service-architecure">about
      the same time</a>. Adrian Cockcroft at Netflix, describing this
      approach as "fine grained SOA" was pioneering the style at web
      scale as were many of the others mentioned in this article - Joe
      Walnes, Dan North, Evan Botcher and
      Graham Tackley.
    </p>
</div>

<div class="footnote-list-item" id="footnote-monolith">
<p><span class="num">2: </span>
      The term monolith has been in use by the Unix community for some
      time. It appears in <a href="https://www.amazon.com/gp/product/B003U2T5BA?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B003U2T5BA">The Art of Unix
      Programming</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""> to describe systems that get too big.
    </p>
</div>

<div class="footnote-list-item" id="footnote-service-object">
<p><span class="num">3: </span>
      Many object-oriented designers, including ourselves, use the
      term service object in the <a href="https://www.amazon.com/gp/product/0321125215?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215">Domain-Driven
      Design</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""> sense for an object that carries out a significant
      process that isn't tied to an entity. This is a different
      concept to how we're using "service" in this article. Sadly the
      term service has both meanings and we have to live with the
      polyseme.
    </p>
</div>

<div class="footnote-list-item" id="footnote-application">
<p><span class="num">4: </span>
      We consider <a href="/bliki/ApplicationBoundary.html">an application to be a social
      construction</a> that binds together a code base, group of
      functionality, and body of funding.
    </p>
</div>

<div class="footnote-list-item" id="footnote-conwayslaw">
<p><span class="num">5: </span>
      The original paper can be found on Melvyn Conway's website <a href="http://www.melconway.com/Home/Committees_Paper.html">here</a></p>
</div>

<div class="footnote-list-item" id="footnote-protobufs">
<p><span class="num">6: </span>
      At extremes of scale, organisations often move to binary
      protocols - <a href="https://code.google.com/p/protobuf/">protobufs</a> for
      example. Systems using these still exhibit the characteristic of
      smart endpoints, dumb pipes - and trade off <i>transparency</i>
      for scale. Most web properties and certainly the vast majority
      of enterprises don't need to make this tradeoff - transparency
      can be a big win.
    </p>
</div>

<div class="footnote-list-item" id="footnote-esb">
<p><span class="num">7: </span>
      We can't resist mentioning Jim Webber's statement that ESB
      stands for <a href="http://www.infoq.com/presentations/soa-without-esb">"Egregious
      Spaghetti Box"</a>. </p>
</div>

<div class="footnote-list-item" id="footnote-fine-grained">
<p><span class="num">8: </span>
      Netflix makes the link explicit - until recently referring to
      their architectural style as fine-grained SOA.
    </p>
</div>

<div class="footnote-list-item" id="footnote-YAGNI">
<p><span class="num">9: </span>
      "YAGNI" or "You Aren't Going To Need It" is an <a href="http://c2.com/cgi/wiki?YouArentGonnaNeedIt">XP
      principle</a> and exhortation to not add features until you know
      you need them.
    </p>
</div>

<div class="footnote-list-item" id="footnote-many-languages">
<p><span class="num">10: </span>
      It's a little disengenuous of us to claim that monoliths are
      single language - in order to build systems on todays web, you
      probably need to know JavaScript and XHTML, CSS, your server
      side language of choice, SQL and an ORM dialect. Hardly single
      language, but you know what we mean.
    </p>
</div>

<div class="footnote-list-item" id="footnote-netflix-flowcon">
<p><span class="num">11: </span>
      Adrian Cockcroft specifically mentions "developer self-service"
      and "Developers run what they wrote"(sic) in <a href="http://www.slideshare.net/adrianco/flowcon-added-to-for-cmg-keynote-talk-on-how-speed-wins-and-how-netflix-is-doing-continuous-delivery">this
      excellent presentation</a> delivered at Flowcon in November,
      2013.
    </p>
</div>

<div class="footnote-list-item" id="footnote-trickycd">
<p><span class="num">12: </span>
      We are being a little disengenuous here. Obviously deploying
      more services, in more complex topologies is more difficult than
      deploying a single monolith. Fortunately, patterns reduce this
      complexity - investment in tooling is still a must though.
    </p>
</div>

<div class="footnote-list-item" id="footnote-RCA">
<p><span class="num">13: </span>
      In fact, Dan North refers to this style as <i>Replaceable
      Component Architecture</i> rather than microservices. Since this
      seems to talk to a subset of the characteristics we prefer the
      latter.
    </p>
</div>

<div class="footnote-list-item" id="footnote-beck-rate-of-change">
<p><span class="num">14: </span>
      Kent Beck highlights this as one his design principles in
      <a href="https://www.amazon.com/gp/product/0321413091?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321413091">Implementation Patterns</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden="">.
    </p>
</div>

<div class="footnote-list-item" id="footnote-already">
<p><span class="num">15: </span>
      And SOA is hardly the root of this history. I remember people saying
      "we've been doing this for years" when the SOA term appeared at
      the beginning of the century. One argument was that this style
      sees its roots as the way COBOL programs communicated via data
      files in the earliest days of enterprise computing. In another
      direction, one could argue that microservices are the same thing
      as the Erlang programming model, but applied to an enterprise
      application context.
    </p>
</div>
</div>

<div id="References"><hr class="topSection">
<h2>References</h2>

<p>While this is not an exhaustive list, there are a number of sources
that practitioners have drawn inspiration from or which espouse a
similar philosophy to that described in this article.</p>

<p>Blogs and online articles</p>

<ul>
<li><a href="http://blogs.msdn.com/b/clemensv/">Clemens Vasters’ blog
on cloud at microsoft</a></li>

<li><a href="http://davidmorgantini.blogspot.com/2013/08/micro-services-introduction.htm">David
Morgantini’s introduction to the topic on his blog</a></li>

<li><a href="http://12factor.net/">12 factor apps from Heroku</a></li>

<li><a href="https://www.gov.uk/design-principles">UK Government
Digital Service design principles</a></li>

<li><a href="http://jimmynilsson.com/blog/">Jimmy Nilsson’s blog</a><a href="http://www.infoq.com/articles/CCC-Jimmy-Nilsson">and article
on infoq about Cloud Chunk Computing</a></li>

<li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Alistair
Cockburn on Hexagonal architectures</a></li>
</ul>

<p>Books</p>

<ul>
<li><a href="https://www.amazon.com/gp/product/0978739213?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0978739213">Release it</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0596805829?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596805829">Rest in practice</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://pages.apigee.com/web-api-design-ebook.html">Web
API Design (free ebook)</a>. Brian Mulloy, Apigee.</li>

<li><a href="https://www.amazon.com/gp/product/0321200683?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321200683">Enterprise Integration
Patterns</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0131429019?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131429019">Art of unix programming</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0321503627?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627">Growing Object Oriented Software, Guided
by Tests</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0198293755?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0198293755">The Modern Firm: Organizational Design for
Performance and Growth</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0321601912?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321601912">Continuous Delivery: Reliable Software
Releases through Build, Test, and Deployment Automation</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>

<li><a href="https://www.amazon.com/gp/product/0321125215?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215">Domain-Driven Design: Tackling Complexity
in the Heart of Software</a><img src="https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="" style="width: 1px !important; height: 1px !important; border: none !important; margin: 0px !important; display: none !important;" hidden=""></li>
</ul>

<p>Presentations</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=qVyt3qQ_7TA">Architecture
without Architects</a>. Erik Doernenburg.</li>

<li><a href="http://www.infoq.com/presentations/soa-without-esb">Does
my bus look big in this?</a>. Jim Webber and Martin Fowler, QCon
2008</li>

<li><a href="http://www.infoq.com/presentations/webber-guerilla-soa">Guerilla
SOA</a>. Jim Webber, 2006</li>

<li><a href="http://vimeo.com/43659070">Patterns of Effective
Delivery</a>. Dan North, 2011.</li>

<li><a href="http://www.slideshare.net/adrianco">Adrian Cockcroft's
slideshare channel</a>.</li>

<li><a href="http://vimeo.com/28608667">Hydras and Hypermedia</a>. Ian
Robinson, JavaZone 2010</li>

<li><a href="">Justice will take a million intricate
moves</a>. Leonard Richardson, Qcon 2008.</li>

<li><a href="http://vimeo.com/74452550">Java, the UNIX way</a>. James
Lewis, JavaZone 2012</li>

<li><a href="http://yow.eventer.com/yow-2012-1012/micro-services-architecture-by-fred-george-1286">Micro
services architecture</a>. Fred George, YOW! 2012</li>

<li><a href="http://gotocon.com/video#18">Democratising attention data
at guardian.co.uk</a>. Graham Tackley, GOTO Aarhus 2013</li>

<li><a href="http://gotocon.com/video#6">Functional Reactive
Programming with RxJava</a>. Ben Christensen, GOTO Aarhus 2013
(registration required).</li>

<li><a href="http://www.infoq.com/presentations/Breaking-the-Monolith">Breaking
the Monolith</a>. Stefan Tilkov, May 2012.</li>
</ul>

<p>Papers</p>

<ul>
<li>L. Lamport, "The Implementation of Reliable Distributed
Multiprocess Systems", 1978 http://
research.microsoft.com/en-us/um/people/lamport/pubs/implementation.pdf</li>

<li>L. Lamport, R. Shostak, M. Pease, "The Byzantine Generals
Problem", 1982 (available at) http://
www.cs.cornell.edu/courses/cs614/2004sp/papers/lsp82.pdf</li>

<li>R.T. Fielding, "Architectural Styles and the Design of
Network-based Software Architectures", 2000
http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</li>

<li>E. A. Brewer, "Towards Robust Distributed Systems", 2000
http://www.cs.berkeley.edu/ ~brewer/cs262b-2004/PODC-keynote.pdf</li>

<li>E. Brewer, "CAP Twelve Years Later: How the 'Rules' Have Changed",
2012, http://
www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed</li>
</ul>
</div>

<div id="further-reading"><hr class="topSection">
<h2>Further Reading</h2>

<p><a href="/microservices"><img src="/microservices/microservices-sq.png"></a>The above list captures the references we used when we originally
  wrote this article in early 2014. For an up to date list of sources
  for more information, take a look at the <a href="/microservices">Microservice Resource Guide</a>.</p>
</div>
</div>

<br><hr>

<a href="https://smartbear.com/learn/api-design/what-are-microservices/">src N3</a>
<h2>what-are-microservices</h2>
<div class="col-md-9 cye-lm-tag">
            
            <p class="cye-lm-tag">While there is no standard, formal definition of microservices, there are certain characteristics that help us identify the style.&nbsp; Essentially, microservice architecture is a method of developing software applications as a suite of independently deployable, small, modular services in which each service runs a unique process and communicates through a well-defined, lightweight mechanism to serve a business goal.<br>
&nbsp;<br>
How the services communicate with each other depends on your application’s requirements, but many developers use HTTP/REST with JSON or <a href="https://github.com/google/protobuf/" target="_blank">Protobuf</a>.&nbsp; DevOps professionals are, of course, free to choose any communication protocol they deem suitable, but in most situations, <a href="http://blog.smartbear.com/apis/understanding-soap-and-rest-basics/" target="_blank">REST</a> (Representational State Transfer) is a useful integration method because of its comparatively lower complexity over other protocols.<br>
&nbsp;<br>
To begin to understand microservices architecture, it helps to consider its opposite: the monolithic architectural style.&nbsp; Unlike microservices, a monolith application is always built as a single, autonomous unit.&nbsp; In a client-server model, the server-side application is a monolith that handles the HTTP requests, executes logic, and retrieves/updates the data in the underlying database.&nbsp; The problem with a monolithic architecture, though, is that all change cycles usually end up being tied to one another.&nbsp; A modification made to a small section of an application might require building and deploying an entirely new version.&nbsp; If you need to scale specific functions of an application, you may have to scale the entire application instead of just the desired components.&nbsp; This is where <a href="https://smartbear.com/learn/api-design/how-to-create-a-microservices-setup/">creating microservices</a> can come to the rescue.&nbsp;</p>

<h2>SOA vs. Microservices</h2>

<p class="cye-lm-tag">“Wait a minute,” some of you may be murmuring over your morning coffee, “isn’t this just another name for SOA?”&nbsp; Service-Oriented Architecture (SOA) sprung up during the first few years of this century, and microservice architecture (<a href="http://blog.xebia.com/2015/02/04/microservices-versus-the-common-soa-implementation/" target="_blank">abbreviated by some</a> as MSA) bears a number of similarities.&nbsp; Traditional SOA, however, is a broader framework and can mean <a href="http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html" target="_blank">a wide variety of things</a>.&nbsp; Some microservices advocates reject the SOA tag altogether, while others consider microservices to be simply an ideal, refined form of SOA.&nbsp; In any event, we think there are clear enough differences to justify a distinct “microservice” concept (at least as a special form of SOA, as we’ll illustrate later).<br>
&nbsp;<br>
The typical SOA model, for example, usually has more dependent <a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">ESBs</a>, with microservices using faster messaging mechanisms.&nbsp; SOA also focuses on imperative programming, whereas microservices architecture focuses on a responsive-actor programming style.&nbsp; Moreover, SOA models tend to have an outsized relational database, while microservices frequently use NoSQL or micro-SQL databases (which can be connected to conventional databases).&nbsp; But the real difference has to do with the architecture methods used to arrive at an integrated set of services in the first place.&nbsp;<br>
&nbsp;<br>
Since everything changes in the digital world, <a href="https://smartbear.com/learn/software-testing/what-is-agile-testing/">agile development techniques</a> that can keep up with the demands of software evolution are invaluable.&nbsp; Most of the practices used in microservices architecture come from developers who have created software applications for large enterprise organizations, and who know that today’s end users expect dynamic yet consistent experiences across a wide range of devices.&nbsp; Scalable, adaptable, modular, and quickly accessible cloud-based applications are in high demand.&nbsp; And this has led many developers to change their approach.</p>

<h2>Examples of Microservices</h2>

<p class="cye-lm-tag">As Martin Fowler <a href="http://martinfowler.com/articles/microservices.html" target="_blank">points out</a>, Netflix, eBay, Amazon, the UK Government Digital Service, realestate.com.au, Forward, Twitter, PayPal, Gilt, Bluemix, Soundcloud, The Guardian, and many other large-scale websites and applications have all evolved from monolithic to microservices architecture.<br>
&nbsp;<br>
Netflix has a widespread architecture that has evolved from monolithic to SOA.&nbsp; It receives more than <em>one billion</em> calls every day, from more than 800 different types of devices, to its streaming-video API.&nbsp; Each API call then prompts around five additional calls to the backend service.<br>
&nbsp;<br>
Amazon has also migrated to microservices.&nbsp; They get countless calls from a variety of applications—including applications that manage the web service API as well as the website itself—which would have been simply impossible for their old, two-tiered architecture to handle.<br>
&nbsp;<br>
The auction site eBay is yet another example that has gone through the same transition.&nbsp; Their core application comprises several autonomous applications, with each one executing the business logic for different function areas.</p>

<div class="trial-cta-banner grey-banner">
<h3>Build and Design your APIs Now with <strong>SwaggerHub</strong></h3>
<a class="cta-button in-page-cta" data-learn-product="SwaggerHub" href="http://swaggerhub.com/">Sign Up Free</a></div>

<h2>Understanding Microservice Architecture</h2>

<p class="cye-lm-tag">Just as there is no formal definition of the term microservices, there’s no standard model that you’ll see represented in every system based on this architectural style.&nbsp; But you can expect most microservice systems to share a few notable characteristics.<br>
&nbsp;<br>
First, software built as microservices can, by definition, be broken down into multiple component services.&nbsp; Why?&nbsp; So that each of these services can be deployed, tweaked, and then redeployed independently without compromising the integrity of an application.&nbsp; As a result, you might only need to change one or more distinct services instead of having to redeploy entire applications.&nbsp; But this approach does have its downsides, including expensive remote calls (instead of in-process calls), coarser-grained remote APIs, and increased complexity when redistributing responsibilities between components.<br>
&nbsp;<br>
Second, the microservices style is usually organized around business capabilities and priorities.&nbsp; Unlike a traditional monolithic development approach—where different teams each have a specific focus on, say, UIs, databases, technology layers, or server-side logic—microservice architecture utilizes cross-functional teams. &nbsp;The responsibilities of each team are to make specific products based on one or more individual services communicating via message bus.&nbsp; That means that when changes are required, there won’t necessarily be any reason for the project, as a whole, to take more time or for developers to have to wait for budgetary approval before individual services can be improved.&nbsp; Most development methods focus on projects: a piece of code that has to offer some predefined business value, must be handed over to the client, and is then periodically maintained by a team.&nbsp; But in microservices, a team owns the product for its lifetime, as in Amazon’s oft-quoted maxim “<a href="http://www.strehle.de/tim/weblog/archives/2010/11/09/1320">You build it, you run it</a>.”<br>
&nbsp;<br>
Third, microservices act somewhat like the classical UNIX system: they receive requests, process them, and generate a response accordingly.&nbsp; This is opposite to how many other products such as ESBs (Enterprise Service Buses) work, where high-tech systems for message routing, choreography, and applying business rules are utilized.&nbsp; You could say that microservices have smart endpoints that process info and apply logic, and dumb pipes through which the info flows.<br>
&nbsp;<br>
Fourth, since microservices involve a variety of technologies and platforms, old-school methods of centralized governance aren’t optimal.&nbsp; Decentralized governance is favored by the microservices community because its developers strive to produce useful tools that can then be used by others to solve the same problems.&nbsp; A practical example of this is Netflix—the service responsible for <a href="http://www.wsj.com/articles/SB10001424052702304908304579561802483718502" target="_blank">about 30% of traffic on the web</a>.&nbsp; The company encourages its developers to save time by always using code libraries established by others, while also giving them the freedom to flirt with alternative solutions when needed.&nbsp; Just like decentralized governance, microservice architecture also favors decentralized data management.&nbsp; Monolithic systems use a single logical database across different applications.&nbsp; In a microservice application, each service usually manages its unique database.<br>
&nbsp;<br>
Fifth, like a well-rounded child, microservices are designed to cope with failure.&nbsp; Since several unique and diverse services are communicating together, it’s quite possible that a service could fail, for one reason or another (e.g., when the supplier isn’t available).&nbsp; In these instances, the client should allow its neighboring services to function while it bows out in as graceful a manner as possible.&nbsp; For obvious reasons, this requirement adds more complexity to microservices as compared to monolithic systems architecture.<br>
&nbsp;<br>
Finally, microservices architecture is an evolutionary design and, again, is ideal for evolutionary systems where you can’t fully anticipate the types of devices that may one day be accessing your application.&nbsp; This is because the style’s practitioners see decomposition as a powerful tool that gives them control over application development.&nbsp; A good instance of this scenario could be seen with <a href="http://www.theguardian.com/us" target="_blank"><em>The Guardian’s</em> website</a> (prior to the late 2014 redesign).&nbsp; The core application was initially based on monolithic architecture, but as several unforeseen requirements surfaced, instead of revamping the entire app the developers used microservices that interact over an older monolithic architecture through APIs.<br>
&nbsp;<br>
To sum up: Microservice architecture uses services to componentize and is usually organized around business capabilities; focuses on products instead of projects; has smart end points but not-so-smart info flow mechanisms; uses decentralized governance as well as decentralized data management; is designed to accommodate service interruptions; and, last but not least, is an evolutionary model.&nbsp;<br>
&nbsp;<br>
Now let’s take a closer look at how all of it actually plays out in practice…</p>

<h2>How Microservice Architecture Works</h2>

<p class="cye-lm-tag">“If you wish to converse with me,” said Voltaire, “define your terms.”&nbsp; Just as there is more than one programming language, there are many terms to describe similar concepts used by different developers.&nbsp; So to follow our brief overview of microservices here, it will help to have at least a basic grasp of the following concepts:</p>

<ul>
	<li>Object Oriented Programming (OOP)—<em>a modern programming paradigm (see also </em><a href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29" target="_blank"><em>SOLID</em></a><em>)</em></li>
	<li>Web service / API—<em>a way to expose the functionality of your application to others, without a user interface</em></li>
	<li>Service Oriented Architecture (SOA)—<em>a way of structuring many related applications to work together, rather than trying to solve all problems in one application</em></li>
	<li>Systems—<em>in the general sense, meaning any collection of parts that can work together for a wider purpose</em></li>
	<li>Single Responsibility Principle (SRP)—<em>the idea of code with one focus</em></li>
	<li>Interface Segregation Principle (ISP)—<em>the idea of code with defined boundaries.</em></li>
</ul>

<h2>1) Monoliths and Conway’s Law</h2>

<p class="cye-lm-tag">To begin with, let’s explore <a href="http://en.wikipedia.org/wiki/Conway%27s_law" target="_blank">Conway’s Law</a>, which states: <em>“Organizations which design systems…are constrained to produce designs which are copies of the communication structures of these organizations.”</em><br>
&nbsp;<br>
Imagine Company X with two teams: <em>Support</em> and <em>Accounting</em>.&nbsp; Instinctively, we separate out the high risk activities; it’s only difficult deciding responsibilities like customer refunds.&nbsp; Consider how we might answer questions like “Does the Accounting team have enough people to process both customer refunds and credits?” or “Wouldn’t it be a better outcome to have our Support people be able to apply credits and deal with frustrated customers?”&nbsp; The answers get resolved by Company X’s new policy: Support can apply a <em>credit</em>, but Accounting has to <em>process a refund</em> to return money to a customer.&nbsp; The roles and responsibilities in this interconnected system have been successfully split, while gaining customer satisfaction and minimizing risks.<br>
&nbsp;<br>
Likewise, at the beginning of designing any software application, companies typically assemble a <em>team</em> and create a <em>project</em>.&nbsp; Over time, the team grows, and multiple projects on the same codebase are completed.&nbsp; More often than not, this leads to competing projects: two people will find it difficult to work at cross purposes in the same area of code without introducing tradeoffs.&nbsp; And adding more people to the equation only makes the problem worse.&nbsp; As <a href="http://en.wikipedia.org/wiki/Brooks%27s_law" target="_blank">Fred Brooks</a> puts it, nine women can’t make a baby in one month.&nbsp;<br>
&nbsp;<br>
Moreover, in Company X or in any dev team, priorities frequently shift, resulting in management and communication issues.&nbsp; Last month’s highest priority item may have caused our team to push hard to ship code, but now a user is reporting an issue, and we no longer have time to resolve it because of <em>this</em> month’s priority.&nbsp; This is the most compelling reason to adopt SOA, including the microservices variety.&nbsp; Service-oriented approaches recognize the frictions involved between change management, domain knowledge, and business priorities, allowing dev teams to explicitly separate and address them.&nbsp; Of course, this in itself is a tradeoff—it requires coordination—but it allows you to centralize friction and introduce efficiency, as opposed to suffering from a large number of small inefficiencies.<br>
&nbsp;<br>
Most importantly, smartly implementing an SOA or microservice architecture forces you to apply the <a href="http://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank">Interface Separation Principle</a>.&nbsp; Due to the connected nature of mature systems, when isolating issues of concern, the typical approach is to find a seam or communication point and then draw a dotted line between two halves of the system.&nbsp; Without careful thought, however, this can lead to accidentally creating two smaller but growing monoliths, now connected with some kind of bridge.&nbsp; The consequence of this can be marooning important code on the wrong side of a barrier: Team A doesn’t bother to look after it, while Team B needs it, so they reinvent it.</p>

<h2>2) Microservices: Avoiding the Monoliths</h2>

<p class="cye-lm-tag">We’ve named some problems that commonly emerge; now let’s begin to look at some solutions.<br>
&nbsp;<br>
How do you deploy relatively independent yet integrated services without spawning accidental monoliths?&nbsp; Well, suppose you have a large application, as in the sample from our Company X below, and are splitting up the codebase and teams to scale.&nbsp; Instead of finding an entire section of an application to split off, you can look for something on the <em>edge</em> of the application graph.&nbsp; You can tell which sections these are because nothing depends on them.&nbsp; In our example, the arrows pointing to Printer and Storage suggest they’re two things that can be easily removed from our main application and abstracted away.&nbsp; Printing either a Job or Invoice is irrelevant; a Printer just wants printable data.&nbsp; Turning these—Printer and Storage—into external services avoids the monoliths problem alluded to before.&nbsp; It also makes sense as they are used multiple times, and there’s little that can be reinvented.&nbsp; Use cases are well known from past experience, so you can avoid accidentally removing key functionality.<br>
&nbsp;<br>
<img alt="MicroServices Architecture" src="./micro_pics_files/microservices_image1.png" style="border-width: 0px; border-style: solid; width: 500px; height: 352px;"></p>

<h2>3) Service Objects and Identifying Data</h2>

<p class="cye-lm-tag">So how do we go from monoliths to services?&nbsp; One way is through <em>service objects</em>.&nbsp; Without removing code from your application, you effectively just begin to structure it as though it were completely external.&nbsp; To do that, you’ll first need to differentiate the <em>actions</em> that can be done and the <em>data</em> that is present as inputs and outputs of those actions.&nbsp; Consider the code below, with a notion of <em>doing something useful</em> and a <em>status of that task</em>.<br>
&nbsp;<br>
<img alt="https://lh4.googleusercontent.com/c1m-A0QI3j2Jchp2jF8y2yE-jGzmS1pJKoMDna-i0Y3E7boyIF1Pga9mjm1aEycxJAdNyMVWCRbQIhMwMt1DkaYH4TYIUD_JdcfgsvD5XF2kpYDK_SJZuVzNg50Bh_CJlA" src="./micro_pics_files/microservices_code1.png" style="border-width: 0px; border-style: solid; width: 500px; height: 440px;"><br>
&nbsp;<br>
To prepare this to begin looking like a microservice, what’s next?<br>
&nbsp;<br>
<img alt="https://lh6.googleusercontent.com/bIR5tLCb3yJom6jYyIKeBLPtTWnYxnurkTRUBpPNj47Z8fXrbmibKsVv-F19ha-dNXDPD8LyxYH4FgYnA4z9dM15BqBpwnIStOLUodh2XzhjR0PYdGIZZhDwIz4IGFNRow" src="./micro_pics_files/microservices_code2.png" style="border-width: 0px; border-style: solid; width: 500px; height: 701px;"><br>
&nbsp;<br>
Now we’ve distinguished two distinct classes: one that models the data, and one that performs the operations.&nbsp; Importantly, our JobService class has little or no state—you can call the same actions over and over, changing only the data, and expect to get consistent results.&nbsp; If JobService somehow started taking place over a network, our otherwise monolithic application wouldn’t care.&nbsp; Shifting these types of classes into a library, and substituting a network client for the previous implementation, would allow you to transform the existing code into a scalable external service.<br>
&nbsp;<br>
This is <a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank">Hexagonal Architecture</a>, where the core of your application and the coordination is in the center, and the external components are orchestrated around it to achieve your goals.<br>
&nbsp;<br>
<img alt="" src="./micro_pics_files/hexagonalarchitecture.png" style="width: 500px; height: 474px; border-width: 0px; border-style: solid;"><br>
&nbsp;<br>
(You can read more about service objects and hexagonal architecture <a href="http://blog.mattwynne.net/2012/05/31/hexagonal-rails-objects-values-and-hexagons/" target="_blank">here</a> and <a href="https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services" target="_blank">here</a>.)</p>

<h2>4) Coordination and Dumb Pipes</h2>

<p class="cye-lm-tag">Now let’s take a closer look at what makes something a microservice as opposed to a traditional SOA.</p>

<p class="cye-lm-tag">Perhaps the most important distinction is <em>side effects</em>.&nbsp; Microservices avoid them.&nbsp; To see why, let’s look at an older approach: Unix pipes.</p>

<h3>ls | wc -l</h3>

<p class="cye-lm-tag">Above, two programs are chained together: the first lists all of the files in a directory, the second reads the number of lines in a stream of input.&nbsp; Imagine writing a comparable program, then having to modify it into the below:</p>

<h3>ls | less</h3>

<p class="cye-lm-tag">Composing small pieces of functionality relies on repeatable results, a standard mechanism for input and output, and an exit code for a program to indicate success or lack thereof.&nbsp; We know this works from observational evidence, and we also know that a Unix pipe is a “dumb” interface because it has no control statements.&nbsp; The pipe applies SRP by pushing data from A to B, and it’s up to members of the pipeline to decide if the input is unacceptable.<br>
&nbsp;<br>
Let’s go back to Company X’s Job and Invoice systems.&nbsp; Each controls a transaction and can be used together or separately: Invoices can be created for jobs, jobs can be created without an invoice, and invoices can be created without a job.&nbsp; Unlike Unix shell commands, the systems that own jobs and invoices have their own users working independently.&nbsp; But without falling back to a <em>policy</em>, it’s impossible to enforce rules for either system globally.<br>
&nbsp;<br>
Say we want to extract out the key operations that can be repeatedly executed—the services for sending an invoice, mutating a job status and mutating an invoice status.&nbsp; These are completely separate from the task of <em>persisting</em> data.<br>
&nbsp;<br>
<img alt="illing.png" src="./micro_pics_files/microservices_image-pipelines.png" style="width: 500px; height: 335px; border-width: 0px; border-style: solid;"><br>
&nbsp;<br>
Here this allows us to wire together the discrete components into two pipelines:</p>

<h2>User creates a manual invoice</h2>

<ul>
	<li>Adds data to invoice, status <em>created</em><br>
	— Invokes BillingPolicyService to determine when an invoice is payable for a given customer</li>
	<li>Invoice is issued to customer</li>
	<li>Persists to the invoice data service, status <em>sent</em></li>
</ul>

<h2>User finishes a job, creating an invoice</h2>

<ul>
	<li>Validates job is completable</li>
	<li>Adds data to invoice, status <em>created</em><br>
	—&nbsp;Invokes BillingPolicyService to determine when an invoice is payable for a given customer</li>
	<li>Invoice is issued to customer</li>
	<li>Persists to the invoice data service, status <em>sent</em></li>
</ul>

<p class="cye-lm-tag">The invoice calculation related steps are idempotent, and it’s then trivial to compose a <em>draft invoice</em> or preview the amounts payable by the customer by leveraging our new dedicated microservices.<br>
&nbsp;<br>
Unlike traditional SOA, the difference here is that we have low-level details exposed via a simple interface, as compared to a high-level API call that might execute an entire business action.&nbsp; With a high-level API, in fact, it becomes difficult to rewire small components together, since the service designer has removed many of the seams or choices we can take by providing a one-shot interface.<br>
&nbsp;<br>
By this point, the repetition of business logic, policy and rules leads many to traditionally push this complexity into a service bus or singular, centralized workflow orchestration tool.&nbsp; However, the crucial advantage of microservice architecture is not that we <em>never</em> share business rules/processes/policies, but that we push them into discrete packages, aligned to business needs.&nbsp; Not only does this mean that policy is distributed, but it also means that <em>you can change your business processes without risk</em>.</p>

<h2>Microservice Pros and Cons</h2>

<p class="cye-lm-tag">Microservices are not a silver bullet, and by implementing them you will expose communication, teamwork, and other problems that may have been previously implicit but are now forced out into the open. But <a href="https://smartbear.com/learn/api-design/api-gateways-in-microservices/">API Gateways in Microservices</a> can greatly reduce build and qa time and effort.<br>
&nbsp;<br>
One common issue involves sharing schema/validation logic across services.&nbsp; What A requires in order to consider some data valid doesn’t always apply to B, if B has different needs.&nbsp; The best recommendation is to apply versioning and distribute schema in shared libraries.&nbsp; Changes to libraries then become discussions between teams.&nbsp; Also, with strong versioning comes dependencies, which can cause more overhead.&nbsp; The best practice to overcome this is planning around backwards compatibility, and accepting <a href="https://smartbear.com/learn/automated-testing/what-is-regression-testing/" target="_blank">regression tests</a> from external services/teams.&nbsp; These prompt you to have a conversation <em>before</em> you disrupt someone else’s business process, not after.<br>
&nbsp;<br>
As with anything else, whether or not microservice architecture is right for you depends on your requirements, because they all have their pros and cons.&nbsp; Here’s a quick rundown of some of the good and bad:</p>

<p class="cye-lm-tag"><strong>Pros</strong></p>

<ol>
	<li>Microservice architecture gives developers the freedom to independently develop and deploy services</li>
	<li>A microservice can be developed by a fairly small team</li>
	<li>Code for different services can be written in different languages (though many practitioners discourage it)</li>
	<li>Easy integration and automatic deployment (using open-source continuous integration tools such as Jenkins, Hudson, etc.)</li>
	<li>Easy to understand and modify for developers, thus can help a new team member become productive quickly</li>
	<li>The developers can make use of the latest technologies</li>
	<li>The code is organized around business capabilities</li>
	<li>Starts the web container more quickly, so the deployment is also faster</li>
	<li>When change is required in a certain part of the application, only the related service can be modified and redeployed—no need to modify and redeploy the entire application</li>
	<li>Better fault isolation: if one microservice fails, the other will continue to work (although one problematic area of a monolith application can jeopardize the entire system)</li>
	<li>Easy to scale and integrate with third-party services</li>
	<li>No long-term commitment to technology stack</li>
</ol>

<p class="cye-lm-tag"><strong>Cons</strong></p>

<ol>
	<li>Due to distributed deployment, testing can become complicated and tedious</li>
	<li>Increasing number of services can result in information barriers</li>
	<li>The architecture brings additional complexity as the developers have to mitigate fault tolerance, network latency, and deal with a variety of message formats as well as load balancing</li>
	<li>Being a distributed system, it can result in duplication of effort</li>
	<li>When number of services increases, integration and managing whole products can become complicated</li>
	<li>In addition to several complexities of monolithic architecture, the developers have to deal with the additional complexity of a distributed system</li>
	<li>Developers have to put additional effort into implementing the mechanism of communication between the services</li>
	<li>Handling use cases that span more than one service without using distributed transactions is not only tough but also requires communication and cooperation between different teams</li>
	<li>The architecture usually results in increased memory consumption</li>
	<li>Partitioning the application into microservices is very much an art</li>
</ol>

<h2>The Future of Microservice Architecture</h2>

<p class="cye-lm-tag">Whether or not microservice architecture becomes the preferred style of developers in future, it’s clearly a potent idea that offers serious benefits for designing and implementing enterprise applications.&nbsp; Many developers and organizations, without ever using the name or even labeling their practice as SOA, have been using an approach toward leveraging APIs that could be classified as microservices.<br>
&nbsp;<br>
We’ve also seen a number of existing technologies try to address parts of the segmentation and communication problems that microservices aim to resolve.&nbsp; SOAP does well at describing the operations available on a given endpoint and where to discover it via WSDLs.&nbsp; UDDI is theoretically a good step toward advertising what a service can do and where it can be found.&nbsp; But these technologies have been compromised by a relatively complex implementation, and tend not to be adopted in newer projects.&nbsp; REST-based services face the same issues, and although you can use <a href="http://www.ibm.com/developerworks/webservices/library/ws-restwsdl/" target="_blank">WSDLs with REST</a>, it is not widely done.<br>
&nbsp;<br>
Assuming discovery is a solved problem, sharing schema and <em>meaning</em> across unrelated applications still remains a difficult proposition for anything other than microservices and other SOA systems.&nbsp; Technologies such as <a href="http://www.w3.org/TR/rdf-schema/" target="_blank">RDFS</a>, <a href="http://www.w3.org/TR/owl2-overview/" target="_blank">OWL</a>, and <a href="http://www.w3.org/standards/techs/rif#w3c_all" target="_blank">RIF</a> exist and are standardized, but are not commonly used.&nbsp; <a href="http://json-ld.org/" target="_blank">JSON-LD</a> and <a href="http://schema.org/" target="_blank">Schema.org</a> offer a glimpse of what an entire open web that shares definitions looks like, but these aren’t yet adopted in large private enterprises.&nbsp;<br>
&nbsp;<br>
The power of shared, standardized definitions are making inroads within government, though.&nbsp; <a href="http://www.ted.com/talks/tim_berners_lee_on_the_next_web" target="_blank">Tim Berners Lee has been widely advocating Linked Data</a>.&nbsp; The results are visible through in data.gov and data.gov.uk, and you can explore the large number of data sets available as well-described linked data <a href="http://lod-cloud.net/" target="_blank">here</a>.&nbsp; If a large number of standardized definitions can be agreed upon, the next steps are most likely toward <em>agents</em>: small programs that orchestrate microservices from a large number of vendors to achieve certain goals.&nbsp; When you add the increasing complexity and communication requirements of SaaS apps, wearables, and the Internet of Things into the overall picture, it’s clear that microservice architecture probably has a very bright future ahead.</p>

<p class="cye-lm-tag"><em>Written by: <a href="https://plus.google.com/+TomHuston1?rel=author" target="_blank">Tom Huston</a></em></p>

<div class="product-category cye-lm-tag">
<h2>Further Resources</h2>

<h3>Tools:</h3>

<ul class="cye-lm-tag">
	<li class="cye-lm-tag">Test Your API with&nbsp;<a href="http://smartbear.com/product/ready-api/overview/">Ready! API</a></li>
	<li>Design Your API with <a href="https://swaggerhub.com/">SwaggerHub</a></li>
</ul>

<h3>Additional Microservices Reading:</h3>

<ul>
	<li><a href="http://blog.smartbear.com/microservices/delving-into-the-microservices-architecture/">Delving into the Microservices Architecture</a></li>
	<li><a href="http://martinfowler.com/articles/microservices.html">Martin Fowler on Microservices</a></li>
	<li><a href="http://microservices.io/patterns/microservices.html">Microservices.io</a></li>
	<li><a href="http://www.activestate.com/blog/2014/08/microservices-and-paas-part-i">Microservices and PaaS</a></li>
</ul>
</div>

<div class="product-category">
<h2>Related Topics</h2>

<ul>
	<li><a href="http://blog.swaggerhub.com/api-design/what-is-api-design/">What is API Design (And Why Does it Matter?)</a></li>
	<li><a href="https://smartbear.com/learn/performance-testing/">Learn Top Load and Performance Testing Tips</a></li>
	<li><a href="https://smartbear.com/learn/code-review/">Why You Should Begin Code Review</a></li>
	<li><a href="https://smartbear.com/learn/code-review/" target="_blank">Why Test APIs?</a></li>
	<li><a href="https://smartbear.com/learn/performance-monitoring/">Monitoring Resources for Websites, APIs and Cloud Applications</a><br>
	&nbsp;</li>
</ul>
</div>

        </div>

<a href="https://opensource.com/resources/what-are-microservices">src</a>
<h2>What are microservices?</h2>
<div class="field-item even cye-lm-tag" property="content:encoded"><p class="cye-lm-tag">The idea behind microservices is that some types of applications become easier to build and maintain when they are broken down into smaller, composable pieces which work together. Each component is developed separately, and the application is then simply the sum of its constituent components.&nbsp;This is in contrast to a traditional, "monolithic" application which is all developed all in one piece.</p>
<p class="cye-lm-tag">There are many reasons why this approach is considered an easier way to develop large applications, particular enterprise applications, and various types of software as a service delivered over the Internet.</p>
<p class="cye-lm-tag">One of the reasons is from a project engineering perspective. When the different components of an application are separated, they can be developed concurrently. Another is resilience. Rather than relying upon a single virtual or physical machine, components can be spread around multiple severs or even multiple data centers. If a component dies, you spin up another, and the rest of the application can continue to function. It allows more efficient scaling, as rather than scaling <i>up</i> with bigger and more powerful machines, or just more copies of the entire application, you can scale <i>out</i> with duplicate copies of the heaviest-used parts.</p>
<h2>Is this a new concept?</h2>
<p class="cye-lm-tag">The idea of separating applications into smaller parts is nothing new; there are other programming paradigms which address this same concept, such as Service Oriented Architecture (SOA). What may be new are some of the tools and techniques used to deliver on the promise of microservices.</p>
<div class="embedded-callout-menu callout-float-right">
<div class="view view-related-content-callout view-id-related_content_callout view-display-id-article_block view-dom-id-4b1a688ad2885c3612b0c05745e480ac">
<div class="view-header">
<p class="cye-lm-tag">More on microservices</p>
</div>
<div class="view-content">
<div class="views-row views-row-1 views-row-odd views-row-first views-row-last">
<div class="views-field views-field-field-related-content-link">
<div class="field-content">
<div class="item-list">
<ul>
<li class="first"><a href="https://blog.openshift.com/microservices-how-to-explain-them-to-your-ceo/?intcmp=7016000000127cYAAQ">How to explain microservices to your CEO</a></li>
<li><a href="https://www.openshift.com/promotions/microservices.html?intcmp=7016000000127cYAAQ">Free eBook: Microservices vs. service-oriented architecture</a></li>
<li class="last"><a href="https://opensource.com/business/16/11/secured-devops-microservices?intcmp=7016000000127cYAAQ">Secured DevOps for microservices</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p class="cye-lm-tag">The common definition of microservices generally relies upon each microservice providing an API endpoint, often but not always a stateless REST API which can be accessed over HTTP(S) just like a standard webpage. This method for accessing microservices make them easy for developers to consume as they only require tools and methods many developers are already familiar with.</p>
<p class="cye-lm-tag">Microservices depend not just on the technology being set up to support this concept, but on an organization having the culture, know-how, and structures in place for development teams to be able to adopt this model. Microservices are a part of a larger shift in IT departments towards a DevOps culture, in which development and operations teams work closely together to support an application over its lifecycle, and go through a rapid or even continuous release cycle rather than a more traditional long cycle.</p>
<h2>Why is open source important for microservices?</h2>
<p class="cye-lm-tag">When you design your applications from the ground up to be modular and composable, it allows you to use drop-in components in many places where in the past you may have required proprietary solutions, either because the licensing of the components, or specialized requirements. Many application components can be off-the-shelf open source tools.</p>
<p class="cye-lm-tag">A focus on microservices may also make it easier for application developers to offer alternative interfaces to your applications. When everything is an API, communications between application components become standardized. All a component has to do to make use of your application and data is to be able to authenticate and communicate across those standard APIs. This allows both those inside and, when appropriate, outside your organization to easily develop new ways to utilize your application's data and services.</p>
<h2>Where do Docker and container technologies come in?</h2>
<p class="cye-lm-tag">Many people see <a href="https://opensource.com/resources/what-docker">Docker</a> or other container technologies as enablers of a microservice architecture.</p>
<p class="cye-lm-tag">Unlike virtual machines, containers are designed to be pared down to the minimal viable pieces needed to run whatever the one thing the container is designed to do, rather than packing multiple functions into the same virtual or physical machine. The ease of development that Docker and similar tools provide help make possible rapid development and testing of services.</p>
<p class="cye-lm-tag">Of course, containers are just a tool, and microservice architecture is just a concept. So it is entirely possible to build an application which could be described as following a microservices approach without using containers, just as it would be possible to build a much more traditional application inside of a container (although this may not be a good idea).</p>
<h2>How do you orchestrate microservices?</h2>
<p class="cye-lm-tag">In order to actually run an application based on microservices, you need to be able monitor, manage, and scale the different constituent parts. There are a number of different tools that might allow you to accomplish this. For containers, open source tools like <a href="http://kubernetes.io/">Kubernetes</a>, <a href="https://docs.docker.com/swarm/">Docker Swarm</a>, or Apache projects like <a href="http://mesos.apache.org/">Mesos</a> or <a href="http://zookeeper.apache.org/">ZooKeeper</a> might be a part of your solution. Alternatively, for non-container pieces of an application, other tools may be used for orchestrating components: for example, in an <a href="https://opensource.com/resources/what-is-openstack">OpenStack</a> cloud you might use Heat for managing application components. Another option is to use a Platform as a Service (PaaS) tool, which lets developers focus on writing code by abstracting some of the underlying orchestration technology and allowing them to easily select off-the-shelf open source components for certain parts of an application, like a database storage engine, a logging service, a continuous integration server, web server, or other pieces of the puzzle. Some PaaS systems like <a href="https://www.openshift.org/">OpenShift</a> directly use upstream projects like Docker and Kubernetes for managing application components, while others try to re-implement management tools themselves.</p>
<h2>What about existing applications?</h2>
<p class="cye-lm-tag">While utilizing microservices may be an important component of an organization's IT strategy going forward, there are certainly many applications which don't meet this model, nor is it likely that those applications will be rearchitected overnight to meet this new paradigm. Microservices and traditional applications can work together in the same environments, provided the organization has a solid bi-modal IT strategy.</p>
<p class="cye-lm-tag">Bi-modal IT, according to <a href="http://www.gartner.com/it-glossary/bimodal">Gartner</a>, is the ability to deliver on both traditional IT applications with a focus on stability and up time, and newer, more agile but possibly less tested applications through newer methods involving things like the ability of developers to self-provision machines and short development cycles.</p>
<p class="cye-lm-tag">Many if not most organizations will need to be adapted to work with both approaches for many years to come.</p>
<h2>Where can I learn more?</h2>
<p class="cye-lm-tag">Opensource.com has a number of resources for those who are interested in learning more about different tools and design patterns that might be a part of a microservices-oriented application. Here are a few we recommend you check out:</p>
<ul>
<li><a href="https://opensource.com/business/14/12/containers-microservices-and-orchestrating-whole-symphony">Containers, microservices, and orchestrating the whole symphony</a> by Uri Cohen</li>
<li><a href="https://opensource.com/bus/15/3/google-grpc-open-source-remote-procedure-calls">Google shares gRPC as alternative to REST for microservices</a> by Luis Ibáñez</li>
<li><a href="https://opensource.com/business/15/2/interview-sarah-novotny-nginx">NGINX: The secret heart of the modern web</a> by Jason Hibbets</li>
<li><a href="https://opensource.com/business/15/5/api-integrations-with-python-and-zato">Smart API integrations with Python and Zato</a> by Dariusz Suchojad</li>
<li><a href="https://opensource.com/business/14/7/interview-jerome-petazzoni-docker">Senior software engineer Petazzoni on the breathtaking growth of Docker</a> by Richard Morrell</li>
</ul>
</div>
</body>
</html>