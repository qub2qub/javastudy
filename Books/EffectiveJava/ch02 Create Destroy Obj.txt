ch02 Creating and Destroying Objects
******************************************************
*** Item 1: Consider static factory methods instead of constructors ***

The normal way for a class to allow a client to obtain an instance of itself is to provide a public constructor. 
A class can provide a public static factory method, which is simply a static method that returns an instance of the class. 

Note that a static factory method is not the same as the Factory Method pattern from Design Patterns. 
The static factory method described in this item has no direct equivalent in Design Patterns.

A class can provide its clients with static factory methods instead of, or in addition to, constructors. 
Но у этого есть свои + и -

11 One advantage of static factory methods is that, unlike constructors, they have names. If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read.

A class can have only a single constructor with a given signature. 
поэтому прогеры делают второй конструктор, whose parameter lists differ only in the order of their parameter types.
This is a really bad idea. People reading code that uses these constructors will not know what the code does without referring to the class documentation.

!! In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences.

22 A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked. This allows immutable classes (Item 15) to use preconstructed instances, or to cache instances as they’re constructed, and dispense them repeatedly to avoid creating unnecessary duplicate objects.
The ability of static factory methods to return the same object from repeated invocations allows classes to maintain strict control over what instances exist at any time.
Classes that do this are said to be INSTANCE-CONTROLLED. 

Instance control allows a class to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4). Also, it allows an immutable class (Item 15) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a==b. If a class makes this guarantee, then its clients can use the == operator instead of the equals(Object) method, which may result in improved performance. Enum types (Item 30) provide this guarantee.

33 A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type. 
This gives you great flexibility in choosing the class of the returned object.

One application of this flexibility is that an API can return objects without making their classes public. 
Hiding implementation classes in this fashion leads to a very compact API. This technique lends itself to interface-based frameworks (Item 18), where interfaces provide natural return types for static factory methods.

Interfaces can’t have static methods, so by convention, static factory methods for an interface named Type are put in a noninstantiable class (Item 4) named Types.
Например, см java.util.Collections
public class Collections {
    // Suppresses default constructor, ensuring non-instantiability.
    private Collections() {
    }
....

using such a static factory method requires the client to refer to the returned object by its interface rather than its implementation class, which is generally good practice (Item 52).

Класс, который вернётся из public static factory method МОЖЕТ БЫТЬ NONPUBLIC, а также the class can vary from invocation to invocation depending on the values of the parameters to the static factory.
Any class that is a subtype of the declared return type is permissible. The class of the returned object can also vary from release to release for enhanced software maintainability and performance.

The class java.util.EnumSet (Item 32), introduced in release 1.5, has no public constructors, only static factories.
They return one of two implementations, depending on the size of the underlying enum type: 
		if (universe.length <= 64)
			// which is backed by a single long; 
            return new RegularEnumSet<>(elementType, universe);
        else
        	// backed by a long array.
            return new JumboEnumSet<>(elementType, universe);

The existence of these two implementation classes is invisible to clients.
Clients neither know nor care about the class of the object they get back from the factory; they care only that it is some subclass of EnumSet.

The class of the object returned by a static factory method need not even exist at the time the class containing the method is written. 
Such flexible static factory methods form the basis of service provider frameworks (Например, JDBC)
!! A SERVICE PROVIDER FRAMEWORK is a system in which multiple service providers implement a service, and the system makes the implementations available to its clients, decoupling them from the implementations.

There are three essential components of a service provider framework: 
1) a service interface, which providers implement; 
2) a provider registration API, which the system uses to register implementations, giving clients access to them; 
3) and a service access API, which clients use to obtain an instance of the service. 
4*) An optional fourth component of a service provider framework is a SERVICE PROVIDER INTERFACE, which providers implement to create instances of their service implementation. In the absence of a service provider interface, implementations are registered by class name and instantiated reflectively (Item 53).

The [service access API](апи для доступа к сервису) typically allows but does not require the client to specify some criteria for choosing a provider. In the absence of such a specification, the API returns an instance of a default implementation. 
The service access API is the “flexible static factory” that forms the basis of the service provider framework.

In the case of JDBC:
1) Connection plays the part of the service interface(providers implement), 
2) DriverManager.registerDriver() is the provider registration API(system uses to register implementations),
3) DriverManager.getConnection() is the service access API(clients use to obtain an instance of the service), 
4) and Driver is the service provider interface (providers implement to create instances of their service implementation).

44 A fourth advantage of static factory methods is that they reduce the verbosity[vɜ:`bɒsıtı](многословие, словесное наполнение) of creating parameterized[параметерайзд] type instances. 
Unfortunately, you must specify the type parameters when you invoke the constructor of a parameterized class even if they’re obvious from context. 
This typically requires you to provide the type parameters twice in quick succession:
Map<String, List<String>> m = new HashMap<String, List<String>>();

With static factories the compiler can figure out the type parameters for you. This is known as TYPE INFERENCE. (вывод, заключение; умозаключение, подразумеваемое, предполагаемое; предположение)
public static <K, V> HashMap<K, V> newInstance() {
	return new HashMap<K, V>();
}

111 The main disadvantage of providing only static factory methods is that classes without public or protected constructors cannot be subclassed. 
The same is true for nonpublic classes returned by public static factories. 
For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework. 
Arguably this can be a blessing in disguise, as it encourages programmers to use composition instead of inheritance (Item 16).

222 A second disadvantage of static factory methods is that they are not readily distinguishable from other static methods. 
They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors.

Here are some common names for static factory methods:
• valueOf — 
Returns an instance that has, loosely speaking, the same value as its parameters. Such static factories are effectively type-conversion methods.

• of — 
A concise alternative to valueOf, popularized by EnumSet (Item 32).

• getInstance —
Returns an instance that is described by the parameters but cannot be said to have the same value. 
In the case of a singleton, getInstance takes no parameters and returns the sole instance.

• newInstance — 
Like getInstance, except that newInstance guarantees that each instance returned is distinct from all others.

• getType —
Like getInstance, but used when the factory method is in a different class. 
Type indicates the type of object returned by the factory method.

• newType —
Like newInstance, but used when the factory method is in a different class. 
Type indicates the type of object returned by the factory method.

In summary, static factory methods and public constructors both have their uses, and [it pays](это выгодно, имеет смысл) to understand their relative merits.(заслуга, достоинство) 
Often static factories are preferable, so avoid the reflex to provide public constructors without first considering static factories. 

******************************************************
*** Item 2: Consider a builder when faced with many constructor parameters ***

Static factories and constructors share a limitation: they do not scale well to large numbers of optional parameters. 

111 Traditionally, programmers have used the TELESCOPING CONSTRUCTOR PATTERN, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on..

Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler won’t complain, but the program will misbehave at runtime (Item 40).

222 A second alternative when you are faced with many constructor parameters is the JavaBeans pattern, in which you call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest

Но у него есть "минус":
Because construction is split across multiple calls, a JavaBean may be in an inconsistent state partway through its construction.
The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters. 
И класс становиться muttable.

A related disadvantage is that the JavaBeans pattern precludes[предотвращать, устранять, мешать, препятствовать] the possibility of making a class immutable (Item 15), and requires added effort on the part of the programmer to ensure thread safety.

333 a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern.

Instead of making the desired object directly, 
1) the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. 
2) Then the client calls setter-like methods on the builder object to set each optional parameter of interest. 
3) Finally, the client calls a parameterless build method to generate the object, which is immutable. 

The builder is a static member class (Item 22) of the class it builds.
Т.е. билдер -- это статический внутренний класс внутри создаваемого класса.
А то и нельзя было бы создать инстанс билдера, если бы он был не статик, без сознания самого класса.

Note that NutritionFacts is immutable, and that all parameter default values are in a single location. The builder’s setter methods return the builder itself so that invocations can be chained. 

Like a constructor, a builder can impose(налагать) invariants on its parameters. The build() method can check these invariants. 
 -- INVARIANT -- правило, устанавливающее взаимосвязи свойств объекта или определяющее условия его жизнеспособности.

It is critical that they be checked after copying the parameters from the builder to the object, and that they be checked on the object fields rather than the builder fields (Item 39). 
If any invariants are violated, the build method should throw an IllegalStateException (Item 60). 
The exception’s detail method should indicate which invariant is violated (Item 63).

Another way to impose invariants involving multiple parameters is to have setter methods take entire groups of parameters on which some invariant must hold. 
If the invariant isn’t satisfied, the setter method throws an IllegalArgumentException. 
This has the advantage of detecting the invariant failure as soon as the invalid parameters are passed, instead of waiting for build() to be invoked.

!! A minor advantage of builders over constructors is that builders can have multiple varargs parameters. Constructors, like methods, can have only one varargs parameter. Because builders use separate methods to set each parameter, they can have as many varargs parameters as you like, up to one per setter method.

The Builder pattern is flexible. A single builder can be used to build multiple objects. The parameters of the builder can be tweaked between object creations to vary the objects. 
The builder can fill in some fields automatically, such as a serial number that automatically increases each time an object is created.

--A builder whose parameters have been set makes a fine Abstract Factory.
тогда client can pass such a builder to a method to enable the method to create one or more objects for the client. 
--To enable this usage, you need a TYPE to represent the BUILDER. 
If you are using release 1.5 or a later release, a SINGLE GENERIC TYPE (Item 26) suffices for all builders, no matter what type of object they’re building:
		public interface Builder<T> {
			public T build();
		}

Methods that take a Builder instance would typically constrain the builder’s type parameter using a bounded wildcard type (Item 28). For example, here is a method that builds a tree using a client-provided Builder instance to build each node:
	Tree buildTree(Builder<? extends Node> nodeBuilder) { ... }

The traditional Abstract Factory implementation in Java has been the Class object, with the newInstance() method playing the part of the build() method. 
т.е. традиционно подразумевается, что для получения инстанса в фабрику ты передаёшь класс_обжект.
This usage is FRAUGHT WITH(полный, преисполненный; чреватый) problems. 

1) The newInstance() method always attempts to invoke the class’s parameterless constructor, which may not even exist. 
You don’t get a compile-time error if the class has no accessible parameterless constructor. 
Instead, the client code must cope with InstantiationException or IllegalAccessException at runtime, which is ugly and inconvenient. 
2) Also, the newInstance() method propagates(распространять, передавать от поколения к поколению) any exceptions thrown by the parameterless constructor, even though newInstance() lacks the corresponding throws clauses. 

In other words, Class.newInstance() breaks compile-time exception checking. The Builder interface, shown above, corrects these deficiencies(недостаток, порок; неполноценность, голодание).

МИНУСЫ Builder pattern:
1) In order to create an object, you must first create its builder. 
While the cost of creating the builder is unlikely to be noticeable in practice, it could be a problem in some performance-critical situations.
2) Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters, say, four or more. 
But keep in mind that you may want to add parameters in the future.
Therefore, it’s often better to start with a builder in the first place.

******************************************************
*** Item 3: Enforce the singleton property with a private constructor or an enum type ***

Singletons typically represent a system component that is intrinsically unique, such as the window manager or file system. Making a class a singleton can make it difficult to test its clients, as it’s impossible to substitute a mock implementation for a singleton unless it implements an interface that serves as its type.

Before release 1.5, there were two ways to implement singletons. 
Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. 
11 In one approach, the member is a final field:
		public static final Elvis INSTANCE = new Elvis();
		private Elvis() { ... } // конструктор
Но можно добраться до этого конструктора через рефлекшн. (можно добавить проверку на создание >1 instance в конструкторе на выброс исключения)

22 In the second approach to implementing singletons, the public member is a static factory method:
// Singleton with static factory
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() { return INSTANCE; }
}

One advantage of the factory-method approach is that it gives you the flexibility to change your mind about whether the class should be a singleton without changing its API.
The factory method returns the sole instance but could easily be modified to return, say, a unique instance for each thread that invokes it. 
A second advantage, concerning generic types, is discussed in Item 27. Often neither of these advantages is relevant, and the final-field approach is simpler.

Чтобы сделать singleton serializable (Chapter 11), недостаточно просто добавить "implements Serializable" to its declaration. 
To maintain the singleton guarantee, you have to declare all instance fields "transient" and provide a readResolve() method (Item 77). 
Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings. To prevent this, add this readResolve() method to the Elvis class:
	private Object readResolve() {
		// Return the one true Elvis and let the garbage collector
		// take care of the Elvis impersonator.
		return INSTANCE;
	}

33 As of release 1.5, there is a third approach to implementing singletons. Simply make an enum type with one element:
		public enum Elvis {
			INSTANCE;
		}
This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad(покрытый бронёй, бронированный) guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. 
While this approach has yet to be widely adopted, a single-element enum type is the best way to implement a singleton.

******************************************************
*** Item 4: Enforce noninstantiability with a private constructor ***

Occasionally you’ll want to write a CLASS that is just a GROUPING OF STATIC METHODS AND STATIC FIELDS. 
Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses. 
1) They can be used to group related methods on primitive values or arrays, in the manner of java.lang.Math or java.util.Arrays. 
2) They can also be used to group static methods, including factory methods (Item 1), for objects that implement a particular interface, in the manner of java.util.Collections. 
3) Lastly, they can be used to group methods on a final class, instead of extending the class.

Such utility classes were not designed to be instantiated: an instance would be NONSENSICAL[nɒn`sensık(ə)l](бессмысленный; нелепый, глупый; абсурдный). In the absence of explicit constructors, however, the compiler provides a public, parameterless default constructor. 

A simple idiom to ensure noninstantiability.
    A default constructor is generated only if a class contains no explicit constructors, so a class can be made noninstantiable by including a private constructor:
    	// Suppress default constructor for noninstantiability
		private UtilityClass() {
			throw new AssertionError();
		}
Because the explicit constructor is private, it is inaccessible outside of the class. 
The AssertionError isn’t strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class. It guarantees that the class will never be instantiated under any circumstances. 
This idiom is mildly counterintuitive, as the constructor is provided expressly so that it cannot be invoked. It is therefore wise to include a comment, as shown above.

As a side effect, this idiom also prevents the class from being subclassed. All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke.

******************************************************
*** Item 5: Avoid creating unnecessary objects ***

It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. 
Reuse can be both faster and more stylish. 
An object can always be reused if it is immutable (Item 15).

Если вызывать много раз в цикле, то millions of String instances can be created needlessly: String s = new String("str");

Лучше писать так: String s = "str";
This version uses a single String instance, rather than creating a new one each time it is executed. Furthermore, it is guaranteed that the object will be reused by any other code running in the same virtual machine that happens to contain the same string literal.

You can often avoid creating unnecessary objects by using static factory methods (Item 1) in preference to constructors on immutable classes that provide both. Использовать static factory methods вместо конструкторов.

For example, the static factory method Boolean.valueOf(String) is almost always preferable to the constructor Boolean(String). The constructor creates a new object each time it’s called, while the static factory method is never required to do so and won’t in practice.

In addition to reusing immutable objects, you can also reuse mutable objects if you know they won’t be modified.
Например, It involves mutable Date objects that are never modified once their values have been computed.
“baby boomer,” in other words, whether the person was born between 1946 and 1964.

The isBabyBoomer() method unnecessarily creates a new Calendar, TimeZone, and two Date instances each time it is invoked. The version that follows avoids this inefficiency with a static initializer.
The improved version of the Person class creates Calendar, TimeZone, and Date instances only once, when it is initialized, instead of creating them every time isBabyBoomer is invoked. This results in significant performance gains if the method is invoked frequently.

Но бывает случай, когда статик переменные были проинициализированы, но метод, где они ис-ся, так и не вызывался. 
It would be possible to eliminate the unnecessary initializations by lazily initializing these fields (Item 71) the first time the isBabyBoomer method is invoked, BUT IT IS NOT RECOMMENDED. 
As is often the case with LAZY INITIALIZATION, it would complicate the implementation and would be unlikely to result in a noticeable performance improvement beyond what we’ve already achieved (Item 55).

Второй случай, где можно переиспользовать объекты:
Consider the case of adapters, also known as views. 
An adapter is an object that delegates to a backing object, providing an alternative interface to the backing object. 
Because an adapter has no state beyond that of its backing object, there’s no need to create more than one instance of a given adapter to a given object.

For example, the keySet() method of the Map interface returns a Set view of the Map object, consisting of all the keys in the map. Naively, it would seem that every call to keySet() would have to create a new Set instance, but every call to keySet() on a given Map object may return the same Set instance.
Although the returned Set instance is typically mutable, all of the returned objects are functionally identical: when one of the returned objects changes, so do all the others BECAUSE THEY’RE ALL BACKED BY THE SAME MAP INSTANCE. While it is harmless to create multiple instances of the keySet view object, it is also unnecessary.
--- В хэшмапе: --- public Set<K> keySet(){..} --- The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. 

There’s a new way to create unnecessary objects in release 1.5. It is called AUTOBOXING,
There are subtle semantic distinctions, and not-so-subtle performance differences (Item 49). Consider the following program, which calculates the sum of all the positive int values.

This program gets the right answer, but it is much slower than it should be, due to a one-character typographical error. 
The variable sum is declared as a "Long" instead of a "long", which means that the program constructs about 2^31 unnecessary Long instances (roughly one for each time the long i is added to the Long sum).

The lesson is clear: prefer primitives to boxed primitives, and watch out for unintentional autoboxing.
* * *
!!! Но вообще создание объектов ДЁШЕВО, поэтому создавать новые объекты -- это хорошо, особенно если оно делает программу проще и удобнее читаемой.

Conversely, avoiding object creation by maintaining your own object pool is a BAD IDEA unless the objects in the pool are EXTREMELY HEAVYWEIGHT. Например, для конекшенов к БД.

The counterpoint to this item is Item 39 on DEFENSIVE COPYING. 
Item 5 says, “Don’t create a new object when you should reuse an existing one,” while Item 39 says, “Don’t reuse an existing object when you should create a new one.” 
Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. 
Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely[только, просто; единственно] affects style and performance.

-- insidious [ın`sıdıəs] 
1) хитрый, вероломный, коварный, предательский
2) незаметно подкрадывающийся, подстерегающий

******************************************************
*** Item 6: Eliminate obsolete object references ***

-- obsolete [`ɒbsəli:t]
1) устарелый, вышедший из употребления; малоупотребительный
2) немодный, старомодный, отживший; прекративший существование

So where is the memory leak? 
If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program using the stack has no more references to them. 
This is because the stack maintains obsolete references to these objects. An obsolete reference is simply a reference that will never be dereferenced again. In this case, any references outside of the “active portion” of the element array are obsolete. The active portion consists of the elements whose index is less than size.

-- insidious [ın`sıdıəs] 
1) хитрый, вероломный, коварный, предательский
2) незаметно подкрадывающийся, подстерегающий

Memory leaks in garbage-collected languages (more properly known as unintentional object retentions) are insidious. 

**111** If an object reference is unintentionally retained(неумышленно сохранена), not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on. 
Even if only a few object references are unintentionally retained, many, many objects may be prevented from being garbage collected, with potentially large effects on performance.

The fix for this sort of problem is simple: null out references once they become obsolete. In the case of our Stack class, the reference to an item becomes obsolete as soon as it’s popped off the stack. 

An added benefit of nulling out obsolete references is that, if they are subsequently dereferenced by mistake, the program will immediately fail with a NullPointerException, rather than quietly doing the wrong thing. It is always beneficial to detect programming errors as quickly as possible.

The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope (Item 45).

Generally speaking, whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.

**222** Another common source of memory leaks is CACHES. 
Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant. 

If you’re lucky enough to implement a cache for which an entry is relevant exactly so long as there are references to its key outside of the cache, represent the cache as a WeakHashMap; 
entries will be removed automatically after they become obsolete. Remember that WeakHashMap is useful only if the desired lifetime of cache entries is determined by external references to the key, not the value.

More commonly, the useful lifetime of a cache entry is less well defined, with entries becoming less valuable over time. Under these circumstances, the cache should occasionally be cleansed of entries that have fallen into disuse. 
This can be done by a background thread (perhaps a Timer or ScheduledThreadPoolExecutor) or as a side effect of adding new entries to the cache. The LinkedHashMap class facilitates the latter approach with its removeEldestEntry() method. For more sophisticated caches, you may need to use java.lang.ref directly.

**333** A third common source of memory leaks is LISTENERS and other CALLBACKS. 
If you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action. 
The best way to ensure that callbacks are garbage collected promptly is to store only weak references to them, for instance, by storing them only as keys in a WeakHashMap.

Because memory leaks typically do not manifest themselves as obvious failures, they may remain present in a system for years. They are typically discovered only as a result of careful code inspection or with the aid of a debugging tool known as a heap profiler. 
Therefore, it is very desirable to learn to anticipate problems like this before they occur and prevent them from happening.

******************************************************
*** Item 7: Avoid finalizers ***

Finalizers are UNPREDICTABLE, often DANGEROUS, and generally UNNECESSARY.

Their use can cause erratic behavior, poor performance, and portability problems. Finalizers have a few valid uses, which we’ll cover later in this item, but as a rule of thumb, you should avoid finalizers.

In Java, the garbage collector reclaims the storage associated with an object when it becomes unreachable, requiring no special effort on the part of the programmer. 
And try-finally block is generally used to reclaim other nonmemory resources.

One shortcoming of finalizers is that there is no guarantee they’ll be executed promptly. 
It can take arbitrarily long between the time that an object becomes unreachable and the time that its finalizer is executed. 
This means that you should never do anything time-critical in a finalizer. 
For example, it is a grave error to depend on a finalizer to close files, because open file descriptors are a limited resource. 
If many files are left open because the JVM is tardy in executing finalizers, a program may fail because it can no longer open files.

The promptness with which finalizers are executed is primarily a function of the garbage collection algorithm, и сильно зависит от версии jvm.
нет гарантии, что они вообще будут выполнены, не говоря уже о том, что они будут выполнены быстро.
As a consequence, you should never depend on a finalizer to update critical persistent state. 

--refrain [rı`freın] сдерживать, удерживать, обуздывать
1) сдерживаться, удерживаться, воздерживаться

--seduce [sı`dju:s] прельщать, пленять; (be seduced by)
1) соблазнить, обольстить; совратить
2) (часто into) заманивать, совращать
3) (from) отклонить (от чего-л.); заставить забыть (что-л.)

The only methods that claim to guarantee finalization are System.runFinalizersOnExit() and its evil twin, Runtime.runFinalizersOnExit(). 
These methods are fatally flawed and have been deprecated [ThreadStop].

   !!!  if an uncaught exception is thrown during finalization, the exception is ignored, and finalization of that object terminate.
Uncaught exceptions can leave objects in a corrupt state. 
If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result. 
Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer — it won’t even print a warning.

!!!  there is a severe performance penalty for using finalizers.

Как же тогда закрывать ресурсы?
Just provide an explicit termination method, and require clients of the class to invoke this method on each instance when it is no longer needed. 
One detail worth mentioning is that the instance must KEEP TRACK of whether it has BEEN TERMINATED: 
  1) the explicit termination method must record in a private field that the object is no longer valid, 
  2) and other methods must check this field and throw an IllegalStateException if they are called after the object has been terminated.

Typical examples of explicit termination methods are the close methods on InputStream, OutputStream, and java.sql.Connection. И некоторые другие..

...другие методы.. THESE METHODS ARE OFTEN OVERLOOKED(ими пренебрагают,не замечать, пропускать, не обращать внимания, не придавать значения), WITH PREDICTABLY DIRE(ужасный, страшный, зловещий, крайний, полный) PERFORMANCE CONSEQUENCES.

EXPLICIT TERMINATION METHODS are typically used in combination with the try-finally construct to ensure termination. Invoking the explicit termination method inside the finally clause ensures that it will get executed even if an exception is thrown while the object is being used.

So what, if anything, are finalizers good for? There are perhaps two legitimate uses. 
1) One is to act as a “SAFETY NET” in case the owner of an object forgets to call its explicit termination method. 
While there’s no guarantee that the finalizer will be invoked promptly, it may be better to free the resource late than never, in those (hopefully rare) cases when the client fails to call the explicit termination method. 
But the finalizer should log a warning if it finds that the resource has not been terminated, as this indicates a bug in the client code, which should be fixed. If you are considering writing such a safety-net finalizer, think long and hard about whether the extra protection is worth the extra cost.

2) A second legitimate use of finalizers concerns objects with NATIVE PEERS. 
A native peer is a native object to which a normal object delegates via native methods. 
Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed. 
A finalizer is an appropriate vehicle for performing this task, assuming the native peer holds no critical resources. If the native peer holds resources that must be terminated promptly, the class should have an explicit termination method, as described above. 
The termination method should do whatever is required to free the critical resource. The termination method can be a native method, or it can invoke one.
- - - - - - - - - -
It is important to note that “finalizer chaining” is not performed automatically. If a class (other than Object) has a finalizer and a subclass overrides it, the subclass finalizer must invoke the superclass finalizer manually. You should finalize the subclass in a try block and invoke the superclass finalizer in the corresponding finally block. This ensures that the superclass finalizer gets executed even if the subclass finalization throws an exception and vice versa.

-- Finalizer Guardian idiom --
If a subclass implementor overrides a superclass finalizer but forgets to invoke it, the superclass finalizer will never be invoked. 
It is possible to defend against such a careless or malicious subclass at the cost of creating an additional object for every object to be finalized. 
    !!! Instead of putting the finalizer on the class requiring finalization, put the finalizer on an anonymous class (Item 22) whose sole purpose is to finalize its enclosing instance. 

A single instance of the anonymous class, called a finalizer guardian, is created for each instance of the enclosing class. The enclosing instance stores the sole reference to its finalizer guardian in a private instance field so the finalizer guardian becomes eligible for finalization at the same time as the enclosing instance. 
When the guardian is finalized, it performs the finalization activity desired for the enclosing instance, just as if its finalizer were a method on the enclosing class.
   !!!Т.е. если челы забудут вызвать файналазер у суперкласса явно, он всё равно вызовется, когда будет удаляться объект вложенного анонимного класса. Дёрнется его файналазер и в нём будет логика по очистке enclosing класса.
This technique should be considered for every nonfinal public class that has a finalizer.

In summary, don’t use finalizers except as a safety net or to terminate noncritical native resources. 
In those rare instances where you do use a finalizer, remember to invoke super.finalize(). 
If you use a finalizer as a safety net, remember to log the invalid usage from the finalizer. 
Lastly, if you need to associate a finalizer with a public, nonfinal class, consider using a finalizer guardian, so finalization can take place even if a subclass finalizer fails to invoke super.finalize().

