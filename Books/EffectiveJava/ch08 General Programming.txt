ch08 General Programming 209-240
******************************************************
*** Item 45: Minimize the scope of local variables

 By minimizing the scope of local variables, you increase the readability and maintainability of your code and reduce the likelihood of error.
 !! Java lets you declare variables anywhere a statement is legal.

 The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.
   If a variable is declared before it is used, it’s just clutter — one more thing to distract the reader who is trying to figure out what the program does. By the time the variable is used, the reader might not remember the variable’s type or initial value.

Обозначишь её раньше - она может оказаться в более широком скоупе. а тогда the consequences can be disastrous.

Nearly every local variable declaration SHOULD CONTAIN AN INITIALIZER. If you don’t yet have enough information to initialize a variable sensibly, you should postpone the declaration until you do.
One exception to this rule concerns try-catch statements. If a variable is initialized by a method that throws a checked exception, it must be initialized inside a try block. If the value must be used outside of the try block, then it must be declared before the try block, where it cannot yet be “sensibly initialized.”
***
Loops present a special opportunity to minimize the scope of variables. 
The for loop, in both its traditional and for-each forms, allows you to declare loop variables, limiting their scope to the exact region where they’re needed. (This region consists of the body of the loop as well as the initialization, test, and update preceding the body.) 
!!! Therefore, PREFER FOR LOOPS TO WHILE LOOPS, assuming the contents of the loop variable aren’t needed after the loop terminates.
		for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
            doSomething(i.next());
        }

Here is another loop idiom that minimizes the scope of local variables:
        for (int i = 0, n = expensiveComputation(); i < n; i++) { 
            doSomething(i);
        }
The important thing to notice about this idiom is that it has two loop variables, i and n, both of which have exactly the right scope. The second variable, n, is used to store the limit of the first, thus avoiding the cost of a redundant computation on every iteration. As a rule, you should use this idiom if the loop test involves a method invocation that is guaranteed to return the same result on each iteration.

A final technique to minimize the scope of local variables is to keep methods small and focused. 
If you combine two activities in the same method, local variables relevant to one activity may be in the scope of the code performing the other activity.
To prevent this from happening, simply separate the method into two: one for each activity.

******************************************************
*** Item 46: Prefer for-each loops to traditional for loops

Prior to release 1.5, this was the preferred idiom for iterating over a collection:
// No longer the preferred idiom to iterate over a collection!
for (Iterator i = c.iterator(); i.hasNext(); ) {
		doSomething((Element) i.next()); // (No generics before 1.5)
}

This was the preferred idiom for iterating over an array:
// No longer the preferred idiom to iterate over an array!
for (int i = 0; i < a.length; i++) { 
		doSomething(a[i]);
}

These idioms are better than while loops (Item 45), but they aren’t perfect. The iterator and the index variables are both just clutter. Furthermore, they represent opportunities for error. The iterator and the index variable occur three times in each loop, which gives you two chances to get them wrong. If you do, there is no guarantee that the compiler will catch the problem.

Since 1.5 hide the iterator or index variable completely:
// The preferred idiom for iterating over collections and arrays
for (Element e : elements) { doSomething(e); }

When you see the colon (:), read it as “in.” Thus, the loop above reads as “for each element e in elements.” 
Note that there is no performance penalty for using the for-each loop, even for arrays. In fact, it may offer a slight performance advantage over an ordinary for loop in some circumstances, as it computes the limit of the array index only once. While you can do this by hand (Item 45), programmers don’t always do so.
		int[] arr = {1, 2, 3};
        for (int i = 0, n = arr.length; i < n; i++) {
            doSomething(arr[i]);
        }
...
Not only does the for-each loop let you iterate over collections and arrays, it lets you iterate over any object that implements the Iterable interface. This simple interface, which consists of a single method, was added to the platform at the same time as the for-each loop.
				java.lang.Iterable

It is not hard to implement the Iterable interface. If you are writing a type that represents a group of elements, have it implement Iterable even if you choose not to have it implement Collection. This will allow your users to iterate over your type using the for-each loop, and they will be forever grateful.

In summary, the for-each loop provides COMPELLING ADVANTAGES over the traditional for loop in clarity and bug prevention, with no performance penalty. You should use it wherever you can. 
Unfortunately, there are three common situations where you can’t use a for-each loop:
1.    Filtering — If you need to traverse a collection and remove selected elements, then you need to use an explicit iterator so that you can call its remove method.
2.    Transforming — If you need to traverse a list or array and replace some or all of the values of its elements, then you need the LIST ITERATOR or ARRAY INDEX in order to set the value of an element.
3.    Parallel iteration — If you need to traverse multiple collections in parallel (видимо несколько колекций в одном цикле), then you need explicit control over the iterator or index variable, so that all iterators or index variables can be advanced in lockstep (as demonstrated unintentionally in the buggy card and dice examples above).

If you find yourself in any of these situations, use an ordinary for loop, be wary of the traps mentioned in this item, and know that you’re doing the best you can.

******************************************************
*** Item 47: Know and use the libraries

// Common but deeply flawed!
	static int random(int n) {
		return Math.abs(rnd.nextInt()) % n;
	}
This method may look good, but it has three flaws. 
1) The first is that if n is a small power of two, the sequence of random numbers it generates will repeat itself after a fairly short period. 
2) The second flaw is that if n is not a power of two, some numbers will, on average, be returned more frequently than others. If n is large, this effect can be quite pronounced. 
3) The third flaw in the random method is that it can, on rare occasions, fail catastrophically, returning a number outside the specified range. This is so because the method attempts to map the value returned by rnd.nextInt() to a non-negative int by calling Math.abs. If nextInt() returns Integer.MIN_VALUE, Math.abs will also return Integer.MIN_VALUE, and the remainder operator (%) will return a negative number, assuming n is not a power of two. This will almost certainly cause your program to fail, and the failure may be difficult to reproduce.

!!! Поэтому юзай написанную умными людьми ф-ю Random.nextlnt(int)
Приемущества:
1) By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who used it before you.
2) A second advantage of using the libraries is that you don’t have to waste your time writing ad hoc solutions to problems that are only marginally related to your work.
3) A third advantage of using standard libraries is that their performance tends to improve over time, with no effort on your part.
4) Libraries also tend to gain new functionality over time. If a library is missing something, the developer community will make it known, and the missing functionality may get added to a subsequent release. 
5) A final advantage of using the standard libraries is that you place your code in the mainstream. Such code is more easily readable, maintainable, and reusable by the multitude of developers.

Given all these advantages, it seems only logical to use library facilities in preference to ad hoc implementations, yet a significant fraction of programmers don’t. Why? Perhaps they don’t know the library facilities exist. Numerous features are added to the libraries in every major release, and it pays to keep abreast of these additions.

Смотри хотя бы 
java.util.Collections
java.util.concurrent.*

Occasionally, a library facility can fail to meet your needs. The more specialized your needs, the more likely this is to happen. While your first impulse should be to use the libraries, if you’ve looked at what they have to offer in some area and it doesn’t meet your needs, then use an alternate implementation. There will always be holes in the functionality provided by any finite set of libraries. If the functionality that you need is missing, you may have no choice but to implement it yourself.

To summarize, don’t reinvent the wheel. If you need to do something that seems like it should be reasonably common, there may already be a class in the libraries that does what you want. If there is, use it; if you don’t know, check. 
!!! GENERALLY SPEAKING, LIBRARY CODE IS LIKELY TO BE BETTER THAN CODE THAT YOU’D WRITE YOURSELF AND IS LIKELY TO IMPROVE OVER TIME. 
This is no reflection on your abilities as a programmer. Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.

******************************************************
*** Item 48: Avoid float and double if exact answers are required

The float and double types are designed primarily for scientific and engineering calculations. They perform binary floating-point arithmetic, which was carefully designed to furnish accurate approximations quickly over a broad range of magnitudes.
They do not, however, provide exact results and should not be used where exact results are required. 
The float and double types are particularly ill-suited for monetary calculations because it is impossible to represent 0.1 (or any other negative power of ten) as a float or double EXACTLY.

--You might think that the problem could be solved merely by rounding results prior to printing, but unfortunately this does not always work.

The right way to solve this problem is to use BigDecimal, int, or long for monetary calculations.

There are, however, two disadvantages to using BigDecimal: 
1) it’s less convenient than using a primitive arithmetic type, 
2) and it’s slower. 
The latter (Последний) disadvantage is irrelevant if you’re solving a single short problem, 
but the former(первый) may annoy you.

An alternative to using BigDecimal is to use int or long, depending on the amounts involved, and to keep track of the decimal point yourself. In this example, the obvious approach is to do all computation in cents instead of dollars.

in summary, 
1) don’t use float or double for any calculations that require an exact answer. Use BigDecimal if you want the system to keep track of the decimal point and you don’t mind the inconvenience and cost of not using a primitive type. 
2) Using BigDecimal has the added advantage that it gives you full control over rounding, letting you select from eight rounding modes whenever an operation that entails rounding is performed. This comes in handy if you’re performing business calculations with legally mandated rounding behavior. 
3) If performance is of the essence, you don’t mind keeping track of the decimal point yourself, and the quantities aren’t too big, use int or long. 
4) If the quantities don’t exceed nine decimal digits, you can use int; if they don’t exceed eighteen digits, you can use long. If the quantities might exceed eighteen digits, you must use BigDecimal.

******************************************************
какое макс число можно хранить в BigDecimal, BigInteger?
какой макс размер пассива int[]? = Integer.MAX_VALUE = 32bit
почему если <9 значащих цифр - ис-ть int
<18 значащих цифр - ис-ть long ==> потому что в 10й системе счисления Integer.MAX_VALUE = 2 147 483 647 имеет 9 разрядов, в которые можно закодировать все 10чные цифры от 0 до 9
BigInteger и BigDecimal взаимозаменяемы? 
******************************************************
*** Item 49: Prefer primitive types to boxed primitives

Java has a two-part type system, consisting of primitives, such as int, double, and boolean, and reference types, such as String and List. Every primitive type has a corresponding reference type, called a boxed primitive. The boxed primitives corresponding to int, double, and boolean are Integer, Double, and Boolean.

AUTOBOXING  blur but do not erase the distinction between the primitive and boxed primitive types. There are real differences between the two.

There are three major differences between primitives and boxed primitives. 
1) First, primitives have only their values, whereas boxed primitives have identities distinct from their values. In other words, two boxed primitive instances can have the same value and different identities. 
2) Second, primitive types have only fully functional values, whereas each boxed primitive type has one nonfunctional value, which is null, in addition to all of the functional values of its corresponding primitive type. 
3) Last, primitives are generally more time- and space-efficient than boxed primitives. All three of these differences can get you into real trouble if you aren’t careful.

#1/expression first == second, which performs an identity comparison on the two object references. 
!!! Applying the '==' operator to boxed primitives is almost always wrong.

#2/It throws a NullPointerException when evaluating the expression (i == 42).

!!! when you mix primitives and boxed primitives in a single operation, the boxed primitive is auto-unboxed, and this case is no exception. If a null object reference is auto-unboxed, you get a NullPointerException. 

The program compiles without error or warning, and the variable is repeatedly boxed and unboxed, causing the observed performance degradation:

So when should you use boxed primitives? They have several legitimate uses. 
1) The first is as elements, keys, and values in collections. 
You can’t put primitives in collections, so you’re forced to use boxed primitives. This is a special case of a more general one. 
2) You must use boxed primitives as type parameters in parameterized types, because the language does not permit you to use primitives.
3) Finally, you must use boxed primitives when making reflective method invocations (Item 53).

In summary, 
!!! USE PRIMITIVES IN PREFERENCE TO BOXED PRIMITIVES WHENEVER YOU HAVE THE CHOICE. 
Primitive types are simpler and faster. 
If you must use boxed primitives, be carefull !
Autoboxing reduces the verbosity(многословность), but not the danger, of using boxed primitives. 
When your program compares two boxed primitives with the == operator, it does an IDENTITY COMPARISON, which is almost certainly not what you want. 
When your program does mixed-type computations involving boxed and unboxed primitives, it does unboxing, and when your program does unboxing, it can throw a NullPointerException. 
Finally, when your program boxes primitive values, it can result in costly and unnecessary object creations.

******************************************************
*** Item 50: Avoid strings where other types are more appropriate

Strings are poor substitutes for other value types. 

If it’s numeric, it should be translated into the appropriate numeric type, such as int, float, or BigInteger. If it’s the answer to a yes-or-no question, it should be translated into a boolean. More generally, if there’s an appropriate value type, whether primitive or object reference, you should use it; if there isn’t, you should write one. While this advice may seem obvious, it is often violated.

1) Strings are poor substitutes for enum types.

2) Strings are poor substitutes for aggregate types. 
If an entity has multiple components, it is usually a bad idea to represent it as a single string:
			String compoundKey = className + "#" + i.next();
This approach has many disadvantages. 
-If the character used to separate fields occurs in one of the fields, chaos may result. 
-To access individual fields, you have to parse the string, which is slow, tedious, and error-prone. 
-You can’t provide equals, toString, or compareTo methods but are forced to accept the behavior that String provides. A better approach is simply to write a class to represent the aggregate, often a private static member class (Item 22).

3) Strings are poor substitutes for capabilities. 
Occasionally, strings are used to grant access to some functionality. For example, consider the design of a thread-local variable facility. Such a facility provides variables for which each thread has its own value. The Java libraries have had a thread-local variable facility since release 1.2

You don’t really need the static methods anymore. They can instead become instance methods on the key, at which point the key is no longer a key for a thread-local variable: it is a thread-local variable. At this point, the noninstantiable top-level class isn’t doing anything for you anymore, so you might as well get rid of it and rename the nested class to ThreadLocal:
This is, roughly speaking, the API that java.lang.ThreadLocal provides. In addition to solving the problems with the string-based API, it is faster and more elegant than either of the key-based APIs.

To summarize, avoid the natural tendency to represent objects as strings when better data types exist or can be written. Used inappropriately, strings are more cumbersome, less flexible, slower, and more error-prone than other types. 
Types for which strings are commonly misused include primitive types, enums, and aggregate types.

******************************************************
*** Item 51: Beware the performance of string concatenation

The string concatenation operator (+) is a convenient way to combine a few strings into one. It is fine for generating a single line of output or for constructing the string representation of a small, fixed-size object, 
!!!!  but IT DOES NOT SCALE. 
Using the string concatenation operator repeatedly to concatenate N strings requires time QUADRATIC in N (	O(n^2) ). It is an unfortunate consequence of the fact that strings are immutable (Item 15). 
When two strings are concatenated, the contents of both are copied.

 Because the first method is quadratic in the number of items and the second is linear, the performance difference is even more dramatic for larger numbers of items. Note that the second method preallocates a StringBuilder large enough to hold the result. Even if it is detuned to use a default-sized StringBuilder, it is still fifty times faster.

The moral is simple: don’t use the string concatenation operator to combine more than a few strings unless performance is irrelevant. Use StringBuilder’s append method instead. Alternatively, use a character array, or process the strings one at a time instead of combining them.

******************************************************
*** Item 52: Refer to objects by their interfaces

You should favor the use of interfaces rather than classes to refer to objects. 
If appropriate interface types exist, then parameters, return values, variables, and fields should all be declared using interface types. 
The only time you really need to refer to an object’s class is when you’re creating it with a constructor. 

If you get into the habit of using interfaces as types, your program will be much more flexible. If you decide that you want to switch implementations, all you have to do is change the class name in the constructor (or use a different static factory).
and all of the surrounding code would continue to work. The surrounding code was unaware of the old implementation type, so it would be oblivious to the change.

There is one caveat: if the original implementation offered some special functionality not required by the general contract of the interface and the code depended on that functionality, then it is critical that the new implementation provide the same functionality. 
For example, if the code surrounding the first declaration depended on Vector’s synchronization policy, then it would be incorrect to substitute ArrayList for Vector in the declaration. If you depend on any special properties of an implementation, document these requirements where you declare the variable.

Declaring the field with the interface type “keeps you honest.”

It is entirely appropriate to refer to an object by a class rather than an interface if no appropriate interface exists. (such as String and BigInteger)

More generally, if a concrete class has no associated interface, then you have no choice but to refer to it by its class whether or not it represents a value. (The Random class)

A second case in which there is no appropriate interface type is that of objects belonging to A FRAMEWORK WHOSE FUNDAMENTAL TYPES ARE CLASSES RATHER THAN INTERFACES. If an object belongs to such a class-based framework, it is preferable to refer to it by the relevant base class, which is typically abstract, rather than by its implementation class. The java.util.TimerTask class falls into this category.

A final case in which there is no appropriate interface type is that of classes that implement an interface but provide extra methods not found in the interface — for example, LinkedHashMap. Such a class should be used to refer to its instances only if the program relies on the extra methods. It should rarely be used as a parameter type (Item 40).

These cases are not meant to be exhaustive but merely to convey the flavor of situations where it is appropriate to refer to an object by its class. 
In practice, it should be apparent whether a given object has an appropriate interface. If it does, your program will be more flexible if you use the interface to refer to the object; if not, just use the least specific class in the class hierarchy that provides the required functionality.

******************************************************
*** Item 53: Prefer interfaces to reflection

The core reflection facility, java.lang.reflect, offers programmatic access to information about loaded classes. Given a Class object, you can obtain Constructor, Method, and Field instances representing the constructors, methods, and fields of the class represented by the Class instance. These objects provide programmatic access to the class’s member names, field types, method signatures, and so on.

Moreover, Constructor, Method, and Field instances let you manipulate their underlying counterparts reflectively: you can construct instances, invoke methods, and access fields of the underlying class by invoking methods on the Constructor, Method, and Field instances. 
For example, Method.invoke lets you invoke any method on any object of any class (subject to the usual security constraints). Reflection allows one class to use another, even if the latter class did not exist when the former was compiled. 

This power, however, comes at a price:
•    You lose all the benefits of compile-time type checking, including exception checking. If a program attempts to invoke a nonexistent or inaccessible method reflectively, it will fail at runtime unless you’ve taken special precautions.
•    The code required to perform reflective access is clumsy and verbose. It is tedious to write and difficult to read.
•    Performance suffers. Reflective method invocation is much slower than normal method invocation. Exactly how much slower is hard to say, because there are so many factors at work. On my machine, the speed difference can be as small as a factor of two or as large as a factor of fifty.

The core reflection facility was originally designed for [component-based application builder tools]. Such tools generally load classes on demand and use reflection to find out what methods and constructors they support. 
The tools let their users interactively construct applications that access these classes, but [the generated applications] access the classes normally, not reflectively. 
Reflection is used only at design time. As a rule, objects should not be accessed reflectively in normal applications at runtime.

There are a few sophisticated applications that require reflection. 
Examples include class browsers, object inspectors, code analysis tools, and interpretive embedded systems. Reflection is also appropriate for use in remote procedure call (RPC) systems to eliminate the need for stub compilers. If you have any doubts as to whether your application falls into one of these categories, it probably doesn’t.

You can obtain many of the benefits of reflection while incurring few of its costs by using it only in a very limited form. 
For many programs that must use a class that is unavailable at compile time, there exists at compile time an appropriate interface or superclass by which to refer to the class (Item 52). If this is the case, you can create instances reflectively and access them normally via their interface or superclass. If the appropriate constructor has no parameters, then you don’t even need to use java.lang.reflect; the Class.newInstance() method provides the required functionality.

 two disadvantages of reflection:
   1) First, the example can generate three runtime errors, all of which would have been compile-time errors if reflective instantiation were not used. 
   2) Second, it takes twenty lines of tedious code to generate an instance of the class from its name, whereas a constructor invocation would fit neatly on a single line. 
These disadvantages are, however, restricted to the part of the program that instantiates the object. Once instantiated, it is indistinguishable from any other Set instance. In a real program, the great bulk of the code is thus unaffected by this limited use of reflection.

!!! System.exit() ->
It is rarely appropriate to call this method, which terminates the entire VM. 
It is, however, appropriate for abnormal termination of a command line utility.

A legitimate use of reflection:
 if rare, -> is to manage a class’s dependencies on other classes, methods, or fields that may be absent at runtime. 
 This can be useful if you are writing a package that must run against multiple versions of some other package. 
 The technique is to compile your package against the minimal environment required to support it, typically the oldest version, and to access any newer classes or methods reflectively. 

 In summary, reflection is a powerful facility that is required for certain sophisticated system programming tasks, but it has many disadvantages. If you are writing a program that has to work with classes unknown at compile time, you should, if at all possible, use reflection only to instantiate objects, and access the objects using some interface or superclass that is known at compile time.

***************************************************
*** Item 54: Use native methods judiciously

The Java Native Interface (JNI) allows Java applications to call native methods, which are special methods written in native programming languages such as C or C++. Native methods can perform arbitrary computation in native languages before returning to the Java programming language.

Historically, native methods have had three main uses. 
- They provided access to platform-specific facilities such as registries and file locks. 
- They provided access to libraries of legacy code, which could in turn provide access to legacy data. 
- Finally, native methods were used to write performance-critical parts of applications in native languages for improved performance.

It is legitimate to use native methods to access platform-specific facilities, but as the Java platform matures, it provides more and more features previously found only in host platforms. For example, java.util.prefs, added in release 1.4, offers the functionality of a registry, and java.awt.SystemTray, added in release 1.6, offers access to the desktop system tray area. It is also legitimate to use native methods to access legacy code.

It is rarely advisable to use native methods for improved performance. In early releases (prior to 1.3), it was often necessary, but JVM implementations have gotten much faster. For most tasks, it is now possible to obtain comparable performance without resorting to native methods.

The use of native methods has serious disadvantages. Because native languages are not safe (Item 39), applications using native methods are no longer immune to memory corruption errors. Because native languages are platform dependent, applications using native methods are far less portable. 
Applications using native code are far more difficult to debug. There is a fixed cost associated with going into and out of native code, so native methods can decrease performance if they do only a small amount of work. 
Finally, native methods require “glue code” that is difficult to read and tedious to write.

In summary, think twice before using native methods. 
Rarely, if ever, use them for improved performance. 
If you must use native methods to access low-level resources or legacy libraries, use as little native code as possible and test it thoroughly. 
A single bug in the native code can corrupt your entire application.

***************************************************
*** Item 55: Optimize judiciously

Три афоризма про оптимизацию:
1) More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.
2) We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.
3) We follow two rules in the matter of optimization:
		Rule 1. Don’t do it.
		Rule 2 (for experts only). Don’t do it yet — that is, not until you have a perfectly clear and unoptimized solution.

They tell a deep truth about optimization: it is easy to do more harm than good, especially if you optimize prematurely. In the process, you may produce software that is neither fast nor correct and cannot easily be fixed.

!! DON’T SACRIFICE SOUND ARCHITECTURAL PRINCIPLES FOR PERFORMANCE. 
!! STRIVE TO WRITE GOOD PROGRAMS RATHER THAN FAST ONES. 
If a good program is not fast enough, its architecture will allow it to be optimized.
  Good programs embody the principle of information hiding: where possible, they localize design decisions within individual modules, so individual decisions can be changed without affecting the remainder of the system (Item 13).

Но тем не менее --> 
!!! YOU MUST THINK ABOUT PERFORMANCE DURING THE DESIGN PROCESS.
потому что
pervasive architectural flaws that limit performance can be impossible to fix without rewriting the system.

!! STRIVE TO AVOID DESIGN DECISIONS THAT LIMIT PERFORMANCE. 
The components of a design [that are most difficult to change after the fact] are those [specifying interactions between modules] and with the outside world. 
Chief among these design components are: 
--> APIs, wire-level protocols, and persistent data formats. 
Not only are these design components difficult or impossible to change after the fact, but all of them can place significant limitations on the performance that a system can ever achieve.

!! CONSIDER THE PERFORMANCE CONSEQUENCES OF YOUR API DESIGN DECISIONS.

Making a public type mutable may require a lot of needless defensive copying (Item 39). Similarly, using inheritance in a public class where composition would have been appropriate ties the class forever to its superclass, which can place artificial limits on the performance of the subclass (Item 16). As a final example, using an implementation type rather than an interface in an API ties you to a specific implementation, even though faster implementations may be written in the future (Item 52).

!! THE EFFECTS OF API DESIGN ON PERFORMANCE ARE VERY REAL.

!! GOOD API DESIGN IS CONSISTENT WITH GOOD PERFORMANCE.
It is a very bad idea to warp an API to achieve good performance. 
The performance issue that caused you to warp the API may go away in a future release of the platform or other underlying software, but the warped API and the support headaches that come with it will be with you for life.

Once you’ve carefully designed your program and produced a clear, concise, and well-structured implementation, then it may be time to consider optimization, assuming you’re not already satisfied with the performance of the program.

Measure performance before and after each attempted optimization. You may be surprised by what you find. Often, attempted optimizations have no measurable effect on performance; sometimes, they make it worse. 
The main reason is that it’s difficult to guess where your program is spending its time. The part of the program that you think is slow may not be at fault, in which case you’d be wasting your time trying to optimize it. 

!!! Common wisdom says that programs spend 80 percent of their time in 20 percent of their code.

Profiling tools can help you decide where to focus your optimization efforts. Such tools give you runtime information, such as roughly how much time each method is consuming and how many times it is invoked. 
In addition to focusing your tuning efforts, this can alert you to the need for algorithmic changes. If a quadratic (or worse) algorithm lurks inside your program, no amount of tuning will fix the problem. You must replace the algorithm with one that is more efficient. The more code in the system, the more important it is to use a profiler. It’s like looking for a needle in a haystack: the bigger the haystack, the more useful it is to have a metal detector. 
The JDK comes with a simple profiler and modern IDEs provide more sophisticated profiling tools.

The need to measure the effects of attempted optimization is even greater on the Java platform than on more traditional platforms, because the Java programming language DOES NOT HAVE A STRONG PERFORMANCE MODEL. 
The relative costs of the various primitive operations are not well defined. 
The “semantic gap” between what the programmer writes and what the CPU executes is far greater than in traditional statically compiled languages, which makes it very difficult to reliably predict the performance consequences of any optimization. 
There are plenty of performance myths floating around that turn out to be half-truths or outright lies.

Not only is Java’s performance model ill-defined, but it varies from JVM implementation to JVM implementation, from release to release, and from processor to processor. If you will be running your program on multiple JVM implementations or multiple hardware platforms, it is important that you measure the effects of your optimization on each. Occasionally you may be forced to make trade-offs between performance on different JVM implementations or hardware platforms.

To summarize, do not strive to write fast programs—strive to write good ones; speed will follow. Do think about performance issues while you’re designing systems and especially while you’re designing APIs, wire-level protocols, and persistent data formats. When you’ve finished building the system, measure its performance. If it’s fast enough, you’re done. If not, locate the source of the problems with the aid of a profiler, and go to work optimizing the relevant parts of the system. The first step is to examine your choice of algorithms: no amount of low-level optimization can make up for a poor choice of algorithm. Repeat this process as necessary, measuring the performance after every change, until you’re satisfied.

***************************************************
*** Item 56: Adhere to generally accepted naming conventions

Loosely speaking, naming conventions fall into two categories: 
TYPOGRAPHICAL and GRAMMATICAL.

There are only a handful of typographical naming conventions, covering packages, classes, interfaces, methods, fields, and type variables. You should rarely violate them and never without a very good reason. If an API violates these conventions, it may be difficult to use. If an implementation violates them, it may be difficult to maintain. In both cases, violations have the potential to confuse and irritate other programmers who work with the code and can cause faulty assumptions that lead to errors. The conventions are summarized in this item.

Package names should be hierarchical with the components separated by periods. Components should consist of lowercase alphabetic characters and, rarely, digits. The name of any package that will be used outside your organization should begin with your organization’s Internet domain name with the top-level domain first, for example, edu.cmu, com.sun, gov.nsa. The standard libraries and optional packages, whose names begin with java and javax, are exceptions to this rule. Users must not create packages whose names begin with java or javax.

The remainder of a package name should consist of one or more components describing the package. Components should be short, generally eight or fewer characters. Meaningful abbreviations are encouraged, for example, util rather than utilities. Acronyms are acceptable, for example, awt. Components should generally consist of a single word or abbreviation.

Many packages have names with just one component in addition to the Internet domain name. Additional components are appropriate for large facilities whose size demands that they be broken up into an informal hierarchy.
Such packages are known as subpackages, although there is no linguistic support for package hierarchies.

Class and interface names, including enum and annotation type names, should consist of one or more words, with the first letter of each word capitalized, for example, Timer or FutureTask. Abbreviations are to be avoided, except for acronyms and certain common abbreviations like max and min. There is little consensus as to whether acronyms should be uppercase or have only their first letter capitalized. While uppercase may be more common, a strong argument can be made in favor of capitalizing only the first letter: even if multiple acronyms occur back-to-back, you can still tell where one word starts and the next word ends. Which class name would you rather see, HTTPURL or HttpUrl ?

Method and field names follow the same typographical conventions as class and interface names, except that the first letter of a method or field name should be lowercase, for example, remove or ensureCapacity. If an acronym occurs as the first word of a method or field name, it should be lowercase.

The sole exception to the previous rule concerns “constant fields,” whose names should consist of one or more uppercase words separated by the underscore character.
A constant field is a static final field whose value is immutable. If a static final field has a primitive type or an immutable reference type (Item 15), then it is a constant field. For example, enum constants are constant fields. 
If a static final field has a mutable reference type, it can still be a constant field if the referenced object is immutable. Note that constant fields constitute the only recommended use of underscores.

Type parameter names usually consist of a single letter. Most commonly it is one of these five: T for an arbitrary type, E for the element type of a collection, K and V for the key and value types of a map, and X for an exception. A sequence of arbitrary types can be T, U, V or T1, T2, T3.

Identifier  Type	|| 	Examples
---------------------------------------------------------------------
Package				||	com.google.inject, org.joda.time.format
Class or Interface	||	Timer, FutureTask, LinkedHashMap, HttpServlet
Method or Field		||	remove, ensureCapacity, getCrc
Constant Field		||	MIN_VALUE, NEGATIVE_INFINITY
Local Variable		||	i, xref, houseNumber
Type Parameter		||	T, E, K, V, X, T1, T2

Grammatical naming conventions are more flexible and more controversial than typographical conventions. 
- There are no grammatical naming conventions to speak of for packages. 
- Classes, including enum types, are generally named with a singular noun or noun phrase;
- Interfaces are named like classes, for example, Collection or Comparator, or with an adjective ending in able or ible, for example, Runnable, Iterable, or Accessible.
- Because annotation types have so many uses, no part of speech predominates. Nouns, verbs, prepositions, and adjectives are all common, for example, BindingAnnotation, Inject, ImplementedBy, or Singleton.

Methods that perform some action are generally named with a verb or verb phrase (including object), for example, append or drawImage. Methods that return a boolean value usually have names that begin with the word is or, less commonly, has, followed by a noun, noun phrase, or any word or phrase that functions as an adjective, for example, isDigit, isProbablePrime, isEmpty, isEnabled, or hasSiblings.

Methods that return a non-boolean function or attribute of the object on which they’re invoked are usually named with a noun, a noun phrase, or a verb phrase beginning with the verb get, for example, size, hashCode, or getTime. There is a vocal contingent that claims that only the third form (beginning with get) is acceptable, but there is little basis for this claim. The first two forms usually lead to more readable code, 

The form beginning with get is mandatory if the class containing the method is a Bean [JavaBeans], and it’s advisable if you’re considering turning the class into a Bean at a later time. Also, there is strong precedent for this form if the class contains a method to set the same attribute. In this case, the two methods should be named getAttribute and setAttribute.

A few method names deserve special mention. 
Methods that convert the type of an object, returning an independent object of a different type, are often called toType, for example, toString, toArray. 
Methods that return a view (Item 5) whose type differs from that of the receiving object are often called asType, for example, asList. 
Methods that return a primitive with the same value as the object on which they’re invoked are often called "typeValue", for example, intValue. 
Common names for static factories are valueOf, of, getInstance, newInstance, getType, and newType (Item 1, page 10).

Grammatical conventions for field names are less well established and less important than those for class, interface, and method names, as well-designed APIs contain few if any exposed fields. Fields of type boolean are often named like boolean accessor methods with the initial is omitted, for example, "initialized", "composite". 
Fields of other types are usually named with nouns or noun phrases, such as height, digits, or bodyStyle. 
Grammatical conventions for local variables are similar to those for fields, but even weaker.

To summarize, internalize the standard naming conventions and learn to use them as second nature. 
The typographical conventions are straightforward and largely unambiguous; 
the grammatical conventions are more complex and looser. 
To quote from The Java Language Specification [JLS, 6.8], “These conventions should not be followed slavishly if long-held conventional usage dictates otherwise.” 
Use common sense.
