10 Concurrency 259-288
***************************************************************
*** Item 66: Synchronize access to shared mutable data

The synchronized keyword ensures that only a single thread can execute a method or block at one time. Many programmers think of synchronization solely as a means of mutual exclusion, to prevent an object from being observed in an inconsistent state while it’s being modified by another thread. In this view, an object is created in a consistent state (Item 15) and locked by the methods that access it. These methods observe the state and optionally cause a state transition, transforming the object from one consistent state to another. Proper use of synchronization guarantees that no method will ever observe the object in an inconsistent state.

This view is correct, but it’s only half the story. Without synchronization, one thread’s changes might not be visible to other threads. Not only does synchronization prevent a thread from observing an object in an inconsistent state, but it ensures that each thread entering a synchronized method or block sees the effects of all previous modifications that were guarded by the same lock.

The language specification guarantees that READING OR WRITING A VARIABLE IS ATOMIC UNLESS THE VARIABLE IS OF TYPE LONG OR DOUBLE (только на 32-битной jvm ??). In other words, reading a variable other than a long or double is guaranteed to return a value that was stored into that variable by some thread, even if multiple threads modify the variable concurrently and without synchronization.
(а для Integer как объект когда сетается значение - будет ли это атомарным действием ??)

You may hear it said that to improve performance, you should avoid synchronization when reading or writing atomic data. 
					!!!! THIS ADVICE IS DANGEROUSLY WRONG. !!!
While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another. 
!!! SYNCHRONIZATION IS REQUIRED FOR RELIABLE COMMUNICATION BETWEEN THREADS AS WELL AS FOR MUTUAL EXCLUSION. !!!
This is due to a part of the language specification known as the memory model, which specifies when and how changes made by one thread become visible to others

The consequences of failing to synchronize access to shared mutable data can be dire even if the data is atomically readable and writable. Consider the task of stopping one thread from another. The libraries provide the Thread.stop() method, but this method was deprecated long ago because it is inherently unsafe—its use CAN RESULT IN DATA CORRUPTION. 
!!!! Do not use Thread.stop(). !!!
A recommended way to stop one thread from another is to have the first thread poll a boolean field that is initially false but can be set to true by the second thread to indicate that the first thread is to stop itself. Because reading and writing a boolean field is atomic, some programmers dispense with synchronization when accessing the field: просто какую-то булеан переменную можно создать и в потоке проверять её while(boolNotInterupted).

!!! It is not sufficient to synchronize only the write method !! 
In fact, synchronization has no effect unless BOTH READ AND WRITE OPERATIONS ARE SYNCHRONIZED.

The actions of the synchronized methods in StopThread would be atomic even without synchronization. In other words, the synchronization on these methods is used solely for its communication effects, not for mutual exclusion. While the cost of synchronizing on each iteration of the loop is small, there is a correct alternative that is less verbose and whose performance is likely to be better. The locking in the second version of StopThread can be omitted if stopRequested is declared volatile. While the volatile modifier performs no mutual exclusion, it guarantees that any thread that reads the field will see the most recently written value:

The problem is that the increment operator (++) is not atomic.
first it reads the value, then it writes back a new value, equal to the old value plus one. If a second thread reads the field between the time a thread reads the old value and writes back a new one, the second thread will see the same value as the first and return the same serial number. This is a safety failure: the program computes the wrong results.

One way to fix the generateSerialNumber method is to add the synchronized modifier to its declaration. This ensures that multiple invocations won’t be interleaved, and that each invocation will see the effects of all previous invocations. Once you’ve done that, you can and should remove the volatile modifier from nextSerialNumber. To bulletproof the method, use long instead of int, or throw an exception if nextSerialNumber is about to wrap.

!!! The best way to avoid the problems discussed in this item is NOT TO SHARE MUTABLE DATA. Either SHARE IMMUTABLE DATA (Item 15), or DON’T SHARE AT ALL. !! 
In other words, CONFINE MUTABLE DATA TO A SINGLE THREAD. !!
If you adopt this policy, it is important to document it, so that it is maintained as your program evolves. It is also important to have a deep understanding of the frameworks and libraries you’re using, as they may introduce threads that you are unaware of.

It is acceptable for ONE THREAD TO MODIFY A DATA OBJECT FOR A WHILE AND THEN TO SHARE IT WITH OTHER THREADS, synchronizing only the act of sharing the object reference. 
Other threads can then read the object without further synchronization, so long as it ISN’T MODIFIED AGAIN. Such objects are said to be EFFECTIVELY IMMUTABLE. 
Transferring such an object reference from one thread to others is called SAFE PUBLICATION.
There are many ways to safely publish an object reference: 
1) you can store it in a static field as part of class initialization; 
2) you can store it in a volatile field, a final field, or a field that is accessed with normal locking; 
3) or you can put it into a concurrent collection (Item 69).

In summary, when multiple threads share mutable data, each thread that reads or writes the data must perform synchronization. 
Without synchronization, there is no guarantee that one thread’s changes will be visible to another. 
The penalties for failing to synchronize shared mutable data are liveness and safety failures. 
These failures are among the most difficult to debug. They can be intermittent and timing-dependent, and program behavior can vary radically from one VM to another. 

IF YOU NEED ONLY INTER-THREAD COMMUNICATION, AND NOT MUTUAL EXCLUSION, the VOLATILE MODIFIER is an acceptable form of synchronization, but it can be tricky to use correctly.

***************************************************************
*** Item 67: Avoid excessive synchronization

excessive synchronization can cause reduced performance, может вызвать deadlock, or even непредсказуемое-nondeterministic behavior.

To avoid LIVENESS AND SAFETY FAILURES, never cede control to the client within a synchronized method or block. 
In other words, inside a synchronized region, do not invoke a method that is designed to be overridden, or one provided by a client in the form of a function object (Item 21). 
From the perspective of the class with the synchronized region, such methods are alien.
 !!! The class has no knowledge of what the method does and has no control over it. 
Depending on what an alien method does, calling it from a synchronized region can cause exceptions, deadlocks, or data corruption.

1) Now we are in trouble. We are trying to remove an element from a list in the midst of iterating over it, which is illegal. 
  The iteration in the notifyElementAdded method is in a synchronized block to prevent CONCURRENT MODIFICATION, but it doesn’t prevent the iterating thread itself from calling back into the observable set and modifying its observers list.

2) This time we don’t get an exception; we get a deadlock.
  The background thread calls s.removeObserver(), which attempts to lock observers, but it can’t acquire the lock, because the main thread already has the lock.
All the while, the main thread is waiting for the background thread to finish removing the observer, which explains the deadlock.

This example is contrived because there is no reason for the observer to use a background thread, but the problem is real. Invoking alien methods from synchronized regions has caused many deadlocks in real systems, such as GUI toolkits.

In both of the previous examples (the exception and the deadlock) we were lucky. The resource that was guarded by the synchronized region (observers) was in a consistent state when the alien method (added) was invoked. 
Suppose you were to invoke an alien method from within a synchronized region while the invariant protected by the synchronized region was temporarily invalid. 
Because locks in the Java programming language are reentrant, such calls won’t deadlock. As in the first example, which resulted in an exception, the calling thread already holds the lock, so the thread will succeed when it tries to reacquire the lock, even though another conceptually unrelated operation is in progress on the data guarded by the lock. 
The consequences of such a failure can be CATASTROPHIC. In essence, the lock has failed to do its job. Reentrant locks simplify the construction of multithreaded object-oriented programs, but they can TURN LIVENESS FAILURES INTO SAFETY FAILURES.
при первом вызове объект уже в поломенно состоянии, поэтому нельзя разрешать получать второй лок из другого метода.

Luckily, it is usually not too hard to fix this sort of problem by MOVING ALIEN METHOD INVOCATIONS OUT OF SYNCHRONIZED BLOCKS. 
For the notifyElementAdded() method, this involves taking a “snapshot” of the observers list that can then be safely traversed without a lock.

CopyOnWriteArrayList ==>  It is a variant of ArrayList in which all write operations are implemented by making a fresh copy of the entire underlying array.	
Because the internal array is never modified, iteration requires no locking and is very fast. For most uses, the performance of CopyOnWriteArrayList would be atrocious, but it’s perfect for observer lists, which are rarely modified and often traversed.

!!! An alien method invoked outside of a synchronized region is known as an OPEN CALL !!!
Besides preventing failures, OPEN CALLS CAN GREATLY INCREASE CONCURRENCY. 
An alien method might run for an arbitrarily long period. If the alien method were invoked from a synchronized region, other threads would be denied access to the protected resource unnecessarily.

!!! As a rule, you should DO AS LITTLE WORK AS POSSIBLE INSIDE SYNCHRONIZED REGIONS в частности для алиен-методов !!! (а иначе лучше всё делать в синхр-блоке, тогда меньше race condition и т.п. ?? зависит)

Obtain the lock, examine the shared data, transform it as necessary, and drop the lock. If you must perform some time-consuming activity, find a way to move the activity out of the synchronized region without violating the guidelines in Item 66.

The first part of this item was about correctness. Now let’s take a brief look at performance. 
While the cost of synchronization has plummeted since the early days of Java, it is more important than ever not to oversynchronize. 
1) In a multicore world, the real cost of excessive synchronization is not the CPU time spent obtaining locks; it is the lost opportunities for parallelism and the delays imposed by the need to ensure that every core has a consistent view of memory.( засинхр-ть ядра с памятью)
2) Another hidden cost of oversynchronization is that it can limit the VM’s ability to optimize code execution.

You should make a mutable class thread-safe (Item 70) if it is intended for concurrent use and 
1) YOU CAN ACHIEVE SIGNIFICANTLY HIGHER CONCURRENCY by synchronizing internally than you could by locking the entire object externally.
 2) Otherwise, don’t synchronize internally. Let the client synchronize externally where it is appropriate. 
   3) When in doubt, do not synchronize your class, but document that it is not thread-safe (Item 70).

If you do synchronize your class internally, you can use various techniques to achieve high concurrency, such as lock splitting, lock striping, and nonblocking concurrency control.

If a method modifies a static field, you must synchronize access to this field, even if the method is typically used only by a single thread. 
It is not possible for clients to perform external synchronization on such a method because there can be no guarantee that unrelated clients will do likewise. 
The generateSerialNumber method on page 263 exemplifies this situation.

In summary, to avoid deadlock and data corruption, 
1) never call an alien method from within a synchronized region.
2)  More generally, try to limit the amount of work that you do from within synchronized regions. 
3)  When you are designing a mutable class, think about whether it should do its own synchronization. 
4)  In the modern multicore era, it is more important than ever not to synchronize excessively. 
5)  Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (Item 70).

***************************************************************
*** Item 68: Prefer executors and tasks to threads

Executor Framework is a flexible interface-based task execution facility. 

You can do many more things with an executor service. For example, you can wait for a particular task to complete (as in the “background thread SetObserver” in Item 67, page 267), you can wait for any or all of a collection of tasks to complete (using the invokeAny() or invokeAll() methods), you can wait for the executor service’s graceful termination to complete (using the awaitTermination() method), you can retrieve the results of tasks one by one as they complete (using an ExecutorCompletionService), and so on.

Choosing the executor service for a particular application can be tricky. 

Choosing the executor service for a particular application can be tricky. If you’re writing a small program, or a lightly loaded server, using Executors.newCachedThreadPool() is generally a good choice, as it demands no configuration and generally “does the right thing.” But a cached thread pool is not a good choice for a heavily loaded production server! 
In a cached thread pool, submitted tasks are not queued but immediately handed off to a thread for execution. If no threads are available, a new one is created. 
If a server is so heavily loaded that all of its CPUs are fully utilized, and more tasks arrive, more threads will be created, which will only make matters worse. 
Therefore, in a heavily loaded production server, you are much better off using Executors.newFixedThreadPool, which gives you a pool with a fixed number of threads, or using the ThreadPoolExecutor class directly, for maximum control.

Not only should you refrain from writing your own work queues, but you should generally refrain from working directly with threads. The key abstraction is no longer Thread, which served as both the unit of work and the mechanism for executing it. 
Now the unit of work and mechanism are separate. 
THE KEY ABSTRACTION IS THE UNIT OF WORK, WHICH IS CALLED A TASK. 
There are two kinds of tasks: Runnable and its close cousin, Callable (which is like Runnable, except that it returns a value). 
THE GENERAL MECHANISM FOR EXECUTING TASKS IS THE EXECUTOR SERVICE. 
If you think in terms of tasks and let an executor service execute them for you, you gain great flexibility in terms of selecting appropriate execution policies. In essence, the Executor Framework does for execution what the Collections Framework did for aggregation.

The Executor Framework also has a replacement for java.util .Timer, which is ScheduledThreadPoolExecutor. While it is easier to use a timer, a scheduled thread pool executor is much more flexible. A timer uses only a single thread for task execution, which can hurt timing accuracy in the presence of long-running tasks. If a timer’s sole thread throws an uncaught exception, the timer ceases to operate. A scheduled thread pool executor supports multiple threads and recovers gracefully from tasks that throw unchecked exceptions.

***************************************************************
*** Item 69: Prefer concurrency utilities to wait and notify

Given the difficulty of using wait and notify correctly, you should use the higher-level concurrency utilities instead.

The concurrent collections provide high-performance concurrent implementations of standard collection interfaces such as List, Queue, and Map. To provide high concurrency, these implementations manage their own synchronization internally (Item 67). Therefore, it is impossible to exclude concurrent activity from a concurrent collection; locking it will have no effect but to slow the program.

This means that clients can’t atomically compose method invocations on concurrent collections. Some of the collection interfaces have therefore been extended with state-dependent modify operations, which combine several primitives into a single atomic operation. For example, ConcurrentMap extends Map and adds several methods, including putIfAbsent(key, value), which inserts a mapping for a key if none was present and returns the previous value associated with the key, or null if there was none. This makes it easy to implement thread-safe canonicalizing maps.

In fact, you can do even better. ConcurrentHashMap is optimized for retrieval operations, such as get. Therefore, it is worth invoking get initially and calling putIfAbsent only if get indicates that it is necessary

Besides offering excellent concurrency, ConcurrentHashMap is very fast.

Unless you have a compelling reason to do otherwise, use ConcurrentHashMap in preference to Collections.synchronizedMap() or Hashtable. Simply replacing old-style synchronized maps with concurrent maps can dramatically increase the performance of concurrent applications. More generally, use concurrent collections in preference to externally synchronized collections.

Some of the collection interfaces have been extended with blocking operations, which wait (or block) until they can be successfully performed. For example, BlockingQueue extends Queue and adds several methods, including take, which removes and returns the head element from the queue, waiting if the queue is empty. This allows blocking queues to be used for work queues (also known as producer-consumer queues), to which one or more producer threads enqueue work items and from which one or more consumer threads dequeue and process items as they become available. As you’d expect, most ExecutorService implementations, including ThreadPoolExecutor, use a BlockingQueue (Item 68).

!!!! SYNCHRONIZERS are objects that enable threads to wait for one another, allowing them to coordinate their activities. 
The most commonly used synchronizers are CountDownLatch and Semaphore. 
Less commonly used are CyclicBarrier and Exchanger.
!!!!

COUNTDOWN LATCHES are single-use barriers that allow one or more threads to wait for one or more other threads to do something. The sole constructor for CountDownLatch takes an int that is the number of times the countDown() method must be invoked on the latch before all waiting threads are allowed to proceed.

It is surprisingly easy to build useful things atop this simple primitive. For example, suppose you want to build a simple framework for timing the concurrent execution of an action. This framework consists of a single method that takes an executor to execute the action, a concurrency level representing the number of actions to be executed concurrently, and a runnable representing the action. All of the worker threads ready themselves to run the action before the timer thread starts the clock (this is necessary to get an accurate timing). When the last worker thread is ready to run the action, the timer thread “fires the starting gun,” allowing the worker threads to perform the action. As soon as the last worker thread finishes performing the action, the timer thread stops the clock. Implementing this logic directly on top of wait and notify would be messy to say the least, but it is surprisingly straightforward on top of CountDownLatch:

A few more details bear noting. 
1) The executor that is passed to the time method must allow for the creation of at least as many threads as the given concurrency level, or the test will never complete. This is known as a THREAD STARVATION DEADLOCK.
   2) If a worker thread catches an InterruptedException, it reasserts the interrupt using the idiom Thread.currentThread().interrupt() and returns from its run() method. This allows the executor to deal with the interrupt as it sees fit, which is as it should be. 
3) Finally, note that System.nanoTime() is used to time the activity rather than System.currentTimeMillis(). For interval timing, always use System.nanoTime() in preference to System.currentTimeMillis(). System.nanoTime() is both more accurate and more precise, and it is not affected by adjustments to the system’s real-time clock.

This item only scratches the surface of the concurrency utilities. For example, the three countdown latches in the previous example can be replaced by a single cyclic barrier. The resulting code is even more concise, but it is more difficult to understand.

While you should always use the concurrency utilities in preference to wait and notify, you might have to MAINTAIN LEGACY CODE that uses wait() and notify(). 
!! The wait() method is used to make a thread wait for some condition. 
It must be invoked inside a synchronized region that locks the object on which it is invoked. Here is the STANDARD IDIOM for using the WAIT METHOD:

synchronized (obj) {
	while (<condition does not hold>) { // пока условие не выполняется
		obj.wait(); // (Releases lock, and reacquires on wakeup)
	}
	... // Perform action appropriate to condition
}

!!! Always use the WAIT LOOP IDIOM to invoke the wait method; never invoke it outside of a loop. The loop serves to test the condition before and after waiting.

Testing the condition before waiting and skipping the wait if the condition already holds are necessary to ENSURE LIVENESS. 
If the condition already holds and the notify (or notifyAll) method has already been invoked before a thread waits, there is no guarantee that the thread will ever wake from the wait.

synchronized (response) {
	while (!requestIsProcessed) {
		response.wait();
	}
	response.populateFromRequestAnalysis(request);
}

Testing the condition after waiting and [waiting again if the condition does not hold] are necessary to ENSURE SAFETY. 
If the thread proceeds with the action when the condition does not hold, it can destroy the invariant guarded by the lock. 
There are SEVERAL REASONS a THREAD MIGHT WAKE UP WHEN THE CONDITION DOES NOT HOLD:

•1    Another thread could have obtained the lock and changed the guarded state between the time a thread invoked notify() and the time the waiting thread woke.

•2    Another thread could have invoked notify() accidentally or maliciously when the condition did not hold. Classes expose themselves to this sort of mischief by waiting on PUBLICLY ACCESSIBLE OBJECTS. 
Any wait contained in a synchronized method of a publicly accessible object is susceptible to this problem.

•3    The notifying thread could be overly “generous” in waking waiting threads. For example, the notifying thread might invoke notifyAll() even if only some of the waiting threads have their condition satisfied.

•4    The waiting thread could (rarely) wake up in the absence of a notify. This is known as a SPURIOUS WAKEUP.

A related issue is whether you should use notify() or notifyAll() to wake waiting threads. (Recall that notify() wakes a single waiting thread, assuming such a thread exists, and notifyAll() wakes all waiting threads) 
   It is often said that you should always use notifyAll(). This is reasonable, conservative advice. It will always yield correct results because it guarantees that you’ll wake the threads that need to be awakened. 
You may wake some other threads, too, but this won’t affect the correctness of your program. These threads will check the condition for which they’re waiting and, finding it false, will continue waiting.

As an optimization, you may choose to invoke notify() instead of notifyAll() if all threads that could be in the wait-set are waiting for the SAME CONDITION and ONLY ONE THREAD AT A TIME CAN BENEFIT FROM THE CONDITION BECOMING TRUE.
! особенно если у тебя private lock - то так видимо можно делать!

Even if these conditions appear true, there may be cause to use notifyAll() in place of notify(). Just as placing the wait invocation in a loop protects against accidental or malicious notifications on a PUBLICLY ACCESSIBLE OBJECT, 
!! using notifyAll() in place of notify() PROTECTS AGAINST ACCIDENTAL OR MALICIOUS WAITS BY AN UNRELATED THREAD. 
Such waits could otherwise “SWALLOW” a critical notification, leaving its intended recipient waiting indefinitely.

In summary, using wait() and notify() directly is like programming in “concurrency assembly language,” as compared to the higher-level language provided by java.util.concurrent. 
There is seldom, if ever, a reason to use wait() and notify() in new code. If you maintain code that uses wait and notify, MAKE SURE THAT IT ALWAYS INVOKES WAIT FROM WITHIN A WHILE LOOP USING THE STANDARD IDIOM. 
The notifyAll() method should generally be used in preference to notify(). If notify() is used, great care must be taken to ensure liveness.

***************************************************************
*** Item 70: Document thread safety

How a class behaves when its instances or static methods are subjected to concurrent use is an important part of the contract the class makes with its clients. 
If you don’t document this facet of a class’s behavior, programmers who use the class will be forced to make assumptions. If those assumptions are wrong, the resulting program may perform insufficient synchronization (Item 66) or excessive synchronization (Item 67). In either case, serious errors can result.

In fact, there are several LEVELS OF THREAD SAFETY. To enable safe concurrent use, a class must clearly document what level of thread safety it supports.
The following list summarizes levels of thread safety. 
It is not exhaustive but covers the common cases:

•1    IMMUTABLE — НЕИЗМЕНЯЕМЫЕ
Instances of this class appear constant. No external synchronization is necessary. Examples include String, Long, and Biglnteger (Item 15).

•2    UNCONDITIONALLY THREAD-SAFE — БЕЗУСЛОВНО БЕЗОПАСНЫЕ
Instances of this class are mutable, but the class has sufficient internal synchronization that its instances can be used concurrently without the need for any external synchronization. Examples include Random and ConcurrentHashMap.

•4    CONDITIONALLY THREAD-SAFE — УСЛОВНО БЕЗОПАСНЫЕ
Like unconditionally thread-safe, except that some methods require external synchronization for safe concurrent use. 
Examples include the collections returned by the Collections.synchronized(..) wrappers, whose iterators require external synchronization.

•5    NOT THREAD-SAFE — НЕБЕЗОПАСНЫЕ
Instances of this class are mutable. To use them concurrently, clients must surround each method invocation (or invocation sequence) with external synchronization of the clients’ choosing. 
Examples include the general-purpose collection implementations, such as ArrayList and HashMap.

•6 THREAD-HOSTILE — ВРАЖДЕБНЫЕ К МНОГОПОТОЧНОСТИ
This class is not safe for concurrent use even if all method invocations are surrounded by external synchronization. 
!! THREAD HOSTILITY usually results from modifying static data without synchronization. 

No one writes a thread-hostile class on purpose; such classes result from the failure to consider concurrency. Luckily, there are very few thread-hostile classes or methods in the Java libraries. The System.runFinalizersOnExit(..) method is thread-hostile and has been deprecated.

These categories (apart from thread-hostile) correspond roughly to the thread safety annotations in Java Concurrency in Practice, which are @Immutable, @ThreadSafe, and @NotThreadSafe. 
The UNCONDITIONALLY and CONDITIONALLY thread-safe categories in the above taxonomy are both covered under the THREADSAFE annotation.

Documenting a conditionally thread-safe class requires care. You must indicate which invocation sequences require external synchronization, and which lock (or in rare cases, which locks) must be acquired to execute these sequences. 
Typically it is the lock on the instance itself, but there are exceptions. If an object represents a view on some other object, the client generally must synchronize on the BACKING OBJECT, so as to prevent its DIRECT MODIFICATION.

It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:

Map<K, V> map = Collections.synchronizedMap(new HashMap<K, V>());
Set<K> s = map.keySet(); 		// Needn't be in synchronized block
synchronized(map) {    			// Synchronizing on "map", not s!
	for (K key : s) key.f();
}

Failure to follow this advice may result in non-deterministic behavior.

The description of a class’s thread safety generally belongs in its documentation comment, but methods with special thread safety properties should describe these properties in their own documentation comments. 
It is not necessary to document the immutability of enum types. Unless it is obvious from the return type, static factories must document the thread safety of the returned object, as demonstrated by Collections.synchronizedMap (above).

When a class commits to using a PUBLICLY ACCESSIBLE LOCK, it enables clients to execute a sequence of method invocations atomically, but this flexibility comes at a price. 
It is incompatible with HIGH-PERFORMANCE INTERNAL CONCURRENCY CONTROL.
Also, a client can mount a denial-of-service attack by holding the publicly accessible lock for a prolonged period. This can be done accidentally or intentionally.

To prevent this denial-of-service attack, you can use a PRIVATE LOCK OBJECT instead of using synchronized methods (which imply a publicly accessible lock):
Because the private lock object is inaccessible to clients of the class, it is impossible for them to interfere with the object’s synchronization. In effect, we are applying the advice of Item 13 by encapsulating the lock object within the object it synchronizes.

Note that the LOCK FIELD IS DECLARED FINAL. This prevents you from inadvertently changing its contents, which could result in catastrophic unsynchronized access to the containing object (Item 66). We are applying the advice of Item 15, by minimizing the mutability of the lock field.

To reiterate, the PRIVATE LOCK OBJECT IDIOM can be used only on UNCONDITIONALLY thread-safe classes. 
CONDITIONALLY thread-safe classes CAN’T USE THIS IDIOM because they must document WHICH LOCK THEIR CLIENTS ARE TO ACQUIRE when performing certain method invocation sequences.

The PRIVATE LOCK OBJECT IDIOM is particularly well-suited to CLASSES DESIGNED FOR INHERITANCE (Item 17). 
If such a class were to use its instances for locking, a subclass could easily and unintentionally interfere with the operation of the base class, or vice versa. 
By using the same lock for different purposes, the subclass and the base class could end up “stepping on each other’s toes.” This is not just a theoretical problem. For example, it happened with the Thread class 

To summarize, every class should clearly document its thread safety properties with a carefully worded prose description or a thread safety annotation. The synchronized modifier plays no part in this documentation. Conditionally thread-safe classes must document which method invocation sequences require external synchronization, and which lock to acquire when executing these sequences. If you write an unconditionally thread-safe class, consider using a private lock object in place of synchronized methods. This protects you against synchronization interference by clients and subclasses and gives you the flexibility to adopt a more sophisticated approach to concurrency control in a later release.

***************************************************************
*** Item 71: Use lazy initialization judiciously

Lazy initialization is the act of delaying the initialization of a field until its value is needed. If the value is never needed, the field is never initialized. This technique is applicable to both static and instance fields. While lazy initialization is primarily an optimization, it can also be used to break harmful circularities in class and instance initialization.

As is the case for most optimizations, the best advice for lazy initialization is “don’t do it unless you need to” (Item 55). Lazy initialization is a double-edged sword. It decreases the cost of initializing a class or creating an instance, at the expense of increasing the cost of accessing the lazily initialized field. Depending on what fraction of lazily initialized fields eventually require initialization, how expensive it is to initialize them, and how often each field is accessed, lazy initialization can (like many “optimizations”) actually harm performance.

!!! That said, lazy initialization has its uses. If a field is accessed only on a fraction of the instances of a class and it is costly to initialize the field, then lazy initialization may be worthwhile. The only way to know for sure is to measure the performance of the class with and without lazy initialization.

In the presence of multiple threads, lazy initialization is tricky. If two or more threads share a lazily initialized field, it is critical that some form of synchronization be employed, or severe bugs can result (Item 66). All of the initialization techniques discussed in this item are thread-safe.

!! UNDER MOST CIRCUMSTANCES, NORMAL INITIALIZATION IS PREFERABLE TO LAZY INITIALIZATION. 

Here is a typical declaration for a normally initialized instance field. Note the use of the final modifier (Item 15):
// Normal initialization of an instance field
private final FieldType field = computeFieldValue();

If you use lazy initialization to break an initialization circularity, use a synchronized accessor, as it is the simplest, clearest alternative:
// Lazy initialization of instance field - SYNCHRONIZED ACCESSOR
private FieldType field;
synchronized FieldType getField() { 
	if (field == null) field = computeFieldValue(); 
	return field;
}

Both of these idioms (NORMAL INITIALIZATION and LAZY INITIALIZATION WITH A SYNCHRONIZED ACCESSOR) are unchanged when applied to STATIC FIELDS, except that you add the STATIC MODIFIER to the field and accessor declarations.

If you need to use lazy initialization for performance on a static field, use the lazy initialization holder class idiom. This idiom (also known as the initialize-on-demand holder class idiom) exploits the guarantee that a class will not be initialized until it is used:
// Lazy initialization holder class idiom for static fields
private static class FieldHolder {
	static final FieldType field = computeFieldValue();
}
static FieldType getField() { return FieldHolder.field; }

When the getField() method is invoked for the first time, it reads FieldHolder.field for the first time, causing the FieldHolder class to get initialized. 
The beauty of this idiom is that the getField() method IS NOT SYNCHRONIZED AND PERFORMS ONLY A FIELD ACCESS, so lazy initialization adds practically nothing to the cost of access. A modern VM will synchronize field access only to initialize the class. Once the class is initialized, the VM will patch the code so that subsequent access to the field does not involve any testing or synchronization.

If you need to use lazy initialization for performance on an instance field, use the DOUBLE-CHECK IDIOM. 
This idiom avoids the cost of locking when accessing the field after it has been initialized (Item 67). The idea behind the idiom is to check the value of the field twice (hence the name double-check): once without locking, and then, if the field appears to be uninitialized, a second time with LOCKING. Only if the second check indicates that the field is uninitialized does the call initialize the field. Because there is no locking if the field is already initialized, it is critical that the field be declared volatile (Item 66).

This code may appear a bit convoluted. In particular, the need for the local variable result may be unclear. What this variable does is to ensure that field is read only once in the common case where it’s already initialized. While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming. On my machine, the method above is about 25 percent faster than the obvious version without a local variable.

Prior to release 1.5, the DOUBLE-CHECK IDIOM did not work reliably because the semantics of the VOLATILE MODIFIER were not strong enough to support it. 
THE MEMORY MODEL INTRODUCED IN RELEASE 1.5 fixed this problem. 
Today, the DOUBLE-CHECK IDIOM is the technique of choice for lazily initializing an instance field. While you can apply the double-check idiom to static fields as well, there is no reason to do so: the LAZY INITIALIZATION HOLDER CLASS IDIOM is a better choice.

TWO VARIANTS OF THE DOUBLE-CHECK IDIOM BEAR NOTING:
Occasionally, you may need to lazily initialize an instance field that CAN TOLERATE REPEATED INITIALIZATION. 
If you find yourself in this situation, you can use a VARIANT of the double-check idiom that dispenses with the second check.
It is, not surprisingly, known as the SINGLE-CHECK IDIOM. Here is how it looks. Note that field is still declared volatile.

 All of the initialization techniques discussed in this item apply to primitive fields as well as object reference fields. When the double-check or single-check idiom is applied to a numerical primitive field, the field’s value is checked against 0 (the default value for numerical primitive variables) rather than null.

If you don’t care whether every thread recalculates the value of a field, and the type of the field is a primitive [other than long or double], then you may choose to REMOVE THE VOLATILE MODIFIER from the field declaration in the single-check idiom. This variant is known as the RACY SINGLE-CHECK IDIOM. 
It speeds up field access on some architectures, at the expense of additional initializations (up to one per thread that accesses the field). This is definitely an exotic technique, not for everyday use. It is, however, used by String instances to cache their hash codes.

In summary, you should initialize MOST FIELDS NORMALLY, not lazily. 
If you must initialize a field lazily in order to achieve your performance goals, or to break a harmful initialization circularity, then use the appropriate lazy initialization technique. 
1) For instance fields, it is the double-check idiom; 
2) for static fields, the lazy initialization holder class idiom. 
3) For instance fields that can tolerate repeated initialization, you may also  consider the single-check idiom (ПРИ ЭТОМ У ТЕБЯ VOLATILE ПЕРЕМЕННАЯ).

***************************************************************
*** Item 72: Don’t depend on the thread scheduler 
(ОТ СИСТЕМНОГО ПЛАНИРОВЩИКА ПОТОКОВ)

When many threads are runnable, the thread scheduler determines which ones get to run, and for how long. Any reasonable operating system will try to make this determination fairly, but the policy can vary. Therefore, well-written programs shouldn’t depend on the details of this policy. Any program that relies on the thread scheduler for correctness or performance is likely to be nonportable.

The best way to write a robust, responsive, portable program is to ensure that the AVERAGE NUMBER OF RUNNABLE THREADS IS NOT SIGNIFICANTLY GREATER THAN THE NUMBER OF PROCESSORS. 
This leaves the thread scheduler with little choice: it simply runs the runnable threads till they’re no longer runnable. The program’s behavior doesn’t vary too much, even under radically different thread-scheduling policies. Note that the number of runnable threads isn’t the same as the total number of threads, which can be much higher. Threads that are waiting are not runnable.

The main technique for keeping the number of runnable threads down is TO HAVE EACH THREAD DO SOME USEFUL WORK AND THEN WAIT FOR MORE. 
Threads should not run if they aren’t doing useful work. In terms of the Executor Framework (Item 68), this means SIZING YOUR THREAD POOLS APPROPRIATELY, and keeping tasks reasonably small and independent of one another. Tasks shouldn’t be too small, or dispatching overhead will harm performance.

!!THREADS SHOULD NOT BUSY-WAIT, [т.е. ждать, выполняя какую-то пустую работу]
repeatedly checking a shared object waiting for something to happen. Besides making the program vulnerable to the vagaries of the scheduler, busy-waiting greatly increases the load on the processor, reducing the amount of useful work that others can accomplish. 

When faced with a program that barely works because some threads aren’t getting enough CPU time relative to others, resist the temptation to “fix” the program by putting in calls to Thread.yield(). 
You may succeed in getting the program to work after a fashion, but it will not be portable. The same yield invocations that improve performance on one JVM implementation might make it worse on a second and have no effect on a third. Thread.yield() has no testable semantics. 
A BETTER COURSE OF ACTION IS TO RESTRUCTURE THE APPLICATION TO REDUCE THE NUMBER OF CONCURRENTLY RUNNABLE THREADS.

A related technique, to which similar caveats apply, is adjusting thread priorities. Thread priorities are among the least portable features of the Java platform. 
It is not unreasonable to tune the responsiveness of an application by tweaking a few thread priorities, but it is rarely necessary and is not portable. It is unreasonable to solve a serious liveness problem by adjusting thread priorities. The problem is likely to return until you find and fix the underlying cause.

!! It is within specification for Thread.yield() to do nothing at all, simply returning control to its caller. Some modern VMs actually do this. Therefore, you should use Thread.sleep(1) instead of Thread.yield() for concurrency testing. Do not use Thread.sleep(0), which can return immediately.

In summary, do not depend on the thread scheduler for the correctness of your program. The resulting program will be neither robust nor portable. 
!!! As a corollary, do not rely on Thread.yield() or thread priorities. 
These facilities are merely hints to the scheduler. Thread priorities may be used sparingly to improve the quality of service of an already working program, but they should never be used to “fix” a program that barely works.

***************************************************************
*** Item 73: Avoid thread groups

Along with threads, locks, and monitors, a basic abstraction offered by the threading system is thread groups. Thread groups were originally envisioned as a mechanism for isolating applets for security purposes. They never really fulfilled this promise, and their security importance has waned to the extent that they aren’t even mentioned in the standard work on the Java security model

Given that thread groups don’t provide any security functionality to speak of, what functionality do they provide? Not much. They allow you to apply certain Thread primitives to a bunch of threads at once. Several of these primitives have been deprecated, and the remainder are infrequently used.

Thread’s setUncaughtExceptionHandler method.

To summarize, thread groups don’t provide much in the way of useful functionality, and much of the functionality they do provide is flawed. Thread groups are best viewed as an unsuccessful experiment, and you should simply ignore their existence. If you design a class that deals with logical groups of threads, you should probably use thread pool executors (Item 68).

