Если поток одновременно и notified and interrupted while waiting (пока ждёт), то он может следующее:
1) нормально выйти из wait, и при этом имея ожидающий Interrupt (другими словами вызов Thread.interrupted вернёт true)
2) вернётся/выйдет/return из wait выбросив InterruptedException

Аналогичным образом, уведомления не могут быть потеряны из-за прерывания. Предположим, что множество S потоков находится в wait set объекта M, а другой поток выполняет notify у объекта M. Тогда либо:
1) по меньшей мере один поток из S должен выйти из ожидания нормально, или
2) все потоки в S должны выйти из ожидания, выбросив InterruptedException

Обратите внимание, что если поток одновременно прерывается и пробуждается (interrupted and notified), и этот поток возвращается из ожидания, бросая InterruptedException, то другой поток в wait set must be notified.
************
SLEEP AND YIELD

Thread.sleep заставляет выполняющийся поток заснуть (временно прекращают выполнение) в течение указанного перида времени. Поток не теряет право собственности на любых мониторах (ownership of any monitors), и возобновление выполнения будет зависеть от планирования и доступности процессоров, на которых выполнить этот поток.

Важно отметить, что ни один, ни Thread.sleep ни Thread.yield НЕ имеют никакой семантики синхронизации. В частности, компилятору не надо выгружать кэшированные данные из регистров в память перед вызовом Thread.sleep или Thread.yield, а также компилятору не надо перезагружать  в регистрах кэшированные значения после вызова Thread.sleep или Thread.yield.

For example, in the following (broken) code fragment, assume that this.done is a non-volatile boolean field:

while (!this.done)
    Thread.sleep(1000);

The compiler is free to read the field this.done just once, and reuse the cached value in each execution of the loop. This would mean that the loop would never terminate, even if another thread changed the value of this.done.

********************
Модель памяти
Модель памяти описывает, учитывая программу и трассировки выполнения этой программы, правильным ли является выполнение программы. 
Модель памяти языка программирования Java работает путем изучения каждой операции чтения в трассировки выполнения и проверки, что операция записи, после которой вызвали чтение, действует в соответствии с определенными правилами.
Модель памяти описывает возможные модели поведения программы. Реализация не ограничена в способах производить любой код, который ей нравится, до тех пор, пока результаты, полученные в ходе выполнения программы могут быть предсказаны моделью памяти.
Это обеспечивает большую свободу для реализаторов выполнять множество трансформаций кода, включая изменения порядка действий и удаления ненужной синхронизации.

Некорректно Синхронизированные Программы могут демонстрировать поразительное поведение

Семантика языка программирования Java позволяют компиляторам и микропроцессорам выполнять оптимизацию, но она может взаимодействовать с неправильно синхронизированым кода такими образом,что это может приводить к парадоксальным результатм. Вот некоторые примеры того, как неправильно синхронизированные программы могут демонстрировать удивительные модели поведения.

Рассмотрим пример, программа использует локальные переменные r1 и r2 и общие переменные А и В. Первоначально A == B == 0.
