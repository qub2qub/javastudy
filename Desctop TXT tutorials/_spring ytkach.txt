https://www.youtube.com/user/ytkach/videos
https://www.youtube.com/watch?v=aNcTL9e7luM
Что такое спринг -- 
1) легковесный -- всего пару jar файлов
2) контейнер -- сам управляет жизненным циклом объектов.
3) фреймворк -- предоставляют готовые решения (классы для упрощения работы с БД, почтой, веб-сервис.)
4) Реализует принцип Инверсию Контроля (IoC) посредством инъекции зависимостей (DI).
IoC - объекты не создают свои зависимости, а получают из контейнера.
5) Аспекты (AOP) -- спринг сам реализует поддержку аоп, а также а многие его утилитарные классы и функции работаю с помощью этой технологии.

---------------
из каких модулей состоит спринг:
1) Core Container -- ядро -- СОДЕРЖИТ:
beans - управляют бинами, 
core - реализуют внедрение зависимостей, 
context - управляет контекстом, где хранятся бины и обеспечивает доступ к ним, 
expression - спец. язык выражений.

2) AOP -- и в него входят 2 блока:
aop -- поддержка аоп
aspects -- модуль обеспечивает поддержку библиотеки aspect_j
3) модуль Instreumentation -- нужен когда спринг ис-ся в каком-то AS. Этот модуль обеспечивает загрузку классов в контейнер и позволяет ему управлять контекстом и бинами.
4) data access and integration -- 
JDBC,JMS,ORM,Transaction
5) Web & Remoting -- Web, Servlet, Struts.
...security, и др.
6) Testing.
-----------------------------------------
II Dependency injection
Решение проблем:
1) всю статическую информацию (которая может когда-либо измениться) надо вынести по внешние файлы.
2) разъединение на интерфейсы (decouple with interfaces) - можно будет использовать разную реализацию.
Т.е. какой-то сервис-класс не будет зависеть от реализации, а будет зависеть от интерфейса.
3) внедрение зависимостей -- чтобы для интерфейса нам реализацию кто-то отдал.
т.к. DI позволяет объектам получать другие классы, а не создавать их самостоятельно.
класс не создаёт другие классы, а получает их извне (от контейнера)
*) т.е. спринг контейнер будет классы создавать, между собой их соединять (передавать 1 в другой), а мы будем к нему обращаться за необходимой информацией.
****************************
III BEAN NAMING
<bean id="valid_unique_value" />
<bean name="any symbol and spaces" />

1) ID  - формальный XML атрибут, должен быть уникальным. До версии 3.2 допускал только валидные символы (англ.алфавита цифры и некоторые другие).
2) NAME - там можно написать несколько имён, разделяя их пробелами, запятыми, точкой с запятой.
в таком случае у бина будут несколько имён.
3) можно указать оба и id и name, они будут суммироваться.
4) ALIAS можно задать отдельным Тэгом alias; Когда подключаем сторонний контекст, в котором не можем изменить ид-шники бинов. тогда через алиас можем задать тем бинам своё имя.
<bean id="aaa" name="xxx,zzz"/>
<alias name="aaa" alias="bbb" />
-------
заинжектить какую-то информацию можно либо через конструктор либо через сеттеры.
1) <constructor-arg value="first_arg" />
По умолчаню спринг инжектить их в том порядке, в которому она записаны в xml.
2) Если надо изменить порядок, то можно использовать атрибут index.
3) Если же типы аргументов разные -- то их можно писать вразнобой, спринг сам поймёт куда какое значение присвоить.
4) Но в этом случае, если например для стринга и для инта указали значение 1, то в constructor-arg надо указать тип аргумента:
<constructor-arg type="java.lang.String" value="1" />
<constructor-arg type="java.lang.Integer" value="1" />
5) Можно также указывать атрибут name, который будет равен имени переменной в коде.
<constructor-arg name="arg1" value="John" />
Но это будет работать ТОЛЬКО если включены debug symbols при компиляции приложения.
!!! на проде так не делать !!!
6) чтобы проинжектить бины в конструктор надо ис-ть атрибут ref, в котором указан id/name внедряемого бина:
<constructor-arg ref="eventLogger"/>
По умолчанию спринг будет испльзовать конструктор по умолчанию, поэтому если в классе есть другие конструкторы -- его надо явно объявить.
модификтор переменной в конструкторе может быть любым private, protected и т.п. спринг в любом случае его вызовет и проинжектит.
------------------------------------
ТИПЫ КОНТЕЙНЕРОВ В СПРИНГЕ
1) BeanFactory - самый простой и делает в основном только DI
2) ApplicationContext - делает то же, что и BeanFactory (т.е. DI), но также предоставляет сервисы фреймворка, по управлению этими бинами.
ApplicationContext могут быть разных видов.
можно передавать несколько контекстов, спринг их соединит в один (это по простому говоря.)
***********************************
SCOPES AND INNER BEANS
scope=цикл жизни объекта в контейнере.
По умолчанию все бины в спринг синглтоны = singleton. Т.е. каждый раз запрашивая бин, спринг будет возвращать один и тот же объект, который он создал при инициализации.
Иногда надо получать новый объект, кажый раз когда к нему обращаются. Для таких объектов ставится scope="prototype".
Для веб приложений также есть ещё 3 доп. scope-а:
1=request - на время обработки запроса
2=session - на время пока есть http сессия
3=global-session - пока есть глобальная http сессия
---------
INNER BEANS --
Например, когда в класс event надо передавать дату события. И например её надо создавать в определённой time zone. Тогдя для бина с датой надо тоже указать scope="prototype".
Но если этот бин даты нужен только в 1 месте, в бине event, то можем его создать как inner bean.
--!!!Внутренний бин виден только там, где он определён!!! INNER BEAN без ID, т.к. он не нужен.
<bean id="event" class="com.yet.spring.core.beans.Event" scope="prototype">
        <constructor-arg>
            <bean class="java.util.Date"/>
        </constructor-arg>
        <constructor-arg ref="dateFormat"/>
    </bean>
    
    <bean id="dateFormat" class="java.text.DateFormat"
        factory-method="getDateTimeInstance"/>
---------
т.е. бин эвэнт описан как прототип, то спринг каждый раз будет его создавать, т.е. вызывать его конструктор, а в нём -- inner bean -- и его спринг тоже будет каждый раз создавать.
!!!все внутренние бины создаются в момент инициализации внешнего бина!!!
Если класс создаётся из статического метода, а не из конструктора, то в спринге применяется атрибут factory-method, в котором указвается статический метод данного класса, который возвращает новую сущность требуемого объекта.
Например, в абстрактом классе DateFormat есть метод DateFormat.getDateTimeInstance(). Класс возвращаемого объекта, который создаётся этим factory-method-ом, не обязательно должен совпадать с классом, где этот метод находится.
Это значит, что неважно что мы указали в данном примере класс java.text.DateFormat, т.к. метод getDateTimeInstance() может вернуть объект с типом например java.util.Date.
Если надо передать агрументы в factory-method -- то надо использовать тэги constructor-arg, и указывать их какже как и для конструктора класса.
**************************
05 - INITIALIZE & DESTROY
init() метод указывается в атрибуте бина init-method="init".
init() метод:
1) не должен иметь аргументов
2) может иметь любой модификатор доступа (даже private, спринг его всё равно вызовет, а другие классы -- нет).
3) может что-то возвращать или выбрасывать исключение. (возвращаемое значение всё равно никто не прочитает, а exception -- видимо да).
-------
ну и соответственно при удалении бина, надо проверить, не остались ли в кэше невыведенные сообщение -- и вывести их.
для этого описать метод destroy. через атрибут бина destroy-method="destroy"
метод destroy будет вызван когда закрывается контекст, это когда явно вызывается метод appCtx.close().
если просто кильнуть процесс и вызвать System.exit() -- то закрытия спринг контекста не будет.
Надо чтобы контекст имплементил ConfigurableApplicationContext. Он также позволяет зарегить shutdownHook(), т.е. когда прога будет закрываться, то контест перед этим будет закрыт.
****************
06 CONTEXT FEATURES
Если бин наследуется от другого бина, и родитель имеет init или destroy методы -- то в xml файле для потомка надо также указать init или destroy методы родителя.
В предыдущем примере, для CacheFileEventLogger надо указать инит метод родителя FileEventLogger.
НО спринг может делать это автоматически, для этого есть "настедование определений" BEAN DEFINITION INHERITANCE.
для этого в атрибуте parent="fileLogger" надо указать имя родительского бина.
также можно задать атрибут abstract="true" для родительского, тогда спринг не будет создавать этот родительский бин, но будет использовать его атрибуты для наследования определений.
Абстрактые бины можно вообще не мапить на какой-то конкретный класс, т.е. атрибут class=".." можно даже не указывать.
НО в спринге -- это именно наследование определений, а не самих классов как в джаве. Надо это различать.
Не обязательно определиние 1 бина будет суперклассом 2го бина.
------
ЗАВИСИМОСТЬ БИНОВ. BEAN DEPENDENCY.
Если есть 2 бина, классы которых не связаны между собой, ни через аргументы конструктора, ни через проперти, но если надо чтобы инициализация 1 класса произошла только после инициализации другого класса, тогда надо испльзовать атрибут depends-on, в нём можно указать несколько имён бинов через запятую, от которых будет зависеть второй бин.
Например есть бин мониторинга, который должен стартовать только после инициализации всех дургих классов приложения.
------
ПОЗДНЯЯ ИНИЦИАЛИЗАЦИЯ. LAZY INITIALIZATION.
По умолчанию спринг создаёт бины сразу, когда читает определение контекста, или когда он понимает, что ему надо 1 бин внедрить в другой, но можно задать атрибут lazy-init="true", и тогда бин не будет создан до того момента, пока к нему не обратятся. например, через getBean из контекста.
-----
MULTIPLE CONTEXT.
В спринг есть понятие родительского и дочернего контекста.
При создании контекста ему можно предать ссылку на родительский контекст.
В таком случае дочернему контексту станут доступны все бины из родительского контекста.
При этом родитель ничего не будет знать о бинах дочерних контекстов.
***************************
07 PROPERTY INJECTION
Если значение устанавливается и через конструктор и через проперти, то здесь как и в джаве:
сначала вызовется конструктор и установит значение, потом вызовется проперти сеттер и перетрёт первое значение.
--
для установки списков/массивов ис-ся тэг <list> или <set> или <map>.
кроме этого есть возможность задать значения для java.util.properties: Тэгом <props>
можно задать null значение тэгом <null/>
*****************************
08 MORE CONTEXT FEATURES
Можно подключить проперти файлы:
1) задать бин PropertyPlaceholderConfigurer.
2) у него задать проперти locations, в к-м указать где искать проперти файлы.
можно задать пути через абсолютный или относительный путь, или через директиву classpath.
3) также у бина можна задать доп. атрибуты
-ignoreResourceNotFound -- если файл ресурсов не найден - будет exception
-systemPropertiesModeName -- по умолчанию если ключ не найден в подключённых проперти файлах -- то спринг попытается найти его в системных свойствах и переменных окружения. А можно задать так, чтобы дефолтные значения брались из подключённых проперти файлов, но системные проперти оверрайдили это значение.
------
Можно подключить namespace "util", который добавляет полезные штучки.
1) использовать в xml констату, определённую в каком-то классе, в кач-ве значения свойства или аргумента конструктора.
2) можно определять/задавать списки/мапы/наборы_свойств(проперти файлы) как отдельные бины. Чтобы потом можно было переиспользовать такие списки.
3) можно загрузить все проперти в объект java.util.properties
4) для мап можно явно задать тип класса, например TreeMap
---------
AUTOWIRE в XML. Автоматическое связывание.
<bean id="xxx" class="zzz" autowire="..." />
1) byName - по имени - спринг будет искать в своём контексте бин с именем/id равным названию проперти/поля в классе.
2) byType - по типу - спринг будет искать в своём контексте бин с таким классом, который подходит для типа/класса  проперти/поля в классе.
3) constructor - по типу через конструктов - как и по типу, только для внедрения искользуется конструктор, а не проперти.
Т.е. он подходит для внедрения бинов с уникальным именем или с уникальным классом.
Не рекомендуется комбинировать: когда пару значений через autowired, а другие явно указываются.
ОГРАНИЧЕНИЯ AUTOWIRED:
1) нельзя использовать для внедрения простых типов(примитивов), строк и классов, т.к. неясно, вы хотите внедрить бин или константу, или значение из проперти файла.
(primitives, String, class)
2) явное указание на какой-то бин имеем приоритет над автоматическим связыванием.
(direct reference has higher priority)
-------------
До этого мы определяли классы, которые не знали ничего о том, где они выполняются.
Но может возникнуть случай, когда классу нужно знать в каком контексте он выполняется, или какое у него имя в контексте.
Для этого в спринге есть ряд AWARE интерфейсов, реализовав которые, класс получит от спринга нужную инфу.
---
ApplicationListener
****************************
09 CONFIGURATION WITH ANNOTATION
Чтобы спринг начал искать и обрабатывать аннотации в классах надо подключить namespace "context" и добавить тэг
<context:annotation-config />
Тогда спринг будет искать аннотации и выполнять действия соглано с ними.
@Autowired указывает, что какое-то поле/проперти надо найти и подставить из конекста.
Если для @Autowired(required=false) -- то если в контексте не будет найден бин -- спринг засетит null, иначе (когда по умолчанию тру -- получим exception)
С помощью @Autowired можно внедрять и сами объекты спринг, такие как: BeanFactory, ApplicationContext, ResourceLoader, ApplicationEventPublisher.
Аннотацию @Autowired можно указать над:
1) описанием поля (даже private) -- усложняется юнит тестирование.
2) над сеттером
3) над конструктором.
----
@Autowired инжектит по типу. Если есть несколько бинов с одним и тем же типом, то чтобы их различить
1) можно ввести QUALIFIER, по умолчанию для qualifier используется имя/id бина.
@Qualifier("bean_name")
2) или использовать jdk аннотацию @Resource(name="bean2_name")
Но @Resource можно использовать только над полями класса или сеттерами класса с 1 аргументом.
------------
@PostConstruct и @PreDestroy -- каждую из них можно указать над несколькими методами, и они все будут вызваны.
----
Чтобы через аннотации передать значение из файла свойств -- надо указать @Value("${prop_key.id}").
Также через @Value можно задавать простые значения: @Value("Hi there!")
----
Аннотации к самим классам
@Component - основная
@Service
@Repository
@Controller
 Для того чтобы класс, помеченный такой аннотацией попал в контекст, надо дать спрингу команду на поиск таких классов с аннотациями, для этого используется тэг:
<context:component-scan base-package="..." />
************
10 EXPRESSION LANGUAGE
Через EL можно получить ссылку на внутрений бин, который внедрялся из xml.
Например, value="logger.date"
или можно вызвать метод и дальше от него продолжать что-то вызывать:
value="#{logger.getDateTime().getDay().name}"
В методы можно передавать параметры: бины, простые значения.
value="#{client.say('Hello')}"
в сприге Можно задать проверку на null
 value="#{app.createEvent()?.date}"
---
Если хотим обратиться к статическому полю, то надо вначала написать букву "T" - сокращение от type.
 value="#{T(java.lang.Math).PI}" или value="#{T(java.lang.Math).random()}"
---
В выражении можно указывать математическиие операции, или же проверки 
 value="#{'X' instance of T(int)}"
 value="#{'123' matches '^-?\\d+?$'}"
или же логические проверки: #{a and b} или #{not (a | b)}
а также условные операции (тройной оператор): #{ condition ? trueValue : elseValue }
------
Оператор Элвиса и проверка на null.
value = "#{ client.greeting ?: 'HelloString_IfNull'}"
---
В EL можно обращаться к элементу списка по индексу,
по ключу получать значение из мапы или свойств.
также можно самому задать список или мапу.
ИЛи можно прочитать свойства системного окружения или системные свойства программы при запуске.
 systemEnvironment['USER'] или systemProperties['dir'].
--
ЕЩЁ при работе с коллекциями можно сделать выборку элементов или проекцию коллекции.
чтобы получить все элементы, которые удовлетворяют условию, сначала пришется имя коллекции, потом
имя_коллеуции.?[условие_выборки], в условие_выборки могут участвовать поля или методы объектов хранящихся в коллекции.
Используя знак крыши ^ ИЛИ доллара $ можно получить 1-й или последний подходящий элемент.
Проекция позволяет выполнять подвыражения над каждым элементом и получить коллекцию результатов.
*****************
11 AOP
AOP -- это парадигма программирования позволяющая компоновать программы из взаимно пересекающихся блоков.
Programming paradigm that aims to increse modularity by allowing the separation of cross-cutting concerns.
Довольно понятно рассказывает в видео. Смотреть пару раз.
ОСНОВНЫЕ ПОНЯТИЯ В AOP:
1) АСПЕКТ (Aspect)--> это набор какой-то сквозной функциональности. Желательно делать аспекты нацеленными на какую-то конкретную задачу, чтобы разделять ответственнось между классами.
2) ПОИНТКАТ (Pointcut)--> он определяет где будет применяться этот аспект.
ГДЕ--> это значит в каком классе, в каком методе, может быть во всех методах какого-нибудь интерфейса, или в методах помеченных аннотацией.
3) ТочкаСопряжения (JointPoint)-->указывает конкретное место в классе, где подключается аспект.
 Т.е. это шаблон, под который может попасть несколько классов, а в каждом из них будет 1 или несколько конкретных мест, JointPoint-ов, где будет выполнен аспект.
4) СОВЕТ (Advice)--> содержит КОД аспекта, который будет выполняться в местах подключения.
это может быть проверка прав доступа, сбор статистики, логирование чего-то.
Также Advice указвает КОГДА будет выполняться этот код: в начале метода, при завершении и др.
---
Спринг реализует АОП с помощью прокси объектов.
Т.е. если для какого-то бина надо применить аспект, то спринг создаёт для этого бина прокси-объект и возвращает его вместо объекта.
Из-за этого проксирования, Спринг поддерживает только 1 тип JointPoint-а -- это method execution, т.е. выполнение методов на бинах в контексте.
------
Как можно задать Pointcut в приложении:
см. с  7:10.
*******************
12 SIMPLE ASPECTS
Чтобы подключить в спринг аспектЖ надо добавить библиотеку aspectjweave
А если надо будет связывать аспекты напрямую, то нужна библиотека aspectjrt
Далее, надо сообщить спрингу, что у нас есть вспекты в приложении.
для этого надо указать тэг <aop:aspectj-autoproxy /> или какой-то другой типа isNamespaceAop
--
Чтобы создать аспект надо создать класс и добавить к нему аннотацию @Aspect, описать там логику.
и зарегить этот класс либо как бин в xml либо добавить ему аннотацию @Component.
В спринговской реализации аспекты НЕ применяются на других аспектах.
добавим поинткат в нём определим шаблон, под коготорый попадают все методы logEvent во всех логгорах:
@Pointcut("execution(* *.logEvent(..))")
private void allLogEventMethods() {}
данный метод дложен возвращать void.
Имя метода при этом становится именем понтката.
1) Можно объединять поинткаты, ис-уя логические операции, 
2) обращаться к ним по имени
3) задавать определение поинтката напрямую.
--теперь у нас есть поинткат, и можно определить advice -- для этого надо исползовать другую аннотацию надо другим методом. Параметром в этой аннотации будет имя поинтката.
Например, мы хотим выполнить код advice-а перед выполнением метода занным поинткатом.
Метод advice-а может содержать аргумент JointPoint, а может и не содержать, если jointpoint нам не нужен .
--Параметром advice-аннотации может быть или имя поинтката, или его определение (т.е. сам шаблон=expression, чтобы сократить кол-во кода, но тогда поинткат нельзя будет переиспользовать).
--Чтобы вызвать advice после успешного завершения метода-- надо указать аннотацию @AfrerRerutning, в ней также можно указать имя для значения, возвращаемого исходным методом. 
--Если метод выбрасывает исключение, можно задать advice-аннотацию @AfterThrowing, и в ней также можно задать конкретный тип исключения, на который она будет реагировать.
-------
почему не стоит писать определять аспекты в xml файла -- см. с 7:00 --
1) т.к. в xml не поддерживает объединение именованых поинткат-деклараций
2) и в будущем нельзя будет перейти на ис-ие aspectJ библиотеки, без переписывания этого xml.
*****************
13 DATABASE ACCESS
как создать соединение через jdbc:
1) Загрузить драйвер БД в приложение.
для этого мы сообщаем драйвер-менеджеру, какие драйвера загружать:
а) через какое-то property из systemProperties
б) либо загружаем класс драйвера с помощью classLoader-а.
2) С помощью DriverManager  мы создаём connection, указываея URL на конкретную БД
3) Далее, чтобы выполнить запрос, создаём 1 из statement классов, через connection, 
4) заполняем параметры statement.
5) выполняем запрос, с помощью execute или executeUpdate.
6) обрабатываем результаты либо excepttion, который тоже может возникнуть.
7) закрываем connection, чтобы освободить ресурсы.
-------
В спринге есть несколько Template классов:
1) JbdcTemplate
2) NamedParameterJbdcTemplate
3) SimpleJdbcInsert и SimpleJdbcCall
4) RDBMS Objects
Спринг перехватывает все SQL exception, оборачивает их в свои CHECKED exception-ы и далее бросает их.
Иерархия исключений в этом случае такая (примерно):
1) DataAccessException -- как root exception
2) Rintime exception
3) All converted to the same hierarchy
---
Как делать запросы из JbdcTemplate --  см. с 4:31 и до конца.






