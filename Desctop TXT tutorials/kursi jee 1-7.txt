Лекция 1
5.30 - jdbs - интерфейс от java, а сама реализация - это конкретный драйвер от производителя БД.
8.30 - Может быть 1 программа и несколько драйверов. Параметры подключения.
15.30 - создание проекта в idea
19.30 - зачем делать class for name.
21.30 - загрузка классов, когда ис-ем jdbc
24.25 - статитечский код загружается при загрузке класса в ВМ. Так работает new Driver.
Драйвер себя загружает и сам себя регистрирует в драйвер-менеджере.
22.35 - создать БД
36.20 - три типа стейтментов
42.30 - чем плох обычный стейтмент. sql injection, преобразование строк и дат.
44.20 - параметр индекс начинается с 1. ResultSet тоже определяется в драйвере.
48.05 - перемещение по result set. В начале указатель стоит ПЕРЕД первой записью.
53.00 - параметры PreparedStatement для автообновления выгруженных данных.
57.40 - изменить данные в БД прямо из result seta
59.05 - что такое servlet-ы
1.0.15 - http - текстовый протокол, это не бинарный
1.15.30 - как сжимать респонс
1.20.0 - ответ от сервера
1.45.0 - сервлеты - начало
1.49.0 - объясняет AS, WildFly
1.54.0 - war archive
2.9.0 - про tomcat
2.14.0 - WAS
2.27.0 - про idea и другие
2.36.0 - простой servlet из web.xml. Если 2 сервлета на 1 урл, то какой вызовется раньше, из аннотации или веб.хмл?
2.40.20 - создание объекта сервлета. Он сказал, что AS создаёт 1 объект сервлета, и каждый запрос идёт в отдельном thread-е.
2.44.50 - сбор и запуск проекта с сервлетами, проблема с мавеном.
2.49.15 - запуск WildFly
3.0.0 - про фильтр к сервлету.

********************************
Урок 2 - 

1.0 - jsp страницы, и как они преобразуются на сервере
5.30 - скриплет - код java внутри jsp
14.0 - jstl c:forEach
19.0 - связка сервлет + jsp
24.0 - запуск сервлета и jsp на сервере.
29.0 - просмотр war файла
33.0 - class в который преобразовалась jsp страница
38.0 - сервлет готовит данные, преобразует, сохраняет в request, а jsp страница уже только отображает, и не содержит никакой логики.
40.07 - что такое Java EE ? это спецификации,
очень похожа на протокол, описание что нужно сделать, чтобы все понимали друг друга
41.0 - все спецификации на сайте jcp.org
43.40 - AS это есть набор реализаций j2ee спецификаций.
45.30 - части j2ee приложения (3 уровня) - 
47.20 - view, business logic, DAO куда-то ходит за данными
48.25 - что можно испльзовать для DAO.  JBDC
50.20 - ORM продукты
59.0  - myBatis
1.0.30 - Spring JBDC Template
1.1.25 - web services, JAX-WS (WSDL, XML), JAX-RS (HTTP, JavaScriptObjectNotation)
1.5.14 - business logic, что можно использовать.
ЧТо такое вообще BL - это алгоритмы,которые оперируют данными (из дао)
1.10.0 - ejb, jms, spring
1.14.20 - VIEW.
1.31.37 - часть 2
1.35.05 - что важно знать: средства разработки проекта. Где хранить исходный код и т.п.
1.36.40 - про GIT, git-scm.com - pro git скачать книжку.
1.39.40 - системы для сборки проекта maven и т.п.
1.46.10 - issue trackers, continuous integration.
1.57.30 - суть CI
2.1.10 - до этого врмемени рассказывал про CI.
2.4.20 - про maven
2.5.40 - пустой pom.xml
2.13.15 - src/main/java
2.24.10 - maven goals lifecycle, пример сборки jar-war
2.45.40 - реальный пример с maven, пропало видео.

***********************************
Урок - 3.1 - Про ГИТ и другие source manag systems

2.30 - начало про гит - это распределённая система контроля версий.
не нужно подключение к удалённому серверу.
3.30 - схема работы: пользователь и сервер, проект на сервере.
чтобы челы смогли работать с проектом - надо сделать git clone, этой командой мы забираем всё полностью: все файлы, плюс всю историю всех комитов
гит изначально делался чтобы вести разработку линуксового ядра.
удобная штука - если его понять.
9.20 - как работать с проектом, никуда не ходя: уехать на поезде, делать комиты ветки и т.п. у себя локально.
после этого сервер может даже и потерятся, и мы можем восстановить сам серевер очень быстро.
10.10 - если много участников и у них есть полные копии проекта, то потерять серверные данные очень сложно. т.к. от каждого можно получить его изменения и собрать их заново на сервере.
11.55 - что можем делать дальше? комит.
от нас этот комит пока никуда не уходит, он находится в нашей локальной копии. никто другой его пока не видит моего комита. можно сделать много комитов.
13.25 - Чтобы поделиться всеми своими изменениями, надо: git push
гит серверов может быть несколько.
15.15 - например, сделали несколько комитов и потом сделали пуш - если других изменений нет - то наши изменения спокойно лягут в сервер.
16.10 - а если второй чел тоже сделал пару комитов, то пуш у него не получится, потому что ему сервер скажет, что на сервере уже были изменения по отношению к его локальной копии. и поэтому он должен сначать обновить свои файлы локально (pull или fetch).
17.42 - что дальше - merge или rebase. 
18.00 - описывает, что происходит на сервере.
21.15 - даже если меняли не один и тот же файл.
22.00 - две ветки комитов идут от одного комита.
22.25 - MERGE - ещё 1 комит и у него будут 2 родителя.
24.30 - REBASE - изменить базу для своих комитов, например, было ответвление от i-го комита, а мы передвигаем базу на комит №6 другого юзера.
26.20 - каждому комиту присваивается свой гуид (уникальный идентификационный номер). 
27.47 - rebase: мы берём не сами комиты, а берём изменения, которые были в комитах другого юзера, и делаются новые комиты с новыми номерами. изменения будут всё теже, но номера комитов поменяются.
в merge ид комитов сохраняются, но появляются паразитические комиты с мёржем.
в rebase плохо то, что ид комитов меняются.
30.18 - пример, 2 сервера для разных разработчиков.
один разраб сделал пуш своих изменений на 2 серваке.
потом он обновился с 1 сервака, и если он сделает rebase, то комиты на 2 сервак у него локально перестанут существовать.
и если он захочет сделать пул со 2 сервака, то в его локальной копии его же комиты 4,5,6 снова вычекаутся.
32.38 - золотое правило: rebase лучше merge, но только в том случае, если вы не отдавали свои комиты никому другому. но если их уже кому-то отдавали, то уже rebase делать нехорошо.
33.50 - что стало после rebase, выстроилась цепочка 1,2,3 от другого юзера и его же 4,5,6, которые стали 7,8,9, и после этого он уже сможет сделать git push на сервер.
36.45 - git stash - если нужно срочно переключиться на другую разработку, то гит где-то у себя запомнит это состояние и это не будет комитом.
38.05 - BRANCH - например, нужно срочно починить баг - делаем для этого новую ветку. можно по разному создавать branch, например,  git checkout -b new_branch.
в этом случает гит сразу же переходит на эту ветку (т.е. как бы делает её активной)
40.00 - например, у последнего комита всегда есть метка HEAD. таких веток у комита может быть несколько.
41.00 - например, ветка issue-2, создаём символическое имя. и переключаемся на него и делаем комит.
можем вернуться на предудущий комит, и следать ещё 1 комит. бранч как бы станет невидимым, но изменения от него останутся. метка head изменится.
но когда-то мы должны будем свести обе эти ветки вместе.
43.00 - merge rebase на branch
45.10 - пример, github, другие площадки.
46.15 - создаю свой репозиторий на github
47.50 - доступ по SSH, надо создать паблик ключ и добавить его в настройки гита.
48.57 - gitlab.com - установить на линуксе свой сервер.
52.10 - гит сервер из ничего: линунс + доступ по ssh.
53.50 - dowload zip из github.
потом про github UI и создание локальной копии.
1.0.0 - локально гид клон, команды на просмотр branch
1.3.15 - удалённый branch и локальный branch
есть master branch - на сервере и у локальной копии.
1.5.20 - несколько состояний файлов для git
1е состояние - совсем новые файлы и за которыми он не следит.
2е - за к-ми следит, и в них могут быть или не быть какие-то изменения
1.09.45 - один и тот же файл, добавлен в комит и с новыми изменениями не добавленными в комит.
1.12.0 - закомитили, но пишет ahead 1 commit, а как учитывается наш предыдущий комит на сервере?
git status не ходит на сервер и не обновляет данные оттуда. а показывает локальные изменения.
делаем команду git branch -avv
1.14.19 - чтобы забрать изменения с сервера - делаем команду git fetch.
и гит забирает изменения ни в наш локальный master, а в ??? к себе в remotes/origin/master
а ПОТОМУ что git fetch просто копирует изменения с сервера куда-то к себе, и ничего в нашем локальном репозитории не изменяет.
1.17.00 - делаем сначала merge, потом комит, потом пуш, сверяем на сервере.
1.20.10 - снова изменяем на сервере, для последующего rebase, всё замутили и сделали пуш

---------------------
Урок - 3.2 - branch commit junit
02.25 - что такое origin/master ?
07.40 - сделал бранч Б1 и перешли на неё, сделали изменения в файле, запушили в бранч б1
11.45 - чтобы слить изменения из б1 в мастер, rebase делать не надо, т.к. комиты уже ушли в B1. 
Поэтому остаётся только мержить с мастером.
переключились на мастер и дали команду git merge b1
12.52 - не появился паразитический комит с мержем в git log потому что, не было изменений в master от других юзеров или с сервера. все изменения были от нашего имени.
14.52 - рисует эту схему без мерж комита
Если не было изменений в master то гид делает fast-forward, и просто переводит ссылку HEAD на конец бранча B1.
18.35 - как откатить изменияе версия 1 команда  git commit -a --amend
тут вызывается редактор на редактирвоание переданное комментрария к коменту. у меня выдал exception.
Короче, AMEND изменяют послдений комит, если например закомитил уже, а потом вспомнил что забыл точку с запятой поставить. 
тогда amend изменяет последний комит с исправленными изменениями.
НО это можно делать ТОЛЬКО если комит НЕ БЫЛ ЗАПУШЕН.
И при amend меняется ид комита.
21.25 - как откатываться? 
21.50 - удалили бренч В1 - просто затёрли ссылку.
23.00 - как удалить случайные файлы?
git clean -x -d -f
25.50 - откатиться на комит по части его гуида
32.30 - пример на ical календарь, как сделать fork репозитория из гита, pull request.
41.40 - поговорим о UNIT тестах.
43.01 - unit тестирование = функциональное тестирование (какого одного класса или функции), или Интеграционное тестирование - в сценарии ис-ся внешние компоненты к тестируемому модулю.
тестирование сервлетов - сложная штука.
47.00 - тестировать метод суммы 2 чисел.
49.50 - проверяются пограничные ситуации, где вероятна ошибка.
TDD - сначала пишем тест для нереализованного метода. т.к. мы значем, что за функциональность нужно реализовать и как она должна работать.
54.00 - когда надо изменить часть системы или функционала. при сборке запускаем тесты - выдают ошибку - значит, что мы что-то сломали.
56.26 - junit framework
59.20 - создали проект в idea
provided scope - ис-ся при компиляции но не идёт в war
test scope - ис-ся при компиляции и запуске юнит тестов, но не идёт в war
1.9.0 - static import.
*********************************
Урок 4.1 - JUnit
создали тест класс
18.00 - before after
21.20 - static beforeClass afterClass
24.00 - zero exception
29.40 - mochito, как работаем с объектами, которые мы получаем во время работы проги. Например, по jndi. ДЛя тестов нам не всегда нужен прямо такой уж настоящий внешний объект.
С помощью мохито можем съиметировать работы этого объекта.
34.00 - тестируем сервис через мокито.
43.50 - как прогеры ис-ют Junit
45.00 - порядок выполнения методов из junit теста не гарантирован. можно управлять этим внутри одного класса: сказать чтобы выполнялись в алфавитном порядке имён методов.
лучше писать тесты, которые не зависят друг от друга.
48.29 - SPRING при написание JUNIT тестов - например есть какое-то приватное поле без сеттера или не проиниализирован.. нужно залесть к класс в его приватный метод и что- менять... но у спринга есть спец. метод который с помощью рефлекшена ставит любое значение в прайвит поле.
51.45 - логирование. начало.
чем больше логов будет писаться - тем больше это будет сказываться на производительности.
56.00 - log4j начало, всегда есть настройка как чего логировать
58.22 - у log4j они могут быть 2х видов: xml или properties файлы.
в XML файла 2 важных момента, их может быть много: 
APPENDER - куда выводить логи.
CATEGORY - это связка того ЧТО будет писаться в лог с тем КУДА это будет писаться.
Есть разные уровни логирования. Но у каждого фреймворка эти уровни разные, в общем смысле они похожи.
1.5.35 - CATEGORY
1.11.30 - уровни включают себя справа налево
LOYOUT - это формат записи сообщения в логе
у категории есть имя (какое угодно).
1.14.0 - создаём console appender
1.20.0 - можно создать категорию по имени пакета. и тогда при создании логгера по имени класса, log4j сам найдён нужную категорию на основе пакета этого класса.
1.24.20 - можно в 1 категорию добавить несколько аппендеров.

*********************************
Урок 4.2 - 
00.45 - SLF4J НАЧАЛО
2.50 - например используем много разных сторонних библиотек и они используют разные логгеры.
а мы хотим в нашей системе собирать все логи в 1 месте и единообразно и настраивать в одном месте.
04.00 - slf4j-source Это например какая-то библиотека, которую запускают. т.е. сама по себе она на запускается.
7.00 - slf4j-target. уже указывается конкретный логгер для всех зависимых библиотек.
15.00 - когда конструирование строки лога ресурсоёмко - то лучше делать проверку log.isInfoEnabled(). А то ресурсы съедятся а выводить и  не понадобится.
18.00 - начнём SPRING.
21.00 - spring много разных проектов, которые делают написание кода проще.
21.40 - IOC инверсия зависимостей
24.00 - 3 уровня в приложении. все они должны быть связаны. иметь ссылка на друг друга. можно конечно написать руками всё это. но когда прилага сложнее и больше тем больше такого инициализациооного кода нужно писать и т.п. и нужно задавать всякие разные настроики, например для DAO. нужно писать код, который считает файл настроек и т.п.
и так на каждом уровне может быть много различных параметров, которые надо считать, обработать, задать, передать и т.п. и на всё это нужно писать код, который это делает. и к-й не связан с основной лоигикой приложения.
и как раз принцип Sprig IOC позволяет это всё упростить.
32.18 - spring интегрируется со всеми другими фреймворками. spring это просто набор java классов, которые мы можем использовать в своём приложении.
34.15 - спринг можно конфигурировать xml или аннотациями или java кодом. или также на groovy.
36.00 - спринг сам будет создавать объекты за нас. и в декларативном виде можно настроить\сказать ему как нужно собирать наши объекты.
например считать из файла проперти и поместить значение в какое-то поле, или например ссылку на дао.
38.30 - где-то же он спринг всё это создаёт и хранит. это называется spring context. их может быть несколько. всё настраивается.
41.15 - namespace у XML. чтобы он понимал, что за элементы там находятся. есть ссылка на схему. можно по ссылкам сходить посмотреть.
42.40 - как создаются bean. у него есть свой идентификатор. указывается его класс. т.е. спринг создаст для нас объект date.
можем ссылаться на один и тот же объект в других бинах.
создаём бин а в другой бин передаём референс (ссылку) на первый бин по идентификатору.
46.30 - спринг сам создать всю связанную цепочку бинов и всё засетит.
50.00 - в spring context при его создании можно сразу создать все бины, которые описаны в конфиг.файле. а можно создавать бины по мере обращения к ним.
можно передать несколько конфиг.файлов при создании ApplicationContext.
57.00 - описывает создание бинов при запуске апликухи.
59.00 - дата будет создаваться каждый раз новая.
1.3.55 - в спринге можно делать наследование.
1.9.0 - данные дублируются из Parent-а.
1.12.30 - другой пример, определить какие-то списки в спринге.
везде есть конструктор по умолчанию, т.к. нет других явных конструкторов.
бывает так, что нет конструктора по умолчанию, а есть конструктор с параметрами. или ис-ся метод типа getInstance.
на такие случае у спринга в бине есть спец имя для задания параметров: constructor-arg.
1.16.0 - lazy-init true
1.18.30 - проинициализировать коллекцию. можно указать референсы на другие объекты.
1.21.00 - часто после создание объекта нужно выполнить какой-то код, например после создания бина нужно выполнить его метод для завершения инициализации.
в спринге всё можно сделать как мининум тремя 3 способами, и они не всегда совместимы с друг другом, поэтому лучше сразу идти в документацию.
для инит-а вызвать init-method. или  implements InitializingBean, DisposableBean
DESTROY БИНА вызывается когда уничтожается spring context
если просто закроем прогу - этого не будет.
контекст уничтожается когда мы это вызываем явно: context.destroy()
нужно вызывать когда надо правильно высвободить ресурсы.
и когда закрывается приложение на Application Server-е.

*********************************
Урок 5.1 - spring продолжение
02.00 - вызов методов после создания бина
это нужно потому что, 1) не всё можно сделать в конструкторе (т.к. объект ещё не до конца готов)
04.50 -  default-init-method в глобальном тэге beans.
06.10 - через аннотации javax.annotation @PostConstruct и @PreDestroy
spring лучше конфигурировать через xml а hibernate - аннотациями.
13.00 - spring понимает аннотации от спецификации java
13.50 - вообще все аннотации не будут работать везде, а только в тех классах, которые создаются этим applictaion server-ом
т.е. в тех классах, которые мы создаём вручную сами - аннотации не будут работать.
16.00 - много разных способов сделать какую-то штуку в spring.
например, потому что не все классы мы можем изменить.
31.00 - пример создание и уничтожения. 
можно в глобалных beans задать  default-lazy-init="true", чтобы все бины создавались после первого к ним обращения.
34.20 - что ещё есть в spring?
35.20 - аннотацией @Value можно задать значение полю/переменной
35.48 - аннотация @Autowired - как она работает?
у нас есть 2 класса, в одном из них задана эта аннотация.
в спринговой конфигурации задан первый бин="аннотэйтед", но у него не указано никаких пропертей. и есть второй бин="спрингТест".
но если пропишем аннотацию autowired у 1го бина, то при его создании спринг сам попытается понять, что мы хотим здесь видеть:
он попытается найти по имени поля в классе springTest найти бин с таким id в своём контексте.
если не найдёт такого бина - то попытается понять какой нужен бин по типу. и если он найдёт такой бин по типу, то подставит заинженкит его туда.
если таких бинов будет несколько (то он не сможет понять, какой ему нужен)- и будет ругаться, поэтому нужно добавить вторую аннотацию @Qualifier, в которой указать id нужного бина из контекста.
чем чем неявнее получается - тем сложне использовать этот autowire, лучше когда имя поля совпадает с id бина из контекста.
41.00 - задать значение поля из properties файла.
в спринге есть свой вариант Expression Language, в нём можно много чего делать.
springProperties - это такой же бин, только ссылается на файл с пропертями.
и таких способов на ссылку на проперти файла есть несколько вариантов.
44.35 - spring EL - он вполне продвинутый, можно арифметич.операции делать, java код писать, объект создать. А вообще удобно ссылаться на другие поля других объектов.
для упрощения.
47.40 - Спринг - это набор классов, которые вы добавляете к своему приложению и запускаете вместе. Он для облегчения каких-то действий.
он включается на уровне runtime, и что-то делает.
можно считать что это часть моей программы, но она вынесена в отдельную библиотеку.
49.00 - springsuit - импорт других файлов настроек в один файл. Способ логического разбиения сущностей.
52.20 - можно конфигурировать спринг с помощью аннотаций.
54.00 - новый пример, xml файл со сылкой на проперти файл context:property-placeholder location="classpath:jdbc.properties"
57.15 - spring AWARE - создаём объект на основе какого-то бина, а после создания, нужно будет потом запросить у спринга ещё один объект, какой-то другой.
т.е. когда сразу не нужен, а нужен потом. и из этого бина нужна ссылка на спринговый контекст.
есть несколько интерфейсов с именем *Aware.
Идея в том, что если наш класс реализует этот интерфейс ApplicationContextAware, то... (переданный как аргумент ApplicationContext можно сохранить в какую-то переменную)
1.0.5 - при создании такого ApplicationContextAware бина, спринг вызовет заимплеменченный метод и передать себя (ApplicationContext) как аргумент.
1.0.50 - можно создать 2 разных spring context-а. и в каждом контексте создадутся все объекты. т.е. это будут 2 разных мешка.
и в бин aware будет передана ссылка на тот контескт, который его создавал.
1.4.55 - например, потом от спринга нам понадобится объект с датой
1.9.45 - BeanNameAware - 
1.10.50 - ЕСЛИ понадобилось id бина и xml файла внутри этого же бина при выполнении, то надо заимплементить интерфейс BeanNameAware. там будет 1 метод, куда передастся имя бина как string 

*********************************
Урок 5.2 - validation
01.50 - зачем вообще всё это мумтить со спрингом - потому что некоторые вещи проще сделать именно через него.
03.15 - ResourceBundleMessageSource - бандлы для разных языков. или просто чтения проперти файлов.
basename - имя поля, в которую сохранить базовое название файла.
09.40 - в валидаторе, если не прошёл проверку, добавляем значение в errors через rejectValue. 
12.05 - создаём объект errors, говорим для какого класса и какого имени.
и у валидатора вызываем validate, туда передаём класс для проверки и errors.
на выходе получим список ошибок, если они были.
такой механиз валидирование не всегда ис-ся так явно.
т.е. вызов валидатора, обработка ошибок, вывод результов могут обрабатываться каким-то другим фреймворком, который и будет всё это красиво показываться. 
основная суть у спринга в унификации.
15.00 - как это всё работает, запуск прилаги.
25.50 - mini-validators, которые уже стали частью спецификации javax.validation.constraints
аннотации для валидации - они не от spring, а от java спецификации.
можно также использовать constraint-ы от hibernate.
29.40 - другой пример как вызвать валидатор. ничего спрингового, только импрот библиотек от java.
32.00 - обрабатывать и выводить валидацию может какой-то другой объект, например, jax-rs. Т.е. не обязательно вручную самим вызывать проверку на валидацию.
Для того чтобы валидация вообще заработала - достаточно указать эти аннотации для полей класса/бина.
36.20 - лучше тренироваться на своих мелких примерах. не надо писать штуку в большом проекте. лучше сделать отдельный маленький пример, проверить нужную штуку, поэкспериментировать, а потом её всовывать в большой проект.
38.30 - expression language примеры.
39.30 - новая строка toUpperCase в этом EL, или сделать референсе через EL - value="#{userBean}"
40.40 - ExpressionExample можем выполнять на лету, разбор этих примеров.
49.00 - в EL можем вызывать методы и бина и результат присвоить в какое-то property другого бина.
49.30 - запуск Junit из Sprig. 
52.19 - аннотация @RunWith из Junit позволяет запускать его и из SPRING.
С помощью аннотации у спринга указать путь к конфигурации, и в тестах она подымется.
54.00 - для тестирование может быть нужен не весь spring context, a лишь его часть. или для тестов нужен другой spring context, который будет лежать отдельно в папке с тестами. Пусть к файлу можно указать в самом тест-классе.
обычно так и делают, для тестов отдельный конфигурационный файл, с сылкой на тестовую БД, и другие тестовые данные.
59.00 - можно сделать Autowired ссылку на сам Application Context.
1.1.20 - SPRING для общения с БД. Транзакции.
1.2.55 - spring может помочь организовать транзакции.
1.3.20 - у spring есть свой маленький велосипедик для работы с JDBC.
1.4.0 - нужно время на создание соединения к БД. Спринг делает это за нас. И есть ограничение на количество одновременных соединений к БД. Поэтому для приложение конектится к БД, создаёт пул таких соединений (например 30-50 штук) и потом когда нужно выполнить какой-то запрос к БД, мы обращается к этому пулу, нам предоставляется connection, мы его используем, и в конце отдаём обратно в пул, чтобы его переиспользовал кто-то другой.
1.8.20 - JdbcTemplate. Ему для работы нужно передать ссылку на dataSource.
1.11.56 - примеры jdbc операций, как полчить объекты, или список из result set-а, разные способы вставки.
1.20.40 - перенастраиваем проект на другую БД - postgresql.
1.24.30 - добавляем в БД схему для region.
*******************************
Урок 6.1 - продолжение jdbc dao
4.40 - где надо использовать interface: в самом классе использовать интерфейс, а в конфиге передавать конкретную реализацию этого интерфейса. спринг сам всё подсавит. но не нужно преувеличивать. где не нужен интерфейм и разные реализации - там и не делать их.
08.26 - транзакции: это некое объединение каких-то дейстивий в логическую единицу, которая является неделимой с точки зрения её целостности.
например, если далаем несклько запросов к БД и без транзакции, то если что-то пойдёт не так - мы не сможем их откатить.
10.47 - как можно управлять транзакциями в голом jdbc? когда есть connection - где-то у него есть setAutoCommit. Надо поставить false, выполняем несколько запросов, и в конце делаем getTransaction.commit.
Или вызывает rallback.
16.45 - хорошо самим обрабатывать транзакции без фреймворков, т.к. это быстрее. Плохо потому, что например, в методе create, если расширить картину, этот метод может вызываться кем-то в составе какой-то другой большой деятельности, и он хочет, чтобы вся это деятельность была в рамках одной большой транзакции, а не только транзакция для create.
Например, уволить сотрудника. хорошо бы на уровне сервиса выбирать, что включать в транзакцию.
так при увольнение может быть несколько вызовов DAO, и все они должны попасть в 1 транзакцию.
транзакция = бизнес-операция, которая состоит из набора каких-то действий/методов.
20.45 - Если это делать через голый JDBC то нам надо в начале метода добраться до этого connection, setAutoCommit(False), а в конце сделать ему commit. Но в этом случае, мы часть кода из DAO выносим в сервис, что неверно, т.к. сервис не должен зависеть от ДАО и значть как там чё работает. И даже заменить теперь сервис для работы с другой реализацией ДАО уже не получится.
21.35 - spring может помогать с транзакциями, но также и applictaion server тоже может помочь с этим.
22.15 - что нужно в spring чтобы организовать транзакции. это transactionManager.
23.00 - есть разные transactionManager, для hibernate, для jdbc, от AS.
23.45 - JNDI - грубо - это большой MAP которй хранит разные объекты. Можем к нему обратиться и по какому-то имени получить какой-то объект. Например, AS нам сделает dataSource, а мы по jndi его получим.
26.40 - второе, что нам необходимо для транзакций - это каким-то образом сообщать transactionManager когда он должен начинать и заканчивать транзакцию. В spring Это делается через аннотации.
27.45 - например, @Transactional, и когда кто-то вызовет метод с этой аннотацией, spring поймёт, и transactionManager в этом месте начнёт транзакцию. Как только метод закончится, transactionManager закомитит эти изменения. для rollback по умолчанию  учитываются только runtime exception, но это можно настроить.
В сервисе мы ничего не знаем ни про jdbc ни другое дао, но указывам транзакцию.
transactionManager нужна ссылка на dataSource, чтобы он получал из него connection. в ДАО есть ссылка на этот же dataSource.
В конфиге также надо добавить элемент: <tx:annotation-driven transaction-manager="txManager"/>, что транзакции читались из аннотаций, и спринг знал кому отдавать управление ими.
31.10 - в итоге, region service будет только обёрткой, т.е. внутри будут те же методы, но поверх будут добавлены операции/код по управлению транзакциями.
33.40 - если в реализации нашего метода захотим вызвать другой наш же метод, например из create вызовем findBy.. который тоже у нас транзакционный. Этот вызов будет транзакционным в рамках нашей исходной транзакции для create. т.е. если мы закодим вызов метода - то это будет вызов чистого метода, без добавленных спрингов обёрток для транзакции и т.п.
36.20 - тут надо бы получить ссылку на эту обёртку нашего класса из spring applictaion context (прошлый пример *aware)
38.30 - у этих аннотацией есть параметры. например Propagation. Один из главных. По этим параметрам spring будет понимать, создавать ли новую транзакцию, или использовать текущую, или же вообще не создавать.
Например, @Transactional(propagation = Propagation.REQUIRED) - представим, что у нас много разных сервисов, которые каждый вызывает какой-то другой, и каждый метод транзакционный, например, первый сервис вызвал метод, метод начал новую транзакцию. и у второго сервиса стоит Propagation.REQUIRED - то второй заюзает эту же транзакцию. 
НО если вызвали без транзакции - то второй создаст новую транзакцию.
Propagation.REQUIRES_NEW - всегда создаст новую транзакцию. то первая транзакция приостанавливается, создаётся новая, выполняется, завершается, и затем первая продолжается.
43.35 - Propagation.MANDATORY - обязательна, если транзакция есть - будет ис-ся. если нет - выбросится exception.
Propagation.NOT_SUPPORTED - если не было - то и не будет. если была - остановится, метод выполнится без транзакции, потом первая продолжится.
Propagation.NEVER - выдаст исключение.
46.30 - пример со вторым сервисом и откуда берутс транзакции.
53.25 - другой параметр @Transactional(isolation = Isolation.DEFAULT)
Уровень изоляции транзакции - это область видимости для других транзакций тех данных, которые изменяются в транзакции (т.е. то что видно за пределами этой транзакции)
например, мы сделали update, данные в бд уже изменились, но эти изменения не видны другим, пока у транзакции не сделан commit. после него все изменения применяются, и видны другим.
одна из целей - чтобы не было фантомных чтений.
Например, сделали update, кто-то это прочитал, а у нас проблема и мы откатились назад, данные вернулись на прошлые до изменения, а кто-то уже считал неверные данные.
Это всё идёт от самой БД. Есть 4 уровня изоляции.
57.10 - другие параметры у @Transactional. noRollbackFor/rollbackFor - можно задать доп. условия для откаты на опред. exception.
если timeout будет превышен - то будет rollback.
1.0.30 - транзакционной может быть не только работа с БД.
XA транзакции - это распределённые транзакции. Это когда мы работаем с несколькими БД. Это >=2 соединений, и это спец. transactionManager и спец. dataSource.
1.6.30 - spring itegration - не только описать как создавать объекты но и описать как обрабатывать эти объекты.
-- включить логи у спринга, посмотреть.
-- попробовать пару update с транзакциями или нет
-- jdbc и транзакции

*******************************
Урок 6.2 - чистый hibernate
01.50 - это ORM, т.е. наши сущности из БД где таблицы и связи между ними будут транслировться как объекты.
3.20 - читать hibernate документацию.
04.04 - это также обычная библиотека в виде jar, которую можно использоваться даже в консольном приложении.
У него есть свои настройки, могут бить в виде xml, properties file, java, annotation.
10.10 - настройка логирования для hibernate
12.00 - session в hibernate - это наш интерфейс для работы с hibernate. таких сессий может быть несколько, обычно их несколько и есть. есть различия в том, как они обрабатывают внутри себя данные.
Обычно делается каждая сессия на каждый запрос.
Или же делается сессия на пользоавтеля. Такая http сессия. И на ней создаёт hibernate сессия. 
Сессии создаёт session-factory, их тоже может быть несколько. ВНутри session-factory тоже находится JDBC.
default_schema - чтобы в запросах каждый раз эту схему не указывать.
connection.pool_size - hibernate сам будет создавать connection и использовать их. Использовать его для реальной работы - не стоит. (На продакшене connection должен создавать например AS или что-то другое: C3PO, НО самый хороший - это dataSource из AS, который сам и будет создавать пул коннекшенов).
dialect - говорит на каком sql хиб будет строить запросы для БД.
Могут отличаться типы данный, синтаксис получения разного кол-ва записей (например первый 20 записей, с 30 по 50 записи) поэтому чтобы БД понимала наши запросы - нужно использовать язык БД.
20.20 - самый главный параметр current_session_context_class
он выставляет настройку, с помощью которой хиб понимает, на какое событие создавать свою session.
например, thread - значит что  своя сессия будет создаваться на каждый java поток выполнения программы.
23.50 - параметр hbm2ddl.auto - хиб может по нашим настройкам, классам и маппингам сам создавать артефакты в БД (таблицы, поля, foreign key, index и т.п.) на основе того, что мы напишем в java классах и аннотациях.
когда стоит update  - когда хиб запускается, он проверяет соответствие той модели что загружается и того что есть в БД - то он добавит в БД того чего не хватает, удалять из БД он ничего не будет.
createDrop - Это хорошо для junit тестов.
когда всё работает в продакшене - нужно быть аккуратнее.
27.20 - mapping делается на аннотациях, поэтому указан только класс.
28.40 - есть 2 типа аннотаций: hibernate и jpa аннотации.
хиб может работать с обоими и даже мешать.
чисто визуально лучше jpa аннотации. (javax.persistence)
29.50 - @Entity - чтобы хиб понял, что это не просто класс а сущность из БД.
потом идёт @Table - чтобы замапить на табилу в БД. в параметрах можно укахать схему, index, constraints
31.30 - 2 поля в таблице и 2 поля в классе. @Column аннотация.
названия поля в классе и колонки в таблице могут не совпадать.
region_id делаем также и primary key, поэтому указываем @Id, а чтобы заполнялось автоматически добавляем @GeneratedValue 
(autoincrement=IDENTUTY, sequence=УКАЗАТЬ ЕГО ИМЯ, и др.)
35.00 - на поля в классе надо иметь getter И setter. Чтобы данные из result set разложить в объект.
37.00 - как всем этим пользоваться. в разных версиях хиб поменялся порядок первичной инициализации.
в примерах есть static ссылка на  sessionFactory. есть метод init.
в конце инициализации должны прийти к sessionFactory.
в конце работы нужно вызвать destroy метод.
41.00 - sessionFactory.getCurrentSession() - возвращает уже существующую сессию или создаёт новую.
sessionFactory.openSession() - принудительно создаст новую сессию.
Хиб не работает без транзакций. поэтому сразу надо создавать транзакцию и в конце её комитить.
43.50 - session.save возвращает нечто serializable.
44.50 - получить список всех регироно на HQL - свой хиб язык для простых запросов к БД. В нём Region - Это название нашей сущности (по умолчанию имя класса если в @Entity не указано другое name).
54.20 - 255 byte - длина varchar? колонки. Если использовать utf - то это 255/2=127 символов.
58.25 - дополнительная нагрузка при использовании hibernate. есть.
но сейчас он работает быстрее чем в первых версиях.
плюс у хиб есть кэширование, что помогает, но его надо настроить.
1.9.20 - HQL можно сделать NamedQueries. Это можно у сущности записать: 
1.16.00 - пример связки spring+struts+hibernate, разные версии в зависимостях, exclusions в pom.xml.

*******************************
Урок 7.1 - hibernate
05.30 - как узнать, что нужно исключать из POM файла?
в идеи можно построить дерево зависимостей.
загружать в classpath две разные версии библиотек - плохо, т.к. они вряд ли заработают.
в общем, нужно посмотреть зависимости в графе, и удалить ненужное.
или же собрать war файл и по факту найти дублирующиеся библиотеки.
15.20 - @ColumnTransformer (read или write)- при считывании колонки как-то её изменяет.
concat - sql оператор.
20.17 - когда хиб отдаёт нам объект, он может отдать объект не нашего класса.
21.50 - см. пример many to one.
24.00 - fetch бывает 2 типов: EAGER и LAZY.
EAGER - запрос будет таким, что он вытащит инфу и об этом городе и об этом регионе. т.е. сразу всю инфу по всем объектам в связке выгрузит из БД.
LAZY - то при запросе объекта city - он выгрузить только его данные, без всяких join-ов на регион. регион будет null, а заполнится он только тогда, когда мы обратимся к getRegion.
хиб перехватит этот запрос о регионе и сделает доп.запрос в БД на выгрузку этой инфы.
хиб перехватывает LAZY: когда он получает resultSet. но он создаёт не наш объект а некий прокси, похожий на наш (спрятанный за интерфейс), и у этого объекта переопределён метод getRegion (у этой прокси обёртки), тогда он создаст запрос и выгрузит регион из БД.
33.50 - обратная связть от региона на город. здесь не указывали joinColumn, т.к. его уже указали у city. 
но у region указываем имя поля в классе city, у которого есть все настройки, чтобы хиб понял как их связывать.
35.20 - параметр cascade - аналог того, что мы указываем при создании foreignKey в БД: т.е. что делать со связанными записями on update и on delete.
Например, удаляя регион - удалить все его города.
или удаляя город - неверно удалять регион.
т.е. какие операции будут распространяться и на связанные сущности в том числе.
37.50 - cascade=PERSIST - например создали новый город и регион - тогда хиб при сохранении города - сохранит и новый регион. если PERSIST не стоит - то в БД город будет создан а регион - нет.
41.00 - посидеть и поэкспериментировать с сохранением объектов.
41.40 - cascade=REFRESH - при обновлении города также обновиться и регион.
cascade=REMOVE - удалятся оба.
cascade=MERGE - ХЗ, 
cascade=DETACH - хиб следит за выгруженным объектом в рамках сессии. если у этого объекта мы изменили какое-то поле, то при закрытии сессии хиб применит эти изменения в БД.
46.40 - запуск, что происходит в main.
53.00 - объясняет как хиб выгражает lazy связи.
59.00 - resultSet и хиб по умолчанию не следят не следят за изменениями в БД.
1.2.45 - пример EAGER fetch.
1.13.35 - many to many  пример. Это реализуется 3 тремя таблицами, где две с данными, а третья - это связи между ними.
1.15.0 - связка вынесена в 3 тертью таблицу @JoinTable
Первая связь на свою колонку joinColumns = @JoinColumn(name = "book_id")
а вторя связь на вторую конец many to many -
inverseJoinColumns = @JoinColumn(name = "author_id")
1.17.0 - для хиб не принципиально будет тип list или set, для девелопера и производительносьти это может быть важно.
во втором классе уже не обязательно указывать те же настройки для many to many, достаточно указать mappedBy и ссылку на первый конец many2many: mappedBy = "authorList"

*******************************
Урок 7.2 - hibernate
01.45 - наследование в Java и хиб.
05.50 - для наследование в хиб надо задать аннотацию 
@Inheritance(strategy = InheritanceType.JOINED)
JOINED - значит что есть 1 таблица с общими данными и есть отдельный таблицы на конкретные сущности.
06.45 - у каждой наследуемой сущности указывает какая колонка будет являться primary key, куда попадёт payment id
15.05 - @Inheritance TABLE_PER_CLASS - у каждого дочернего класса прописывается своя собственная таблица.
@AttributeOverrides({
        @AttributeOverride(name = "amount", column = @Column(name = "amount"))
})
21.00 - @Inheritance SINGLE_TABLE
@DiscriminatorColumn и @DiscriminatorValue("1")
простая ненормализованная таблица. для хиб нужен дискриминатор, чтобы различать классы.
31.05 - чаще всего используется table-per-class наследование, т.к. не накладывает особых ограничений.
31.30 -кэширование в хиб: есть несколько видов.
кэш 1-го уровня - работает на уровне сессии, т.е. если объект уже был получен из БД, то когда в другом запросе идёт обращение к нему же - то он берётся из кэша. в частности если стоит lazy инициализация, то если в 1  месте это поле было проиниализировано, то во 2м месте эти данные уже не будут выгружаться.
Но это только для одной и той же сессии, кэш 1-го уровня всегда включён по умолчанию, выключить его нельзя.
но для разных сессий такой кэн не работает.
если сессию закрыли - то все данные из кэша пропадают.
35.45 - кэш второго уровня - он работает на уровне sessionFactory.
объекты будут доступны из всех сессий, созданных это фабрикой.
этот кэш по умолчанию выключен, его нужно включить и настроить вручшую принудительно ( в т.ч. и через сторонние библиотеки)
От хиб реализация называется EhCache.
39.00 - чем грозит использование кэша? надо засетить параметры для кэша, чтобы он заработал.
41.10 - к классу добавить аннотацию 
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = 
"CacheForRegion")
READ_ONLY - эта сущность может одновременно читаться из кэше разными потоками. и эта сущность не бдует изменяться в кеше, даже если она изменится в хиб
READ_WRITE - при изменении сущ в хиб она будет изменена и в кэше.
NONSTRICT_READ_WRITE - есть послабление в виде...?
TRANSACTIONAL - большая транзакция, но не все реализации кэша поддерживают этот тип.
также можем задать region регион кэширования. можно добавить спец. конфиг файл, где можно указать различные параметры для этих регионов, т.е. логически разделить сущности по различным регионам кэширования.
54.15 - включили кэш2ур, но лог всё равно вывел 2 запроса к БД.
Почему? В кэш2ур кладутся объекты/сущности, они туда кладутся не в виде объектов, а в виде какой-то сериализации (но не java), а какой-то массив простых типов.
и у этого массива есть ключ=primary key, и из этого массива при получении делается объект.
почему не работает? - т.к. в примере мы запрашиваем СПИСОК этих сущностей, а не сами сущности. поэтому из кэша2ур мы ничего не получаем.
57.20 - КЭШ ЗАПРОСОВ - по умолчанию выключена.
<property name="cache.use_query_cache">true</property>
и в этот кэш (типа мэп) сохраняется: для ключа ис-ся сам запрос, а значением явл-ся список ID сущностей, возвращаемых запросом.
и когда в след раз мы выполним точно такой же запрос - то хиб возьмёт результы (только ид-шники) их этого кэша. Но если при этом был включен кэш2ур - то в связке они дадут хороший прирост производительности.
1.9.0 - выгрузка одного и того же класса, но кэши не сработали, хотя сессия одна и та же. Причина в том, что в этом методе делается commit, но причина не в нём самом, а в том, что хиб может закрывать сессию при коммите транзакции.
есть спец. настройка в конфике, чтобы не закрывать сессию при коммите.
Если получать сессию из sessionFactory.getCurrentSession(), то при  session.getTransaction().commit(); хиб автоматом закроект эту сессию.
1.16.55 - просмотр статистике по кэшу.



------------------
можно получить объект, который не замаплен.
как получить объект из сессии.
посмотреть все методы session.
какие состояния могут быть у сущности в хиб.
сделать бин getByID
для рест - заботанить связку jax-rs + cdi
git k origin/master - визуально покажет измения.

интерактивный rebase - ? gir rebase -i имя ветки.
простой rebase идёт по комиту.
git fetch.
git rabase origin/master - по 1 комиту добавляет на мастер, линейно на мастер добавляет.
merge - делает 2 пути от меня и мастер - и в 1 комите фиксаю все конфликты из всех изменений.
-как в спринге подключить файл от хиб?