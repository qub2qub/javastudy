как стадии в мавене, как создать свою?
чем отличается от анта?
gradle изучить.

как устроена память в java, хип, где создаются объекты, где хранятся переменные?
как работает gc, разлчные варианты его работы?

Кто и что создаёт бины в спринге? (это BeanFactory или AppCtx)
bean lifecycle в спринге?
для чего BeanPostProcessor?
circular dependency когда 1 бин втавляется во 2й, и 2й в 1й.

что такое транзакция?
как орм работает с сессией?

что такое коллизия в хэшмапе?

примеры sql,
что за FK, из чего состоит как хранится?
когда нужна новая таблица для связей 1---* или *---* ?

-------------------------
какую проблему решают каждый уровень изоляции?

acid принципы транзакции?

какие кэши бывают в хиб?

какие типы бинов: Pers, trans, detach?

кэш второго уровня один на 50 машин.

если референс по ид будет нул? что дальше.
он его вычитает только когда первый раз сделаю getfield.

fetch stratagy - сколько, как работают.
-----------------------
java graph wiki
EN - https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29
RU - https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_%28%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29

дорога с перкрёстками.
задача sales men, есть курьер и дороги между городами, каждая дорога имеет длинну, и надо посетить все города.

Алгоритм Дейкстры
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B
----
коллизия (хэш кода) - когда объекты не равные, а хэш код у них одинаковые.
HashSet - может иметь разные реализации борьбы с коллизиями. Когда этот объект сохраняется в другой бакет, называется open table, который не ис-е линкед лист а математически рассчитывает другой номер бакета. Вероятность коллизии в другом бакете увеличивается, но не расходует память на линкед листы.
-----
где какую коллекцию использовать?
1 одинаковые объекты или нет
2 сортированные или нет
3 array list - для random access
4 linked - вставляешь за конст, и хранишь указатели, доп нагрузка по памяти
5 arraylist - нет доп нагрузки по памяти, 

---
сбалансированное двоичное дерево поиска  -  путь от вершины до самого дальнего листа (node-узел) меньше либо равно log(N)+1
log - это в какую степень надо возвести 2, чтобы получилось число N.
есть много разных алгоритмов балансировки, в java используется (чёрно красное дерево).
балансировка занимает константу, т.е. не зависит от кол-ва нодов в дереве. Потому что к red-black они хранят доп информацию, и все перестановки - это переделывание 3 указателей. Посмотреть в инете лекция m-it 
http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-6-avl-trees-avl-sort/

поиск занимает log(N).
set от list - в set нельзя вставить одинаковые объекты.

