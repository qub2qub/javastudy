<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>TransErrors</title>
    <link rel="stylesheet" href="grey.css">
</head>
<body>
<a href="http://www.ibm.com/developerworks/ru/library/j-ts1/">src</a>
<div id="ibm-leadspace-head">

	<h1>Стратегии работы с транзакциями: Распространенные ошибки</h1><p><em><span>Не забывайте о распространенных ошибках при реализации транзакций на платформе Java</span></em></p>

	<div id="dw-summary-area" class="dw-summary-columns">
		<div class="ibm-col-6-4">
		<p>В процессе выполнения транзакций должна достигаться высокая степень целостности и согласованности данных. В этой статье, первой части серии, посвященной вопросам эффективной стратегии выполнения транзакций на платформе Java, Марк Ричардс описывает распространенные подводные камни, которые могут привести к потере согласованности. Часто совершаемые ошибки объясняются на примерах, взятых из инфраструктуры Spring Framework и спецификации EJB (Enterprise JavaBeans) 3.0.</p>
		</div>
		

<div class="ibm-columns">
<div class="ibm-col-1-1">

<p>Основной причиной использования транзакций в приложениях является обеспечение высокой степени целостности и согласованности данных. Если вас не заботит качество ваших данных, то нет причин думать на тему применения транзакций, поскольку на платформе Java они могут серьезно снизить производительность, привести к проблемам, связанным с блокировками, а также повысить сложность приложения в целом. </p><div class="dw-sidebar ibm-inset"><h2 id="N10051">Об этой серии</h2><p>Транзакции позволяют повысить качество, целостность и согласованность данных, а также надежность приложения в целом. При этом реализация успешной схемы выполнения транзакций в приложениях Java представляет собой нетривиальную задачу, основная сложность которой заключается в проектировании, а не в написании кода. В этой новой <a href="http://www.ibm.com/developerworks/ru/views/java/libraryview.jsp?search_by=транзакциями+Стратегии:">серии</a> Марк Ричардс предлагает свое руководство по дизайну эффективной стратегии управления транзакциями при решении различных задач – от создания простых приложений до реализации высокопроизводительных транзакционных систем.</p></div><p>Разработчики, не желающие применять транзакции, поступают так на свой страх и риск. Практически во всех бизнес-приложениях необходимо поддерживать высокое качество данных. Один только финансовый инвестиционный бизнес теряет десятки миллиардов долларов из-за неудачных торгов, причем второй по распространенности причиной этого являются некачественные данные (см. раздел <a href="#resources">Ресурсы</a>). Отсутствие транзакций является не единственным фактором, отвечающим за потерю качества данных, но тем не менее можно смело утверждать, что недостаточная и отсутствующая вовсе поддержка транзакций стоит финансовой индустрии миллиардов долларов. </p><p>Одной из проблем является плохая осведомленность разработчиков о транзакциях вообще. Мне часто приходится слышать утверждения наподобие такого: "В наших приложениях не бывает сбоев, поэтому поддержка транзакций не требуется". В чем-то это верно. Я встречал приложения, которые или очень редко, или никогда не выбрасывают исключения. Благодаря хорошо написанному коду, процедурам валидации, а также циклу тестирования и проверке покрытия кода тестами, им удается избежать потерь производительности и повышенной сложности, связанной с обработкой транзакций. Однако подобный взгляд на необходимость транзакций является несколько однобоким, поскольку принимает во внимание только одно их свойство – <em>атомарность</em>. Атомарность гарантирует, что все изменения в базе данных являются единым целым и либо все выполняются, либо все отменяются. Однако координированное выполнение и откат изменений – это лишь один из аспектов транзакционности. Другим аспектом является <em>изоляция</em> транзакций, означающая, что процедуры работы с данными изолируются друг от друга. В отсутствие должной изоляции одним процедурам могут стать видимы изменения, сделанные другими, параллельно выполняющимися процедурами, даже если последние еще не завершились. В результате бизнес-решения могут приниматься на основании неполных данных, которые, в частности, могут привести к срыву торгов и другим негативным и дорого обходящимся последствиям. </p><div class="dw-sidebar ibm-inset"><h2 id="anecdote">Лучше поздно, чем никогда</h2><p>В полной мере я начал оценивать проблемы, связанные с обработкой транзакций, в начале 2000-х годов, когда, работая на стороне заказчика, натолкнулся на строчку в проектном плане, которая была последней перед задачей тестирования системы. Она гласила: "<em>Реализовать поддержку транзакций</em>. Да-да, это ведь так просто – добавить поддержку транзакций в крупное приложение, практически готовое к тестированию, не правда ли? К сожалению, этот подход встречается слишком часто. По крайней мере, в том проекте, в отличие от большинства проектов, <em>была</em> заложена поддержка транзакций, пусть и в самом конце цикла разработки.</p></div><p>Итак, учитывая то, насколько дорого могут обойтись некачественные данные, а также обладая базовым представлением о важности и необходимости транзакций, вам необходимо научиться их использовать и решать связанные с ними потенциальные проблемы. Допустим, вам удалось "продавить" решение о добавлении транзакций в ваше приложение. Именно в этот момент часто начинаются проблемы. В частности, на платформе Java транзакции зачастую работают не так, как было обещано по причинам, которые будут рассмотрены ниже. Я покажу на примерах некоторые из распространенных ошибок при работе с транзакциями, которые приходится наблюдать из раза в раз, причем, как правило, в уже введенных в эксплуатацию приложениях.</p><p>Несмотря на то, что в большей части примеров к этой статье используется Spring Frameworks (версия 2.5), понятия при работе с транзакциями остались такими же, как и в спецификации EJB 3.0. В большинстве случаев достаточно заменить аннотацию <code>@Transactional</code> в Spring на аннотацию <code>@TransactionAttribute</code> из спецификации EJB 3.0. В тех случаях, когда Spring и EJB расходятся (концептуально и технически), будут приведены примеры кода, соответствующие обеим инфраструктурам. </p><h2 id="N1007F">Ошибки, связанные с локальными транзакциями</h2><p>Начать лучше всего с рассмотрения самого простого случая, а именно – <em>локальных транзакций</em>, также часто называемых <em>транзакциями баз данных</em>. В былые времена при работе с хранилищами данных (например, через JDBC) было принято оставлять обработку транзакций базе данных. В конце концов, это ее прямая обязанность, не так ли? Локальные транзакции идеально подходят для обработки логических единиц работы (logical units of work – LUW), выполняющих единичные операторы вставки, изменения или удаления данных. Например, рассмотрим простой фрагмент JDBC-кода, который добавляет торговый приказ в таблицу <code>TRADE</code> (листинг 1).</p><h5 id="listing1">Листинг 1. Простая вставка записи в базу данных через JDBC</h5><div class="codesection"><pre class="displaycode">@Stateless
public class TradingServiceImpl implements TradingService {
   @Resource SessionContext ctx;
   @Resource(mappedName="java:jdbc/tradingDS") DataSource ds;

   public long insertTrade(TradeData trade) throws Exception {
      Connection dbConnection = ds.getConnection();
      try {
         Statement sql = dbConnection.createStatement();
         String stmt =
            "INSERT INTO TRADE (ACCT_ID, SIDE, SYMBOL, SHARES, PRICE, STATE)"
          + "VALUES ("
          + trade.getAcct() + "','"
          + trade.getAction() + "','"
          + trade.getSymbol() + "',"
          + trade.getShares() + ","
          + trade.getPrice() + ",'"
          + trade.getState() + "')";
         sql.executeUpdate(stmt, Statement.RETURN_GENERATED_KEYS);
         ResultSet rs = sql.getGeneratedKeys();
         if (rs.next()) {
            return rs.getBigDecimal(1).longValue();
         } else {
            throw new Exception("Trade Order Insert Failed");
         }
      } finally {
         if (dbConnection != null) dbConnection.close();
      }
   }
}</pre></div><p>В коде работы через JDBC, приведенном в листинге 1, нет никакой логики обработки транзакций, хотя они и сохраняют торговые приказы в таблице <code>TRADE</code> в базе данных. В данном случае за выполнение транзакций отвечает сама база данных.</p><p>Все это работает хорошо в случае выполнения единственной операции в LUW. Однако, допустим, что необходимо обновить состояние счета в момент добавления заказа в базу данных, как показано в листинге 2.</p><h5 id="listing2">Листинг 2. Выполнение нескольких операций изменения данных внутри одного метода</h5><div class="codesection"><pre class="displaycode">public TradeData placeTrade(TradeData trade) throws Exception {
   try {
      insertTrade(trade);
      updateAcct(trade);
      return trade;
   } catch (Exception up) {
      //запись в журнал ошибок
      throw up;
   }
}</pre></div><p>В этом примере методы <code>insertTrade()</code> и <code>updateAcct()</code> используют JDBC, не включая их в одну транзакцию. После выполнения метода <code>insertTrade()</code> торговый приказ был сохранен в базе данных, и соответствующая транзакция была подтверждена. Если вызов метода <code>updateAcct()</code>, то приказ останется в таблице <code>TRADE</code> что будет означать несогласованность базы данных. Если бы метод <code>placeTrade()</code> использовал транзакции, то обе операции являлись бы частью единой LUW, и заказ на торги был бы отменен в случае сбоя при обновлении счета.</p><p>Подобные примеры кода, непосредственно работающего с JDBC, стали встречаться реже в связи с распространением Java-инфраструктур для работы с хранилищами данных, таких как Hibernate, TopLink и Java Persistence API (JPA).  Как правило, используются библиотеки для объектно-реляционного отображения (ORM), которые облегчают жизнь разработчикам, скрывая весь нелицеприятный код JDBC за вызовами нескольких методов. Например, для того, чтобы выполнить ту же операцию по вставке заказа, JDBC-код из листинга 1 можно заменить на JPA-код, показанный в листинге 3, предварительно отобразив класс <code>TradeData</code> на таблицу <code>TRADE</code>.</p><h5 id="listing3">Листинг 3. Пример простой вставки данных при помощи JPA</h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl {
    @PersistenceContext(unitName="trading") EntityManager em;

    public long insertTrade(TradeData trade) throws Exception {
       em.persist(trade);
       return trade.getTradeId();
    }
}</pre></div><p>Обратите внимание, что в листинге 3 вызывается метод <code>persist()</code> класса <code>EntityManager</code> для вставки торгового приказа. Все просто? Отнюдь. Этот код не вставит запись в таблицу <code>TRADE</code>, как этого можно было бы ожидать, но не выбросит и исключения. Он просто вернет значение <code>0</code> в качестве первичного ключа приказа, не изменяя состояния базы данных. Это один из первых серьезных подводных камней при обработке транзакций: <em>инфраструктурам ORM требуются транзакции для синхронизации содержимого кэша объектов и базы данных.</em> Генерация SQL-кода и изменение базы данных вследствие выполнения нужного оператора (insert, update или delete) выполняется только при подтверждении транзакции. В отсутствие транзакции некому дать сигнал ORM о том, что надо сгенерировать код SQL и выполнить изменения в базе данных, поэтому метод просто завершается, ничего не сделав, даже не выбросив исключения. При работе с ORM вы обязаны использовать транзакции. Больше нельзя полагаться на базу данных в вопросах управления соединения и подтверждения изменений.</p><p>Эти простые примеры ясно показывают, что транзакции необходимы для поддержки целостности и согласованности данных. Однако пока мы затронули лишь верхушку айсберга в вопросах сложности и потенциальных ошибок при реализации выполнения транзакций на платформе Java. </p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N100DA">Ошибки, связанные с аннотацией <code>@Transactional</code> в Spring Framework</h2><p>Итак, выполнив код, приведенный в <a href="#listing3">листинге 3</a>, мы убедились, что в отсутствие транзакций метод <code>persist()</code> работает не так, как предполагалось. Выполнив поверхностный поиск в Интернет, можно найти ряд страниц, на которых объясняется, что при работе с Spring Framework следует использовать аннотацию <code>@Transactional</code>. Добавьте ее в код, как показано в листинге 4.</p><h5 id="listing4">Листинг 4. Пример использования аннотации <code>@Transactional</code></h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl {
   @PersistenceContext(unitName="trading") EntityManager em;

   @Transactional
   public long insertTrade(TradeData trade) throws Exception {
      em.persist(trade);
      return trade.getTradeId();
   }
}</pre></div><p>Однако этот вариант программы по-прежнему не работает по причине того, что следует явно сообщить Spring Framework о факте использования аннотаций для управления транзакциями. Эту проблему иногда сложно обнаружить, если код полностью не покрыт юнит-тестами. Из-за этого некоторые разработчики попросту добавляют логику управления транзакциями в конфигурационные файлы Spring вместо использования аннотаций.</p><p>При использовании аннотации  <code>@Transactional</code> в Spring следует добавить следующую строку в конфигурационный файл Spring:</p><div class="codesection"><pre class="displaycode">&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</pre></div><p>В свойстве <code>transaction-manager</code> хранится ссылка на менеджер транзакций, определенный в конфигурационном файле Spring. Эта строка указывает Spring, что при применении перехватчика транзакций следует использовать аннотацию <code>@Transactional</code>. Без нее данная аннотация игнорируется, в результате чего транзакции в коде не используются вовсе.</p><p>Добиться того, чтобы аннотация <code>@Transactional</code> в <a href="#listing4">листинге 4</a> заработала – это только начало. Обратите внимание, что в листинге 4 эта аннотация используется без каких бы то ни было параметров. Мне встречалось множество разработчиков, которые применяли аннотацию <code>@Transactional</code>, не разобравшись полностью в том, что она делает. Например, какой режим распространения используется при отсутствии параметров аннотации? Каково значение флага "только чтение" (read-only)? Какой уровень изоляции используется? Еще более важным является вопрос о том, когда транзакция должна откатываться. Понимание того, как следует применять данную аннотацию, очень важно для организации правильной поддержки транзакций в вашем приложении. Ответы звучат следующим образом: при использовании аннотации <code>@Transactional</code> без параметров режимом распространения является <code>REQUIRED</code>, значением атрибута "только чтение" – <code>false</code>, уровень изоляции соответствует уровню изоляции по умолчанию для базы данных (как правило, это <code>READ_COMMITTED</code>), и транзакция не будет откатываться в случае контролируемых исключений (checked exception).</p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10124">Ошибки, связанные с флагом "только чтение" аннотации <code>@Transactional</code></h2><p>Одной из ошибок, которые мне часто приходится наблюдать, является некорректное использование признака "только чтение" аннотации <code>@Transactional</code> в Spring. Попробуйте ответить на следующий вопрос: что делает аннотация <code>@Transactional</code> (листинг 5) в случае установки этого флага в значение <code>true</code> и режима распространения <code>SUPPORTS</code> при использовании стандартного JDBC-кода для сохранения данных?</p><h5 id="listing5">Листинг 5. Пример использования флага "только чтение" и режима распространения <code>SUPPORTS</code> с JDBC</h5><div class="codesection"><pre class="displaycode">@Transactional(readOnly = true, propagation=Propagation.SUPPORTS)
public long insertTrade(TradeData trade) throws Exception {
   //Работа через JDBC...
}</pre></div><p>Выберите из следующих вариантов правильный вариант того, что произойдет при выполнении метода <code>insertTrade()</code> из листинга 5.</p><ul class="ibm-bullet-list" type="A"><li>Выбросит исключение, поскольку подключение разрешает только операции чтения.</li><li>Корректно вставит торговый приказ и подтвердит сохранение данных.</li><li>Ничего не сделает, поскольку уровнем распространения является <code>SUPPORTS</code>.</li></ul><p>Сдаетесь? Правильным является ответ "В". Торговый приказ корректно сохраняется в базе данных несмотря на флаг "только чтение" и режим распространения <code>SUPPORTS</code>. Как это возможно? Дело в том, что из-за режима распространения <code>SUPPORTS</code> новая транзакция не начинается, поэтому в методе используется локальная транзакция (т.е. транзакция базы данных). Флаг "только чтение" применяется только в случае начала новой транзакции, а в этом примере он попросту игнорируется.</p><p>Тогда возникает вопрос, что будет делать аннотация <code>@Transactional</code> в листинге 6 с установленным флагом "только чтение" и режимом распространения <code>REQUIRED</code>?</p><h5 id="listing6">Листинг 6. Пример использования флага "только чтение" и режима распространения <code>REQUIRED</code> в JDBC</h5><div class="codesection"><pre class="displaycode">@Transactional(readOnly = true, propagation=Propagation.REQUIRED)
public long insertTrade(TradeData trade) throws Exception {
   //Работа через JDBC...
}</pre></div><p>Как вы думаете, что из следующего произойдет при выполнении метода <code>insertTrade()</code>, приведенного в листинге 6:</p><ul class="ibm-bullet-list" type="A"><li>Метод выбросит исключение, поскольку подключение разрешает только операции чтения.</li><li>Метод корректно вставит торговый приказ и подтвердит сохранение данных. </li><li>Ничего не произойдет, поскольку выставлен флаг "только чтение".</li></ul><p>На этот вопрос несложно ответить, принимая во внимание объяснение предыдущей ситуации. Правильным ответом является "А". Метод выбросит исключение, говорящее о том, что производится попытка изменения данных через соединение, разрешающее только операции чтения. В данном случае начинается новая транзакция (из-за режима распространения <code>REQUIRED</code>), поэтому соединение помечается как "только для чтения". Таким образом, при попытке выполнить оператор SQL вы получите исключение, указывающее на это. </p><p>Странной особенностью флага "только чтение" является то, что он вступает в силу только с началом новой транзакции. Зачем надо начинать транзакцию, если речь идет только о чтении данных? Разумеется, этого делать не нужно. Начало транзакции при выполнении операции чтения всего лишь добавит лишних накладных расходов в обрабатывающий поток, а также может привести к появлению разделяемых блокировок чтения в базе данных (это зависит от типа используемой базы данных и уровня изоляции). Таким образом, флаг "только чтение" оказывается несколько бессмысленным при работе через JDBC и приводит к увеличению накладных расходов из-за выполнения необязательной транзакции.</p><p>А что будет происходить при использовании ORM-инфраструктуры? Попробуйте угадать результат работы аннотации <code>@Transactional</code> в случае, если метод <code>insertTrade()</code> вызывался при использовании  Hibernate и JPA (листинг 7).</p><h5 id="listing7">Листинг 7. Пример использования флага "только чтение" и режима распространения <code>REQUIRED</code> в JPA</h5><div class="codesection"><pre class="displaycode">@Transactional(readOnly = true, propagation=Propagation.REQUIRED)
public long insertTrade(TradeData trade) throws Exception {
   em.persist(trade);
   return trade.getTradeId();
}</pre></div><p>Выберите правильный вариант того, что произойдет при вызове метода <code>insertTrade()</code> из листинга 7.</p><ul class="ibm-bullet-list" type="A"><li>Метод выбросит исключение, поскольку подключение разрешает только операции чтения. </li><li>Метод корректно вставит торговый приказ и подтвердит сохранение данных.</li><li>Ничего не произойдет, поскольку выставлен флаг <code>readOnly</code> (только чтение).</li></ul><p>Ответ на этот вопрос не так прост. В некоторых ситуациях ответом будет "С", однако в большинстве случаев (в частности, при использовании JPA) – "В". Торговый приказ благополучно добавляется в базу данных без всяких ошибок. Секундочку, ведь предыдущий пример ясно продемонстрировал, что при использовании режима распространения <code>REQUIRED</code> будет выброшено исключение. Это так при работе через JDBC, однако при использовании инфраструктуры ORM флаг "только чтение" работает несколько по-другому. В момент вставки записи инфраструктура будет сначала обращаться к базе данных для генерации ключевого значения. В некоторых ORM режим сброса данных (flush) будет равен <code>MANUAL</code>, поэтому, если ключ не сгенерирован, то вставка выполнена не будет. То же самое справедливо для изменения данных. Однако другие ORM, в частности TopLink, всегда выполняют вставку и изменение данных при установленном флаге "только чтение". Несмотря на то, что это поведение определяется конкретной инфраструктурой ORM и ее версией, необходимо помнить, что нет гарантии, что операции вставки или изменения данных не будут выполнены при установленном флаге "только чтение", особенно при использовании JPA, поскольку ее поведение не зависит от компании-разработчика.</p><p>Итак, мы подходим к еще одной ошибке, которую мне часто приходится наблюдать. Приняв во внимание все, что было рассказано выше, как вы думаете, что произойдет при выполнении кода в листинге 8, где единственным атрибутом аннотации <code>@Transactional</code> является флаг "только чтение"?</p><h5 id="listing8">Листинг 8. Пример использования флага "только чтение" в JPA </h5><div class="codesection"><pre class="displaycode">@Transactional(readOnly = true)
public TradeData getTrade(long tradeId) throws Exception {
   return em.find(TradeData.class, tradeId);
}</pre></div><p>Что из следующего произойдет при выполнении метода <code>getTrade()</code>, приведенного в листинге 8.</p><ul class="ibm-bullet-list" type="A"><li>Транзакция начнется, будет выбран торговый приказ, затем транзакция будет подтверждена.</li><li>Торговый приказ будет получен без старта новой транзакции.</li></ul><div class="dw-sidebar ibm-inset"><h2 id="never">Никогда не говори "никогда"</h2><p>В некоторых случаях может понадобиться начать транзакцию при выполнении операции чтения данных из базы, например в целях изоляции операций чтения для обеспечения согласованности, либо для задания нужного уровня изоляции для конкретной операции выборки данных. Однако в бизнес-приложениях эти ситуации встречаются достаточно редко, и, за их исключением, не следует начинать транзакции при выборке данных из базы, поскольку они не являются необходимыми и могут приводить к взаимным блокировкам, снижению производительности и пропускной способности.</p></div><p>Правильным ответом является "А": транзакция будет начата и подтверждена. Не забывайте, что режимом распространения по умолчанию для аннотации <code>@Transactional</code> является <code>REQUIRED</code>. Это означает, что транзакция будет начата даже в том случае, когда это не необходимо (см. заметку <a href="#never">Никогда не говори "никогда"</a>). В зависимости от используемой базы данных, это может приводить к необязательным разделяемым блокировкам, которые могут повлечь за собой взаимные блокировки. Кроме того, начало и завершение транзакции приводят к увеличению продолжительности обработки и повышенному расходованию ресурсов. Итак, можно сделать следующий вывод: при использовании ORM флаг "только чтение", как правило, бесполезен, и в большинстве случаев игнорируется. Однако если вы все же хотите его использовать, то обязательно установите режим распространения <code>SUPPORTS</code>, чтобы избежать запуска транзакций (листинг 9).</p><h5 id="listing9">Листинг 9. Пример использования флага "только чтение" и режима распространения <code>SUPPORTS</code> при выборке данных</h5><div class="codesection"><pre class="displaycode">@Transactional(readOnly = true, propagation=Propagation.SUPPORTS)
public TradeData getTrade(long tradeId) throws Exception {
   return em.find(TradeData.class, tradeId);
}</pre></div><p>Еще лучше вообще не использовать аннотацию <code>@Transactional</code> при чтении данных из базы (листинг 10).</p><h5 id="listing10">Листинг 10. Выборка данных без аннотации <code>@Transactional</code></h5><div class="codesection"><pre class="displaycode">public TradeData getTrade(long tradeId) throws Exception {
   return em.find(TradeData.class, tradeId);
}</pre></div><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N101F2">Ошибки, связанные с атрибутом транзакций <code>REQUIRES_NEW </code></h2><p>При работе со Spring Framework или EJB использование атрибута транзакций <code>REQUIRES_NEW</code> может привести к негативным результатам, в частности, к искажению данных или потере согласованности. Этот атрибут всегда запускает новую транзакцию при начале выполнения метода вне зависимости от того, существует ли ранее начатая транзакция. Многие разработчики некорректно используют атрибут <code>REQUIRES_NEW</code>, предполагая, что это правильный способ гарантии запуска транзакции. Рассмотрим два метода, показанные в листинге 11.</p><h5 id="listing11">Листинг 11. Пример использования атрибута <code>REQUIRES_NEW</code></h5><div class="codesection"><pre class="displaycode">@Transactional(propagation=Propagation.REQUIRES_NEW)
public long insertTrade(TradeData trade) throws Exception {...}

@Transactional(propagation=Propagation.REQUIRES_NEW)
public void updateAcct(TradeData trade) throws Exception {...}</pre></div><p>Заметьте, что оба метода в листинге 11 являются открытыми, а это, в частности, означает, что они могут быть вызваны независимо друг от друга. Проблемы, связанные с атрибутом <code>REQUIRES_NEW</code>, возникают в случае, если методы вызываются внутри одной логической единицы работы (LUW) путем межсервисного или программного взаимодействия. Например, допустим, что метод <code>updateAcct()</code> в листинге 11 может вызываться независимо от других методов, однако в некоторых случаях он может быть вызван внутри метода <code>insertTrade()</code>. Если при этом будет выброшено исключение после вызова <code>updateAcct()</code>, то добавление торгового приказа будет отменено, но изменения баланса счета будут сохранены в базу данных (листинг 12).</p><h5 id="listing12">Листинг 12. Несколько операций изменения данных при использовании атрибута <code>REQUIRES_NEW</code></h5><div class="codesection"><pre class="displaycode">@Transactional(propagation=Propagation.REQUIRES_NEW)
public long insertTrade(TradeData trade) throws Exception {
   em.persist(trade);
   updateAcct(trade);
   //В этом месте возникает исключение.
   //Добавление приказа отменяется, а изменение баланса - нет.
   ...
}</pre></div><p>Это происходит потому, что новая транзакция начинается внутри метода <code>updateAcct()</code> и, следовательно, она подтверждается после его благополучного завершения. Использование атрибута транзакции <code>REQUIRES_NEW</code> означает, что выполнение существующей транзакции (если таковая есть) прерывается, и начинается новая транзакция. После завершения метода новая транзакция подтверждается, а старая – возобновляется. </p><p>Вследствие такого поведения атрибут <code>REQUIRES_NEW</code> должен использоваться только в случае, если операция с базой данных должна быть подтверждена вне зависимости от результатов внешней транзакции. Например, допустим, что каждый торговый приказ должен быть отражен в базе данных аудита. Эта информация должна быть сохранена вне зависимости от того, был ли приказ успешен или завершился неудачей ввиду ошибок валидации, отсутствия необходимых средств или по любой другой причине. Если в этой ситуации не использовать атрибут <code>REQUIRES_NEW</code> для метода аудита, то сохранение аудиторской информации будет отменено вместе с сохранением самого приказа. Данный атрибут гарантирует, что информация для аудита будет сохранена в базе данных вне зависимости от успешности исходной транзакции. Таким образом, следует всегда использовать атрибуты  <code>MANDATORY</code> или <code>REQUIRED</code> вместо <code>REQUIRES_NEW</code>, кроме особых случаев, схожих с примером сохранения аудиторской информации.</p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N1023B">Ошибки, связанные с откатом транзакций</h2><p>Я приберег наиболее распространенную ошибку напоследок. К сожалению, мне приходится видеть ее в рабочем коде в более чем половине случаев. Мы сначала рассмотрим ситуацию с использованием Spring Framework, а затем перейдем к EJB 3.</p><p>До этого момента все примеры кода выглядели примерно как в листинге 13.</p><h5 id="listing13">Листинг 13. Выполнение операций без возможности отката</h5><div class="codesection"><pre class="displaycode">@Transactional(propagation=Propagation.REQUIRED)
public TradeData placeTrade(TradeData trade) throws Exception {
   try {
      insertTrade(trade);
      updateAcct(trade);
      return trade;
   } catch (Exception up) {
      //Запись ошибки в журнал
      throw up;
   }
}</pre></div><p>Допустим, что на счете недостаточно средств для покупки ценных бумаг, либо он не настроен должным образом для их покупки или продажи. В этом случае метод выбросит контролируемое исключение, например <code>FundsNotAvailableException</code>. Сохранится ли в базе данных торговый приказ, или логическая единица работы будет полностью отменена? Как ни странно, но при выбросе контролируемого исключения в Spring Framework или EJB транзакция подтвердит все неподтвержденные к этому моменту изменения. Применительно к листингу 13 это означает, что при возникновении исключения в методе <code>updateAcct()</code> торговый приказ будет сохранен, но соответствующие изменения в балансе счета произведены не будут.</p><p>Это, возможно, главная угроза целостности и согласованности данных при работе с транзакциями. Исключения времени выполнения (или неконтролируемые исключения) автоматически приводят к откату всей логической единицы работы, а контролируемые исключения – нет. Таким образом, код в листинге 13 оказывается бессмысленным с точки зрения обработки транзакций. Может показаться, что транзакции используются для обеспечения атомарности и согласованности, но это лишь видимость.</p><p>Подобное поведение транзакций может показаться странным, однако у него есть убедительное обоснование. Во-первых, не все контролируемые исключения являются ошибками, они также могут использоваться для отправки уведомлений или передачи управления по заданному условию. Однако основной причиной является то, что прикладной код может сам обрабатывать некоторые типы контролируемых исключений, после чего транзакция должна быть подтверждена. Например, рассмотрим следующий сценарий: вы пишете приложение для книжного Интернет-магазина. Для завершения заказа приложение должно отправить клиенту подтверждение по электронной почте. Если сервер e-mail неработоспособен, то будет выброшено контролируемое исключение SMTP, сигнализирующее о невозможности отправки сообщения. Если бы контролируемые исключения автоматически приводили к откату транзакций, то весь заказ на покупку книг был бы отменен только потому, что сервер не смог отправить почту. Если же транзакции не откатываются, то вы сами можете перехватить такое исключение и обработать его нужным образом (например, поместить сообщение в очередь на отправку), после чего подтвердить остальные изменения, касающиеся заказа. </p><p>Если вы используете декларативную модель транзакций (она более подробно описывается во второй статье этой серии), то необходимо указать, как именно контейнер или инфраструктура должны обрабатывать контролируемые исключения. В Spring Framework это делается при помощи параметра <code>rollbackFor</code> в аннотации <code>@Transactional</code> (листинг 14).</p><h5 id="listing14">Листинг 14. Добавление возможности отката транзакции при работе с Spring</h5><div class="codesection"><pre class="displaycode">@Transactional(propagation=Propagation.REQUIRED, rollbackFor=Exception.class)
public TradeData placeTrade(TradeData trade) throws Exception {
   try {
      insertTrade(trade);
      updateAcct(trade);
      return trade;
   } catch (Exception up) {
      //Запись ошибки в журнал
      throw up;
   }
}</pre></div><p>Обратите внимание на использование параметра <code>rollbackFor</code> в аннотации <code>@Transactional</code>. Значением этого параметра может быть либо класс исключения, либо массив подобных классов. Кроме того, можно использовать параметр  <code>rollbackForClassName</code> для задания имен исключений в строковом виде. Существует также обратный параметр <code>noRollbackFor</code> для указания того, что любое исключение, кроме заданных, должно приводить к откату транзакции. Как правило, большинство разработчиков указывают в качестве значения <code>Exception.class</code>, что означает, что все исключения, выбрасываемые данным методом, должны приводить к откату транзакции.</p><p>В том, что касается отката транзакций, поведение EJB несколько отличается от Spring Framework. Атрибут <code>@TransactionAttribute</code>, описанный в спецификации EJB 3.0, не предоставляет директив для управления откатом транзакции. Вместо этого вы должны использовать метод <code>SessionContext.setRollbackOnly()</code> для того, чтобы пометить транзакцию как подлежащую откату (листинг 15).</p><h5 id="listing15">Листинг 15. Добавление возможности отката транзакций при работе с EJB</h5><div class="codesection"><pre class="displaycode">@TransactionAttribute(TransactionAttributeType.REQUIRED)
public TradeData placeTrade(TradeData trade) throws Exception {
   try {
      insertTrade(trade);
      updateAcct(trade);
      return trade;
   } catch (Exception up) {
      //Запись ошибки в журнал
      sessionCtx.setRollbackOnly();
      throw up;
   }
}</pre></div><p>После вызова метода <code>setRollbackOnly()</code> уже ничего изменить нельзя: откат неминуемо произойдет после завершения выполнения метода, который начал транзакцию. В следующих статьях будут описаны стратегии обработки транзакций, которые помогут вам решить, когда и где использовать директивы отката, а также в каких случаях следует использовать атрибуты транзакции <code>REQUIRED</code> и <code>MANDATORY</code>.</p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10291">Заключение</h2><p>Код, который приходится писать для выполнения транзакций в Java, не представляет особых сложностей, но при этом бывает непросто решить, как его использовать и конфигурировать. Вследствие этого с реализацией поддержки транзакционности в приложениях Java связано множество распространенных ошибок (в том числе некоторые реже встречающиеся проблемы, которые не вошли в эту статью). Главной проблемой является то, что о некорректной работе транзакций в вашем приложении вы не узнаете ни от ошибок компилятора, ни от аварийного завершения программы на этапе выполнения. Более того, реализация поддержки транзакций не ограничивается лишь написанием кода, как это предполагалось в истории, описанной в заметке "<a href="#anecdote">Лучше поздно, чем никогда</a>". Это также требует существенных усилий на этапе проектирования приложения. Остальные статьи серии "Стратегии работы с транзакциями" помогут вам в проектировании эффективных стратегий работы с транзакциями при решении различных задач – от создания простых приложений до реализации высокопроизводительных транзакционных систем.</p><!--CMA ID: 676754--><!--Site ID: 40--><!--XSLT stylesheet used to transform this file:
        dw-document-html-7.0.xsl-->


</div>
</div>
</body>
</html>