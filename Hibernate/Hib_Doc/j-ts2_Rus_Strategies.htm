<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>j-ts2_Rus</title>
    <link rel="stylesheet" href="grey.css">
</head>
<body>
<a href="http://www.ibm.com/developerworks/ru/library/j-ts2/">src_rus</a>
<h3>Стратегии работы с транзакциями: Oбзор моделей транзакций и стратегий их использования</h3>
<div class="ibm-col-1-1">
<p>Очень часто разработчики, проектировщики и архитекторы путают понятия <em>модели транзакций</em> и <em>стратегии использования транзакций</em>. Как правило, я прошу архитектора или технического руководителя клиентской компании описать стратегию использования транзакций в их проекте. При этом обычно в ответ получаю один из трех вариантов: либо тихое признание, что транзакции не используются вовсе, либо смущенный ответ в стиле "я не уверен, что понял Ваш вопрос", либо, что встречается гораздо чаще, – третий вариант – уверенный ответ, что используются декларативные транзакции. Однако, как будет объяснено ниже, термин <em>декларативные транзакции</em> означает <em>модель транзакций</em>, а не <em>стратегию использования</em>.</p>
<div class="dw-sidebar ibm-inset"><h2 id="N10064">Об этой серии</h2><p>Транзакции позволяют повысить качество, целостность и согласованность данных, а также надежность приложения в целом. При этом реализация успешной схемы выполнения транзакций в приложениях Java представляет собой нетривиальную задачу, основная сложность которой заключается в проектировании, а не в написании кода. В этой новой серии Марк Ричардс предлагает свое руководство по дизайну эффективной стратегии управления транзакциями при решении различных задач – от создания простых приложений до реализации высокопроизводительных транзакционных систем.</p></div>
<hr>
<p>Платформой Java поддерживаются следующие модели транзакций:</p>
<ol>
<li>локальная модель; (Local Transaction model)</li>
<li>программная модель; (Programmatic Transaction model)</li>
<li>декларативная модель. (Declarative Transaction model)</li>
</ol>
<p>Эти модели задают:
<br>1) основные принципы поведения транзакций. 
<br>2) как транзакции должны реализовываться.
<br><br>
 При этом модели описывают только правила и семантику обработки транзакций, оставляя вопросы применения модели на усмотрение разработчика. </p>
<p>Эти модели задают основные принципы поведения транзакций на платформе Java и то, как они должны реализовываться. При этом модели описывают только правила и семантику обработки транзакций, оставляя вопросы применения модели на усмотрение разработчика. Вам придется самостоятельно решать следующие вопросы: в каких случаях нужно использовать атрибут <code>REQUIRED</code>, а в каких <code>MANDATORY</code>? Когда следует задавать директивы отката транзакций? Как сделать выбор между программной и декларативной моделями транзакций? Как оптимизировать транзакции для высокопроизводительных систем? Модели транзакций сами по себе не дают ответов на эти вопросы. Для этого вам следует либо разработать собственную стратегию использования транзакций, либо принять на вооружение одну из четырех основных стратегий, которые будут рассмотрены ниже.</p>
<h3>3 модели транзакций и 4 стратегии использования транзакций.</h3>
<p>В <a href="http://www.ibm.com/developerworks/java/library/j-ts1.html">первой статье</a> серии было продемонстрировано, что множество распространенных ошибок при использовании транзакций могут влиять на их поведение и, как следствие, ставить под угрозу целостность и согласованность ваших данных. Аналогичным образом, негативный эффект может произвести отсутствие эффективной (или любой) стратегии использования транзакций. Транзакционные модели, рассматриваемые в этой статье, играют роль строительного материала при разработке эффективной стратегии. Понимание этих моделей и различий между ними имеет колоссальное значение для понимания стратегий, которые их используют. После описания трех моделей мы перейдем к стратегиям использования, которые могут применяться практически во всех бизнес-приложениях, начиная от простых Web-приложений до крупных высокопроизводительных систем обработки транзакций. Более подробно эти стратегии будут рассмотрены в будущих статьях серии <a href="http://www.ibm.com/developerworks/ru/views/java/libraryview.jsp?search_by=транзакциями+Стратегии:">Стратегии работы с транзакциями</a>.</p>
<h2 id="N10088">_1_ Локальная модель транзакций</h2>
<p>Локальная модель транзакций получила свое имя из-за того, что управление всеми транзакциями осуществляется менеджером ресурсов базы данных, а не контейнером или инфраструктурой, в которой выполняется ваше приложение. В этой модели вы сами управляете только <em>соединениями</em>, но не <em>транзакциями</em>. Как говорилось в статье <a href="http://www.ibm.com/developerworks/ru/library/j-ts1.html">Распространенные ошибки</a>, вы не можете использовать локальную модель при выполнении изменений в базе данных через инфраструктуру объектно-реляционного отображения, например Hibernate, TopLink или Java Persistence API (JPA). Тем не менее вы можете применять эту модель при использовании объектов доступа к данным, инфраструктур JDBC и хранимых процедур.</p>
<p>You can still apply it when using data-access object (DAO) or JDBC-based frameworks and database stored procedures.</p>
<p>Локальная транзакционная модель может использоваться двумя способами: 
<ol>
   <li>либо путем программного управления соединениями, </li>
   <li>либо оставив это на усмотрение базы данных.</li>
</ol>
Во втором случае необходимо установить свойство <code>autoCommit</code> JDBC-объекта <code>Connection</code> в <code>true</code> (это значение используется по умолчанию). Таким образом вы указываете системе управления базой данных (СУБД), что необходимо подтверждать транзакцию после выполнения каждой операции вставки, изменения или удаления записи, либо откатывать ее в случае ошибки. Этот подход иллюстрируется в листинге 1, в котором приводится фрагмент кода для вставки торгового приказа в таблицу <code>TRADE</code>.</p><h5 id="listing1">Листинг 1. Пример использования локальных транзакций при выполнении одной операции изменения данных</h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl {
   public void processTrade(TradeData trade) throws Exception {
      Connection dbConnection = null;
      try {
         DataSource ds = (DataSource)
              (new InitialContext()).lookup("jdbc/MasterDS");
         dbConnection = ds.getConnection();
         dbConnection.setAutoCommit(true);
	 Statement sql = dbConnection.createStatement();
	 String stmt = "insert into TRADE ...";
	 sql.executeUpdate(stmt1);
      } finally {
         if (dbConnection != null)
            dbConnection.close();
      }
   }
}</pre></div><p>Обратите внимание, что в листинге 1 свойство <code>autoCommit</code> устанавливается в значение <code>true</code>. Это является указанием СУБД, что локальная транзакция должна подтверждаться после выполнения каждого оператора БД. Этот подход работает отлично, если выполняется только одна операция в базе данных на каждую логическую единицу работы (LUW). Однако представьте, что метод <code>processTrade()</code>, показанный в листинге 1, также должен обновлять баланс счета в таблице <code>ACCT</code>, чтобы отразить сумму торгового приказа. В этом случае выполняются две независимые друг от друга операции, причем вставка записи в таблицу <code>TRADE</code> будет подтверждена до изменения записи в таблице <code>ACCT</code>. Если вторая операция завершится неудачно, то не будет возможности откатить результат первой, что приведет к рассогласованию данных.</p><p>В ответ на подобные ситуации был предложен второй подход – программное управление транзакциями. В этом случае свойство <code>autoCommit</code> объекта <code>Connection</code> должно равняться <code>false</code>, и вам придется самостоятельно подтверждать или откатывать транзакции. Пример приведен в листинге 2.</p><h5 id="listing2">Листинг 2. Пример использования локальных транзакций при выполнении нескольких операций изменения данных</h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl {
   public void processTrade(TradeData trade) throws Exception {
      Connection dbConnection = null;
      try {
         DataSource ds = (DataSource)
             (new InitialContext()).lookup("jdbc/MasterDS");
         dbConnection = ds.getConnection();
         dbConnection.setAutoCommit(false);
	 Statement sql = dbConnection.createStatement();
	 String stmt1 = "insert into TRADE ...";
	 sql.executeUpdate(stmt1);
	 String stmt2 = "update ACCT set balance...";
	 sql.executeUpdate(stmt2);
	 dbConnection.commit();
      } catch (Exception up) {
         dbConnection.rollback();
         throw up;
      } finally {
         if (dbConnection != null)
            dbConnection.close();
      }
   }
}</pre></div><p>Обратите внимание, что в листинге 2 свойство <code>autoCommit</code> устанавливается в значение <code>false</code>, указывающее СУБД, что управление соединением будет осуществляться в коде, а не в базе данных. В этом случае необходимо вызывать метод <code>commit()</code> объекта <code>Connection</code> при успешном завершении операции. В случае же выброса исключения следует вызывать метод <code>rollback()</code>. Таким образом можно координировать выполнение двух операций внутри одной логической единицы работы.</p><p>Несмотря на то, что локальная модель транзакций может выглядеть несколько устаревшей на сегодняшний день, она остается важным элементом основных стратегий использования транзакций, о которых будет рассказано ниже.</p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p>
<h2 id="N100E7">_2_ Программная модель транзакций</h2>
<p>Программная модель транзакций обязана своим названием тому, что ответственность за управление транзакциями возлагается на разработчика. В отличие от локальной модели, в данном случае вы сами управляете <em>транзакциями</em>, которые оказываются изолированными от низкоуровневых <em>соединений</em> с базой данных.</p><p>При работе с этой моделью разработчик должен самостоятельно получить ссылку на транзакцию от менеджера транзакций, начать ее, затем подтвердить, а если возникло исключение – то откатить. Нетрудно себе представить, что подобный подход приводит к большому объему кода, в котором возможны ошибки, причем он смешивается с бизнес-логикой приложения. Тем не менее, некоторые стратегии использования транзакций подразумевают использование программной модели.</p><p>Несмотря на то, что в Spring Framework и EJB 3.0 под программной моделью транзакций подразумевается одно и то же, ее реализация оказывается различной. Мы сначала рассмотрим реализацию модели в EJB 3.0, а затем выполним те же операции обновления базы данных при помощи Spring.</p><h3 id="N100F8">Программные транзакции в EJB 3.0</h3><p>В EJB 3.0 вы должны запросить транзакцию у менеджера транзакций (другими словами, контейнера) через интерфейс JNDI (Java Naming and Directory Interface) по имени <code>javax.transaction.UserTransaction</code>. Получив ссылку на объект <code>UserTransaction</code>, вы можете вызвать метод <code>begin()</code> для начала новой транзакции, <code>commit()</code> – для подтверждения транзакции и <code>rollback()</code>- для отката транзакции в случае возникновения ошибки. При работе с этой моделью контейнер не будет автоматически подтверждать и откатывать транзакции, поэтому все действия по описанию поведения Java-метода, выполняющего изменения в базе данных, ложатся на плечи разработчика. Пример использования программной модели в EJB 3.0 и JPA приведен в листинге 3.</p><h5 id="listing3">Листинг 3. Пример работы с программными транзакциями в EJB 3.0</h5><div class="codesection"><pre class="displaycode">@Stateless
@TransactionManagement(TransactionManagementType.BEAN)
public class TradingServiceImpl implements TradingService {
   @PersistenceContext(unitName="trading") EntityManager em;
   public void processTrade(TradeData trade) throws Exception {
      InitialContext ctx = new InitialContext();
      UserTransaction txn = (UserTransaction)ctx.lookup("UserTransaction");
      try {
         txn.begin();
	 em.persist(trade);
	 AcctData acct = em.find(AcctData.class, trade.getAcctId());
	 double tradeValue = trade.getPrice() * trade.getShares();
	 double currentBalance = acct.getBalance();
	 if (trade.getAction().equals("BUY")) {
	    acct.setBalance(currentBalance - tradeValue);
         } else {
            acct.setBalance(currentBalance + tradeValue);
         }
         txn.commit();
      } catch (Exception up) {
         txn.rollback();
         throw up;
      }
   }
}</pre></div><p>При использовании программной модели транзакций внутри контейнера Java EE с компонентами сессии, не сохраняющими свое состояние, (Java EE container environment with a stateless session bean) необходимо указать контейнеру, что используются программные транзакции. Для этого следует использовать аннотацию <code>@TransactionManagement</code>, задав <code>BEAN</code> в качестве типа транзакции. Если данная аннотация не используется, то контейнер будет полагать, что применяется декларативное управление транзакциями (тип <code>CONTAINER</code>, являющийся типом транзакций по умолчанию для EJB 3.0). Задавать тип транзакции не обязательно, если вы работаете на клиентском уровне вне контекста компонента сессии, не сохраняющего состояние.</p>
<p>When you use programmatic transactions in the client layer outside of the context of a stateless session bean, you don't need to set the transaction type.</p>
<h3 id="N10120">Программные транзакции в Spring</h3><p>Spring Framework поддерживает два способа реализации программной модели транзакций. Можно использовать либо класс <code>TransactionTemplate</code>, либо напрямую работать с <em>менеджером транзакций платформы</em> в Spring. Поскольку я не являюсь горячим сторонником анонимных внутренних классов и плохо читаемого кода, то мы рассмотрим только второй подход для иллюстрации программной модели транзакций в Spring.</p><p>В Spring присутствует, по крайней мере, девять платформенных менеджеров транзакций. Из них наиболее часто используются <code>DataSourceTransactionManager</code>, <code>HibernateTransactionManager</code>, <code>JpaTransactionManager</code> и <code>JtaTransactionManager</code>. Поскольку в наших примерах используется JPA, то конфигурация будет показана для класса <code>JpaTransactionManager</code>.</p><p>Для конфигурирования менеджера <code>JpaTransactionManager</code> в Spring необходимо определить объект класса <code>org.springframework.orm.jpa.JpaTransactionManager</code> в XML-контексте приложения и добавить в него ссылку на фабрику менеджеров сущностей JPA (JPA Entity Manager Factory). Затем в случае, если объект, содержащий логику вашего приложения, также управляется Spring, следует добавить в него ссылку на менеджер транзакций. Пример приведен в листинге 4.</p><h5 id="listing4">Листинг 4. Описание менеджера транзакций JPA в Spring</h5><div class="codesection"><pre class="displaycode">&lt;bean id="transactionManager"
         class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
   &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;
&lt;bean id="tradingService" class="com.trading.service.TradingServiceImpl"&gt;
   &lt;property name="txnManager" ref="transactionManager"/&gt;
&lt;/bean&gt;</pre></div><p>Если же ваш прикладной класс не управляется Spring, то вы можете получить ссылку на менеджер транзакций, вызвав метод <code>getBean()</code> у класса, представляющего контекст Spring.</p><p>Теперь вы можете использовать платформенный менеджер для получения ссылки на транзакцию. После выполнения всех изменений можно вызвать метод <code>commit()</code> для ее подтверждения либо <code>rollback()</code> – для отката. Пример подобной работы приведен в листинге 5.</p><h5 id="listing5">Листинг 5. Пример использования менеджера транзакций JPA в Spring</h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl  {
   @PersistenceContext(unitName="trading") EntityManager em;
   JpaTransactionManager txnManager = null;
   public void setTxnManager(JpaTransactionManager mgr) {
      txnManager = mgr;
   }
   public void processTrade(TradeData trade) throws Exception {
      TransactionStatus status =
         txnManager.getTransaction(new DefaultTransactionDefinition());
      try {
         em.persist(trade);
	 AcctData acct = em.find(AcctData.class, trade.getAcctId());
	 double tradeValue = trade.getPrice() * trade.getShares();
	 double currentBalance = acct.getBalance();
	 if (trade.getAction().equals("BUY")) {
	    acct.setBalance(currentBalance - tradeValue);
	 } else {
	    acct.setBalance(currentBalance + tradeValue);
	 }
         txnManager.commit(status);
      } catch (Exception up) {
         txnManager.rollback(status);
         throw up;
      }
   }
}</pre></div><p>На примере, показанном в листинге 5, видно различие между Spring Framework и EJB 3.0. В Spring ссылка на транзакцию запрашивается путем вызова метода <code>getTransaction()</code> платформенного менеджера транзакций. После этого транзакция выполняется. Подробная информация о транзакции и ее поведении хранится в анонимном классе <code>DefaultTransactionDefinition</code>. Он содержит данные об имени транзакции, уровне изоляции, режиме распространения (он задается атрибутом транзакции) и значении тайм-аута, если таковой задан. В данном примере используются значения по умолчанию, т.е. именем транзакции является пустая строка, уровень изоляции определяется СУБД (как правило, это <code>READ_COMMITTED</code>), режимом распространения является <code>PROPAGATION_REQUIRED</code>, а тайм-аут также зависит от СУБД. Кроме того, обратите внимание, что методы <code>commit()</code> и <code>rollback()</code> вызываются у менеджера транзакций, а не у самой транзакции, как в случае EJB.</p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p>
<h2 id="N10175">__3__ Декларативная модель транзакций</h2>
<p>Наиболее часто применяемой моделью транзакций на платформе Java является декларативная модель, также известная как <em>модель транзакций, управляемых контейнером</em> (Container Managed Transactions – CMT). При работе с этой моделью контейнер самостоятельно начинает, подтверждает и откатывает транзакции. Задачей разработчика является только <u>описание поведения транзакций</u>. 
<br>
Большинство ошибок, рассмотренных в <a href="http://www.ibm.com/developerworks/java/library/j-ts1.html">первой статье</a> серии, связаны с использованием именно декларативной модели.</p><p>Для описания поведения транзакций в Spring Framework и EJB 3.0 используются аннотации. В Spring аннотация называется <code>@Transactional</code>, а в EJB 3.0 – <code>@TransactionAttribute</code>. 
<br>При использовании декларативной модели контейнер <b>не будет</b> автоматически <b>откатывать</b> транзакции при выбросе контролируемых(<b>checked</b>) исключений. <br>Разработчику следует указать, когда и в каких именно случаях выброс таких исключений должен приводить к откату транзакции. В Spring Framework это делается при помощи свойства <code>rollbackFor</code> аннотации <code>@Transactional</code>. В EJB для этого служит метод <code>setRollbackOnly()</code> класса <code>SessionContext</code>.</p><p>Пример использования декларативной модели транзакций в EJB приведен в листинге 6.</p><h5 id="listing6">Листинг 6. Пример использования декларативных транзакций в EJB 3.0</h5><div class="codesection"><pre class="displaycode">@Stateless
public class TradingServiceImpl implements TradingService {
   @PersistenceContext(unitName="trading") EntityManager em;
   @Resource SessionContext ctx;
   @TransactionAttribute(TransactionAttributeType.REQUIRED)
   public void processTrade(TradeData trade) throws Exception {
      try {
         em.persist(trade);
	 AcctData acct = em.find(AcctData.class, trade.getAcctId());
	 double tradeValue = trade.getPrice() * trade.getShares();
	 double currentBalance = acct.getBalance();
	 if (trade.getAction().equals("BUY")) {
	    acct.setBalance(currentBalance - tradeValue);
	 } else {
	    acct.setBalance(currentBalance + tradeValue);
	 }
      } catch (Exception up) {
         ctx.setRollbackOnly();
         throw up;
      }
   }
}</pre></div><p>В листинге 7 иллюстрируется работа с декларативной моделью транзакций в Spring Framework.</p><h5 id="listing7">Листинг 7.  Пример использования декларативных транзакций в Spring</h5><div class="codesection"><pre class="displaycode">public class TradingServiceImpl {
   @PersistenceContext(unitName="trading") EntityManager em;
   @Transactional(propagation=Propagation.REQUIRED,
                  rollbackFor=Exception.class)
   public void processTrade(TradeData trade) throws Exception {
      em.persist(trade);
      AcctData acct = em.find(AcctData.class, trade.getAcctId());
      double tradeValue = trade.getPrice() * trade.getShares();
      double currentBalance = acct.getBalance();
      if (trade.getAction().equals("BUY")) {
         acct.setBalance(currentBalance - tradeValue);
      } else {
         acct.setBalance(currentBalance + tradeValue);
      }
   }
}</pre></div><h3 id="N101A9">Атрибуты транзакций</h3><p>Кроме директив отката необходимо задать <em>атрибут транзакции</em>, который определяет ее поведение. Платформа Java поддерживает 6 атрибутов транзакций вне зависимости от того, используете вы Spring Framework или EJB 3.0:</p>
<ol><li><code>Required</code></li><li><code>Mandatory</code></li><li><code>RequiresNew</code></li><li><code>Supports</code></li><li><code>NotSupported</code></li><li><code>Never</code></li></ol>
<p>Для описания каждого из них будет использоваться вымышленный метод <code>methodA()</code>, к которому применяются атрибуты. </p>
<p>Если к методу <code>methodA()</code> применяется атрибут <code><b>Required</b></code> и метод вызывается в области видимости ранее начатой транзакции, то именно она будет использоваться при выполнении метода. В противном случае метод <code>methodA()</code> начнет новую транзакцию. Если метод запустил новую транзакцию, то она должна завершиться (т.е. быть подтверждена или отменена) самим методом. Это наиболее часто используемый атрибут, являющийся атрибутом по умолчанию в EJB 3.0 и Spring. К сожалению, во многих ситуациях он применяется некорректно, что приводит к проблемам с согласованностью и целостностью данных. Использование этого атрибута будет обсуждаться более подробно в следующих статьях серии, посвященных стратегиям работы с транзакциями.</p>
<br><hr>
<p>Если к методу <code>methodA()</code> применяется атрибут <code><b>Mandatory</b></code> и метод вызывается в области видимости ранее начатой транзакции, то она, как и ранее, будет использоваться при выполнении метода. Однако если метод вызывается вне контекста транзакции, то будет выброшено исключение типа <code>TransactionRequiredException</code>, сигнализирующее о том, что транзакция должна быть начата до вызова метода <code>methodA()</code>. Этот атрибут используется в стратегии <em>клиентского дирижирования</em>, рассматриваемой в следующем разделе статьи.</p>
<br><hr>
<p>Атрибут <code><b>RequiresNew</b></code> представляет особый интерес. Более чем в половине случаев мне приходится констатировать, что разработчики неверно понимают или используют этот атрибут. Если он применяется к методу <code>methodA()</code>, то новая транзакция начинается (и, соответственно, должна быть закончена в данном методе) всегда, вне зависимости от того, был ли вызван метод в контексте существующей транзакции или нет. Это означает, что если <code>methodA()</code> был вызван в контексте некой транзакции (назовем ее <code>Transaction1</code>), то она будет прервана, и будет начата новая транзакция (<code>Transaction2</code>). При завершении метода <code>methodA()</code> транзакция <code>Transaction2</code> либо подтверждается, либо откатывается, после чего возобновляется выполнение <code>Transaction1</code>. Такая схема работы <b>очевидным образом нарушает принцип ACID</b> (атомарность, согласованность, изолированность, стойкость), присущий транзакциям (особенно <em>атомарность</em>). 
<br><br>
Другими словами, <u>операции изменения данных в БД более не содержатся внутри одной единицы работы</u>. <br><br>
Если транзакцию <code>Transaction1</code> придется откатить, то результаты <code>Transaction2</code> все равно останутся подтвержденными. Если так, то зачем же нужен этот атрибут? Как объяснялось в первой статье, он должен использоваться только для операций, которые должны производиться вне зависимости от исхода первой транзакции (<code>Transaction1</code>), например, для ведения аудита или журналирования.</p>
<br><hr>
<p>Атрибут <b><code>Supports</code></b> является еще одним примером режима распространения, который большинство разработчиков либо не до конца понимают, либо не ценят. Если он применяется к методу <code>methodA()</code>, который вызывается в области видимости существующей транзакции, то метод будет выполнен внутри этой транзакции. Если же метод <code>methodA()</code> вызывается вне контекста транзакции, то транзакция не будет начата вовсе. Этот атрибут, как правило, используется для операций чтения данных из базы. Однако почему бы в этом случае не использовать атрибут <code>NotSupported</code> (описываемый в следующем абзаце)? Это будет означать, что метод будет выполняться вне контекста транзакции. Ответ достаточно прост.
<p><i>Supports:</i> Если выполнять запрос внутри транзакции, то данные будут читаться из лога транзакций базы данных, т.е. будут видны только что сделанные изменения. Если же запрос выполняется вне транзакции, то ему будут доступны только неизмененные данные.</p>
Допустим, что вы добавляете новый торговый приказ в таблицу <code>TRADE</code> и сразу за этим, не заканчивая транзакцию, запрашиваете полный список всех приказов. В этом случае еще не подтвержденный приказ попадет в результаты запроса. Если бы использовался атрибут <code>NotSupported</code>, то в результаты попали бы только записи из таблицы, а не из лога транзакций, поэтому неподтвержденный заказ был бы не виден. <br> Это далеко не всегда является нежелательным эффектом – все зависит от конкретной ситуации и бизнес-логики приложения. </p>
<br><hr>
<p>Атрибут <code><b>NotSupported</b></code> означает, что метод не должен выполняться внутри транзакции, ни новой, ни уже существующей. 
<br> <br>
Если этот атрибут указан для метода <code>methodA()</code>, вызванного в контексте транзакции, то она будет приостановлена до момента завершения метода. После выхода из метода выполнение транзакции будет возобновлено. Данный атрибут имеет смысл использовать в ограниченном числе случаев, причем, <u>как правило, они связаны с вызовом хранимых процедур</u>. Если хранимая процедура вызывается в контексте существующей транзакции, но при этом содержит строку <code>BEGIN TRANS</code>, или если базой данных является Sybase, работающая в несвязанном (unchained) режиме, то будет сгенерировано исключение, говорящее о том, что новая транзакция не может быть начата. Другими словами, вложенные транзакции не поддерживаются. Практически все контейнеры используют JTS (Java Transaction Service) в качестве реализации транзакций по умолчанию, и именно он (а не сама платформа Java) не поддерживает вложенные транзакции. Если у вас нет возможности изменить код хранимой процедуры, то можно использовать атрибут <code>NotSupported</code> для приостановки текущей транзакции, чтобы избежать исключения. 
<u>При этом теряется свойство атомарности изменений, поскольку операции с базой данных более не являются частью одной LUW</u>.
<br> 
Таким образом, использование этого атрибута имеет не только хорошие, но плохие стороны, но зато он может помочь вам быстро выбраться из сложной ситуации.</p>
<br><hr>
<p>Наибольший интерес, вероятно, представляет атрибут <code><b>Never</b></code>. Он ведет себя практически так же, как <code>NotSupported</code>, за одним важным исключением: если метод, отмеченный данным атрибутом, вызывается в контексте транзакции, то выбрасывается исключение, сигнализирующее о том, что в момент вызова этого метода транзакция недопустима.
<br><br>
Я смог придумать только одну ситуацию, при которой этот атрибут имеет смысл использовать: тестирование. Он позволяет легко и быстро проверить факт существования транзакции в момент вызова некоторого метода. Вызвав метод с атрибутом <code>Never</code> и получив в ответ исключение, вы можете быть точно уверены, что ранее была начата транзакция. В противном случае транзакции не существовало. Таким образом можно убедиться в надежной работе выбранной стратегии использования транзакций.</p><div class="ibm-alternate-rule">
<hr>
<h3>Summary of Transaction Attributes</h3>
<p>Table 44-1 summarizes the effects of the transaction attributes. Both the T1 and the T2 transactions are controlled by the container. A T1 transaction is associated with the client that calls a method in the enterprise bean. In most cases, the client is another enterprise bean. A T2 transaction is started by the container just before the method executes.</p>
<p>In the last column of Table 44-1, the word “None” means that the business method does not execute within a transaction controlled by the container. However, the database calls in such a business method might be controlled by the transaction manager of the database management system.</p>
<div>Table 44-1 Transaction Attributes and Scope</div>
<table class="cye-lm-tag"><colgroup><col width="29%"><col width="29%"><col width="41%"></colgroup><tbody class="cye-lm-tag"><tr class="cye-lm-tag"><th align="left" valign="top" scope="column" class="cye-lm-tag"><p class="cye-lm-tag">Transaction Attribute</p>
</th>
<th align="left" valign="top" scope="column"><p class="cye-lm-tag">Client’s Transaction</p>
</th>
<th align="left" valign="top" scope="column"><p class="cye-lm-tag">Business Method’s Transaction</p>
</th>
</tr>
<tr class="cye-lm-tag"><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Required</tt></p>
</td>
<td align="left" valign="top" scope="row" class="cye-lm-tag"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T2</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Required</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>RequiresNew</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T2</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>RequiresNew</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T2</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Mandatory</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">Error</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Mandatory</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>NotSupported</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>NotSupported</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Supports</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Supports</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Never</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">None</p>
</td>
</tr>
<tr><td align="left" valign="top" scope="row"><p class="cye-lm-tag"><tt>Never</tt></p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">T1</p>
</td>
<td align="left" valign="top" scope="row"><p class="cye-lm-tag">Error</p>
</td>
</tr>
</tbody></table>
<hr>
<h2 id="4">Стратегии использования транзакций</h2><p>Модели транзакций, описанные в этой статье, являются основой стратегий использования транзакций, которые будут рассмотрены ниже. Перед тем как формировать собственную стратегию, важно досконально понимать различия между моделями. Основными стратегиями использования транзакций, которые могут применяться в большинстве бизнес-приложений, являются следующие:</p>

<ol class="ibm-bullet-list"><li>стратегия клиентского дирижирования (client orchestration transaction strategy);</li><li>стратегия на основе интерфейсного слоя (API layer transaction strategy);</li><li>стратегия с высокой степенью параллелизма (High Concurrency transaction strategy);</li><li>высокопроизводительная стратегия (High-Speed Processing transaction strategy).</li></ol>

<p>Далее я кратко представлю каждую из стратегий, а более подробно они будут рассмотрены в последующих статьях серии.</p><p>Стратегия <em>клиентского дирижирования</em> применяется в ситуациях, когда несколько клиентских обращений к серверу или модели составляют одну единицу работы. В качестве клиента может выступать инфраструктура Web-приложений, приложение-портал, настольное приложение либо, в некоторых случаях, даже система автоматизации деловых процедур (workflow) или компонент для управления бизнес-процессами (BPM). По сути, именно клиент определяет последовательность действий, необходимых для каждого конкретного запроса. Например, для отправки торгового приказа может быть необходимо сохранить его в базе данных, а затем обновить состояние счета клиента, отразив в нем сумму сделки. Если приложение предоставляет слишком "мелкозернистый" интерфейс, то приходится вызывать оба метода по отдельности. В этом случае транзакция должна определяться на клиентской стороне, чтобы гарантировать атомарность обработки запроса.</p><p><em>Стратегия на основе интерфейсного слоя</em> применяется, когда приложение предоставляет меньшее количество методов, которые выступают в качестве основных точек доступа к серверной функциональности (при желании такие точки можно называть <em>сервисами</em>). При этом клиенты (в том числе клиенты Web-приложений и сервисов, клиенты систем обработки сообщений и даже настольные приложения) выполняют вызов только одного серверного метода для обработки запроса. Если применить эту стратегию к предыдущему примеру с отправкой торгового приказа, то следует создать один метод (назвав его, например, <code>processTrade()</code>), который будет вызываться клиентами. Он должен содержать всю логику сохранения приказа и обновления состояния счета. Своим названием стратегия обязана тому факту, что, как правило, клиентские приложения получают доступ к серверной функциональности через интерфейсы. Данная стратегия является одной из наиболее часто используемых в настоящее время.</p><p><em>Стратегия с высокой степенью параллелизма</em> является разновидностью описанной выше интерфейсной стратегии. Она используется в приложениях, поддерживающих долго выполняющиеся транзакции в интерфейсном слое (как правило, в целях повышения производительности или масштабируемости). Как следует из названия, эта стратегия, как правило, применяется в случаях, когда приложение должно параллельно обслуживать большое число клиентов. На платформе Java транзакции обходятся достаточно дорого. В зависимости от используемой базы данных, они могут приводить к блокировкам (в некоторых случаях даже взаимным блокировкам), захвату ресурсов и ухудшению пропускной способности приложения. Главной идеей, стоящей за этой стратегией, является сокращение контекста транзакций с целью минимизации блокировок, но при этом по-прежнему сохраняя свойство атомарности при обработке всех клиентских запросов. В некоторых случаях можно изменить логику приложения таким образом, чтобы применить данную стратегию использования транзакций.</p><p><em>Высокопроизводительная стратегия</em> является, вероятно, наиболее экстремальной из всех возможных стратегий. Она применяется в случаях, когда необходимо добиться максимальной скорости обработки запросов (и, как следствие, пропускной способности), но при этом в какой-то мере сохранить атомарность выполнения транзакций. Данная стратегия подразумевает некоторый риск для целостности и согласованности данных, однако при правильной реализации она является наиболее быстрой из всех стратегий, возможных на платформе Java. В то же время она оказывается наиболее сложной и неудобной в реализации из всех четырех стратегий, упоминавшихся в этой статье. </p><div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="6">Заключение</h2><p>Как видите, разработка эффективной стратегии использования транзакций далеко не всегда представляет собой тривиальную задачу. Обеспечение целостности и согласованности данных требует серьезного обдумывания различных вариантов работы, используемых моделей, инфраструктур, конфигураций и методов. За долгие годы работы с приложениями, использующими транзакции, я понял, что хотя общее количество комбинаций различных моделей, методов и вариантов конфигурирования огромно, на практике имеет смысл применять лишь относительно небольшое число из них. Четыре разработанных мною стратегии использования транзакций, которые будут подробно рассматриваться в следующих статьях, должны охватывать большинство случаев, с которыми можно столкнуться при создании бизнес-ориентированных приложений на платформе Java. При этом необходимо оговориться: ни одна из стратегий не является своего рода "серебряной пулей" – простым и единственно верным решением проблемы. В некоторых случаях для реализации той или иной стратегии требуется рефакторинг исходного кода или дизайна приложения. В подобной ситуации вы просто должны спросить себя: "Насколько важно поддерживать целостность и согласованность моих данных?". Как правило, риски и возможные потери, связанные с искажением данных, перевешивают затраты, необходимые на рефакторинг приложения.</p>
</div>
</body>
</html>