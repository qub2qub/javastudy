<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JS Scope Chains</title>
    <link rel="stylesheet" href="../Guides/grey.css">
    <style type="text/css">
</style>
</head>
<body>
<a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">src3</a>
	<h2>Объект переменных.</h2>
<div class="entry-content" itemprop="mainContentOfPage">
		<p class="cye-lm-tag">Read this article in: <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/">English</a>, Chinese (<a href="http://www.denisdeng.com/?p=878">version1</a>, <a href="http://www.cnblogs.com/justinw/archive/2010/04/23/1718733.html">version2</a>, <a href="http://goddyzhao.tumblr.com/post/11141710441/variable-object">version 3</a>), <a href="http://huns.me/?p=189" title="http://huns.me/?p=189">Korean</a>, <a href="http://www.bolm24.de/index.php?title=ECMA-262:Kapitel_2._Variablenobjekt" title="http://www.bolm24.de/index.php?title=ECMA-262:Kapitel_2._Variablenobjekt">German</a>.</p>
<div class="ds-toc"><ol><li><a href="#vvedenie" title="Введение">Введение</a></li><li><a href="#obyyavlenie-dannyih" title="Объявление данных">Объявление данных</a></li><li><a href="#konkretizatsiya-obyekta-peremennyih" title="Конкретизация объекта переменных">Конкретизация объекта переменных</a><ol><li><a href="#obyekt-peremennyih-v-globalnom-kontekste" title="Объект переменных в глобальном контексте">Объект переменных в глобальном контексте</a></li><li><a href="#obyekt-peremennyih-v-kontekste-funktsii" title="Объект переменных в контексте функции">Объект переменных в контексте функции</a></li></ol></li><li><a href="#detalizatsiya-obrabotki-koda-konteksta" title="Детализация обработки кода контекста">Детализация обработки кода контекста</a><ol><li><a href="#vhod-v-kontekst-ispolneniya" title="Вход в контекст исполнения">Вход в контекст исполнения</a></li><li><a href="#interpretatsiya-koda" title="Интерпретация кода">Интерпретация кода</a></li></ol></li><li><a href="#o-peremennyih" title="О переменных">О переменных</a></li><li><a href="#osobennost-realizatsiy-svoystvo-__parent__" title="Особенность реализаций: свойство __parent__">Особенность реализаций: свойство __parent__</a></li><li><a href="#zaklyuchenie" title="Заключение">Заключение</a></li><li><a href="#dopolnitelnaya-literatura" title="Дополнительная литература">Дополнительная литература</a></li></ol></div><p class="cye-lm-tag"></p>
<h2 id="vvedenie" class="header-link"><a href="#vvedenie">Введение</a></h2>
<p class="cye-lm-tag">Постоянно в программах мы описываем функции и переменные, которые затем благополучно используем (вызываем, обращаемся) при построении наших систем. Однако, как и где интерпретатор находит наши <em>данные</em> (функции, переменные)? Что происходит, когда мы обращаемся к нужным нам объектам?<br>
<span id="more-16" class="cye-lm-tag"></span></p>
<p class="cye-lm-tag">Многие знают, что переменные тесно связаны со своим <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-1-execution-contexts/">контекстом исполнения</a>:</p>
<div><div id="highlighter_42859" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10; </code><code class="jscript comments">// переменная глобального контекста</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">b = 20; </code><code class="jscript comments">// локальная переменная контекста функции</code></div><div class="line number5 index4 alt2"><code class="jscript plain">})();</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// 10</code></div><div class="line number8 index7 alt1"><code class="jscript plain">alert(b); </code><code class="jscript comments">// b is not defined</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Также, многим известно, что обособленную <em>область видимости</em> в текущей спецификации, создают лишь контексты исполнения типа “Функция”. Т.е., в отличии от C/C++, к примеру, цикл <code>for</code> в ECMAScript не создаёт локальный контекст:</p>
<div><div id="highlighter_933349" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">for</code> <code class="jscript plain">(</code><code class="jscript keyword">var</code> <code class="jscript plain">k </code><code class="jscript keyword">in</code> <code class="jscript plain">{a: 1, b: 2}) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(k);</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">alert(k); </code><code class="jscript comments">// переменная "k" осталась жить и после цикла</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Посмотрим более детально, что происходит, когда мы объявляем наши данные.</p>
<h2 id="obyyavlenie-dannyih" class="header-link"><a href="#obyyavlenie-dannyih">Объявление данных</a></h2>
<p class="cye-lm-tag">Итак, коль скоро, переменные связаны с контекстом, последний должен знать, где хранятся его данные и как их получить. Данный механизм называется <em>Объектом переменных</em>.</p>
<div class="definition"><em>Объект переменных (Variable object, сокращённо VO)</em> – это связанный с контекстом исполнения объект, служащий хранилищем для:<br clear="all"><br clear="all"><p class="cye-lm-tag"></p>
<ul>
<li>переменных (var);</li>
<li>деклараций функций (FunctionDeclaration, сокращённо FD);</li>
<li>и формальных параметров функции,</li>
</ul>
<p class="cye-lm-tag">объявленных в данном контексте.</p></div>
<p class="note cye-lm-tag">Обратите внимание, в <abbr title="ECMA-262-5">ES5</abbr> концепция <em>объекта переменных (variable object)</em> заменена моделью <em>лексических окружений (lexical environments)</em>, подробное описание которых можно найти в <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" title="ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.">соответствующей главе</a>.</p>
<p class="cye-lm-tag">Схематично и для примеров, объект переменных можно представить в виде обычного JS-объекта:</p>
<div><div id="highlighter_809259" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO = {};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">И, как мы отметили, VO является свойством контекста исполнения:</p>
<div><div id="highlighter_181546" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">activeExecutionContext = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO: {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// данные контекста (var, FD, параметры функций)</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number5 index4 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Косвенное обращение к переменным (по именам свойств VO) позволяет лишь VO глобального контекста (где сам глобальный объект и является объектом переменных, но об этом чуть позже). Для остальных контекстов напрямую обратиться к VO невозможно; это чисто механизм реализации.</p>
<p class="cye-lm-tag">Когда мы объявляем переменную или декларируем функцию, происходит ничто иное, как создание свойства с именем и значением нашей переменной в VO контекста.</p>
<p class="cye-lm-tag">Пример:</p>
<div><div id="highlighter_915468" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">test(x) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">b = 20;</code></div><div class="line number5 index4 alt2"><code class="jscript plain">};</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">test(30);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Имеем:</p>
<div><div id="highlighter_475489" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript comments">// Объект переменных глобального контекста</code></div><div class="line number2 index1 alt1"><code class="jscript plain">VO(globalContext) = {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">a: 10,</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">test: &lt;ссылка на функцию&gt;</code></div><div class="line number5 index4 alt2"><code class="jscript plain">};</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript comments">// Объект переменных контекста функции test</code></div><div class="line number8 index7 alt1"><code class="jscript plain">VO(test functionContext) = {</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">x: 30,</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">b: 20</code></div><div class="line number11 index10 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Но, и на уровне реализации (да и спецификации) объект переменных является абстрактной сущностью. Физически же, в конкретных контекстах исполнения, VO называется по-разному и имеет разную инициализирующую структуру.</p>
<h2 id="konkretizatsiya-obyekta-peremennyih" class="header-link"><a href="#konkretizatsiya-obyekta-peremennyih">Конкретизация объекта переменных</a></h2>
<p class="cye-lm-tag">Некоторое базовые операции (например, <em>создание переменных — variable instantiation</em>) и поведение объекта переменных являются общими для всех контекстов исполнения. Контекст функции может также определять дополнительные сущности, связанные с VO.</p>
<div><div id="highlighter_97054" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">AbstractVO (общее поведение процесса создания переменных)</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">║</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">╠══&gt; GlobalContextVO</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">║&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VO === </code><code class="jscript keyword">this</code> <code class="jscript plain">=== global)</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">║</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">╚══&gt; FunctionContextVO</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">(VO === AO, добавлены: объект &lt;arguments&gt; и &lt;формальные параметры&gt;)</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Рассмотрим эти случаи подробней.</p>
<h3 id="obyekt-peremennyih-v-globalnom-kontekste" class="header-link"><a href="#obyekt-peremennyih-v-globalnom-kontekste">Объект переменных в глобальном контексте</a></h3>
<p class="cye-lm-tag">Здесь, для начала, нужно дать определение Глобального объекта.</p>
<p class="definition cye-lm-tag"><em>Глобальный объект (Global object)</em> — объект, который создаётся <em>до</em> входа в любой из контекстов исполнения. Данный объект существует в единственном экземпляре, свойства его доступны из любого места программы, жизненный цикл объекта завершается с завершением программы.</p>
<p class="cye-lm-tag">При создании, глобальный объект инициализируется такими свойствами, как <code>Math</code>, <code>String</code>, <code>Date</code>, <code>parseInt</code> и т.д., а также, дополнительными объектами, среди которых может быть и ссылка на сам глобальный объект — например, в <abbr title="Browser Object Model">BOM</abbr>, свойство <code>window</code> глобального объекта ссылается на сам глобальный объект (однако, не во всех реализациях):</p>
<div><div id="highlighter_116598" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">global = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">Math: &lt;...&gt;,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">String: &lt;...&gt;</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">...</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">...</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">window: global</code></div><div class="line number7 index6 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При обращении к свойствам глобального объекта префикс обычно не используется, поскольку сам глобальный объект не доступен напрямую по имени. Однако, получить доступ к нему можно посредством значения <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/#this-v-globalnom-kode">this в глобальном контексте</a>, а также через свойства-ссылки на самого себя, например <code>window</code> в <abbr title="Browser Object Model">BOM</abbr>, поэтому пишется просто:</p>
<div><div id="highlighter_941772" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">String(10); </code><code class="jscript comments">// подразумевается global.String(10);</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript comments">// с префиксами</code></div><div class="line number4 index3 alt1"><code class="jscript plain">window.a = 10; </code><code class="jscript comments">// === global.window.a = 10 === global.a = 10;</code></div><div class="line number5 index4 alt2"><code class="jscript keyword">this</code><code class="jscript plain">.b = 20; </code><code class="jscript comments">// global.b = 20;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Так вот, возвращаясь к объекту переменных глобального контекста. В глобальном контексте, объектом переменных является <em>сам глобальный объект</em>:</p>
<div><div id="highlighter_597007" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO(globalContext) === global;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Необходимо чётко осознавать этот факт, т.к. именно поэтому, объявляя переменную в глобальном контексте, мы имеем возможность косвенно обратиться к ней посредством свойства глобального объекта (например, когда имя переменной заранее неизвестно):</p>
<div><div id="highlighter_567853" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = </code><code class="jscript keyword">new</code> <code class="jscript plain">String(</code><code class="jscript string">'test'</code><code class="jscript plain">);</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// напрямую, будет найдено в VO(globalContext): "test"</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">alert(window[</code><code class="jscript string">'a'</code><code class="jscript plain">]); </code><code class="jscript comments">// косвенно через global === VO(globalContext): "test"</code></div><div class="line number6 index5 alt1"><code class="jscript plain">alert(a === </code><code class="jscript keyword">this</code><code class="jscript plain">.a); </code><code class="jscript comments">// true</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">aKey = </code><code class="jscript string">'a'</code><code class="jscript plain">;</code></div><div class="line number9 index8 alt2"><code class="jscript plain">alert(window[aKey]); </code><code class="jscript comments">// косвенно, имя свойства сформировано налету: "test"</code></div></div></td></tr></tbody></table></div></div>
<h3 id="obyekt-peremennyih-v-kontekste-funktsii" class="header-link"><a href="#obyekt-peremennyih-v-kontekste-funktsii">Объект переменных в контексте функции</a></h3>
<p class="cye-lm-tag">Касательно же контекста исполнения типа “Функция”, — здесь VO недоступен напрямую, и его функцию исполняет, так называемый, <em>Объект активации</em>.</p>
<div><div id="highlighter_731680" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO(functionContext) === AO;</code></div></div></td></tr></tbody></table></div></div>
<p class="definition cye-lm-tag"><em>Объект активации (Activation object, сокращённо AO)</em> — специальный объект, который создаётся при входе в контекст функции и инициализируется свойством <code>arguments</code> — <em>Объект аргументов</em> (<em>Arguments object</em>):</p>
<div><div id="highlighter_962239" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">AO = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">arguments: &lt;ArgO&gt;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag"><em>Объект аргументов (Arguments object, сокращённо ArgO)</em> – объект, находящийся в объекте активации контекста функции и содержащий следующие свойства:</p>
<ul>
<li><em>callee</em> – ссылка на выполняемую функцию;</li>
<li><em>length</em> – количество <em>реально переданных</em> параметров;</li>
<li><em>свойства-индексы</em> (числовые, приведённые к строке), значения которых – есть формальные параметры функции (слева направо в списке параметров). Количество этих свойств-индексов == arguments.length. Значения свойств-индексов объекта arguments и <em>присутствующие</em> формальные параметры – взаимозаменяемы:</li>
</ul>
<p class="cye-lm-tag">Пример:</p>
<div><div id="highlighter_92177" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo(x, y, z) {</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// количество описанных параметров функции (x, y, z)</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(foo.length); </code><code class="jscript comments">// 3</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// количество реально переданных параметров (только x, y)</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments.length); </code><code class="jscript comments">// 2</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// ссылка функции на саму себя</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments.callee === foo); </code><code class="jscript comments">// true</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// разделение параметров</code></div><div class="line number13 index12 alt2">&nbsp;</div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x === arguments[0]); </code><code class="jscript comments">// true</code></div><div class="line number15 index14 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number16 index15 alt1">&nbsp;</div><div class="line number17 index16 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">arguments[0] = 20;</code></div><div class="line number18 index17 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x); </code><code class="jscript comments">// 20</code></div><div class="line number19 index18 alt2">&nbsp;</div><div class="line number20 index19 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">x = 30;</code></div><div class="line number21 index20 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments[0]); </code><code class="jscript comments">// 30</code></div><div class="line number22 index21 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number23 index22 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// однако, для не переданного параметра z,</code></div><div class="line number24 index23 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// соответствующее свойство-индекс объекта</code></div><div class="line number25 index24 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// arguments - не взаимозаменяемое</code></div><div class="line number26 index25 alt1">&nbsp;</div><div class="line number27 index26 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">z = 40;</code></div><div class="line number28 index27 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments[2]); </code><code class="jscript comments">// undefined</code></div><div class="line number29 index28 alt2">&nbsp;</div><div class="line number30 index29 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">arguments[2] = 50;</code></div><div class="line number31 index30 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(z); </code><code class="jscript comments">// 40</code></div><div class="line number32 index31 alt1">&nbsp;</div><div class="line number33 index32 alt2"><code class="jscript plain">}</code></div><div class="line number34 index33 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number35 index34 alt2"><code class="jscript plain">foo(10, 20);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Относительно последнего случая, в старых версиях Google Chrome был <em>баг</em> — там параметр <code>z</code> и <code>arguments[2]</code> были также взаимозаменяемы.</p>
<p class="note cye-lm-tag">В <abbr title="ECMA-262-5">ES5</abbr> понятие <em>объекта активации (activation object)</em> также заменено единой моделью <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" title="ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.">лексических окружений (lexical environments)</a>.</p>
<h2 id="detalizatsiya-obrabotki-koda-konteksta" class="header-link"><a href="#detalizatsiya-obrabotki-koda-konteksta">Детализация обработки кода контекста</a></h2>
<p class="cye-lm-tag">Сейчас мы подошли к ключевому моменту, касающемуся данной заметки. Обработка кода контекста исполнения делится на два основных этапа:</p>
<ol>
<li>Вход в контекст исполнения;</li>
<li>Непосредственно, интерпретация кода.</li>
</ol>
<p class="cye-lm-tag">С этими двумя этапами тесно связана модификация объекта переменных.</p>
<p class="cye-lm-tag">Обратите внимание, что обработка этих двух стадий является <em>общей</em> для всех контекстов.</p>
<h3 id="vhod-v-kontekst-ispolneniya" class="header-link"><a href="#vhod-v-kontekst-ispolneniya">Вход в контекст исполнения</a></h3>
<p class="cye-lm-tag">При входе в контекст исполнения (но <em>до</em> построчного выполнения его кода), VO наполняется следующими свойствами (они уже были описаны в начале статьи):</p>
<ul>
<li>для каждого <em>формального параметра функции</em> (если мы находимся в контексте исполнения функции)</li>
<p class="cye-lm-tag"> – создаётся свойство VO с именем и значением формального параметра; для непереданных параметров – создаётся свойство VO с именем формального параметра и значением <em>undefined</em>;</p>
<li>для каждой <em>декларации функции (FunctionDeclaration, FD)</em></li>
<p class="cye-lm-tag"> – создаётся свойство VO, с именем функции и значением, являющимся ссылкой на объект-функцию; если в VO уже присутствовало свойство с таким именем, оно его значение и атрибуты заменяются значением функции;</p>
<li>для каждой <em>переменной (var)</em></li>
<p class="cye-lm-tag"> – создаётся свойство VO с именем переменной, и значением <em>undefined</em>; если в VO уже присутствовало свойство с таким именем, оно остаётся нетронутым.
</p></ul>
<p class="cye-lm-tag">Разберём на примере:</p>
<div><div id="highlighter_359473" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">test(a, b) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">c = 10;</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">d() {}</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">e = </code><code class="jscript keyword">function</code> <code class="jscript plain">_e() {};</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">x() {});</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">test(10); </code><code class="jscript comments">// вызов</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При <em>входе</em> в контекст функции “test” с переданным параметром 10, AO будет иметь следующий вид:</p>
<div><div id="highlighter_563371" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">AO(test) = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">a: 10,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">b: undefined,</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">c: undefined,</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">d: &lt;ссылка на FunctionDeclaration </code><code class="jscript string">"d"</code><code class="jscript plain">&gt;</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">e: undefined</code></div><div class="line number7 index6 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Обратите внимание, что в AO не попала функция “x”. Это потому, что “x” является не декларацией функции, а <em>функцией-выражением (FunctionExpression, сокращённо FE)</em>, которые <em>не воздействуют на VO</em>. Однако, функция “_e” также является функцией-выражением, но, как мы увидим ниже, за счёт присваивания ссылки на неё переменной “e”, она становится доступна посредством “e”. О разнице FunctionDeclaration от FunctionExpression можно почитать в <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/">соответствующей заметке</a>.</p>
<p class="cye-lm-tag">А далее наступает вторая фаза обработки кода — построчное выполнение.</p>
<h3 id="interpretatsiya-koda" class="header-link"><a href="#interpretatsiya-koda">Интерпретация кода</a></h3>
<p class="cye-lm-tag">К этому моменту, AO/VO уже наполнен свойствами (хотя, и не все из них ещё имеют истинные значения, описанные нами в коде, пока, большинство из них инициализировано значением <code>undefined</code>).</p>
<p class="cye-lm-tag">Рассматривая всё тот же пример, AO/VO, по мере интерпретации кода, модифицируется следующим образом:</p>
<div><div id="highlighter_131193" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">AO[</code><code class="jscript string">'c'</code><code class="jscript plain">] = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">AO[</code><code class="jscript string">'e'</code><code class="jscript plain">] = &lt;ссылка на FunctionExpression </code><code class="jscript string">"_e"</code><code class="jscript plain">&gt;;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Ещё раз отметим, что FunctionExpression <code>_e</code> осталась в памяти лишь за счёт переменной <code>e</code>. FunctionExpression <code>x</code> не попала в AO/VO: т.е., если в коде попытаться вызвать функцию <code>x</code> до или после объявления – будет ошибка <em>“<code>x</code> is not defined”</em>. Несохранённую FunctionExpression, можно вызвать лишь вместе с объявлением, либо рекурсивно.</p>
<p class="cye-lm-tag">Ещё (классический) пример:</p>
<div><div id="highlighter_207143" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// function</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">x = 20;</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">x() {}</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 20</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Почему в первом выводе “x” — функция, да ещё и доступна до объявления? Почему не 10 и не 20? Потому что, согласно правилу – VO наполняется декларациями функций <em>ещё при входе в контекст</em>, там же, при входе, встречается объявление переменной “x”, но переменные в VO имеют более низкий приоритет, нежели декларации функций, поэтому, при входе, заполнение VO произойдёт следующим образом:</p>
<div><div id="highlighter_118097" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO = {};</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">VO[</code><code class="jscript string">'x'</code><code class="jscript plain">] = &lt;ссылка на FunctionDeclaration </code><code class="jscript string">"x"</code><code class="jscript plain">&gt;</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript comments">// найдена var x = 10;</code></div><div class="line number6 index5 alt1"><code class="jscript comments">// если бы до этого не была объявлена функция</code></div><div class="line number7 index6 alt2"><code class="jscript comments">// с таким же именем, x стало бы undefined, в нашем же</code></div><div class="line number8 index7 alt1"><code class="jscript comments">// же случае переменная не затирает значение функции</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">VO[</code><code class="jscript string">'x'</code><code class="jscript plain">] = &lt;значение осталось прежним - функция&gt;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">А вот уже при выполнении кода, VO модифицируется так:</p>
<div><div id="highlighter_586635" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO[</code><code class="jscript string">'x'</code><code class="jscript plain">] = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">VO[</code><code class="jscript string">'x'</code><code class="jscript plain">] = 20;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">о чём явно свидетельствуют второй и третий выводы.</p>
<p class="cye-lm-tag">В примере ниже, мы снова видим, что переменные попадают в VO ещё при входе в контекст (так, блок else никогда не выполнится, но, тем не менее, переменная “b” существует в VO):</p>
<div><div id="highlighter_77810" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">if</code> <code class="jscript plain">(</code><code class="jscript keyword">true</code><code class="jscript plain">) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">a = 1;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">} </code><code class="jscript keyword">else</code> <code class="jscript plain">{</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">b = 2;</code></div><div class="line number5 index4 alt2"><code class="jscript plain">}</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// 1</code></div><div class="line number8 index7 alt1"><code class="jscript plain">alert(b); </code><code class="jscript comments">// undefined, но не "b is not defined"</code></div></div></td></tr></tbody></table></div></div>
<h2 id="o-peremennyih" class="header-link"><a href="#o-peremennyih">О переменных</a></h2>
<p class="cye-lm-tag">Часто, в различных статьях о JavaScript, можно видеть утверждения вроде: “глобальные переменные можно объявлять и с var (в глобальном контексте) и без var (в любом месте)”. Это не так. Запомните:</p>
<p class="cye-lm-tag"><em>переменные объявляются только с ключевым словом var</em>. </p>
<p class="cye-lm-tag">Присвоение же вроде:</p>
<div><div id="highlighter_204490" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">a = 10;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">лишь создаёт очередное <em>свойство</em> (но не переменную) в глобальном объекте. “Не переменную” не в том смысле, что её нельзя изменить, а “не переменную” в понятии переменных в ECMAScript (которые затем также станут свойствами глобально объекта посредством VO(globalContext) === global, помним, да?).</p>
<p class="cye-lm-tag">А разница следующая (покажем на примере):</p>
<div><div id="highlighter_830308" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// undefined</code></div><div class="line number2 index1 alt1"><code class="jscript plain">alert(b); </code><code class="jscript comments">// "b" is not defined</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">b = 10;</code></div><div class="line number5 index4 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 20;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Всё, опять же, вытекает из VO и стадий его модификации (вход в контекст, исполнение контекста):</p>
<p class="cye-lm-tag">Вход:</p>
<div><div id="highlighter_224143" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">VO = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">a: undefined</code></div><div class="line number3 index2 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Видим, что никакого “b” ещё нет, т.к. это не переменная, “b” появится лишь при исполнении кода (правда, в нашем случае не появится, т.к. будет ошибка). Изменим код:</p>
<div><div id="highlighter_210001" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// undefined, понятно почему</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">b = 10;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">alert(b); </code><code class="jscript comments">// 10, создалось при исполнении</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">a = 20;</code></div><div class="line number7 index6 alt2"><code class="jscript plain">alert(a); </code><code class="jscript comments">// 20, модифицировалось при исполнении</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Ещё один важный момент относительно переменных. Переменные, в отличии от простых свойств, получают атрибут <em>{DontDelete}</em>, означающий невозможность удалить свойство посредством оператора <em>delete</em>:</p>
<div><div id="highlighter_749953" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">a = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">alert(window.a); </code><code class="jscript comments">// 10</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">alert(</code><code class="jscript keyword">delete</code> <code class="jscript plain">a); </code><code class="jscript comments">// true</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">alert(window.a); </code><code class="jscript comments">// undefined</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">b = 20;</code></div><div class="line number9 index8 alt2"><code class="jscript plain">alert(window.b); </code><code class="jscript comments">// 20</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript plain">alert(</code><code class="jscript keyword">delete</code> <code class="jscript plain">b); </code><code class="jscript comments">// false</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript plain">alert(window.b); </code><code class="jscript comments">// по-прежнему, 20</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Но, есть один контекст исполнения, на который это правило не действует, это – контекст <em>eval</em>: здесь <em>{DontDelete} var-ам не выставляется</em>:</p>
<div><div id="highlighter_396619" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">eval(</code><code class="jscript string">'var a = 10;'</code><code class="jscript plain">);</code></div><div class="line number2 index1 alt1"><code class="jscript plain">alert(window.a); </code><code class="jscript comments">// 10</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">alert(</code><code class="jscript keyword">delete</code> <code class="jscript plain">a); </code><code class="jscript comments">// true</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">alert(window.a); </code><code class="jscript comments">// undefined</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Напоминание для тех, кто тестирует эти примеры в консоли отладчика (например, в <em>Firebug</em>): учитывайте, что <em>Firebug</em> также <em>использует eval</em> для запуска вашего кода. И поэтому там <em>var</em>-ы тоже не имеют <em>{DontDelete}</em>.</p>
<h2 id="osobennost-realizatsiy-svoystvo-__parent__" class="header-link"><a href="#osobennost-realizatsiy-svoystvo-__parent__">Особенность реализаций: свойство __parent__</a></h2>
<p class="cye-lm-tag">Как уже отмечалось, по стандарту, получить прямой доступ к объекту активации – невозможно. Однако, в некоторых реализациях, а именно в <em>SpiderMonkey</em> и <em>Rhino</em>, функциям доступно свойство <em>__parent__</em>, являющееся объектом активации (либо, объектом переменных), в котором данные функции были порождены.</p>
<p class="cye-lm-tag">Пример (SpiderMonkey, Rhino):</p>
<div><div id="highlighter_182367" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">global = </code><code class="jscript keyword">this</code><code class="jscript plain">;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">alert(foo.__parent__); </code><code class="jscript comments">// global</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">VO = foo.__parent__;</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">alert(VO.a); </code><code class="jscript comments">// 10</code></div><div class="line number11 index10 alt2"><code class="jscript plain">alert(VO === global); </code><code class="jscript comments">// true</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">В примере выше видно, что функция <em>foo</em> порождена в глобальном контексте, и, соответственно, её свойство <em>__parent__</em> указывает на объект переменных глобального контекста, т.е. на сам глобальный объект.</p>
<p class="cye-lm-tag">Однако, получить <em>объект активации</em> в SpiderMonkey таким образом уже не удастся: в зависимости от версии, <em>__parent__</em> для внутренней функции будет возвращать либо <em>null</em>, либо глобальный объект.</p>
<p class="cye-lm-tag">В Rhino же, доступ к объекту активации открыт и осуществляется аналогичным способом:</p>
<p class="cye-lm-tag">Пример (Rhino):</p>
<div><div id="highlighter_246056" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">global = </code><code class="jscript keyword">this</code><code class="jscript plain">;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// объект активации foo</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">AO = (</code><code class="jscript keyword">function</code> <code class="jscript plain">() {}).__parent__;</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(AO.y); </code><code class="jscript comments">// 20</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// __parent__ текущего объекта </code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// активации - уже глобальный объект,</code></div><div class="line number15 index14 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// т.е. образуется цепь объектов переменных</code></div><div class="line number16 index15 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(AO.__parent__ === global); </code><code class="jscript comments">// true</code></div><div class="line number17 index16 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number18 index17 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(AO.__parent__.x); </code><code class="jscript comments">// 10</code></div><div class="line number19 index18 alt2">&nbsp;</div><div class="line number20 index19 alt1"><code class="jscript plain">})();</code></div></div></td></tr></tbody></table></div></div>
<h2 id="zaklyuchenie" class="header-link"><a href="#zaklyuchenie">Заключение</a></h2>
<p class="cye-lm-tag">В этой статье мы ещё дальше продвинулись в изучении объектов, связанными с контекстами исполнения. Надеюсь, материал будет полезен, и прояснит некоторые аспекты и неясности, которые у вас, возможно, были. Далее по плану: цепь областей видимости (Scope chain), разрешение имён идентификаторов (Identifier resolution) и, как следствие, замыкания (Closures).</p>
<p class="cye-lm-tag">Если у вас возникнут вопросы, я, с удовольствием, отвечу на них в комментариях. </p>
<h2 id="dopolnitelnaya-literatura" class="header-link"><a href="#dopolnitelnaya-literatura">Дополнительная литература</a></h2>
<ul>
<li>10.1.3 – <a href="http://bclary.com/2004/11/07/#a-10.1.3" title="Инстанциация переменных">Инстанциация переменных</a>;</li>
<li>10.1.5 – <a href="http://bclary.com/2004/11/07/#a-10.1.5" title="Глобальный объект">Глобальный объект</a>;</li>
<li>10.1.6 – <a href="http://bclary.com/2004/11/07/#a-10.1.6" title="Объект активации">Объект активации</a>;</li>
<li>10.1.8 – <a href="http://bclary.com/2004/11/07/#a-10.1.8" title="Объект аргументов">Объект аргументов</a>.</li>
</ul>
<p align="right" class="cye-lm-tag"><em>Автор: Dmitry Soshnikov<br>
Дата публикации: 27.06.2009</em></p>
<p class="cye-lm-tag">
					</p></div>
	<br><hr>
<div id="comments" class="comments-area">
				
							<h2 class="comments-title">
					<i class="comments-title-icon"></i>
					32 Comments				</h2>
			
			
			<ol class="commentlist">
						<li class="comment even thread-even depth-1" id="li-comment-7212">
		<article id="comment-7212" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">отличное объясниение спасибо</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-11679">
		<article id="comment-11679" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Добрый день Дмитрий. Спасибо вам за эти замечательные статьи!</p>
<p class="cye-lm-tag">Я хотел бы предложить изменить DOM на BOM, посколько Document Object Model не определяет таких объектов как Window, Screen и др., но это только предложение.</p>
<p class="cye-lm-tag">Максим.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-11681">
		<article id="comment-11681" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>serega</b>, рад, что полезно.</p>
<p class="cye-lm-tag">@<b>maksimr</b></p>
<blockquote><p class="cye-lm-tag">изменить DOM на BOM, посколько Document Object Model не определяет таких объектов как Window, Screen и др.</p></blockquote>
<p class="cye-lm-tag">Да, хорошее замечание; исправил.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-11715">
		<article id="comment-11715" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">В JavaScript все локальные переменные и фунции являются свойствами специального объекта, который называется <strong>LexicalEnvironment</strong> (лексическое окружение). </p>
<p class="cye-lm-tag">Правильно ли я понял, что в Вашей статье этот объект Вы назвали – АО (Activation object) .</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-11724">
		<article id="comment-11724" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>arbeiter</b></p>
<p class="cye-lm-tag">Данная статья относится к циклу ECMA-262-3, и здесь этот объект называется Variable object (или Activation object в функициях).</p>
<p class="cye-lm-tag">В ECMA-262-5 терминология (да и семантика в некоторых местах) была несколько изменена — там уже используется модель окружений.</p>
<p class="cye-lm-tag">Но более правильно в ES5 этот объект называется <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/#variable-environment" rel="nofollow">VariableEnvironment</a> — т.к. именно он используется для наполнения переменными при входе в контекст. Однако в runtime, работа уже идет, да — c <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/#lexical-environment" rel="nofollow">LexicalEnvironment</a>.</p>
<p class="cye-lm-tag">Лексические окружения подробно описаны в цикле ECMA-262-5: <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/" rel="nofollow">Chapter 3.1. Lexical environments: Common Theory</a> и <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" rel="nofollow">Chapter 3.2. Lexical environments: ECMAScript implementation</a>.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-13111">
		<article id="comment-13111" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий, я совсем новичок в программировании, поясните пожалуйста следующие моменты:</p>
<p class="cye-lm-tag">1) “Глобальный объект (Global object) — … жизненный цикл объекта завершается с завершением программы.”<br>
Вопрос: программа завершается, когда происходит закрытие окна браузера или же когда происходит окончательная загрузка страницы(тогда как же быть с событиями)?</p>
<p class="cye-lm-tag">2) из части 6.Замыкания.6.4.Применение замыканий:<br>
…<br>
var a = 10;<br>
// только для примера<br>
xmlHttpRequestObject.onreadystatechange = function () {<br>
  // callback, который вызовется отложенно,<br>
  // когда данные будут готовы;<br>
  // переменная “а” здесь доступна,<br>
  // даже несмотря на то, что контекст,<br>
  // породивший “а” уже завершился<br>
  alert(a); // 10<br>
};<br>
..<br>
Вопрос: Если контекст, породивший а, глобальный, то означает ли завершение контекста также и завершение жизни глобального объекта?</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-13116">
		<article id="comment-13116" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Ivan</b></p>
<blockquote><p class="cye-lm-tag">Вопрос: программа завершается, когда происходит закрытие окна браузера или же когда происходит окончательная загрузка страницы(тогда как же быть с событиями)?</p></blockquote>
<p class="cye-lm-tag">На самом деле я выбрал не совсем удачную формулировку. Поскольку относительно Web’a, <code>Программой</code> считается код каждого отдельного тега <code>script</code>.</p>
<p class="cye-lm-tag">Вместе с тем, каждая такая программа разделяет один и тот же глобальный объект.</p>
<div><div id="highlighter_610139" class="syntaxhighlighter dsHightlight xml"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="xml plain">&lt;</code><code class="xml keyword">script</code><code class="xml plain">&gt;</code></div><div class="line number2 index1 alt1"><code class="xml plain">// программа 1</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="xml plain">// глобальная переменная</code></div><div class="line number5 index4 alt2"><code class="xml plain">var a = 10;</code></div><div class="line number6 index5 alt1"><code class="xml plain">&lt;/</code><code class="xml keyword">script</code><code class="xml plain">&gt;</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="xml plain">&lt;</code><code class="xml keyword">script</code><code class="xml plain">&gt;</code></div><div class="line number10 index9 alt1"><code class="xml plain">// программа 2</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="xml plain">// доступно из глобального объекта,</code></div><div class="line number13 index12 alt2"><code class="xml plain">// который все еще существует</code></div><div class="line number14 index13 alt1"><code class="xml plain">console.log(a); // 10</code></div><div class="line number15 index14 alt2"><code class="xml plain">&lt;/</code><code class="xml keyword">script</code><code class="xml plain">&gt;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Программой также считается код <code>eval</code>‘a.</p>
<p class="cye-lm-tag">Поэтому то, что имелось в виду в моем предложении, точнее можно перефразировать как “жизненный цикла глобального объекта заканчивается (в общем случае) с завершением <em>интерпретатора</em>“. В “общем случае” потому, что может быть <em>несколько</em> глобальных объектов (например, открыто несколько окон или iframe’ов, но при этом, возможно, используется один и тот же интерпретатор).</p>
<blockquote><p class="cye-lm-tag">Вопрос: Если контекст, породивший а, глобальный, то означает ли завершение контекста также и завершение жизни глобального объекта?</p></blockquote>
<p class="cye-lm-tag">Вот как раз из примера выше с двумя тегами <code>script</code> видно, что было порождено два глобальных контекста, которые используют один и тот же глобальный объект. Поэтому ответ на этот вопрос — нет, глобальный объект уничтожится, когда уничтожится интерпретатор (по сути, да — когда закроется окно браузера, если упрощенно).</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-13149">
		<article id="comment-13149" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий !<br>
В секции “Ещё (классический) пример:” добавь вызов функции x, чтобы было понятно что с ней происходит – а то возникаеют вопросы (пришлось пошагово дебажить в хроме, чтобы ответить себе на этот вопрос)</p>
<p class="cye-lm-tag">Как-то так:</p>
<div><div id="highlighter_162145" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// function</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">x = 20;</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">x()</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">x() {}</code></div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 20</code></div></div></td></tr></tbody></table></div></div>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-13152">
		<article id="comment-13152" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>денис</b></p>
<p class="cye-lm-tag">А в твоем примере функция не вызовется. На момент активации, <code>x</code> будет уже числом.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-13158">
		<article id="comment-13158" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий я об этом и говорю ! </p>
<p class="cye-lm-tag">Статьи просто филигранны – все четко и понятно – а ситуация с с заменой функции на число хитра и не очевидна – просто добавь свой коммент как ремарку к тексту если не трудно.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-16353">
		<article id="comment-16353" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Если “в глобальном контексте, объектом переменных является сам глобальный объект”, почему так:</p>
<div><div id="highlighter_194897" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(</code><code class="jscript keyword">this</code><code class="jscript plain">.a)&nbsp; </code><code class="jscript comments">//undefined</code></div><div class="line number2 index1 alt1"><code class="jscript plain">alert(a)&nbsp; </code><code class="jscript comments">//is not defined</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Я думал, что при обращении к ‘потенциальной’ переменой, идет поиск названия переменной в VO, то есть в коде выше, при интерпретации <code>alert(a)</code> идет поиск поля <code>'a'</code> в объекте <code>this</code>.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-16354">
		<article id="comment-16354" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>миша</b>,</p>
<p class="cye-lm-tag">Абсолютно верно, поиск идет, и переменная/свойство глобального объекта отсутствует. И это, по алгоритму <em>поиска переменных</em>, должно бросить <code>ReferenceError</code>.</p>
<p class="cye-lm-tag">Алгоритм же <em>прямого чтения свойств</em> иной — тут дожно вернуться <code>undefined</code>, если свойство не найдено.</p>
<p class="cye-lm-tag">Чтобы удостовериться, что поиск переменных идет и в глобальном объекте и в его цепи прототипов, можно, объявить свойство в <code>Object.prototype</code> (глобальный объект найследует от него, например в Firefox):</p>
<div><div id="highlighter_253144" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">this</code><code class="jscript plain">.a = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">Object.prototype.b = 20;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">console.log(a, b); </code><code class="jscript comments">// 10, 20</code></div></div></td></tr></tbody></table></div></div>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-16367">
		<article id="comment-16367" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий, у меня возник недавно вопрос (когда я где-то читал статью про пространство имен), вот прочитав про переменные вдруг вспомнил:<br>
Как известно, засорять глобальное пространство имен это плохо. Допустим на странице несколько скриптов (программ, как Вы выразились). Скажем скрипт рекламодателя и мой скрипт с обработчиком клика. Скрипт рекламодателя исполняется сразу после загрузки страницы. Мой скрипт только во время клика (правильно я думаю?). Если я объявлю переменную с именем, идентичным имени переменной из первого скрипта, произойдет ли перезапись значения переменной первого скрипта. Ведь эти две программы(скрипта) разделяют один глобальный контекст. Поясните, пожалуйста, этот момент.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-16369">
		<article id="comment-16369" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Scripter</b></p>
<blockquote><p class="cye-lm-tag">Мой скрипт только во время клика (правильно я думаю?)</p></blockquote>
<p class="cye-lm-tag">Да, если Ваш скрипт — это полностью обработчик клика, то, конечно, он выполняется только по клику.</p>
<p class="cye-lm-tag">Если же инициализация Вашего обработчика происходит в отдельном теге <code>script</code>, то этот тег и его код выполняются при загрузке странице. При этом, не обязательно, что Ваш обработчик запускается в это время — просто проходит его инициализация (однако сам скрипт может использовать вспомогательные переменные). И, если в этот момент Вы присваиваете значения глобальным переменным, они, естественно, перезаписывают старые значения (если это позволено; у переменных может быть выставлен, например, <code>[[Writable]]</code> в <code>false</code>).</p>
<p class="cye-lm-tag">Поэтому, да, верно, обе программы разделяют один и тот же глобальный объект, и перезапись происходит.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-17227">
		<article id="comment-17227" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Статьи просто супер! ) </p>
<p class="cye-lm-tag">И у меня вопросик про консоль отладчика, Вы написали что они исполняют код через eval, я проверил в фаер баге – так и есть, но когда я затестил в Хроме мне не удалось удалить переменную объявленную с var. Это связано с движком V8 и другим принципом работы этого браузера?</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-17262">
		<article id="comment-17262" class="comment">
			

			<div class="comment-content "><blockquote>
<div><div id="highlighter_12806" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript comments">// Объект переменных глобального контекста</code></div><div class="line number2 index1 alt1"><code class="jscript plain">VO(globalContext) = {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">a: 10,</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">test: &lt;ссылка на функцию&gt;</code></div><div class="line number5 index4 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
</blockquote>
<p class="cye-lm-tag">Может быть точнее “<i><strong>код (операторы) функции</strong></i>” ,<br>
т.к. <code>alert(test)</code> выдает именно текст функции.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-17334">
		<article id="comment-17334" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Спасибо, очень хорошая статья, многое для меня разъяснила! )</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-17515">
		<article id="comment-17515" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий, насколько я понял если создать свойство VO в текущем контексте исполнения, а не переменную (т.е. без ключевого слова “var”), то это свойство не будет видно в порожденных из текущего контекстах? Т.е. замыкание на такие свойства не распространяется? И таким образом, когда текущий контекст будет удален из стека то и проподет это свойство вместе с ним?<br>
К чему я это все веду, что можно заранее продумать какие свойства нужны будут в порождаемых контекстах, а какие можно смело удалить с текущим контекстом, т.е. вовремя освобождая оперативную память.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-17539">
		<article id="comment-17539" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Отвечу на свой вопрос сам. Свойство так же доступно в порождённых контекстах и остаётся доступно, после удаления текущего контекста, где оно было определено, из стека.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-17982">
		<article id="comment-17982" class="comment">
			

			<div class="comment-content "><blockquote><p class="cye-lm-tag">Косвенное обращение к переменным (по именам свойств VO) позволяет лишь VO глобального контекста (где сам глобальный объект и является объектом переменных, но об этом чуть позже). Для остальных контекстов напрямую обратиться к VO невозможно; это чисто механизм реализации.</p></blockquote>
<p class="cye-lm-tag">надеюсь не отвлеку понапрасну но<br>
наверное первое слово длжно быть “Прямое”?</p>
<p class="cye-lm-tag">и еще одна маленькая штучка</p>
<div><div id="highlighter_33588" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">activeExecutionContext = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO: {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// данные контекста (var, FD, параметры функций)</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number5 index4 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">здесь наверно параметры функциИ а не функциЙ, один VO одна функция?</p>
<blockquote><p class="cye-lm-tag">При обращении к свойствам глобального объекта префикс обычно не используется, поскольку сам глобальный объект не доступен напрямую по имени.</p></blockquote>
<p class="cye-lm-tag">Если не затруднит… о каком имени идет речь? У объектов есть имена?</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-17987">
		<article id="comment-17987" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Domingo</b></p>
<blockquote><p class="cye-lm-tag">наверное первое слово длжно быть “Прямое”?</p></blockquote>
<p class="cye-lm-tag">Нет, все-таки косвенное. Т.е. через свойства объекта переменных:</p>
<div><div id="highlighter_906184" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10; </code><code class="jscript comments">// переменная</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">console.log(a); </code><code class="jscript comments">// прямое обращение</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">console.log(</code><code class="jscript keyword">this</code><code class="jscript plain">.a); </code><code class="jscript comments">// косвенное</code></div><div class="line number6 index5 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">k = </code><code class="jscript string">'a'</code><code class="jscript plain">;</code></div><div class="line number7 index6 alt2"><code class="jscript plain">console.log(</code><code class="jscript keyword">this</code><code class="jscript plain">[k]); </code><code class="jscript comments">// тоже косвенное</code></div></div></td></tr></tbody></table></div></div>
<blockquote><p class="cye-lm-tag">здесь наверно параметры функциИ а не функциЙ, один VO одна функция?</p></blockquote>
<p class="cye-lm-tag">В данном случае несущественно, имеется в виду абстрактное понятие VO, не конкретно одной функции.</p>
<blockquote><p class="cye-lm-tag">Если не затруднит… о каком имени идет речь? У объектов есть имена?</p></blockquote>
<p class="cye-lm-tag">Нет, у объектов нет имен. Имена — у переменных и свойств, которые ссылаются на эти объекты. Глобальный объект доступен через <code>this</code> в глобальном коде (либо через <code>window</code>, но <code>window</code> — это уже браузерная среда). Но нет специального отдельного имени переменной для глобального объекта в спецификации. Некоторые реализации, например NodeJS, делают ссылку <code>global</code>, и можно писать <code>global.a</code> (так же как и <code>this.a</code>). Но обычно, если имя переменной известно, то обычно пишут просто <code>a</code>.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-18046">
		<article id="comment-18046" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Дмитрий, спасибо за ответы, даже как то неудобно отвлекать такого талантливого человека детскими вопросами. Если бы на вашем сайте была кнопка “помочь проекту” я бы ей воспользовался. Ваши статьи это лучшее что мне встречалось по стилю изложения. На мой вкус, отличный баланс ясности и лаконичности. Вы не пишете книги?</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-18047">
		<article id="comment-18047" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Domingo</b>, рад, что оказалось полезным, спасибо.</p>
<p class="cye-lm-tag">Да, по поводу книги были мысли, но все не найду времени. Посмотрим, может ES6 что-нибудь изменит в этом направлении.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-18058">
		<article id="comment-18058" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Почему так?</p>
<div><div id="highlighter_299980" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">tango(x){</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(</code><code class="jscript keyword">false</code><code class="jscript plain">){</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">x(){}</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">x;</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2"><code class="jscript plain">alert(tango(5));</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript comments">// Opera, Chrome - function x(){}</code></div><div class="line number10 index9 alt1"><code class="jscript comments">// FF - 5</code></div></div></td></tr></tbody></table></div></div>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-18066">
		<article id="comment-18066" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Domingo</b>, да, это <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/#rasshirenie-realizatsiy-funktsiya-instruktsiya-function-statement" rel="nofollow">FunctionStatement</a>, поведение варьирует в разных браузерах. Более логичным здесь, конечно, кажется поведение FF. Должно быть специфицировано в ES6 спецификации. Более подробно виды функций описаны в <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/" rel="nofollow">главе 5</a>.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-24095">
		<article id="comment-24095" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Мне интересно , посредством каких механизмов возможно такое:</p>
<div><div id="highlighter_528591" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">void </code><code class="jscript keyword">function</code><code class="jscript plain">() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">typed() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">typed() </code><code class="jscript comments">//too much recursion</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">})()</code></div><div class="line number5 index4 alt2"><code class="jscript plain">}()</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Как возможно , что typed доступна сама из себя , ведь в VO функции typed не попадает же сама функция typed . Но из замыкания тоже не берется этот typed . Поэтому и стало интересно , посредством чего функция доступна сама из себя ?</p>
<p class="cye-lm-tag">На мой взгляд , если функция вызывается сама из себя , то она вызывается через arguments.callee , такое поведение было бы логичным . Или , что было бы ещё логичным , в VO typed попадала бы и сама функция typed но это не так .</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-24101">
		<article id="comment-24101" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>shared memory</b>, совершенно верно, идентификатор <code>typed</code> не находится в VO. Для <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#feature-of-named-function-expression-nfe" rel="nofollow">именнованных функиональных выражений</a>, создается промежуточный объект в scope chain, для хранения этого имени.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-70398">
		<article id="comment-70398" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Поясните пожалуйста вот этот момент. Тут нету ошибки? </p>
<p class="cye-lm-tag">“– создаётся свойство VO с именем и значением формального параметра; для непереданных параметров – создаётся свойство VO с именем формального параметра и значением undefined;”</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-70617">
		<article id="comment-70617" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<b>Морозов Дмитрий</b></p>
<p class="cye-lm-tag">Да, все верно (что Вас смутило?).</p>
<div><div id="highlighter_71893" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo(a, b) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// При вызове foo(10):</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// VO/AO = {a: 10, b: undefined}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">console.log(a, b); </code><code class="jscript comments">// 10, undefined</code></div><div class="line number7 index6 alt2"><code class="jscript plain">}</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript plain">foo(10);</code></div></div></td></tr></tbody></table></div></div>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-122707">
		<article id="comment-122707" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Большое спасибо за серию статей!<br>
Ни в одной книге по javascript не видел такого подробного объяснения принципов работы.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-151075">
		<article id="comment-151075" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">Добрый день, Дмитрий. Фантастические статьи, открываю JS заново.<br>
Вопрос по коду. </p>
<div><div id="highlighter_977981" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// function</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">x = 20;</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">x() {}</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 20</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Но почему последний alert покажет 20, если при интерпретации кода перед последним alert x будет ссылаться на функцию?</p>
<p class="cye-lm-tag">Спасибо.</p>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-152572">
		<article id="comment-152572" class="comment">
			

			<div class="comment-content "><p class="cye-lm-tag">@<strong>ivan</strong></p>
<blockquote><p class="cye-lm-tag">Но почему последний alert покажет 20, если при интерпретации кода перед последним alert x будет ссылаться на функцию?</p></blockquote>
<p class="cye-lm-tag">Поскольку на стадии “входа в контекст” все переменные и декларации функций уже найдены. Визуально это можно представить, как переменные и функции “подняты” наверх (даже существует термин для этого — <a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/" rel="nofollow">hoisting</a>):</p>
<div><div id="highlighter_926903" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript comments">// 1. --- вход в контекст ---</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x;</code></div><div class="line number4 index3 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">x() {}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript comments">// 2. --- исполнение кода контекст ---</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">alert(x); </code><code class="jscript comments">// function</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">x = 10;</code></div><div class="line number11 index10 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript plain">x = 20;</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div><div class="line number15 index14 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 20</code></div></div></td></tr></tbody></table></div></div>
</div>

			<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
			</ol><!-- .commentlist -->
</div>

	<br><hr>
<a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">src</a>
<h2>Цепь областей видимости.</h2>
<div class="entry-content" itemprop="mainContentOfPage">
		<p class="cye-lm-tag">Read this article in: <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" title="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/">English</a>, Chinese (<a href="http://www.denisdeng.com/?p=908">version 1</a>, <a href="http://goddyzhao.tumblr.com/post/11259644092/scope-chain">version 2</a>), <a href="http://huns.me/%EB%B2%88%EC%97%AD-ecma-262-3-in-detail-chapter-4-scope-chain/" title="http://huns.me/%EB%B2%88%EC%97%AD-ecma-262-3-in-detail-chapter-4-scope-chain/">Korean</a>.</p>
<div class="ds-toc"><ol><li><a href="#vvedenie" title="Введение">Введение</a></li><li><a href="#opredelenie" title="Определение">Определение</a></li><li><a href="#jiznennyiy-tsikl-funktsii" title="Жизненный цикл функции">Жизненный цикл функции</a><ol><li><a href="#sozdanie-funktsii" title="Создание функции">Создание функции</a></li><li><a href="#vyizov-funktsii" title="Вызов функции">Вызов функции</a></li></ol></li><li><a href="#osobennosti-scope" title="Особенности Scope">Особенности Scope</a><ol><li><a href="#zamyikaniya" title="Замыкания">Замыкания</a></li><li><a href="#scope-funktsiy-sozdannyih-konstruktorom-function" title="[[Scope]] функций, созданных конструктором Function">[[Scope]] функций, созданных конструктором Function</a></li><li><a href="#dvumernyiy-analiz-scope" title="Двумерный анализ Scope">Двумерный анализ Scope</a></li><li><a href="#scope-globalnogo-konteksta-i-konteksta-eval" title="Scope глобального контекста и контекста eval">Scope глобального контекста и контекста eval</a></li><li><a href="#vozdeystvie-na-scope-pri-ispolnenii-koda" title="Воздействие на Scope при исполнении кода">Воздействие на Scope при исполнении кода</a></li></ol></li><li><a href="#zaklyuchenie" title="Заключение">Заключение</a></li><li><a href="#dopolnitelnaya-literatura" title="Дополнительная литература">Дополнительная литература</a></li></ol></div><p class="cye-lm-tag"></p>
<h2 id="vvedenie" class="header-link"><a href="#vvedenie">Введение</a></h2>
<p class="cye-lm-tag">Как нам уже известно из <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">второй заметки</a>, касающейся <em>объекта переменных</em>, данные <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-1-execution-contexts/">контекста исполнения</a> (переменные, декларации функции и формальные параметры функций) хранятся свойствами этого объекта переменных.<br>
<span id="more-23" class="cye-lm-tag"></span></p>
<p class="cye-lm-tag">Также, мы знаем, что объект переменных создаётся и наполняется инициализирующими значениями каждый раз при <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/#vhod-v-kontekst-ispolneniya">входе в контекст</a>, и, что его модификация происходит при <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/#interpretatsiya-koda">интерпретации кода контекста</a>.</p>
<p class="cye-lm-tag">Данная заметка будет посвящена ещё одной сущности, напрямую связанной с контекстами исполнения; на сей раз, мы затронем тему <em>цепи областей видимости</em>.</p>
<h2 id="opredelenie" class="header-link"><a href="#opredelenie">Определение</a></h2>
<p class="cye-lm-tag">Если представить кратко, выделив основную суть, цепь областей видимости (scope chain) в большей мере связана со вложенными функциями.</p>
<p class="cye-lm-tag">Как мы знаем, в ECMAScript можно описывать вложенные функции и даже возвращать эти функции из внешних.</p>
<div><div id="highlighter_699532" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">bar() {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x + y);</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code>&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">bar;</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript plain">}</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="jscript plain">foo()(); </code><code class="jscript comments">// 30</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При этом, нам известно, что <em>каждый контекст имеет свой объект переменных</em>: для глобального контекста — это сам <em>глобальный объект</em>, для функций — это <em>объект активации</em>.</p>
<p class="cye-lm-tag">Цепь областей видимости и является <em>списком этих (родительских) объектов переменных</em> для вложенных контекстов. Данная цепь используется для поиска переменных. Т.е. из примера выше, scope chain контекста “bar” будет включать AO(bar), AO(foo) и VO(global).</p>
<p class="cye-lm-tag">Но, давайте разбирать эту тему подробней.</p>
<p class="cye-lm-tag">Начнём с определения, далее будем рассматривать его нюансы на примерах.</p>
<p class="definition cye-lm-tag"><em>Цепь областей видимости (Scope, Scope chain, сокращённо SC)</em> – это связанная с контекстом исполнения <em>цепь объектов переменных</em>, в которой происходит поиск переменных при <em>разрешении имён идентификаторов</em>.</p>
<p class="cye-lm-tag">Scope chain функции создаётся <em>при её выполнении</em>, и состоит из <em>объекта активации</em> и внутреннего свойства функции <em>[[Scope]]</em>. Мы будем обсуждать свойство [[Scope]]  чуть ниже.</p>
<p class="cye-lm-tag">Схематично в контексте:</p>
<div><div id="highlighter_539564" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">activeExecutionContext = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">VO: {...}, </code><code class="jscript comments">// или AO</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">this</code><code class="jscript plain">: thisValue,</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">Scope: [ </code><code class="jscript comments">// Scope chain</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// список всех объектов переменных</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// для поиска идентификаторов</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">] </code></div><div class="line number8 index7 alt1"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">где Scope по определению:</p>
<div><div id="highlighter_660756" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">Scope = AO + [[Scope]]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Для примеров будем представлять Scope и [[Scope]] в виде обычных массивов JavaScript — так будет наглядней.</p>
<div><div id="highlighter_672768" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">Scope = [VO1, VO2, ..., VOn]; </code><code class="jscript comments">// scope chain</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Альтернативной формой записи может быть иерархическая цепь объектов с ссылкой на родительскую область видимости (на родительский объект переменных) в каждом звене цепи. Этому представлению соответствует концепция <em>__parent__</em> некоторых реализаций, которую мы <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/#osobennost-realizatsiy-svoystvo-__parent__">обсуждали</a> во второй части, посвящённой объекту переменных:</p>
<div><div id="highlighter_811130" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">VO1 = {__parent__: </code><code class="jscript keyword">null</code><code class="jscript plain">, ... other data}; --&gt;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">VO2 = {__parent__: VO1, ... other data}; --&gt;</code></div><div class="line number3 index2 alt2"><code class="jscript comments">// etc.</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Однако представлять scope chain в виде массива — удобней, поэтому в дальнейшем обсуждении мы будем использовать именно этот подход. К тому же, спецификация сама абстрактно утверждает (см. <a href="http://bclary.com/2004/11/07/#a-10.1.4">10.1.4</a>), что “a scope chain is a <em>list</em> of objects”, независимо от того, что на уровне реализаций может быть использован подход с <em>__parent__</em>. Массив же в ECMAScript является хорошим кандидатом на роль <em>списка (list)</em>.</p>
<p class="cye-lm-tag">Комбинация AO + [[Scope]], а также процесс <em>разрешения имён идентификаторов (identifier resolution)</em>, о котором также будет сказано ниже, связаны с жизненным циклом функций.</p>
<h2 id="jiznennyiy-tsikl-funktsii" class="header-link"><a href="#jiznennyiy-tsikl-funktsii">Жизненный цикл функции</a></h2>
<p class="cye-lm-tag">Жизненный цикл функции подразделяется на этап <em>создания</em> и этап <em>активации (вызова)</em>. Разберём их подробней.</p>
<h3 id="sozdanie-funktsii" class="header-link"><a href="#sozdanie-funktsii">Создание функции</a></h3>
<p class="cye-lm-tag">Как известно, декларации функций попадают в объект переменных (VO) / объект активации (AO) на этапе входа в контекст. Рассмотрим пример объявления переменной и функции в глобальном контексте (где объектом переменных является сам глобальный объект, помним, да?):</p>
<div><div id="highlighter_549336" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x + y);</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">foo(); </code><code class="jscript comments">// 30</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При выполнении функции, мы видим, что выдаётся правильный (и вполне ожидаемый) результат – 30. Однако, здесь есть одна очень важная особенность.</p>
<p class="cye-lm-tag">До сих пор мы говорили лишь об объекте переменных в рамках одного контекста. Здесь мы видим, что переменная “y” определена в функции “foo” (а значит, она находится в AO контекста функции “foo”), но переменная “x”, при входе в контекст, нигде не определялась (и, соответственно, в AO не добавлялась; “с виду”, переменной “x” вообще не существует для функции “foo”, но, как мы увидим ниже, – лишь “с виду”). Объект активации контекста функции “foo” содержит только одно свойство – свойство “y”:</p>
<div><div id="highlighter_417623" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">fooContext.AO = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">y: undefined </code><code class="jscript comments">// undefined - при входе, 20 - при вызове</code></div><div class="line number3 index2 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Каким же образом функция “foo” видит переменную “x”? Логично предположить, что функция должна иметь доступ к объекту переменных <em>вышестоящего</em> контекста. В сущности, так оно и есть, и, физически, данный функционал реализуется за счёт внутреннего свойства функции <em>[[Scope]]</em>.</p>
<p class="definition cye-lm-tag"><em>[[Scope]]</em> – это иерархическая цепь объектов переменных (VO), стоящих <em>выше</em> контекста функции; цепь записывается свойством в функцию при её <em>создании</em>.</p>
<p class="cye-lm-tag">Обратите внимание на ключевой момент – [[Scope]] записывается в функцию <em>при её создании</em> – статически (неизменно), раз, и навсегда (до уничтожения функции). Т.е. функция может быть <em>ни разу не вызвана</em>, но свойство [[Scope]] в неё уже записано.</p>
<p class="cye-lm-tag">Ещё один момент, который следует учесть, это то, что [[Scope]], в отличии от <em>Scope (Scope chain)</em>, является свойством функции, а не контекста. Рассматривая вышеприведённый пример, [[Scope]] функции “foo” будет иметь следующий вид:</p>
<div><div id="highlighter_685834" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">foo.[[Scope]] = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">globalContext.VO </code><code class="jscript comments">// === Global</code></div><div class="line number3 index2 alt2"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">А далее, при вызове функции, как нам известно, происходит вход в контекст функции, где создаётся объект активации, определяется <em>this</em> и <em>Scope (Scope chain)</em>. Рассмотрим подробней этот момент.</p>
<h3 id="vyizov-funktsii" class="header-link"><a href="#vyizov-funktsii">Вызов функции</a></h3>
<p class="cye-lm-tag">Как было сказано в определении, при входе в контекст, после создания AO/VO, свойство контекста Scope определяется следующим образом:</p>
<div><div id="highlighter_538223" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">Scope = AO|VO + [[Scope]]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Основным моментом здесь является то, что <em>объект активации является первым элементом</em> массива <em>Scope</em>:</p>
<div><div id="highlighter_540400" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">Scope = [AO].concat([[Scope]]);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Эта особенность очень важна при <em>разрешении имён идентификаторов</em>.</p>
<p class="definition cye-lm-tag"><em>Разрешение имён идентификаторов (Identifier resolution)</em> – это процесс определения, к какому из объектов переменных в Scope chain принадлежит переменная (или декларация функции) по её имени.</p>
<p class="cye-lm-tag">На выходе данного алгоритма будет всегда значение типа <em>Reference</em>, <em>база</em> которого <em>(base)</em> является соответствующим объектом переменных (либо <em>null</em>, если переменная не найдена), а <em>имя свойства (property name)</em> — имя определяемого (разрешаемого) идентификатора. Подробно тип <em>Reference</em> разбирался в <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">третьей части</a>, посвящённой ключевому слову <em>this</em>.</p>
<p class="cye-lm-tag">Процесс разрешения имён идентификаторов включает в себя поиск в <em>Scope</em> свойства, соответствующего имени переменной, т.е. происходит последовательный опрос объектов переменных в цепи. Таким образом, локальные переменные контекста имеют более высокий приоритет при поиске, нежели переменные из контекста выше, и, соответственно, при одинаковом имени двух переменных из разных контекстов, первой будет определена переменная более глубокого (по вложенности) контекста.</p>
<p class="cye-lm-tag">Немного усложним пример, описанный выше; добавим дополнительный уровень вложенности:</p>
<div><div id="highlighter_149035" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">bar() {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">z = 30;</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x +&nbsp; y + z);</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">bar();</code></div><div class="line number13 index12 alt2"><code class="jscript plain">}</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="jscript plain">foo(); </code><code class="jscript comments">// 60</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Имеем:</p>
<p class="cye-lm-tag">globalContext.VO:</p>
<div><div id="highlighter_181272" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">globalContext.VO === Global = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">x: 10</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">foo: &lt;ссылка на функцию&gt;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При создании “foo”, [[Scope]] “foo”:</p>
<div><div id="highlighter_323687" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">foo.[[Scope]] = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">globalContext.VO</code></div><div class="line number3 index2 alt2"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При запуске “foo”:</p>
<p class="cye-lm-tag">fooContext.AO:</p>
<div><div id="highlighter_192112" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">fooContext.AO = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">y: 20,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">bar: &lt;ссылка на функцию&gt;</code></div><div class="line number4 index3 alt1"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При запуске “foo”, fooContext.Scope = fooContext.AO + foo.[[Scope]]:</p>
<div><div id="highlighter_217642" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">fooContext.Scope = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">fooContext.AO,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">globalContext.VO</code></div><div class="line number4 index3 alt1"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При создании внутрененней функции “bar”, [[Scope]] “bar”:</p>
<div><div id="highlighter_642180" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">bar.[[Scope]] = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">fooContext.AO,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">globalContext.VO</code></div><div class="line number4 index3 alt1"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При запуске “bar”, barContext.AO:</p>
<div><div id="highlighter_498749" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">barContext.AO = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">z: 30</code></div><div class="line number3 index2 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">При запуске “bar”, barContext.Scope = barContext.AO + bar.[[Scope]]:</p>
<div><div id="highlighter_806979" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">barContext.Scope = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">barContext.AO,</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">fooContext.AO,</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">globalContext.VO</code></div><div class="line number5 index4 alt2"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Разрешение имён идентификаторов “x”, “y” и “z” при  alert-e:</p>
<div><div id="highlighter_15471" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">- </code><code class="jscript string">"x"</code></div><div class="line number2 index1 alt1"><code class="jscript plain">-- barContext.AO </code><code class="jscript comments">// не найдено</code></div><div class="line number3 index2 alt2"><code class="jscript plain">-- fooContext.AO </code><code class="jscript comments">// не найдено</code></div><div class="line number4 index3 alt1"><code class="jscript plain">-- globalContext.VO </code><code class="jscript comments">// найдено - 10</code></div></div></td></tr></tbody></table></div></div>
<div><div id="highlighter_530787" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">- </code><code class="jscript string">"y"</code></div><div class="line number2 index1 alt1"><code class="jscript plain">-- barContext.AO </code><code class="jscript comments">// не найдено</code></div><div class="line number3 index2 alt2"><code class="jscript plain">-- fooContext.AO </code><code class="jscript comments">// найдено - 20</code></div></div></td></tr></tbody></table></div></div>
<div><div id="highlighter_278029" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">- </code><code class="jscript string">"z"</code></div><div class="line number2 index1 alt1"><code class="jscript plain">-- barContext.AO </code><code class="jscript comments">// найдено - 30</code></div></div></td></tr></tbody></table></div></div>
<h2 id="osobennosti-scope" class="header-link"><a href="#osobennosti-scope">Особенности Scope</a></h2>
<p class="cye-lm-tag">Рассмотрим несколько важных особенностей, связанных со Scope chain и свойством функций [[Scope]].</p>
<h3 id="zamyikaniya" class="header-link"><a href="#zamyikaniya">Замыкания</a></h3>
<p class="cye-lm-tag"><em>Замыкания (Closures)</em> в ECMAScript напрямую связаны со свойством функций [[Scope]]. Как уже было отмечено, [[Scope]] запоминается при создании функции и существует до тех пор, пока жива сама функция. Собственно, <em>замыкание</em> — это и есть <em>комбинация кода функции и её свойства [[Scope]]</em>. При этом, [[Scope]] одним из объектов цепи содержит то <em>лексическое окружение</em> (родительский объект переменных), в котором функция порождается. Переменные из вышестоящих контекстов при дальнейшей активации функции будут искаться именно в этой лексической (статически запомненной при создании) цепи объектов переменных.</p>
<p class="cye-lm-tag">Примеры:</p>
<div><div id="highlighter_670020" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number5 index4 alt2"><code class="jscript plain">}</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 20;</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">foo(); </code><code class="jscript comments">// 10, а не 20</code></div><div class="line number10 index9 alt1"><code class="jscript plain">})();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Видим, что переменная “x” найдена в [[Scope]] функции “foo”, т.е. для поиска переменных используется лексическая (замкнутая) цепь, определяемая на момент <em>создания</em> функции, но <em>не динамическая</em> цепь <em>вызова</em>, при которой значение переменной “x” определилось бы как 20.</p>
<p class="cye-lm-tag">Ещё (классический) пример замыкания:</p>
<div><div id="highlighter_219765" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert([x, y]);</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript plain">}</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">x = 30;</code></div><div class="line number13 index12 alt2">&nbsp;</div><div class="line number14 index13 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">bar = foo(); </code><code class="jscript comments">// возвратилась анонимная функция</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="jscript plain">bar(); </code><code class="jscript comments">// [10, 20]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Вновь видим, что для разрешения идентификаторов используется лексическая цепь создания функции — переменная “x” определена как 10, а не 30. Более того, данный пример наглядно демонстрирует, что [[Scope]] функции (в данном случае анонимной функции, возвращённой из функции “foo”) <em>продолжает существовать даже после того, как порождающий её контекст уже завершился</em>.</p>
<p class="cye-lm-tag">Более подробно о теории замыканий и об организации данной сущности в ECMAScript читайте в <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-6-closures/">шестой части</a> данного цикла статей.</p>
<h3 id="scope-funktsiy-sozdannyih-konstruktorom-function" class="header-link"><a href="#scope-funktsiy-sozdannyih-konstruktorom-function">[[Scope]] функций, созданных конструктором Function</a></h3>
<p class="cye-lm-tag">В примерах выше наглядно видно, что в функцию при создании записывается свойство [[Scope]], благодаря которому, она получает доступ к переменным всех вышестоящий контекстов. Однако, в этом правиле есть одно важное исключение, и касается оно функций определённых с помощью конструктора <em>Function</em>.</p>
<div><div id="highlighter_294665" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">barFD() { </code><code class="jscript comments">// FunctionDeclaration</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x); </code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(y);</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">barFE = </code><code class="jscript keyword">function</code> <code class="jscript plain">() { </code><code class="jscript comments">// FunctionExpression</code></div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(y);</code></div><div class="line number15 index14 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number16 index15 alt1">&nbsp;</div><div class="line number17 index16 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">barFn = Function(</code><code class="jscript string">'alert(x); alert(y);'</code><code class="jscript plain">);</code></div><div class="line number18 index17 alt1">&nbsp;</div><div class="line number19 index18 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">barFD(); </code><code class="jscript comments">// 10, 20</code></div><div class="line number20 index19 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">barFE(); </code><code class="jscript comments">// 10, 20</code></div><div class="line number21 index20 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">barFn(); </code><code class="jscript comments">// 10, "y" is not defined</code></div><div class="line number22 index21 alt1">&nbsp;</div><div class="line number23 index22 alt2"><code class="jscript plain">}</code></div><div class="line number24 index23 alt1">&nbsp;</div><div class="line number25 index24 alt2"><code class="jscript plain">foo();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Как видим, функции “barFn”, созданной при помощи конструктора Function не доступна переменная “y”. Но это не значит, что функция “barFn” не имеет внутреннего свойства [[Scope]] (иначе бы, она не видела и переменную “x”). А дело в том, что, являясь исключением, функции, порождённые конструктором Function в качестве [[Scope]] всегда имеют <em>лишь глобальный объект</em>. Учитывайте это, т.к., например, создать замыкание внешних контекстов, кроме глобального, при помощи такой функции уже не получится.</p>
<h3 id="dvumernyiy-analiz-scope" class="header-link"><a href="#dvumernyiy-analiz-scope">Двумерный анализ Scope</a></h3>
<p class="cye-lm-tag">Также, особо важным моментом при опросе Scope chain, является то, что, могут опрашиваться и прототипы (если они есть) объектов переменных — ввиду прототипной природы ECMAScript: если свойство не найдено в самом объекте, его поиск продолжается в <em>цепи прототипов (Prototype chain)</em> объекта. Т.е. своего рода двумерный просмотр цепи: (1) по звеньям scope chain, (2) и на каждом из звеньев scope chain — вглубь по звеньям prototype chain. Данный эффект можно наблюдать, если определить свойство в <em>Object.prototype</em>:</p>
<div><div id="highlighter_677555" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">Object.prototype.x = 10;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">foo(); </code><code class="jscript comments">// 10</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Объекты активации прототипа не имеют, что можно видеть в примере ниже:</p>
<div><div id="highlighter_407465" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">foo() {</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 20;</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">bar() {</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">bar();</code></div><div class="line number10 index9 alt1"><code class="jscript plain">}</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript plain">Object.prototype.x = 10;</code></div><div class="line number13 index12 alt2">&nbsp;</div><div class="line number14 index13 alt1"><code class="jscript plain">foo(); </code><code class="jscript comments">// 20</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Если бы AO функции “bar” имел прототип, то свойство “x” должно было быть найдено в <em>Object.prototype</em> (поскольку не найдено в самом AO). В первом же примере, обходя scope chain, мы доходим до глобального объекта, который (в некоторых реализациях, но не во всех) наследуется от <em>Object.prototype</em>, и, соответственно, “x” определяется, как 10.</p>
<p class="cye-lm-tag">Аналогичную ситуацию можно наблюдать в некоторых версиях SpiderMonkey при работе с <em>именованными функциями-выражениями</em> (named function expression, NFE), где <em>спец. объект</em>, хранящий имя функции-выражения наследуется от <em>Object.prototype</em>, а также, в некоторых версиях реализации <em>Blackberry</em>, где сам <em>объект активации</em> наследуется от <em>Object.prototype</em>. Но подробней об этом — <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/">в главе, посвященной функциям</a>.</p>
<h3 id="scope-globalnogo-konteksta-i-konteksta-eval" class="header-link"><a href="#scope-globalnogo-konteksta-i-konteksta-eval">Scope глобального контекста и контекста eval</a></h3>
<p class="cye-lm-tag">Здесь особо разбирать нечего, но, отметить стоит. Цепь областей видимости глобального контекста содержит лишь глобальный объект. Контекст с типом кода “eval” наследует Scope из вызывающего контекста.</p>
<div><div id="highlighter_731444" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">globalContext.Scope = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">Global</code></div><div class="line number3 index2 alt2"><code class="jscript plain">];</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">evalContext.Scope === callingContext.Scope;</code></div></div></td></tr></tbody></table></div></div>
<h3 id="vozdeystvie-na-scope-pri-ispolnenii-koda" class="header-link"><a href="#vozdeystvie-na-scope-pri-ispolnenii-koda">Воздействие на Scope при исполнении кода</a></h3>
<p class="cye-lm-tag">В ECMAScript существуют две инструкции, модифицирующие Scope на этапе исполнения кода контекста. Это инструкции <em>with</em> и часть <em>catch</em> инструкции <em>try {…} catch {…}</em>. Обе они добавляют в начало Scope chain объект, необходимый для поиска значений переменных, фигурирующих в рамках данных инструкций. Т.е., если имеет место один из этих случаев, Scope схематически модифицируется следующим образом:</p>
<div><div id="highlighter_508899" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">Scope = Объект[</code><code class="jscript keyword">with</code><code class="jscript plain">|</code><code class="jscript keyword">catch</code><code class="jscript plain">] + AO|VO + [[Scope]]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Инструкция <em>with</em> в данном случае добавляет объект, являющийся её параметром (и, таким образом, нам становятся доступны свойства этого объекта без использования префикса):</p>
<div><div id="highlighter_840261" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">foo = {x: 10, y: 20};</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">with</code> <code class="jscript plain">(foo) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(y);</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Модификация Scope:</p>
<div><div id="highlighter_48723" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">Scope = foo + AO|VO + [[Scope]]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Покажем ещё раз, что имя переменной будет найдено при разрешении в объекте, добавленном инструкцией <em>with</em> в начало scope chain:</p>
<div><div id="highlighter_532313" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10, y = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">with</code> <code class="jscript plain">({x: 20}) {</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 30, y = 30;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x); </code><code class="jscript comments">// 30</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(y); </code><code class="jscript comments">// 30</code></div><div class="line number9 index8 alt2"><code class="jscript plain">}</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript plain">alert(x); </code><code class="jscript comments">// 10</code></div><div class="line number12 index11 alt1"><code class="jscript plain">alert(y); </code><code class="jscript comments">// 30</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Что здесь произошло? Ещё на этапе входа в контекст, в объект переменных были добавлены имена <em>“x”</em> и <em>“y”</em>. Далее, уже на этапе выполнения кода, были произведены следующие модификации:</p>
<ul>
<li>x = 10, y = 10;</li>
<li>добавился объект <em>{x: 20}</em> в начало scope chain;</li>
<li>встретившаяся инструкция <em>var</em> внутри <em>with</em>, естественно, ничего не создавала, поскольку все <em>var-ы</em> были разобраны и добавлены ещё при ходе в контекст;
</li><li>произошла лишь модификация значения <em>“x”</em>, и именно той <em>“x”</em>, которая будет найдена теперь в объекте, добавленном в scope chain во втором пункте; значение этой <em>“x”</em> было 20, и стало 30;</li>
<li>также произошло изменение переменной <em>“y”</em>, которая будет найдена в объекте переменных выше; соответственно, было 10, стало 30;</li>
<li>далее, после отработки <em>with</em>, её спецобъект был удалён из scope chain (и вместе с ним, изменённое значение <em>“x”</em> – 30);</li>
<li>что и можно видеть в последних двух <em>alert-ах</em>: значение <em>“x”</em> текущего объекта переменных осталось неизменным, значение же <em>“y”</em> теперь равно 30 и было изменено ещё при работе инструкции <em>with</em>.</li>
</ul>
<p class="cye-lm-tag">Также, часть <em>catch</em> инструкции <em>try {…} catch {…}</em> для того, чтобы был доступен параметр-исключение <em>catch</em>, создаёт новый объект и добавляет в него единственное свойство – параметр-исключение. Схематично можно представить так:</p>
<div><div id="highlighter_485164" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">try</code> <code class="jscript plain">{</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">...</code></div><div class="line number3 index2 alt2"><code class="jscript plain">} </code><code class="jscript keyword">catch</code> <code class="jscript plain">(ex) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(ex);</code></div><div class="line number5 index4 alt2"><code class="jscript plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Модификация Scope:</p>
<div><div id="highlighter_240108" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">__catchObject = {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">ex: &lt;объект-исключение&gt;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">};</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">Scope = __catchObject + AO|VO + [[Scope]]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">После отработки данных инструкций, Scope восстанавливается к состоянию, которое цепь имела до их воздействия.</p>
<h2 id="zaklyuchenie" class="header-link"><a href="#zaklyuchenie">Заключение</a></h2>
<p class="cye-lm-tag">На данном этапе, мы разобрали практически все ключевые моменты, касающиеся контекстов исполнения и связанных с ними сущностей. Далее, по плану, – подробный разбор объектов-функций: типы функций (FunctionDeclaration, FunctionExpression) и замыкания (кстати, замыкания напрямую связаны с разобранным в данной статье свойством [[Scope]], но об этом – в очередной заметке). Буду рад ответить на ваши вопросы в комментариях.</p>
<h2 id="dopolnitelnaya-literatura" class="header-link"><a href="#dopolnitelnaya-literatura">Дополнительная литература</a></h2>
<ul>
<li>8.6.2 – <a href="http://bclary.com/2004/11/07/#_Scope_" title="[[Scope]]">[[Scope]]</a></li>
<li>10.1.4 – <a href="http://bclary.com/2004/11/07/#a-10.1.4" title="Иерархия областей видимости и разрешение идентификаторов">Иерархия областей видимости и разрешение идентификаторов</a></li>
</ul>
<p align="right" class="cye-lm-tag"><em>Автор: Dmitry A. Soshnikov.<br>
Дата публикации: 01.07.2009</em></p>
<p class="cye-lm-tag">
					</p></div>
<br><hr>
<div id="comments" class="comments-area cye-lm-tag">
				
			
			
			<ol class="commentlist cye-lm-tag">
						<li class="comment even thread-even depth-1" id="li-comment-16498">
		<article id="comment-16498" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Дмитрий, спасибо за Ваши статьи.<br>
По мере прочтения у меня, человека далёкого от JS, возник вопрос.<br>
Свойство <code>[[Scope]]</code> создаётся для всех типов функций? То есть для FE функции оно тоже будет создано?<br>
И ещё не совсем понимаю, что вклаывает в себя понятие “создание функции”. Вы пишите, что <code>[[Scope]]</code> назначается при создании ф-ии.<br>
Что на более низком уровне означает создание FE функции?</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-16538">
		<article id="comment-16538" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>Konstantin</b></p>
<p class="cye-lm-tag">Да, согласно алгоритму создания функций (см. <a href="http://es5.github.com/#x13.2" rel="nofollow">ES5 13.2</a>, пункт 9), свойство <code>[[Scope]]</code> создается для любой функции.</p>
<p class="cye-lm-tag">Другой вопрос, что хранится в <code>[[Scope]]</code> конкретного типа функции (подробней <a href="http://es5.github.com/#x13" rel="nofollow">здесь</a>) — так для функций <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/#funktsii-sozdannyie-konstruktorom-function" rel="nofollow">созданных с помощью конструктора <code>Function</code></a>, свойство <code>[[Scope]]</code> содержит только глобальный объект:</p>
<div><div id="highlighter_118678" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 100;</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 200;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">FE = </code><code class="jscript keyword">function</code><code class="jscript plain">() {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">console.log(x, y);</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">F = </code><code class="jscript keyword">new</code> <code class="jscript plain">Function(</code><code class="jscript string">'console.log(x); console.log(y);'</code><code class="jscript plain">);</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">FE(); </code><code class="jscript comments">// 100, 200</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">F(); </code><code class="jscript comments">// 10, "y" is not defined</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="jscript plain">})();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Что же касается внутреннего представления, то это уже зависит от конкретного движка, здесь уже свои оптимизации могут быть. <a href="http://es5.github.com/#x13.2" rel="nofollow">Абстрактно же</a> — это “native ECMAScript object”, у которого <code>[[Class]]</code> задан как <code>"Function"</code>.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-16830">
		<article id="comment-16830" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Дмитрий, скажите, пожалуйста, если для функции foo (первый пример, “Двумерный анализ Score”) создается AO, а объекты активации прототипа не имеют, то откуда берется 10?<br>
Или же если это создается VO для переменной x (которое имеет прототип), то почему тогда во втором примере (если убрать var, то x станет такой же глобальной переменной как и в первом примере) присвоение Object.prototype.x = 10; не меняет ее значения при вызове из bar? То есть уточните, пожалуйста, что для чего создается: VO для х, АО для foo и bar и как эти 2 примера работают (часть 2 цикла статей не помогла мне в этом вопросе)?</p>
<p class="cye-lm-tag">Спасибо</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-16867">
		<article id="comment-16867" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>Eli</b></p>
<blockquote><p class="cye-lm-tag">объекты активации прототипа не имеют, то откуда берется 10</p></blockquote>
<p class="cye-lm-tag">Это “фича” SpiderMonkey (Firefox). Там глобальный объект наследует (в итоге) от <code>Object.prototype</code>.</p>
<p class="cye-lm-tag">Когда идет обращение к <code>x</code> из <code>foo</code>, осуществляется поиск <code>x</code> в цепи областей видимости, начиная с <code>foo</code> и вверх по иерархии.</p>
<p class="cye-lm-tag">Проверяется каждый AO в этой цепи. Здесь только два таких объекта: сам AO функции <code>foo</code> (тут <code>x</code> не найден), и глобальный объект (и здесь <code>x</code> не найден).</p>
<p class="cye-lm-tag">Однако, помимо самого объекта в цепи областей видимости, проверяются еще и <em>прототипы</em> (если они есть!). У AO нет прототипов, а у глобального объекта — есть, и это <code>Object.prototype</code> (в одном из звеньев); там-то <code>x</code> и найден.</p>
<blockquote><p class="cye-lm-tag"> если убрать var, то x станет такой же глобальной переменной как и в первом примере</p></blockquote>
<p class="cye-lm-tag">Не совсем “такой же.” <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/#o-peremennyih" rel="nofollow">Если убрать <code>var</code></a>, создается свойство глобального объекта. Сооветственно, оно затеняет свойство из <code>Object.prototype</code>, т.к. найдено раньше:</p>
<div><div id="highlighter_144768" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">Object.prototype.x = 20;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript plain">console.log(x); </code><code class="jscript comments">// 10, из глобального объекта</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript keyword">delete</code> <code class="jscript plain">x;</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">console.log(x); </code><code class="jscript comments">// 20, из Object.prototype</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-19820">
		<article id="comment-19820" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Lists are distinguished from arrays in that lists only allow sequential access, while arrays allow random access.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 cye-lm-tag" id="li-comment-22979">
		<article id="comment-22979" class="comment cye-lm-tag">
			
<div class="comment-content  cye-lm-tag"><p class="cye-lm-tag">Спасибо большое за статьи. Вот функция   </p>
<div class="cye-lm-tag"><div id="highlighter_947262" class="syntaxhighlighter dsHightlight jscript cye-lm-tag"><table border="0" cellpadding="0" cellspacing="0" class="cye-lm-tag"><tbody class="cye-lm-tag"><tr class="cye-lm-tag"><td class="code cye-lm-tag"><div class="container cye-lm-tag"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">f() </code></div><div class="line number2 index1 alt1"><code class="jscript plain">{</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(arguments.length &gt; 0)</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">f.F1 = </code><code class="jscript keyword">function</code><code class="jscript plain">() {</code><code class="jscript keyword">return</code> <code class="jscript plain">a;} </code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">else</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">{</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">eval(</code><code class="jscript string">'var a = 0'</code><code class="jscript plain">);</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">f.F2 = </code><code class="jscript keyword">function</code><code class="jscript plain">() {</code><code class="jscript keyword">return</code> <code class="jscript plain">a;}</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">f(0);</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}&nbsp; </code></div><div class="line number11 index10 alt2"><code class="jscript plain">}</code></div><div class="line number12 index11 alt1"><code class="jscript plain">f();</code></div><div class="line number13 index12 alt2"><code class="jscript plain">f.F1();</code></div><div class="line number14 index13 alt1"><code class="jscript plain">f.F2();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Почему F1 не видит “а”, а F2 видит?</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-22990">
		<article id="comment-22990" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>Oleg</b></p>
<blockquote><p class="cye-lm-tag">Почему F1 не видит “а”, а F2 видит?</p></blockquote>
<p class="cye-lm-tag">Потому что при рекурсивном вызове — <code>f(0)</code> переменная <code>a</code> не создается. Когда запускается функция (рекурсивно или нет — не важно) — всегда создается свежий AO. И AO первого вызова (где создается <code>a</code>, и которая видна для <code>F2</code>) никакого отношения ко второму вызову не имеет (где создается <code>F1</code>, но не создается <code>a<c ode="">).</c></code></p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-39540">
		<article id="comment-39540" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Отличная серия статей. Спасибо.</p>
<p class="cye-lm-tag">Возник вопрос. Какой порядок поиска переменной? AO-&gt;[[Prototype]]-&gt;[[Scope]] или AO-&gt;[[Scope]]-&gt;[[Prototype]]</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-39686">
		<article id="comment-39686" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>MrZorg</b>, по спецификации AO не имеют прототипа. Поэтому поиск всегда осуществляется только в AO и дальше в <code>[[Scope]]</code>.</p>
<p class="cye-lm-tag">Некоторые старые реализации могли задавать прототип AO, и поиск был бы <code>AO.[[Prototype]]</code> -&gt; <code>[[Scope]]</code>, но в данный момент такого поведения не наблюдается.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
			</ol><!-- .commentlist -->
		
	</div>
<br><hr>
	<h2>Замыкания</h2>
	<a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-6-closures/">src2</a>
	<div class="entry-content" itemprop="mainContentOfPage">
		<p class="cye-lm-tag">Read this article in: <a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" title="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">English</a>, <a href="http://goddyzhao.tumblr.com/post/11311499651/closures">Chinese</a>.</p>
<div class="ds-toc"><ol><li><a href="#vvedenie" title="Введение">Введение</a></li><li><a href="#obschaya-teoriya" title="Общая теория">Общая теория</a><ol><li><a href="#opredeleniya" title="Определения">Определения</a></li><li><a href="#funarg-problema" title="Фунарг-проблема">Фунарг-проблема</a></li><li><a href="#zamyikanie" title="Замыкание">Замыкание</a></li></ol></li><li><a href="#realizatsiya-zamyikaniy-v-ecmascript" title="Реализация замыканий в ECMAScript">Реализация замыканий в ECMAScript</a><ol><li><a href="#odin-scope-na-vseh" title="Один [[Scope]] на “всех”">Один [[Scope]] на “всех”</a></li><li><a href="#funarg-i-return" title="Фунарг и return">Фунарг и return</a></li><li><a href="#versii-teorii" title="Версии теории">Версии теории</a></li></ol></li><li><a href="#primenenie-zamyikaniy" title="Применение замыканий">Применение замыканий</a></li><li><a href="#zaklyuchenie" title="Заключение">Заключение</a></li><li><a href="#dopolnitelnaya-literatura" title="Дополнительная литература">Дополнительная литература</a></li></ol></div><p class="cye-lm-tag"></p>
<h2 id="vvedenie" class="header-link"><a href="#vvedenie">Введение</a></h2>
<p class="cye-lm-tag">В этой заметке мы поговорим об одной из наиболее обсуждаемых тем, связанных с JavaScript — о <em>замыканиях</em>. Тема, по сути, избита; существует немалое количество статей, посвящённых этой структуре (некоторые из них очень хорошие, например, статья R. Cornford-a, представленная в списке дополнительной литературы), однако мы постараемся разобрать её более с теоретической точки зрения, и посмотрим, как замыкания в ECMAScript устроены изнутри.<br>
<span id="more-29" class="cye-lm-tag"></span></p>
<p class="cye-lm-tag">Как я уже отмечал в предыдущих статьях (и в комментариях к ним), данный цикл статей является зависимым от предыдущих частей, поэтому желательно, если есть необходимость, прочесть ранние части данного ряда. И, если необходимость всё же есть, то для полного понимания данной части <em>обязательной к прочтению</em> является <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">часть 4</a> <em>(Цепь областей видимости, Scope chain)</em> и, возможно, связанная с ней ранняя статья – <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">часть 2</a> <em>(Объект переменных, Variable object)</em>.</p>
<h2 id="obschaya-teoriya" class="header-link"><a href="#obschaya-teoriya">Общая теория</a></h2>
<p class="cye-lm-tag">Прежде, чем мы перейдём к замыканиям непосредственно в ECMAScript, стоит уточнить ряд определений из общей теории <a href="http://ru.wikipedia.org/wiki/Функциональное_программирование">функционального программирования</a> (безотносительно стандарта ECMA-262-3). В качестве примеров, поясняющих определения, будем использовать, всё же, ECMAScript.</p>
<p class="cye-lm-tag">Как известно, в функциональных языках (и ECMAScript поддерживает эту парадигму и стилистику), функции являются данными, т.е. их можно сохранять в переменные, передавать в качестве значений другим функциям, возвращать из функций и т.д. Подобные функции имеют обособленные названия и структуру.</p>
<h3 id="opredeleniya" class="header-link"><a href="#opredeleniya">Определения</a></h3>
<p class="definition cye-lm-tag"><em>Функциональный аргумент (Functional argument, “Funarg”, “Фунарг”)</em> — аргумент, значением которого является функция.</p>
<p class="cye-lm-tag">Пример:</p>
<div><div id="highlighter_157076" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">exampleFunc(funArg) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">funArg();</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript plain">exampleFunc(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(</code><code class="jscript string">'funArg'</code><code class="jscript plain">);</code></div><div class="line number7 index6 alt2"><code class="jscript plain">});</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Фактическим параметром, сопоставленным с фунаргом, в данном случае является анонимная функция, переданная функции <em>exampleFunc</em>.</p>
<p class="cye-lm-tag">В свою очередь, функции, принимающие функциональные аргументы, называются <em>функциями высшего порядка (ФВП, higher-order functions, HOF)</em>. Другое название таких функций — <em>функционалы (functional)</em> или, ближе к математике, <em>операторы</em>. В примере выше, <em>exampleFunc</em> является функционалом.</p>
<p class="cye-lm-tag">Как уже было сказано, функция может быть не только передана в качестве аргумента, но и возвращена в качестве значения из другой функции. Функции, возвращающие функции, называются <em>функциями с функциональным значением (function valued functions)</em>.</p>
<div><div id="highlighter_157402" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">functionValued() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(</code><code class="jscript string">'returned function is called'</code><code class="jscript plain">);</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number5 index4 alt2"><code class="jscript plain">})()();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Функциональные аргументы, функционалы и функции с функциональным значением, называются <em>функциями первого класса (first-class functions)</em> или более обще — <em>объекты первого класса (first-class objects)</em>. В ECMAScript все функции являются функциями первого класса.</p>
<p class="cye-lm-tag">Функционал, который получает себя в качестве аргумента, называется <em>автоаппликативной функцией (self-applicative, auto-applicative)</em>:</p>
<div><div id="highlighter_827056" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">selfApplicative(funArg) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(funArg &amp;&amp; funArg === selfApplicative) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(</code><code class="jscript string">'self-applicative'</code><code class="jscript plain">);</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code><code class="jscript plain">;</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">selfApplicative(selfApplicative);</code></div><div class="line number7 index6 alt2"><code class="jscript plain">})();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Функция, возвращающая сама себя, называется <em>авторепликативной (self-replicative, auto-replicative)</em>. Иногда, в литературе фигурирует название – <em>самовоспроизводящаяся функция (self-reproducing)</em>:</p>
<div><div id="highlighter_658144" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">selfReplicative() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">selfReplicative;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">})();</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Переменные, описанные внутри функционального аргумента, доступны, естественно, и при активации фунарга (поскольку, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">объект переменных</a>, хранящий данные контекста, создаётся каждый раз при входе в контекст):</p>
<div><div id="highlighter_836685" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">testFn(funArg) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// активация фунарга, доступна</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// локальная переменная localVar</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">funArg(10); </code><code class="jscript comments">// 20</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">funArg(20); </code><code class="jscript comments">// 30</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">testFn(</code><code class="jscript keyword">function</code> <code class="jscript plain">(arg) {</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">localVar = 10;</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(arg + localVar);</code></div><div class="line number11 index10 alt2"><code class="jscript plain">});</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Однако, как нам известно (в частности, из <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">части 4</a> данных заметок), функции в ECMAScript могут быть вложенными, а также использовать переменные из вышестоящих контекстов. С последним свойством связана, так называемая, <em>фунарг-проблема</em>.</p>
<h3 id="funarg-problema" class="header-link"><a href="#funarg-problema">Фунарг-проблема</a></h3>
<p class="cye-lm-tag">В <a href="http://ru.wikipedia.org/wiki/Стековый_язык">стековых языках программирования</a>, локальные переменные функции хранятся в стеке, который наполняется новыми элементами при активации функции; при выходе из функции, эти переменные удаляются из стека. Данная модель является большим ограничением для использования функций в качестве функциональных значений (при возврате из функции). Наиболее характерно проблема проявляется при использовании в функции <em>свободных переменных</em>.</p>
<p class="definition cye-lm-tag"><em>Свободная переменная (Free variable)</em> — переменная, используемая функцией, но не являющаяся ни параметром, ни локальной переменной этой функции.</p>
<p class="cye-lm-tag">Пример:</p>
<div><div id="highlighter_200144" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">testFn() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">localVar = 10;</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">function</code> <code class="jscript plain">innerFn(innerParam) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(innerParam + localVar);</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">innerFn;</code></div><div class="line number7 index6 alt2"><code class="jscript plain">}</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">someFn = testFn();</code></div><div class="line number10 index9 alt1"><code class="jscript plain">someFn(20); </code><code class="jscript comments">// 30</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">В данном случае, для функции “innerFn” свободной переменной является “localVar”.</p>
<p class="cye-lm-tag">Если бы в данной системе использовалась стековая реализация для хранения локальных переменных, это означало бы, что по завершении функции “testFn”, все её локальные переменные должны были бы удалиться из стека, что привело бы к ошибке при вызове функции “innerFn” снаружи посредством “someFn” (более того, конкретно в данном случае, при стековой организации, и сам возврат функции “innerFn” был бы невозможен, т.к. “innerFn” так же является локальной функцией для функции “testFn” и будет удалена по завершению “testFn”).</p>
<p class="cye-lm-tag">Ещё одной проблемой, связанной с функциями-объектами, является передача функции в качестве аргумента при организации системы с <a href="http://en.wikipedia.org/wiki/Scope_(programming)#Dynamic_scoping">динамической областью видимости</a>:</p>
<div><div id="highlighter_669351" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">someFn() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number4 index3 alt1"><code class="jscript plain">}</code></div><div class="line number5 index4 alt2"><code class="jscript plain">someFn(); </code><code class="jscript comments">// 10 - и при статической и при динамической Scope</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 20;</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">someFn(); </code><code class="jscript comments">// 10 - при статической, 20 - при динамической Scope</code></div><div class="line number10 index9 alt1"><code class="jscript plain">})();</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript comments">// аналогично, при передаче someFn</code></div><div class="line number13 index12 alt2"><code class="jscript comments">// в качестве параметра</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">(funArg) {</code></div><div class="line number16 index15 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">x = 30;</code></div><div class="line number17 index16 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">funArg(); </code><code class="jscript comments">// 10 - при статической, 30 - при динамической Scope</code></div><div class="line number18 index17 alt1"><code class="jscript plain">})(someFn);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">То есть, видим, что при организации системы с динамической областью видимости, разрешение имени переменной осуществляется в пределах динамического (активного) стека переменных (свободная переменная ищется в динамической цепи <em>вызова</em>, а не в статической цепи <em>создания</em> функции), что может привести к неоднозначности. При этом, даже, если “x” будет определена (в отличии от предыдущего примера, где локальные переменные удалились бы из стека и были бы не определены), возникнет вопрос, какое из значений “x” (точнее, “x” из какого контекста, какой области видимости) должно использоваться в различных вызовах функции “someFn”?</p>
<p class="cye-lm-tag">Описанные случаи – являются двумя разновидностями <em>фунарг-проблемы</em> – в зависимости от того, имеем ли мы дело с функциональным аргументом, передаваемым функционалу <em>(downward funarg)</em>, или же с функциональным значением, возвращаемым из функции <em>(upward funarg)</em>.</p>
<p class="cye-lm-tag">Для решения данной проблемы (и её подвидов) было предложено понятие <em>замыкания</em>.</p>
<h3 id="zamyikanie" class="header-link"><a href="#zamyikanie">Замыкание</a></h3>
<p class="definition cye-lm-tag"><em>Замыкание (Closure)</em> или более полно — <em>лексическое замыкание (Lexical closure)</em> — это совокупность блока кода и данных того контекста, в котором этот блок порождён.</p>
<p class="cye-lm-tag">Пример псевдокодом:</p>
<div><div id="highlighter_169501" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 20;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">testFn() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(a); </code><code class="jscript comments">// свободная переменная "а" == 20</code></div><div class="line number4 index3 alt1"><code class="jscript plain">}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript comments">// Замыкание для testFn</code></div><div class="line number7 index6 alt2"><code class="jscript plain">closureForTestFn = {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">call: testFn </code><code class="jscript comments">// сама функция</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">lexicalContext: {a: 20} </code><code class="jscript comments">// контекст для поиска свободных переменных</code></div><div class="line number10 index9 alt1"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">В примере выше, “closureForTestFn”, естественно, является псевдокодом, тогда как в ECMAScript сама функция testFn уже содержит свойством цепь областей видимости контекста, в котором она была порождена.</p>
<p class="cye-lm-tag">Слово “лексическое” часто опускается, т.к. подразумевается по-умолчанию, и, в данном случае, оно акцентирует внимание на том, что при создании замыкания, вместе с ним запоминаются данные из контекста, в котором блок кода порождается. При последующих активациях данного блока кода свободные переменные будут использоваться именно из этого запомненного <em>(замкнутого)</em> контекста, что и можно видеть в примерах выше, когда переменная “x” всегда имеет значение 10.</p>
<p class="cye-lm-tag">В определении мы использовали обобщённое понятие – “блок кода”, тогда как в большинстве случаев (в  частности, ECMAScript) фигурирует понятие “функция”, которое мы и будем использовать. Однако, не во всех реализациях замыкание ассоциируется лишь с функциями: например, в языке программирования Ruby, замыканиями могут служить объект-процедура, лямбда-выражение, а также блок кода.</p>
<p class="cye-lm-tag">Что же касается реализаций, для хранения локальных переменных, после того, как контекст уничтожен, стековая организация уже не подходит (поскольку, это противоречит самой стековой структуре). Поэтому в данном случае, как правило, используется хранение данных лексического контекста в <a href="http://ru.wikipedia.org/wiki/Динамически_распределяемая_память">динамически распределяемой памяти</a> (“куча”, “хип”, heap) с использованием сборщика мусора (Garbage collector, GC) и подсчётом ссылок, что является менее эффективным по быстродействию, чем стековая организация. Однако реализации всегда вправе сделать оптимизацию: на этапе парсинга кода определить, используются ли в функции свободные переменные, используются ли функции в качестве функциональных аргументов или функциональных значений, и, в зависимости от этого, решить — размещать ли данные в стеке или “куче”.</p>
<h2 id="realizatsiya-zamyikaniy-v-ecmascript" class="header-link"><a href="#realizatsiya-zamyikaniy-v-ecmascript">Реализация замыканий в ECMAScript</a></h2>
<p class="cye-lm-tag">Разобравшись с теорией, мы наконец-то подошли к замыканиям непосредственно в ECMAScript. Здесь стоит отметить, что ECMAScript использует исключительно <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29#Lexical_scoping">статическую (лексическую) область видимости</a> (тогда как в некоторых языках, например, Perl, переменная может быть объявлена как в статической, так и в динамической области видимости).</p>
<div><div id="highlighter_677175" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">testFn() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(a);</code></div><div class="line number4 index3 alt1"><code class="jscript plain">}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">(funArg) {</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">a = 20;</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// "a" для funArg запомнилось статически из</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// порождаемого её (лексического) контекста,</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// поэтому:</code></div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">funArg(); </code><code class="jscript comments">// 10, а не 20</code></div><div class="line number12 index11 alt1"><code class="jscript plain">})(testFn);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Технически, порождающий функцию лексический контекст запоминается внутренним свойством функции <em>[[Scope]]</em>. Если на данном этапе есть какие-нибудь неясности со свойством [[Scope]], я настоятельно рекомендую вернуться и прочесть <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">часть 4</a>, посвященную цепи областей видимости (Scope chain), где свойство [[Scope]] разбиралось подробно. По сути, если вы полностью разберётесь со [[Scope]] и Scope chain, вопрос о понимании замыканий в ECMAScript отпадёт сам собой.</p>
<p class="cye-lm-tag">Обращаясь к <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/#algoritm-sozdaniya-funktsiy">алгоритму создания функций</a> в ECMAScript, мы видим, что <em>все функции в ECMAScript являются замыканиями</em>, поскольку <em>все без исключения ещё при создании запоминают Scope chain порождающего контекста</em> (независимо от того, будет ли функция вызвана или нет – [[Scope]] в неё уже записался при создании):</p>
<div><div id="highlighter_777149" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">testFn() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(a);</code></div><div class="line number4 index3 alt1"><code class="jscript plain">}</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript comments">// testFn - замыкание</code></div><div class="line number7 index6 alt2"><code class="jscript plain">testFn: &lt;FunctionObject&gt; = {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">[[Call]]: &lt;блок кода testFn&gt;,</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">[[Scope]]: [</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">Global: {</code></div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">a: 10</code></div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">],</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// другие свойства</code></div><div class="line number15 index14 alt2"><code class="jscript plain">};</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Как уже было сказано выше, в целях оптимизации, когда функция не использует свободные переменные, реализации могут не запоминать лексический контекст, однако в спецификации ECMA-262-3 об этом ничего не сказано; поэтому формально (и по технического алгоритму) – все функции запоминают [[Scope]] ещё при создании.</p>
<p class="cye-lm-tag">Некоторые реализации позволяют получить доступ к замкнутому контексту напрямую. К примеру в Rhino, свойству [[Scope]] функции, соответствует нестандартное свойство <em>__parent__</em>, которое мы <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/#osobennost-realizatsiy-svoystvo-__parent__">разбирали</a> в заметке об объекте переменных:</p>
<div><div id="highlighter_750642" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">global = </code><code class="jscript keyword">this</code><code class="jscript plain">;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">x = 10;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">foo = (</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">y = 20;</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(y);</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number9 index8 alt2"><code class="jscript plain">})();</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript plain">foo(); </code><code class="jscript comments">// 20</code></div><div class="line number12 index11 alt1"><code class="jscript plain">alert(foo.__parent__.y); </code><code class="jscript comments">// 20</code></div><div class="line number13 index12 alt2"><code class="jscript plain">foo.__parent__.y = 30;</code></div><div class="line number14 index13 alt1"><code class="jscript plain">foo(); </code><code class="jscript comments">// 30</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="jscript comments">// можно двигаться дальше вверх по scope chain</code></div><div class="line number17 index16 alt2"><code class="jscript plain">alert(foo.__parent__.__parent__ === global); </code><code class="jscript comments">// true</code></div><div class="line number18 index17 alt1"><code class="jscript plain">alert(foo.__parent__.__parent__.x); </code><code class="jscript comments">// 10</code></div></div></td></tr></tbody></table></div></div>
<h3 id="odin-scope-na-vseh" class="header-link"><a href="#odin-scope-na-vseh">Один [[Scope]] на “всех”</a></h3>
<p class="cye-lm-tag">Стоит также отметить, что замкнутый [[Scope]] в ECMAScript является одним и тем же объектом для нескольких замыканий, порождённых в одном лексическом контексте. Это означает, что модификация замкнутой переменной одним замыканием, будет иметь эффект при использовании этой переменной другим замыканием:</p>
<div><div id="highlighter_857032" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">firstClosure;</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">secondClosure;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="jscript keyword">function</code> <code class="jscript plain">testFn() {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">a = 1;</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">firstClosure = </code><code class="jscript keyword">function</code> <code class="jscript plain">() { </code><code class="jscript keyword">return</code> <code class="jscript plain">++a; };</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">secondClosure = </code><code class="jscript keyword">function</code> <code class="jscript plain">() { </code><code class="jscript keyword">return</code> <code class="jscript plain">--a; };</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">a = 2; </code><code class="jscript comments">// воздействие на VO["a"], который в [[Scope]] замыканий</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(firstClosure()); </code><code class="jscript comments">// 3, через firstClosure.[[Scope]]</code></div><div class="line number10 index9 alt1"><code class="jscript plain">}</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="jscript plain">testFn();</code></div><div class="line number13 index12 alt2"><code class="jscript plain">alert(firstClosure()); </code><code class="jscript comments">// 4</code></div><div class="line number14 index13 alt1"><code class="jscript plain">alert(secondClosure()); </code><code class="jscript comments">// 3</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">С этой особенностью связана распространённая ошибка, когда создают функции в циклах, связывая с каждой из них переменную-счётчик цикла (ожидая, что каждая функция запомнит своё значение):</p>
<div><div id="highlighter_373445" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">data = [];</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">for</code> <code class="jscript plain">(</code><code class="jscript keyword">var</code> <code class="jscript plain">k = 0; k &lt; 3; k++) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">data[k] = </code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(k);</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript plain">data[0](); </code><code class="jscript comments">// 3, а не 0</code></div><div class="line number9 index8 alt2"><code class="jscript plain">data[1](); </code><code class="jscript comments">// 3, а не 1</code></div><div class="line number10 index9 alt1"><code class="jscript plain">data[2](); </code><code class="jscript comments">// 3, а не 2</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Предыдущий пример объясняет данное поведение – Scope порождающего контекста — один на три функции (каждая функция ссылается на него через [[Scope]]), и переменная “k” в нём может свободно меняться.</p>
<p class="cye-lm-tag">Схематично:</p>
<div><div id="highlighter_592915" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">activeContext.Scope = [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// вышестоящие объекты переменных</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">{data: [...], k: 3} </code><code class="jscript comments">// объект переменных порождающего контекста</code></div><div class="line number4 index3 alt1"><code class="jscript plain">];</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="jscript plain">data[0].[[Scope]] === Scope;</code></div><div class="line number7 index6 alt2"><code class="jscript plain">data[1].[[Scope]] === Scope;</code></div><div class="line number8 index7 alt1"><code class="jscript plain">data[2].[[Scope]] === Scope;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Соответственно, на момент активации функций, выводится последнее присвоенное значение “k”, т.е. 3.</p>
<p class="cye-lm-tag">Исправить данное положение позволяет создание дополнительного объекта переменных в [[Scope]] функций, посредством создания ещё одной вложенной функции:</p>
<div><div id="highlighter_68083" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">data = [];</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">for</code> <code class="jscript plain">(</code><code class="jscript keyword">var</code> <code class="jscript plain">k = 0; k &lt; 3; k++) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">data[k] = (</code><code class="jscript keyword">function</code> <code class="jscript plain">_helper(x) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(x);</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">})(k); </code><code class="jscript comments">// передаём "k"</code></div><div class="line number8 index7 alt1"><code class="jscript plain">}</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="jscript comments">// теперь всё в порядке</code></div><div class="line number11 index10 alt2"><code class="jscript plain">data[0](); </code><code class="jscript comments">// 0</code></div><div class="line number12 index11 alt1"><code class="jscript plain">data[1](); </code><code class="jscript comments">// 1</code></div><div class="line number13 index12 alt2"><code class="jscript plain">data[2](); </code><code class="jscript comments">// 2</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">В данном случае, функция “_helper” создаётся и тут же запускается с параметром “k”. Результатом функции “_helper” является также функция, и именно она записывается в соответствующий элемент массива “data”. Данная тактика приводит к следующему эффекту: активируясь, “_helper” каждый раз создаёт новый объект переменных, в котором присутствует переменная-параметр “x” (значением этого параметра является переданное значение “k”). Таким образом, [[Scope]] возвращаемых функций будут следующими:</p>
<div><div id="highlighter_58806" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">data[0].[[Scope]] === [</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// вышестоящие объекты переменных</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста примера: {data: [...], k: 3},</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста _helper: {x: 0}</code></div><div class="line number5 index4 alt2"><code class="jscript plain">];</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript plain">data[1].[[Scope]] === [</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// вышестоящие объекты переменных</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста примера: {data: [...], k: 3},</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста _helper: {x: 1}</code></div><div class="line number11 index10 alt2"><code class="jscript plain">];</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript plain">data[2].[[Scope]] === [</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// вышестоящие объекты переменных</code></div><div class="line number15 index14 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста примера: {data: [...], k: 3},</code></div><div class="line number16 index15 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">VO контекста _helper: {x: 2}</code></div><div class="line number17 index16 alt2"><code class="jscript plain">];</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Видим, что теперь [[Scope]] функций имеют ссылку на нужное значение (посредством переменной “x”) и для этого нам понадобилось создать дополнительный объект переменных в [[Scope]] (из возвращённых функций также, естественно, можно обратиться и к переменной “k”, всё с тем же, правильным для всех функций, значением 3).</p>
<p class="cye-lm-tag">Кстати, часто в различных статьях о JavaScript замыканиями (неполно) называют лишь данную конструкцию (с созданием дополнительного VO в [[Scope]] порождаемых функций). Действительно, с прикладной точки зрения особенно важным является именно этот приём, однако, как уже было отмечено, фактически к замыканиям в ECMAScript можно отнести все функции.</p>
<p class="cye-lm-tag">Однако, данный приём не является единственным решением. Зафиксировать нужное значение “k”, например, можно было и так:</p>
<div><div id="highlighter_636390" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">data = [];</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">for</code> <code class="jscript plain">(</code><code class="jscript keyword">var</code> <code class="jscript plain">k = 0; k &lt; 3; k++) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">(data[k] = </code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments.callee.x);</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}).x = k; </code><code class="jscript comments">// запоминаем "k" свойством функции</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number8 index7 alt1"><code class="jscript comments">// также, всё в порядке</code></div><div class="line number9 index8 alt2"><code class="jscript plain">data[0](); </code><code class="jscript comments">// 0</code></div><div class="line number10 index9 alt1"><code class="jscript plain">data[1](); </code><code class="jscript comments">// 1</code></div><div class="line number11 index10 alt2"><code class="jscript plain">data[2](); </code><code class="jscript comments">// 2</code></div></div></td></tr></tbody></table></div></div>
<h3 id="funarg-i-return" class="header-link"><a href="#funarg-i-return">Фунарг и return</a></h3>
<p class="cye-lm-tag">И ещё одна особенность — это возврат из замыканий. В ECMAScript инструкция <em>return</em> из замыкания возвращает управление <em>вызывающему</em> контексту. В других языках, например, в Ruby, возможны различные формы замыканий, по-разному обрабатывающие return: в некоторых случаях это может быть возврат в вызывающий контекст, в других — полный выход из активного контекста.</p>
<p class="cye-lm-tag">Стандартное поведение <em>return</em> в ECMAScript:</p>
<div><div id="highlighter_399485" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">getElement() {</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">[1, 2, 3].forEach(</code><code class="jscript keyword">function</code> <code class="jscript plain">(element) {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(element % 2 == 0) {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// возврат в функционал - .forEach,</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// но не выход из getElement</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(</code><code class="jscript string">'found: '</code> <code class="jscript plain">+ element); </code><code class="jscript comments">// found: 2</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">element;</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">});</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">null</code><code class="jscript plain">;</code></div><div class="line number14 index13 alt1"><code class="jscript plain">}</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="jscript plain">alert(getElement()); </code><code class="jscript comments">// null, а не 2</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Чтобы выйти из нужного контекста, в ECMAScript можно воспользоваться специальным “break”-исключением:</p>
<div><div id="highlighter_146641" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">$</code><code class="jscript keyword">break</code> <code class="jscript plain">= {};</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript keyword">function</code> <code class="jscript plain">getElement() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">try</code> <code class="jscript plain">{</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">[1, 2, 3].forEach(</code><code class="jscript keyword">function</code> <code class="jscript plain">(element) {</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(element % 2 == 0) {</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript comments">// "return" из getElement</code></div><div class="line number11 index10 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(</code><code class="jscript string">'found: '</code> <code class="jscript plain">+ element); </code><code class="jscript comments">// found: 2</code></div><div class="line number12 index11 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">$</code><code class="jscript keyword">break</code><code class="jscript plain">.data = element;</code></div><div class="line number13 index12 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">throw</code> <code class="jscript plain">$</code><code class="jscript keyword">break</code><code class="jscript plain">;</code></div><div class="line number14 index13 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number15 index14 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number16 index15 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">});</code></div><div class="line number17 index16 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number18 index17 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">} </code><code class="jscript keyword">catch</code> <code class="jscript plain">(e) {</code></div><div class="line number19 index18 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(e == $</code><code class="jscript keyword">break</code><code class="jscript plain">) {</code></div><div class="line number20 index19 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">$</code><code class="jscript keyword">break</code><code class="jscript plain">.data;</code></div><div class="line number21 index20 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number22 index21 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number23 index22 alt2"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number24 index23 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript keyword">null</code><code class="jscript plain">;</code></div><div class="line number25 index24 alt2"><code class="jscript plain">}</code></div><div class="line number26 index25 alt1"><code class="jscript spaces">&nbsp;</code>&nbsp;</div><div class="line number27 index26 alt2"><code class="jscript plain">alert(getElement()); </code><code class="jscript comments">// 2</code></div></div></td></tr></tbody></table></div></div>
<h3 id="versii-teorii" class="header-link"><a href="#versii-teorii">Версии теории</a></h3>
<p class="cye-lm-tag">Часто замыкания путают, либо неверно приравнивают (почему-то) к анонимным функциям. Это, не так, поскольку, как мы видели – все функции (не зависимо от вида: анонимная, именованная, FE, FD), в виду механизма Scope chain, являются замыканиями (исключение могут составлять <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/#funktsii-sozdannyie-konstruktorom-function">функции, созданные с помощью конструктора Function</a>, которые в качестве [[Scope]] имеют лишь глобальный объект); и, чтобы не было путаницы, выделим две версии теории замыканий в ECMAScript, которыми можно оперировать:</p>
<p class="cye-lm-tag"><em>Замыканиями в ECMAScript являются</em>:</p>
<ul>
<li><em>с теоретической точки зрения: все функции</em>, т.к. все они запоминают при создании лексический контекcт (и даже в глобальной функции, обращение к глобальной переменной – есть обращение к <em>свободной переменной</em>, а потому – в силу вступает общий для всех функций механизм цепи областей видимости);</li>
<li><em>с практической точки зрения:</em> интерес составляют функции, которые:</li>
<ul>
<li>переживают свой лексический контекст (т.е. являются функциональными значениями, возвращаемыми из функции);</li>
<li>обращаются в коде к свободным переменным.</li>
</ul>
</ul>
<h2 id="primenenie-zamyikaniy" class="header-link"><a href="#primenenie-zamyikaniy">Применение замыканий</a></h2>
<p class="cye-lm-tag">На практике, замыкания позволяют создавать выразительные конструкции, позволяющие кастомизировать различные вычисления по условию, определяемому фунаргом. Примером может служить, например, функция сортировки, принимающая параметром функцию, определяющую порядок сортировки её аргументов:</p>
<div><div id="highlighter_157850" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">[1, 2, 3].sort(</code><code class="jscript keyword">function</code> <code class="jscript plain">(a, b) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">... </code><code class="jscript comments">// условия сортировки</code></div><div class="line number3 index2 alt2"><code class="jscript plain">});</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Или, например, так называемые, <em>отображающие функционалы</em>, как метод массива <em>.map</em> (доступен не во всех реализациях, тестируйте в SpiderMonkey, начиная с версии 1.6), который <em>отображает (map)</em> новый массив по условию функционального аргумента:</p>
<div><div id="highlighter_924124" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">[1, 2, 3].map(</code><code class="jscript keyword">function</code> <code class="jscript plain">(element) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">element * 2;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}); </code><code class="jscript comments">// [2, 4, 6]</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Часто, удобно организовывать функции поиска с помощью функциональных аргументов, определяющих практически неограниченные условия поиска:</p>
<div><div id="highlighter_383851" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">someCollection.find(</code><code class="jscript keyword">function</code> <code class="jscript plain">(element) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">element.someProperty == </code><code class="jscript string">'searchCondition'</code><code class="jscript plain">;</code></div><div class="line number3 index2 alt2"><code class="jscript plain">});</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Также, можно отметить <em>применяющие функционалы</em>, как, например, метод <em>.forEach</em>, который <em>применяет (apply)</em> фунарг к элементам массива:</p>
<div><div id="highlighter_96665" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">[1, 2, 3].forEach(</code><code class="jscript keyword">function</code> <code class="jscript plain">(element) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">if</code> <code class="jscript plain">(element % 2 != 0) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(element);</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">}</code></div><div class="line number5 index4 alt2"><code class="jscript plain">}); </code><code class="jscript comments">// 1, 3</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Кстати, методы объектов-функций <em>.apply</em> и <em>.call</em>, также уходят корнями в <em>применяющие функционалы</em> функционального программирования. Мы уже были знакомы с этими методами в <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/#yavnaya-ustanovka-znacheniya-this-pri-vyizove-funktsiy">заметке о this</a>; здесь, мы видим их в роли применяющих функционалов – функция <em>применяется</em> к аргументам (к списку (массиву) аргументов – в apply, и к позиционным аргументам – в call):</p>
<div><div id="highlighter_86610" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert([].join.call(arguments, </code><code class="jscript string">';'</code><code class="jscript plain">)); </code><code class="jscript comments">// 1;2;3</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}).apply(</code><code class="jscript keyword">this</code><code class="jscript plain">, [1, 2, 3]);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Ещё одним важным примененим замыканий являются <em>отложенные вызовы</em>:</p>
<div><div id="highlighter_932178" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number2 index1 alt1"><code class="jscript plain">setTimeout(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(a); </code><code class="jscript comments">// 10, через секунду</code></div><div class="line number4 index3 alt1"><code class="jscript plain">}, 1000);</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Функции обратного вызова (callback):</p>
<div><div id="highlighter_760689" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">...</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number3 index2 alt2"><code class="jscript comments">// только для примера</code></div><div class="line number4 index3 alt1"><code class="jscript plain">xmlHttpRequestObject.onreadystatechange = </code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// callback, который вызовется отложенно,</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// когда данные будут готовы;</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// переменная "а" здесь доступна,</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// даже несмотря на то, что контекст,</code></div><div class="line number9 index8 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript comments">// породивший "а" уже завершился</code></div><div class="line number10 index9 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert(a); </code><code class="jscript comments">// 10</code></div><div class="line number11 index10 alt2"><code class="jscript plain">};</code></div><div class="line number12 index11 alt1"><code class="jscript plain">..</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Создание обособленной области видимости с целью сокрытия вспомогательных сущностей (инициализирующее пространство):</p>
<div><div id="highlighter_991643" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">testObject = {};</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="jscript comments">// инициализация</code></div><div class="line number4 index3 alt1"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">(object) {</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript keyword">var</code> <code class="jscript plain">a = 10;</code></div><div class="line number6 index5 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">object.getA = </code><code class="jscript keyword">function</code> <code class="jscript plain">_getA() {</code></div><div class="line number7 index6 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript keyword">return</code> <code class="jscript plain">a;</code></div><div class="line number8 index7 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">};</code></div><div class="line number9 index8 alt2"><code class="jscript plain">})(testObject);</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="jscript plain">alert(testObject.getA()); </code><code class="jscript comments">// получение замкнутой "а" - 10 </code></div></div></td></tr></tbody></table></div></div>
<h2 id="zaklyuchenie" class="header-link"><a href="#zaklyuchenie">Заключение</a></h2>
<p class="cye-lm-tag">Данная статья получилась скорее об общей теории, нежели конкретно о стандарте ECMA-262-3, однако я думаю, что эта общая теория позволила более детально приблизиться к понятию замыканий в ECMAScript. Если у вас возникнут вопросы, я с удовольствием отвечу на них в комментариях.</p>
<h2 id="dopolnitelnaya-literatura" class="header-link"><a href="#dopolnitelnaya-literatura">Дополнительная литература</a></h2>
<ul>
<li><a href="http://jibbering.com/faq/notes/closures/">Javascript Closures (by Richard Cornford)</a>
</li><li><a href="http://en.wikipedia.org/wiki/Funarg_problem">Funarg problem</a>
</li><li><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">Closures</a>
</li></ul>
<p class="cye-lm-tag"><strong>Автор:</strong> Dmitry A. Soshnikov<br>
<strong>Дата публикации:</strong> 20.07.2009</p>
<p class="cye-lm-tag">
					</p></div>
<br><hr>
<div id="comments" class="comments-area">
				
							<h2 class="comments-title">
					<i class="comments-title-icon"></i>
					14 Comments				</h2>
			
			
			<ol class="commentlist">
						<li class="comment even thread-even depth-1" id="li-comment-11401">
		<article id="comment-11401" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Это очень крутой цикл статей! Дмитрий, вы молодец!<br>
С новым годом вас.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-16822">
		<article id="comment-16822" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Спасибо, Дмитрий.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-16996">
		<article id="comment-16996" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Соглашусь с похвалами! Вы делаете огромное дело! Спасибо Вам огромное!</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-17350">
		<article id="comment-17350" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Отличный цикл статей. Спасибо, Дмитрий.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-23659">
		<article id="comment-23659" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Сильно!</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-79388">
		<article id="comment-79388" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Здравствуйте, Дмитрий. Оч полезная глубокая серия.</p>
<p class="cye-lm-tag">Прочитал все статьи, и пришел к выводу что наличие в EcmaScript`е концепций Объект, Замыкание, Прототип целиком вытекает из особенности языка иметь функции объектами первого класса (functions – are first-class objects).</p>
<p class="cye-lm-tag">Объясню почему я так думаю.<br>
У нас есть функциональный язык, и мы даём возможность присваивать, передавать и возвращать функции (т.е. делаем их объектами первого класса).<br>
Для этого мы должны решить проблему сохранения внешнего контекста функции (FunArg Problem) в некотором ‘контейнере’, который бы содержал переменные/функции этого контекста (VO/AO). Но такой ‘контейнер’ контекста с переменными/функциями не что иное как Объект с свойствами/методами. Значит достаточно дать юзеру синтаксис ручного определения таких ‘контейнеров’ и мы уже имеем концепт Объекта.<br>
Также, саму связку [текущий контекст функции – внешний (parent) контекст] мы уже можем назвать Замыканием.<br>
А поняв что вложенность функций неограниченна, мы должны прийти к концепту цепочки таких контекстов – Scope Chain (через свойство __parent__ в VO/AO).<br>
Но т.к. SC задается статично, через вложенность блоков в исходном тексте, мы дополнительно даём юзеру возможность ручного гибкого определения цепочек через Прототипы – Prototype Chain (через свойство __proto__ в объектах). Принципиально это таже самая цепочка объектов, которая используется при разрешении идентификатора, только теперь весь resolve происходит в 2D (для каждого объекта в цепочке контекстов (кроме AO), мы должны просмотреть цепочку его прототипов).</p>
<p class="cye-lm-tag">Таким образом, для того чтобы сделать функции объектами первого класса, разработчики языка были вынуждены прийти к концептам объектов и их цепочек, а дальше нужно было лишь дать пользователям возможность “ручного” создания таких Объектов и определения цепочек/иерархий через Прототипы.</p>
<p class="cye-lm-tag">Что Вы думаете насчёт такого анализа?</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-79549">
		<article id="comment-79549" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>Сергей</b>, совершенно верный анализ. Т.е. все вытекало из каких-то практических “неудобст”/”сложностей”, которые нужно было решить (сделали возможность передавать функции – что делать со свободными переменными? – надо придумать замыкание, и т.д.). И, решая эти “неудобвства”, появлялись те или иные конструкции в дизайне языка. Стоит отметить, что они появились задолго до JavaScript <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg"> — во времена Scheme, и еще раньше в 60-ых.</p>
<p class="cye-lm-tag">P.S.: единственное, что прототипы напрямую не связаны со scope chain, но концепция – та же: “наследуемая” цепь объектов, которая по сути является обычным связным списком, который так же появился задолго JS <img draggable="false" class="emoji" alt="😉" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f609.svg"> Я, кстати, тоже использовал цепь прототипов для реализации scope chain: <a href="https://github.com/DmitrySoshnikov/Essentials-of-interpretation/blob/master/src/lesson-5.js#L269-L289" rel="nofollow">https://github.com/DmitrySoshnikov/Essentials-of-interpretation/blob/master/src/lesson-5.js#L269-L289</a></p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-111256">
		<article id="comment-111256" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">На habrahabr есть перевод статьи R. Cornford-a: <a href="http://habrahabr.ru/post/223459/" rel="nofollow">Часть 1</a>, <a href="http://habrahabr.ru/post/229887/" rel="nofollow">Часть 2</a>.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-138680">
		<article id="comment-138680" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Дмитрий, мне не совсем понятно для какой функции вызывается ‘call’ в следующем коде?:</p>
<div><div id="highlighter_770501" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">alert([].join.call(arguments, </code><code class="jscript string">';'</code><code class="jscript plain">));</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}).apply(</code><code class="jscript keyword">this</code><code class="jscript plain">, [1, 2, 3]);</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-138722">
		<article id="comment-138722" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<b>Сергей</b>, это потому, что объект <code>arguments</code> не является массивом, и, соответственно, не имеет метода <code>join</code>. Поэтому мы заимствуем этот метод у (пустого) массива, и вызываем его в контексте объекта <code>arguments</code>.</p>
<p class="cye-lm-tag">Надо сказать, что в ES6 появились rest-параметры, которые являются массивом:</p>
<div><div id="highlighter_164259" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(</code><code class="jscript keyword">function</code> <code class="jscript plain">(...args) {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;</code><code class="jscript plain">console.log(args.join(</code><code class="jscript string">';'</code><code class="jscript plain">));</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}).apply(</code><code class="jscript keyword">this</code><code class="jscript plain">, [1, 2, 3]);</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="li-comment-154025">
		<article id="comment-154025" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">Дмитрий, и все-таки как будет правильней отвечать, если на интервью по JS спросят: “Что такое замыкания?”?</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-154287">
		<article id="comment-154287" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag"><b>Дмитрий</b>, объясните, пожалуйста, для чего в данном коде нужен оператор группировки?</p>
<div><div id="highlighter_250335" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript keyword">var</code> <code class="jscript plain">data = [];</code></div><div class="line number2 index1 alt1"><code class="jscript keyword">for</code> <code class="jscript plain">(</code><code class="jscript keyword">var</code> <code class="jscript plain">k = 0; k &amp;lt; 3; k++) {</code></div><div class="line number3 index2 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">(data[k] = </code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number4 index3 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments.callee.x);</code></div><div class="line number5 index4 alt2"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">}).x = k;</code></div><div class="line number6 index5 alt1"><code class="jscript plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Вот этот кусок кода интересует:</p>
<div><div id="highlighter_981282" class="syntaxhighlighter dsHightlight jscript"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="jscript plain">(data[k] = </code><code class="jscript keyword">function</code> <code class="jscript plain">() {</code></div><div class="line number2 index1 alt1"><code class="jscript spaces">&nbsp;&nbsp;&nbsp;</code><code class="jscript plain">alert(arguments.callee.x);</code></div><div class="line number3 index2 alt2"><code class="jscript plain">}).x = k;</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Как я понял из статьи про <code>this</code> — для получения значения типа <code>Function</code>, объекту которому присваивается свойство <code>x</code>.</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor even thread-even depth-1" id="li-comment-154293">
		<article id="comment-154293" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<strong>Константин</strong>, в самом простом определении:</p>
<p class="cye-lm-tag">Замыкание — это функция, которая при создании запоминает лексическое окружение (область видимости), где она порождена. И посредством этого сохраненного лексического окружения, функция находит свободные переменные (переменные, которые не являются локальными и не являются параметрами этой функции).</p>
<p class="cye-lm-tag">Подробней: <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/" rel="nofollow">http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/</a></p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="li-comment-154294">
		<article id="comment-154294" class="comment">
			
<div class="comment-content "><p class="cye-lm-tag">@<strong>Александр</strong></p>
<blockquote><p class="cye-lm-tag">для получения значения типа <code>Function</code>, объекту которому присваивается свойство <code>x</code></p></blockquote>
<p class="cye-lm-tag">Да, все верно. Нам нужно сохранить <code>x</code> куда-то, и мы сохраняем в саму функцию. Результатом <code>data[k]</code> также является функция (если поставить оператор группировки в другом месте или не поставить его вообще, будет не функция — поэкспериментируйте ;)).</p>
</div>
<div class="reply">
							</div>
			<!-- .reply -->
		</article><!-- #comment-## -->
	</li><!-- #comment-## -->
			</ol><!-- .commentlist -->
	</div>
	<br><hr>

</body>
</html>