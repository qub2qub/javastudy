<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>GC Hotspot JVM</title>
    <link rel="stylesheet" href="grey.css">
</head>
<body>
<div class="entry" id="%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0_%D0%B2_hotspot">

	<h3 class="entry-title">
			Основы сборки мусора в Hotspot JVM
	    </h3>

    <h4 class="entry-meta">By vmrobot on <a href="#">мар 11, 2007</a></h4>

    <div class="entry-body">
<p>Сборка мусора в языке Java является предметом постоянных обсуждений и всевозможных заблуждений. В этом посте мы постараемся пролить свет на некоторые аспекты работы сборщика мусора в виртуальной машине Hotspot JVM.</p>

<p>Спецификация виртуальной машины не содержит каких-либо требований к механизму управления памятью (кроме того, что «память очищается автоматически с помощью механизма сборки мусора»), поэтому при реализации сборщика мусора разработчики ничем не ограничены. JDK 6 предоставляет 3 сборщика мусора: 
<ol>
<li>последовательный - <code>SerialGC</code>, </li>
<li>параллельный - <code>ParallelGC</code>, </li>
<li>совместный - <code>ConcMarkSweepGC</code>.</li>
</ol>
</p>

<br>
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:<br>
<br>
<b>Serial (последовательный)</b> — самый простой вариант для приложений с
 небольшим объемом данных и не требовательных к задержкам. Редко когда 
используется, но на слабых компьютерах может быть выбран виртуальной 
машиной в качестве сборщика по умолчанию.<br>
<br>
<b>Parallel (параллельный)</b> — наследует подходы к сборке от 
последовательного сборщика, но добавляет параллелизм в некоторые 
операции, а также возможности по автоматической подстройке под требуемые
 параметры производительности.<br>
<br>
<b>Concurrent Mark Sweep (CMS)</b> — нацелен на снижение максимальных 
задержек путем выполнения части работ по сборке мусора параллельно с 
основными потоками приложения. Подходит для работы с относительно 
большими объемами данных в памяти.<br>
<br>
<b>Garbage-First (G1)</b> — создан для постепенной замены CMS, особенно в
 серверных приложениях, работающих на многопроцессорных серверах и 
оперирующих большими объемами данных.<br>
<br>

<p>Причина поддержки различных алгоритмов сборки мусора заключается в том, что виртуальная машина может использоваться для запуска приложений разного типа и размера на машинах с различными доступными ресурсами. Очевидно, алгоритмы сборки мусора для запуска пасьянса на домашнем компьютере могут быть неэффективны для большого серверного приложения, работающего на машине, имеющей в распоряжении гигабайты оперативной памяти и несколько десятков процессоров. Различные типы приложений могут иметь различные требования к работе сборщика мусора: для одних важно минимизировать длительность пауз в работе приложения, вызванных сборщиком мусора, другие приложения могут позволять более длительные паузы, увеличивается при этом общую производительность (throughput).</p>

<p>На текущий момент все сборщики мусора в виртуальной машине Sun Hotspot JVM относятся к типу сборщиков мусора, основанных на <b>поколениях</b> <u>(generational garbage collectors)</u>. 
<br><br>
Сборщики такого типа используют наблюдение, справедливое для Java и ряда других языков программирования: <br> большая часть объектов, создаваемых при работе приложения, становится мусором в течение очень небольшого промежутка времени («most objects die young»). <br> При использовании таких сборщиков вся память делится на области, называемые поколениями.
<br>В HotSpot есть два основных поколения: <br>

<ol>
<li>область <i>Young generation</i>, в которой размещаются только что созданные объекты, и </li>
<li><i>Old (или Tenured) generation</i>, в которую перемещаются объекты, пережившие несколько сборок мусора.</li>
 </ol> 

<b>Young generation</b>, как правило, меньше по размерам чем Old generation, оно заполняется быстрее, и сборки мусора в нём проводятся часто. Сборки мусора в Young generation занимают мало времени и являются очень эффективными, так как большинство объектов, содержащихся в этой области, являются мусором. 
<br><b>Old generation</b> имеет больший размер и заполняется медленнее. Сборки мусора в ней проводятся реже и времени они могут отнимать значительно больше.</p>
<p><u>А зачем вообще придумали это разделения на поколения?</u></p>
<p>Главное приемущество разделения памяти на поколения в том, что для сборки мусора в различных поколениях могут применяться различные алгоритмы. <br><br>Для частых сборок в небольшом по размеру <b>Young generation</b>, содержащем большое число ненужных объектов, могут использоваться <b>копирующие алгоритмы</b>, ориентированные в первую очередь на скорость, в то время как алгоритм очистки <b>Old generation</b> должен учитывать ее большой объем.

<br><br>Стоит отметить, что в Hotspot JVM, помимо областей Young generation и Old generation есть область памяти, называемая <b>Permanent generation</b>. <br>В ней виртуальная машина хранит различную информацию, относящуюся к <u>загруженным классам, откомпилированные методы, строки после String.intern()</u>. При этом объекты из Permanent generation также могут быть удалены сборщиком мусора.</p>

<h2>Последовательный сборщик мусора — SerialGC</h2>
<p>В этом посте мы остановимся на работе последовательного сборщика мусора—SerialGC. Этот сборщик мусора <u>используется виртуальной машиной по умолчанию</u> на так называемых машинах клиентского типа (в отличии от машин <a href="http://java.sun.com/javase/6/docs/technotes/guides/vm/server-class.html">серверного типа</a>, они имеют меньше двух процессоров и меньше двух гигабайт оперативной памяти). Можно явно указать, что следует использовать именно этот сборщик мусора, при помощи флага <code>-XX:+UseSerialGC</code>. <br><br>

Последовательный сборщик мусора использует модель работы, называемую <b>stop-the-world</b>. То есть на время его работы все потоки приложения приостанавливаются. Название <i>"последовательный"</i> означает, что этот сборщик мусора использует последовательный (не параллельный) алгоритм: вне зависимости от числа доступных процессоров, сборка мусора выполняется только одним потоком.</p>

<h3>Рассмотрим процесс сборки мусора SerialGC более детально.</h3>
<p>
Область памяти <i>Young generation</i> состоит из трёх областей: <i>Eden</i> и двух меньших по размеру <i>survivor spaces</i>. 
Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут 
быть размещены в ней и поэтому сразу размещаются в Old generation. В survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку 
мусора, но ещё не достигли порога 'старости' (tenuring threshold), чтобы быть перемещенными в Old generation.
</p>

<p>
Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (minor collection, в отличие от процесса сборки, проводимого над всей heap памятью—full collection). Он происходит следующим образом: в начале работы одно из survivor spaces, <i>To space</i>, является пустым, а другое, <i>From space</i>, содержит объекты, пережившие предыдущие сборки. 
<br>Во From space объекты делятся на 2 типа:
<ol>
<li>"молодые" - то есть не пережившие еще заданное число сборок мусора(tenuring threshold)</li>
<li>"старые" - уже пережившие заданное число сборок мусора</li>
</ol>
Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые "молодые" объекты из From space. 

Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.</p>

<p></p><table cellspacing="1" cellpadding="1" border="0" align="center"><tbody><tr><td align="right"><img vspace="0" hspace="0" border="0" align="bottom" src="pics/gc1.png"></td><td><img vspace="0" hspace="0" border="0" align="bottom" src="pics/gc2.png"></td></tr><tr><td valign="top" align="center"><i>Легкая сборка</i></td><td valign="top" align="center"><i>Легкая сборка завершена</i></td></tr></tbody></table><p></p>

<p>
Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden
и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, 
сколько сборок мусора они пережили.
</p>

<p>
Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется <b>копирующим</b>. 
<br><br>
Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую
будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно 
небольших по отношению к общему размеру памяти приложения. 
<u>Young generation как раз удовлетворяет этому условию </u>(по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы).</p><p>&nbsp;Однако, для сборки мусора в Old generation, занимающем больщую часть всей памяти, используется  другой алгоритм.
</p>

<h3>Алгоритма Mark-Sweep-Compact</h3>
<p>
В Old generation сборка мусора происходит с использованием алгоритма <b>Mark-Sweep-Compact</b>, 
который состоит из трёх фаз. 
<ol>
<li>В фазе Mark  (пометка) сборщик мусора помечает все живые объекты, затем,</li>
<li>в фазе Sweep (освобождение) все непомеченные объекты удаляются, </li>
<li>а в фазе Сompact (уплотнение) все живые объекты перемещаются в начало Old generation, </li>
</ol>
в результате чего свободная память после очистки представляет собой 
непрерывную область. <u>Фаза уплотнения</u> выполняется для того, <u>чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation</u>.</p><p>Когда свободная память представляет
собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать 
<b>очень быстрый</b> (около десятка машинных инструкций) алгоритм <b>bump-the-pointer</b>: адрес начала
свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто <u>увеличивает указатель на размер объекта</u>.</p>

<p></p><table cellspacing="1" cellpadding="1" border="0" align="center"><tbody><tr><td align="right"><img vspace="0" hspace="0" border="0" align="bottom" src="pics/gc3.png"></td><td><img vspace="0" hspace="0" border="0" align="bottom" src="pics/gc4.png"></td></tr><tr><td valign="top" align="center"><i>Очистка Old Generation</i></td><td valign="top" align="center"><i>Уплотнение Old Generation</i></td></tr></tbody></table><p></p>

<p>
Последовательный сборщик мусора отлично подходит для 
большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа 
и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же 
время модель <i>stop-the-world</i> может вызвать длительные паузы в работе приложения при использовании 
больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы
компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцесcорных машинах.
</p>

<p>
В следующих постах мы расскажем про другие сборщики мусора, предоставляемые Hotspot JVM, 
а также о возможностях настройки работы сборщика мусора под ваше приложение.</p><p>
Ссылки:
<i><br>
<a href="http://java.sun.com/javase/technologies/hotspot/gc/index.jsp">Java HotSpot Garbage Collection</a>
<br>
<a href="http://java.sun.com/javase/technologies/hotspot/gc/memorymanagement_whitepaper.pdf">Memory Management in the Java HotSpot™ Virtual Machine</a>
<br>
<a href="http://java.sun.com/docs/hotspot/gc1.4.2/faq.html">Frequently Asked Questions about Garbage Collection in the HotspotTM JavaTM Virtual Machine</a></i> <br></p><p><i><font size="2">Семен Бойков</font></i>&nbsp;</p><p>
</p>
        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: GC</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/vmrobot/entry/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0_%D0%B2_hotspot">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
</body>
</html>