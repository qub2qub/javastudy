<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>duk gc3</title>
    <link rel="stylesheet" href="grey.css">
</head>
<body>
Сегодня мы продолжаем цикл статей о сборщиках мусора, поставляемых с виртуальной машиной Oracle Java HotSpot VM. Мы уже <a href="http://habrahabr.ru/post/269621/">изучили</a> немного теории и <a href="http://habrahabr.ru/post/269707/">рассмотрели</a>,
 каким образом с кучей расправляются два базовых сборщика &mdash; Serial GC и 
Parallel GC. А в этой статье речь пойдет о сборщиках CMS GC и G1 GC, 
первостепенной задачей которых является минимизация пауз при наведении 
порядка в памяти приложений, оперирующих средними и большими объемами 
данных, то есть по большей части в памяти серверных приложений.<br>
<br>
Два этих сборщика объединяют общим названием <i>«mostly concurrent collectors»</i>, то есть <i>«по большей части конкурентные сборщики»</i>.
 Это связано с тем, что часть своей работы они выполняют параллельно с 
основными потоками приложения, то есть в какие-то моменты конкурируют с 
ними за ресурсы процессора. Конечно, это не проходит бесследно, и в 
итоге они разменивают улучшение в части пауз на ухудшение в части 
пропускной способности. Хотя делают это по-разному. Давайте посмотрим, 
как.<br>
<a name="habracut"></a><br>
<h1>CMS GC</h1><br>
Сборщик CMS (расшифровывается как Concurrent Mark Sweep) появился в 
HotSpot VM в одно время с Parallel GC в качестве его альтернативы для 
использования в приложениях, имеющих доступ к нескольким ядрам 
процессора и чувствительных к паузам <abbr title="stop the world, остановка приложения на время сборки мусора">STW</abbr>.
 В то время существовала еще одна альтернатива &mdash; Incremental GC, но он 
не прошел естественный отбор за неимением явных преимуществ. А CMS 
выжил. И хотя пик его популярности, видимо, уже прошел, на его 
внутреннее устройство интересно будет взглянуть, так как некоторые 
заложенные в него идеи перекочевали в более современный G1 GC.<br>
<br>
Использование CMS GC включается опцией <i>-XX:+UseConcMarkSweepGC</i>.<br>
<br>
<h3>Принципы работы</h3><br>
Мы уже встречали слова Mark и Sweep при рассмотрении последовательного и
 параллельного сборщиков (если вы не встречали, то сейчас как раз самое 
время это <a href="http://habrahabr.ru/post/269707/">сделать</a>). Они 
обозначали два шага в процессе сборки мусора в старшем поколении: 
пометку выживших объектов и удаление мертвых объектов. Сборщик CMS 
получил свое название благодаря тому, что выполняет указанные шаги 
параллельно с работой основной программы.<br>
<br>
При этом CMS GC использует ту же самую организацию памяти, что и уже 
рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor
 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются
 только тогда, когда дело доходит до полной сборки. В случае CMS ее 
называют <i>старшей (major) сборкой</i>, а не полной, так как она не 
затрагивает объекты младшего поколения. В результате, малая и старшая 
сборки здесь всегда разделены. Одним из побочных эффектов такого 
разделения является то, что все объекты младшего поколения (даже 
потенциально мертвые) могут играть роль корней при определении статуса 
объектов в старшем поколении.<br>
<br>
Важным отличием сборщика CMS от рассмотренных ранее является также то, 
что он не дожидается заполнения Tenured для того, чтобы начать старшую 
сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь 
поддерживать Tenured в компактном состоянии.<br>
<br>
Давайте рассмотрим, что из себя представляет старшая сборка мусора при использовании CMS GC.<br>
<br>
Начинается она с остановки основных потоков приложения и пометки всех 
объектов, напрямую доступных из корней. После этого приложение 
возобновляет свою работу, а сборщик параллельно с ним производит поиск 
всех живых объектов, доступных по ссылкам из тех самых помеченных 
корневых объектов (эту часть он делает в одном или в нескольких 
потоках).<br>
<br>
Естественно, за время такого поиска ситуация в куче может поменяться, и 
не вся информация, собранная во время поиска живых объектов, оказывается
 актуальной. Поэтому сборщик еще раз приостанавливает работу приложения и
 просматривает кучу для поиска живых объектов, ускользнувших от него за 
время первого прохода. При этом допускается, что в живые будут записаны 
объекты, которые на время окончания составления списка таковыми уже не 
являются. Эти объекты называются <i>плавающим мусором (floating garbage)</i>, они будут удалены в процессе следующей сборки.<br>
<br>
После того, как живые объекты помечены, работа основных потоков 
приложения возобновляется, а сборщик производит очистку памяти от 
мертвых объектов в нескольких параллельных потоках. При этом следует 
иметь в виду, что после очистки не производится упаковка объектов в 
старшем поколении, так как делать это при работающем приложении весьма 
затруднительно.<br>
<br>
<div style="text-align:center;"><img width="600" height="200" alt="Потоки при работе сборщика CMS" src="duk3_files/f9fd549a2a104f1eb7acf5098dd0afe8.png"></div><br>
Сборщик CMS достаточно интеллектуальный. Например, он старается 
разносить во времени малые и старшие сборки мусора, чтобы они совместно 
не создавали продолжительных пауз в работе приложения (дополнительные 
подробности об этом разнесении в <a href="#comment_8638131">комментариях</a>). Для этого он ведет статистику по прошедшим сборкам и исходя из нее планирует последующие.<br>
<br>
Отдельно следует рассмотреть ситуацию, когда сборщик не успевает 
очистить Tenured до того момента, как память полностью заканчивается. В 
этом случае работа приложения останавливается, и вся сборка производится
 в последовательном режиме. Такая ситуация называется <i>сбоем конкурентного режима (concurrent mode failure)</i>. Сборщик сообщает нам об этих сбоях при включенных опциях <i>-verbose:gc</i> или <i>-Xloggc:filename</i>.<br>
<br>
У CMS есть один интересный режим работы, называемый Incremental Mode, 
или i-cms, который заставляет его временно останавливаться при 
выполнении работ параллельно с основным приложением, чтобы на короткие 
периоды высвобождать ресурсы процессора (что-то вроде <abbr title="антиблокировочная система">АБС</abbr>
 у автомобиля). Это может быть полезным на машинах с малым количеством 
ядер. Но данный режим уже помечен как не рекомендуемый к применению и 
может быть отключен в будущих релизах, поэтому подробно его разбирать не
 будем.<br>
<br>
<h3>Ситуации STW</h3><br>
Из всего сказанного выше следует, что при обычной сборке мусора у CMS GC существуют следующие ситуации, приводящие к STW:<br>
<ul>
<li>Малая сборка мусора. Эта пауза ничем не отличается от аналогичной паузы в Parallel GC.</li>
<li>Начальная фаза поиска живых объектов при старшей сборке (так называемая <i>initial mark pause</i>). Эта пауза обычно очень короткая.</li>
<li>Фаза дополнения набора живых объектов при старшей сборке (известная также как <i>remark pause</i>). Она обычно длиннее начальной фазы поиска.</li>
</ul><br>
В случае же возникновения сбоя конкурентного режима пауза может затянуться на достаточно длительное время.<br>
<br>
<h3>Настройка</h3><br>
Так как подходы к организации памяти у CMS аналогичны используемым в 
Serial / Parallel GC, для него применимы те же опции определения 
размеров регионов кучи, а также опции автоматической подстройки под 
требуемые параметры производительности.<br>
<br>
Обычно CMS, основываясь на собираемой статистике о поведении приложения,
 сам определяет, когда ему выполнять старшую сборку, но у него также 
есть порог наполненности региона Tenured, при достижении которого должна
 обязательно быть инициирована старшая сборка. Этот порог можно задать с
 помощью опции <i><nobr>-XX:CMSInitiatingOccupancyFraction=?</nobr></i>,
 значение указывается в процентах. Значение -1 (иногда устанавливается 
по умолчанию) указывает на отключение сборки по такому условию.<br>
<br>
<h3>Достоинства и недостатки</h3><br>
Достоинством данного сборщика по сравнению с рассмотренными ранее Serial
 / Parallel GC является его ориентированность на минимизацию времен 
простоя, что является критическим фактором для многих приложений. Но для
 выполнения этой задачи приходится жертвовать ресурсами процессора и 
зачастую общей пропускной способностью.<br>
<br>
Вспомним еще, что данный сборщик не уплотняет объекты в старшем 
поколении, что приводит к фрагментации Tenured. Этот факт в совокупности
 с наличием плавающего мусора приводит к необходимости выделять 
приложению (конкретно &mdash; старшему поколению) больше памяти, чем 
потребовалось бы для других сборщиков (Oracle советует на 20% больше).<br>
<br>
Ну и долгие паузы при потенциально возможных сбоях конкурентного режима 
могут стать неприятным сюрпризом. Хотя они не частые, и при наличии 
достаточного объема памяти CMS’у удается их полностью избегать.<br>
<br>
Тем не менее, такой сборщик может подойти приложениям, использующим 
большой объем долгоживущих данных. В этом случае некоторые его 
недостатки нивелируются. Но в любом случае, не стоит принимать решение о
 его использовании пока вы не познакомились с еще одним сборщиком в 
обойме Java HotSpot VM.<br>
<br>
<hr><br>
<h1>G1 GC</h1><br>
Вот мы и добрались до последнего и наверняка самого интересного для 
многих сборщика мусора &mdash; G1 (что является сокращением от Garbage First).
 Интересен он прежде всего тем, что не является явным продолжением 
линейки Serial / Parallel / CMS, добавляющим параллельность еще в 
какую-нибудь фазу сборки мусора, а использует уже существенно 
отличающийся подход к задаче очистки памяти.<br>
<br>
G1 &mdash; самый молодой в составе сборщиков мусора виртуальной машины 
HotSpot. Он изначально позиционировался как сборщик для приложений с 
большими кучами (от 4 ГБ и выше), для которых важно сохранять время 
отклика небольшим и предсказуемым, пусть даже за счет уменьшения 
пропускной способности. На этом поле он конкурировал с CMS GC, хотя 
изначально и не так успешно, как хотелось бы. Но постепенно он 
исправлялся, улучшался, стабилизировался и, наконец, достиг такого 
уровня, что Oracle говорит о нем как о долгосрочной замене CMS, а в Open
 JDK даже <a href="http://openjdk.java.net/jeps/248">серьезно рассматривают</a> его на роль сборщика по умолчанию для серверных конфигураций в 9-й версии.<br>
<br>
Это все явно стоит того, чтобы разобраться с его устройством. Не будем же откладывать.<br>
<br>
G1 включается опцией Java -XX:+UseG1GC.<br>
<br>
<h3>Принципы работы</h3><br>
Первое, что бросается в глаза при рассмотрении G1 &mdash; это изменение 
подхода к организации кучи. Здесь память разбивается на множество 
регионов одинакового размера. Размер этих регионов зависит от общего 
размера кучи и по умолчанию выбирается так, чтобы их было не больше 
2048, обычно получается от 1 до 32 МБ. Исключение составляют только так 
называемые <i>громадные (humongous) регионы</i>, которые создаются объединением обычных регионов для размещения очень больших объектов.<br>
<br>
Разделение регионов на Eden, Survivor и Tenured в данном случае 
логическое, регионы одного поколения не обязаны идти подряд и даже могут
 менять свою принадлежность к тому или иному поколению. Пример 
разделения кучи на регионы может выглядеть следующим образом (количество
 регионов сильно приуменьшено):<br>
<br>
<div style="text-align:center;"><img width="460" height="90" alt="Регионы сборщика G1 GC" src="duk3_files/34d781181f5e4481be98557899ae0cf2.png"></div><br>
Малые сборки выполняются периодически для очистки младшего поколения и 
переноса объектов в регионы Survivor, либо их повышения до старшего 
поколения с переносом в Tenured. Над переносом объектов трудятся 
несколько потоков, и на время этого процесса работа основного приложения
 останавливается. Это уже знакомый нам подход из рассмотренных ранее 
сборщиков, но отличие состоит в том, что очистка выполняется не на всем 
поколении, а только на части регионов, которые сборщик сможет очистить 
не превышая желаемого времени. При этом он выбирает для очистки те 
регионы, в которых, по его мнению, скопилось наибольшее количество 
мусора и очистка которых принесет наибольший результат. Отсюда как раз 
название Garbage First &mdash; мусор в первую очередь.<br>
<br>
А с полной сборкой (точнее, здесь она называется <i>смешанной (mixed)</i>) все немного хитроумнее, чем в рассмотренных ранее сборщиках. В G1 существует процесс, называемый <i>циклом пометки (marking cycle)</i>,
 который работает параллельно с основным приложением и составляет список
 живых объектов. За исключением последнего пункта, этот процесс выглядит
 уже знакомо для нас:<br>
<ol>
<li>Initial mark. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.</li>
<li>Concurrent marking. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.</li>
<li>Remark. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).</li>
<li>Cleanup. Очистка вспомогательных структур учета ссылок на объекты и 
поиск пустых регионов, которые уже можно использовать для размещения 
новых объектов. Первая часть этого шага выполняется при остановленном 
основном приложении.</li>
</ol><br>
Следует иметь в виду, что для получения списка живых объектов G1 
использует алгоритм Snapshot-At-The-Beginning (SATB), то есть в список 
живых попадают все объекты, которые были таковыми на момент начала 
работы алгоритма, плюс все объекты, созданные за время его выполнения. 
Это, в частности, означает, что G1 допускает наличие плавающего мусора, с
 которым мы познакомились при рассмотрении сборщика CMS.<br>
<br>
После окончания цикла пометки G1 переключается на выполнение смешанных 
сборок. Это значит, что при каждой сборке к набору регионов младшего 
поколения, подлежащих очистке, добавляется некоторое количество регионов
 старшего поколения. Количество таких сборок и количество очищаемых 
регионов старшего поколения выбирается исходя из имеющейся у сборщика 
статистики о предыдущих сборках таким образом, чтобы не выходить за 
требуемое время сборки. Как только сборщик очистил достаточно памяти, он
 переключается обратно в режим малых сборок.<br>
<br>
Очередной цикл пометки и, как следствие, очередные смешанные сборки 
будут запущены тогда, когда заполненность кучи превысит определенный 
порог.<br>
<br>
Смешанная сборка мусора в приведенном выше примере кучи может пройти вот так:<br>
<br>
<div style="text-align:center;"><img width="460" height="200" alt="Смешанная сборка в G1 GC" src="duk3_files/8eed1262d47a407a9f64f2df8635bdb6.png"></div><br>
Может оказаться так, что в процессе очистки памяти в куче не остается 
свободных регионов, в которые можно было бы копировать выжившие объекты.
 Это приводит к возникновению ситуации <i>allocation (evacuation) failure</i>,
 подобие которой мы видели в CMS. В таком случае сборщик выполняет 
полную сборку мусора по всей куче при остановленных основных потоках 
приложения.<br>
<br>
Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может 
менять количество регионов, закрепленных за определенным поколением, для
 оптимизации будущих сборок.<br>
<br>
<h3>Гиганты</h3><br>
В начале рассказа о G1 я упомянул о существовании громадных регионов, в которых хранятся так называемые <i>громадные объекты (humongous objects)</i>. С точки зрения JVM любой объект размером больше половины региона считается громадным и обрабатывается специальным образом:<br>
<ul>
<li>Он никогда не перемещается между регионами.</li>
<li>Он может удаляться в рамках цикла пометки или полной сборки мусора.</li>
<li>В регион, занятый громадным объектом, больше никого не подселяют, даже если в нем остается свободное место.</li>
</ul><br>
Вообще, эти пункты иногда имеют далеко идущие последствия. Объекты 
большого размера, особенно короткоживущие, могут доставлять много 
неудобств всем типам сборщиков, так как не удаляются при малых сборках, а
 занимают драгоценное пространство в регионах старшего поколения 
(помните объекты-акселераты, обсуждавшиеся в предыдущей главе?) Но G1 
оказывается более уязвимым к их негативному влиянию в силу того, что для
 него даже объект в несколько мегабайт (а в некоторых случаях и 500 КБ) 
уже является громадным. В <a href="http://habrahabr.ru/post/269707/#comment_8633731">комментарии</a> к предыдущей статье как раз приводится пример такой <a href="https://wiki.apache.org/solr/ShawnHeisey#GC_Tuning_for_Solr">проблемы у Solr</a>.<br>
<br>
В продолжении данного цикла статей мы посмотрим, как с этим можно бороться.<br>
<br>
<h3>Ситуации STW</h3><br>
Если резюмировать, то у G1 мы получаем STW в следующих случаях:<br>
<ol>
<li>Процессы переноса объектов между поколениями. Для минимизации таких пауз G1 использует несколько потоков.</li>
<li>Короткая фаза начальной пометки корней в рамках цикла пометки.</li>
<li>Более длинная пауза в конце фазы remark и в начале фазы cleanup цикла пометки.</li>
</ol><br>
<br>
<h3>Настройка</h3><br>
Так как основной целью сборщика G1 является минимизация пауз в работе 
основного приложения, то и главной опцией при его настройке можно 
считать уже встречавшуюся нам <i><nobr>-XX:MaxGCPauseMillis=?</nobr></i>,
 задающую приемлемое для нас максимальное время разовой сборки мусора. 
Даже если вы не собираетесь задавать это свойство, хотя бы проверьте его
 значение по умолчанию. Хотя в документации Oracle и говориться, что по 
умолчанию время сборки не ограничено, но по факту это не всегда так.<br>
<br>
Опции <i><nobr>-XX:ParallelGCThreads=?</nobr></i> и <i><nobr>-XX:ConcGCThreads=?</nobr></i> задают количество потоков, которые будут использоваться для сборки мусора и для выполнения цикла пометок соответственно.<br>
<br>
Если вас не устраивает автоматический выбор размера региона, вы можете задать его вручную с помощью опции <i><nobr>-XX:G1HeapRegionSize=?</nobr></i>. Значение должно быть степенью двойки, если мерить в мегабайтах. Например, <i><nobr>-XX:G1HeapRegionSize=16m</nobr></i>.<br>
<br>
При желании можно изменить порог заполненности кучи, при достижении 
которого инициируется выполнение цикла пометок и переход в режим 
смешанных сборок. Это делается опцией <i><nobr>-XX:InitiatingHeapOccupancyPercent=?</nobr></i>, принимающей значение в процентах. По умолчанию, этот порог равен 45%.<br>
<br>
Если же вы решите залезть в дебри настроек G1 по-глубже, то можете включить дополнительные функции опциями <i><nobr>-XX:+UnlockExperimentalVMOptions</nobr></i> и <i><nobr>-XX:+AggressiveOpts</nobr></i> и поиграть с экспериментальными настройками.<br>
<br>
<h3>Достоинства и недостатки</h3><br>
В целом считается, что сборщик G1 более аккуратно предсказывает размеры 
пауз, чем CMS, и лучше распределяет сборки во времени, чтобы не 
допустить длительных остановок приложения, особенно при больших размерах
 кучи. При этом он лишен и некоторых других недостатков CMS, например, 
он не фрагментирует память.<br>
<br>
Расплатой за достоинства G1 являются ресурсы процессора, которые он 
использует для выполнения достаточно большой части своей работы 
параллельно с основной программой. В результате страдает пропускная 
способность приложения. Целевым значением пропускной способности по 
умолчанию для G1 является 90%. Для Parallel GC, например, это значение 
равно 99%. Это, конечно, не значит, что пропускная способность с G1 
всегда будет почти на 10% меньше, но данную особенность следует всегда 
иметь в виду.<br>
<br>
<br>
Вот мы и разобрали алгоритмы работы всех четырех сборщиков мусора в 
виртуальной машине HotSpot. В следующей статье попробуем разобраться, 
каким образом эти знания можно применять для оптимизации работы 
приложений.<br>
<br>
<i>Ранее:</i><br>
<a href="http://habrahabr.ru/post/269707/">← Часть 2 &mdash; Сборщики Serial GC и Parallel GC</a><br>
<a href="http://habrahabr.ru/post/269621/">← Часть 1 &mdash; Введение</a></div>
</body>
</html>