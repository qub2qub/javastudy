<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>QA Java Core</title>
    <link rel="stylesheet" href="../Guides/grey.css">
</head>
<body>
<a href="http://javastudy.ru/interview/list-of-question-java-interview/">src</a>
<h2>1 типы данных, переменные, операторы, циклы, массивы </h2>
<a href="http://javastudy.ru/interview/basics-types-operators-arrays/">src1</a>
<div class="entry-body">
<h3>Вопросы</h3>
<ol>
<li>Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?</li>
<li>Из каких символов может состоять имя переменной (корректный идентификатор)?</li>
<li>Что значит слово “инициализация”?</li>
<li>На какие основные группы можно поделить типы данных?</li>
<li>Какие примитивные типы вы знаете?</li>
<li>Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать&nbsp;логический тип?</li>
<li>Какими значениями инициализируются переменные по умолчанию?</li>
<li>Как передается значение переменной (по ссылке/значению)?</li>
<li>Что вы знаете о функции main, какие обязательные условия ее определения?</li>
<li>Какие логические операции и операторы вы знаете?</li>
<li>В чем разница краткой и полной схемы записи логических операторов?</li>
<li>Что такое таблица истинности?</li>
<li>Что такое тернарный оператор выбора?</li>
<li>Какие унарные и бинарные арифметические операции&nbsp;вы знаете?</li>
<li>Какие побитовые операции вы знаете?</li>
<li>Какова роль и правила написания оператора выбора (switch)?</li>
<li>Какие циклы вы знаете, в чем их отличия?</li>
<li>Что такое “итерация цикла”?</li>
<li>Какие параметры имеет цикл for, можно ли их не задать?</li>
<li>Какой оператор используется для немедленной остановки цикла?</li>
<li>Какой оператор используется для перехода к следующей итерации цикла?</li>
<li>Что такое массив?</li>
<li>Какие виды массивов вы знаете?</li>
<li>Что вы знаете о классах оболочках?</li>
<li>Что такое автоупаковка (boxing/unboxing)?</li>
</ol>
<h3>Ответы</h3>
<h4>1. Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?</h4>
<p>50, два из них не используются: const, goto;</p>
<p>Для запоминания это:</p>
<ul>
<li>Примитивы&nbsp;(byte,&nbsp;short,&nbsp;int,&nbsp;long,&nbsp;char,&nbsp;float,&nbsp;double,&nbsp;boolean)</li>
<li>Циклы и ветвления&nbsp;(if, else,&nbsp;switch,&nbsp;case,&nbsp;default,&nbsp;while,&nbsp;do,&nbsp;break, continue, for)</li>
<li>Исключения (try,&nbsp;catch,&nbsp;finally,&nbsp;throw,&nbsp;throws)</li>
<li>Области видимости (private, protected, public)</li>
<li>Объявление \ Импорт (import, package, class, interface, extends, implements, static,&nbsp;final, void, abstract, native)</li>
<li>Создание \ Возврат \ Вызов (new, return,&nbsp;this,&nbsp;super)</li>
<li>Многопоточность (synchronized,&nbsp;volatile)</li>
<li>instanceof, enum, assert,&nbsp;transient,&nbsp;strictfp, const, goto</li>
</ul>
<table width="100%" cellpadding="0" border="0" summary="">
<tbody>
<tr>
<td width="20%" align="left"><code>abstract</code></td>
<td width="20%" align="left"><code>continue</code></td>
<td width="20%" align="left"><code>for</code></td>
<td width="20%" align="left"><code>new</code></td>
<td width="20%" align="left"><code>switch</code></td>
</tr>
<tr>
<td width="20%"><code>assert</code><sup>***</sup></td>
<td width="20%" align="left"><code>default</code></td>
<td width="20%" align="left"><code>goto</code><sup>*</sup></td>
<td width="20%" align="left"><code>package</code></td>
<td width="20%" align="left"><code>synchronized</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>boolean</code></td>
<td width="20%" align="left"><code>do</code></td>
<td width="20%" align="left"><code>if</code></td>
<td width="20%" align="left"><code>private</code></td>
<td width="20%" align="left"><code>this</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>break</code></td>
<td width="20%" align="left"><code>double</code></td>
<td width="20%" align="left"><code>implements</code></td>
<td width="20%" align="left"><code>protected</code></td>
<td width="20%" align="left"><code>throw</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>byte</code></td>
<td width="20%" align="left"><code>else</code></td>
<td width="20%" align="left"><code>import</code></td>
<td width="20%" align="left"><code>public</code></td>
<td width="20%" align="left"><code>throws</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>case</code></td>
<td width="20%" align="left"><code>enum</code><sup>****</sup></td>
<td width="20%" align="left"><code>instanceof</code></td>
<td width="20%" align="left"><code>return</code></td>
<td width="20%" align="left"><code>transient</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>catch</code></td>
<td width="20%" align="left"><code>extends</code></td>
<td width="20%" align="left"><code>int</code></td>
<td width="20%" align="left"><code>short</code></td>
<td width="20%" align="left"><code>try</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>char</code></td>
<td width="20%" align="left"><code>final</code></td>
<td width="20%" align="left"><code>interface</code></td>
<td width="20%" align="left"><code>static</code></td>
<td width="20%" align="left"><code>void</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>class</code></td>
<td width="20%" align="left"><code>finally</code></td>
<td width="20%" align="left"><code>long</code></td>
<td width="20%" align="left"><code>strictfp</code><sup>**</sup></td>
<td width="20%" align="left"><code>volatile</code></td>
</tr>
<tr>
<td width="20%" align="left"><code>const</code><sup>*</sup></td>
<td width="20%" align="left"><code>float</code></td>
<td width="20%" align="left"><code>native</code></td>
<td width="20%" align="left"><code>super</code></td>
<td width="20%" align="left"><code>while</code></td>
</tr>
</tbody>
</table>
<p>* not used; **added in 1.2, *** added in 1.4, **** added in 5.0.</p>
<h5>http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</h5>
<h4>2.&nbsp;Из каких символов может состоять имя переменной (корректный идентификатор)?</h4>
<p>Имя или идентификатор переменной &mdash; это последовательность из строчных и заглавных латинских букв, цифр, а также символов «$» и «_». Имя переменной <strong>может начинаться с любого из перечисленных символов, кроме цифры</strong>.</p>
<p>Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.</p>
<h4>3.&nbsp;Что значит слово “инициализация”?</h4>
<p><b>Инициализация</b>&nbsp;(от англ. <i>initialization</i>, инициирование)&nbsp;&mdash; создание, активация, подготовка к работе, определение параметров. Приведение программы или устройства в состояние готовности к использованию. С точки зрения Java &mdash; выделение памяти под объект, например при создании MyClass myClass = new MyClass(). Таким образом будет выделена память под объект myClass (он будет инициализирован). Без инициализации (new MyClass()) запись&nbsp;MyClass myClass; просто резервирует имя (объявляется переменная myClass типа MyClass).</p>
<h4>4. На какие основные группы можно поделить типы данных?<br>
5.&nbsp;Какие примитивные типы вы знаете?</h4>
<p><strong>Примитивные</strong></p>
<ul>
<li><code>byte</code> (целые числа, 1 байт, [-128, 127])</li>
<li><code>short</code> (целые числа, 2 байта, [-32768, 32767])</li>
<li><code>int</code> (целые числа, 4 байта, [-2147483648, 2147483647])</li>
<li><code>long</code> (целые числа, 8 байт, [-922372036854775808,922372036854775807])</li>
<li><code>float</code> (вещественные числа, 4 байта)</li>
<li><code>double</code> (вещественные числа, 8 байт)</li>
<li><code>char</code> (символ Unicode, 2 байта, [0, 65536])</li>
<li><code>boolean</code> (значение истина/ложь, используется int, зависит от JVM)</li>
</ul>
<p><strong>Ссылочные</strong>. В&nbsp;ссылочные&nbsp;типы входят все классы, интерфейсы, массивы.</p>
<h5>http://stackoverflow.com/questions/383551/what-is-the-size-of-a-boolean-variable-in-java<br>
boolean type: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4<br>
boolean &mdash; боремся за Java память…&nbsp;https://habrahabr.ru/post/76481/</h5>
<h4>6.&nbsp;Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?</h4>
<p>Преобразование может быть неявным и явным (приведение типов). Неявное преобразование может выполняться&nbsp;если:</p>
<ol>
<li>типы совместимы (например &mdash; оба целочисленные)</li>
<li>размер «принимающего» типа больше чем у того, который преобразуется (так называемое «преобразование с расширением»)</li>
</ol>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc498e991792608">
		
			<div class="crayon-plain-wrap"><pre>int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>Явное преобразование имеет вид 
			<span style="font-size: 14px !important; line-height: 18px !important;font-size: 14px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-familiar crayon-theme-familiar-inline crayon-font-arial" id="crayon-58cdd51dc4997956625463"><span style="font-size: 14px !important; line-height: 18px !important;font-size: 14px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;" class="crayon-pre crayon-code">переменная<span class="crayon-i">_</span>нового<span class="crayon-i">_</span>типа<span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">(</span>новый<span class="crayon-i">_</span>тип<span class="crayon-sy">)</span><span class="crayon-h"> </span>имя<span class="crayon-h"> </span>переменной<span class="crayon-sy">;</span></span></span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc499b969627046">
		
			<div class="crayon-plain-wrap"><pre>int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>Примеры:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc499d972513607">
		
			<div class="crayon-plain-wrap"><pre>public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0044 seconds] -->
<p>При повышении типа byte&gt;short; short&gt;int; int&gt;long; float&gt;double; char&gt;int информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).</p>
<p>При различных операциях может происходить повышение типов в порядке «усиления» к более информативному типу. Например складывая int и double получим тип double. Но есть и особенность, например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double), а не более «длинный»&nbsp;тип. Аналогичный пример с вещественной частью:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49a1183395925">
		
			<div class="crayon-plain-wrap"><pre>  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0016 seconds] -->
<p>Кратко можно записать такие правила:</p>
<ol>
<li>byte, short, char в выражениях всегда повышаются до int</li>
<li>если в выражении участвует тип long &mdash; то именно к этому типу будет приведён результат</li>
<li>если в выражении участвует float &mdash; то результат приводится к float</li>
<li>если один из операндов имеет тип double &mdash; то к этому типу будет приведён весь результат</li>
<li>При выборе между длиной и возможностью сохранить дробную часть &mdash; будет выбрана дробная часть</li>
</ol>
<h4>7.&nbsp;Какими значениями инициализируются переменные по умолчанию?</h4>
<p>Числа инициализируются <span style="color: #920000;">0&nbsp;</span>или&nbsp;<span style="color: #920000;">0.0</span>. Объекты (в том числе String) &mdash; <span style="color: #920000;">null</span>, char &mdash;<span style="color: #920000;"> \u0000</span>; boolean &mdash; <span style="color: #920000;">false</span>;</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49a4118208821">
		
			<div class="crayon-plain-wrap"><pre>      class TestClass {
            int a; double b; float c; char d; String s; Object o; boolean e;

            @Override
            public String toString() {
                return "TestClass{" +
                        "a=" + a + ", b=" + b + ", c=" + c + ", d=" + d + ", s='" + s + '\'' + ", o=" + o +", e=" + e +'}';
            }
        }
        TestClass testClass = new TestClass();
        System.out.println(testClass); //TestClass{a=0, b=0.0, c=0.0, d= , s='null', o=null, e=false}
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0021 seconds] -->
<p></p>
<h4>8.&nbsp;Как передается значение переменной (по ссылке/значению)?</h4>
<p>Постоянный холивар по этому вопросу, видимо, связан с переводом на русский язык некоторых терминов, а так же работой Java с примитивами, строками и ссылочными объектами.&nbsp;По английски всё звучит строго &mdash; <strong>Java is always pass-by-value</strong>. Обычно спор вызывают особенности языка относящиеся к пониманию примитивов, ссылок и объектов в Java (и то, что некоторые из них неизменяемые). Итак:</p>
<ul>
<li>Java передает всё <strong>по значению</strong>. Java никогда не передает ничего по ссылке. Примитивы, ссылки, null &mdash; всё передается по значению, не по «ссылке».</li>
<li><strong>Передача по значению</strong>: Когда передается параметр&nbsp;в метод, то параметр копируется в другую переменную и она передается в метод. Поэтому это и называется «передача по значению».</li>
<li><strong>Передача по ссылке</strong>: Если мы передаем в метод ссылочный тип (объект), то так же происходит передача&nbsp;копии этого объекта (ссылки), которая указывает на какую-либо область памяти (можно назвать ссылку &mdash; «указателем»). Изменив что-то в области памяти, будут изменены все объекты, которые ссылаются на эту область памяти. Отсюда идет название <strong>«передача по ссылке»</strong>, хотя передается всё то же значение, просто значением является указатель на область памяти.</li>
</ul>
<p>Приведу пример с холивара на stackoverflow (http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value) и переведу на русский:</p>
<p>Пусть мы имеем такую строчку, которая резервирует имя <span style="color: #920000;">myDog</span> под тип <span style="color: #920000;">Dog</span>.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49a9446040529">
		
			<div class="crayon-plain-wrap"><pre>Dog myDog;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p>Но это еще не физический объект, а только указатель на тип Dog. Теперь создадим (инициализируем) этот объект.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49ab633687867">
		
			<div class="crayon-plain-wrap"><pre>Dog myDog = new Dog("Rover");
foo(myDog);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>Теперь <span style="color: #008000;">myDog</span> действительно занимает область в памяти (пусть будет область Dog@<span style="color: #920000;">42</span>). Вызвав метод <span style="color: #920000;">foo(myDog)</span> мы передаем <strong>копию</strong>&nbsp;значения указателя&nbsp;на область памяти <span style="color: #920000;">42</span>.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49ae592859506">
		
			<div class="crayon-plain-wrap"><pre>public void foo(Dog someDog) {
    someDog.setName("Max");     // AAA
    someDog = new Dog("Fifi");  // BBB
    someDog.setName("Rowlf");   // CCC
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>В строчке //AAA мы поменяли значение в памяти <span style="color: #920000;">42</span> на «Max».<br>
В строчке //BBB мы создали <strong>новый</strong> объект, который теперь будет лежать в другой области памяти (пусть будет Dog@<span style="color: #920000;">74</span>).<br>
В строке //CCC мы поменяли значение в области памяти <span style="color: #920000;">74</span>. Очевидно, что изначальный объект <span style="color: #008000;">myDog</span>@<span style="color: #920000;">42</span> ничего об этом не знает, но он ссылается на уже измененную в строке //AAA область памяти и теперь будет возвращать имя «Max».</p>
<p>Теперь другая засада &mdash; примитивы и строки.</p>
<ul>
<li>Когда передается примитив в метод, то передается также его копия (копия значения).</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49b1076279868">
		
			<div class="crayon-plain-wrap"><pre>int x = 5;
int y = changeX(x)
//x=5;
//y=25;

private int changeX(int value) {
value = value * 5;
return value;
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Создали примитив <span style="color: #920000;">x = 5</span>. Передали в метод <strong>копию</strong> значения (т.е. <span style="color: #920000;">5</span>). В методе умножили на число и вернули его. Значение примитива <span style="color: #920000;">y</span> будет равно <span style="color: #920000;">25</span>, а значение примитива <span style="color: #920000;">x = 5</span> (т.е. не изменится). Всё дело в том, что мы передали <strong>значение</strong> (5), а <strong>не указатель</strong> на область памяти. Соответственно значение x и не должно было поменяться, т.к. мы его не меняли (в методе использовалась копия значения).</p>
<ul>
<li>Строки immutable, т.е. неизменяемые. Когда мы присваиваем строке новое значение, то всегда будет создан новый объект в памяти.</li>
</ul>
<p>Еще один пример, что происходит при передаче параметра в метод:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49b5296426207">
		
			<div class="crayon-plain-wrap"><pre>class TestClass {
            public ArrayList&lt;Object&gt; changeObjectValue(ArrayList&lt;Object&gt; objectValue) {
                objectValue.clear();
                objectValue.add(999);
                return objectValue;
            }

            public String changeStr(String str) {
                str = "NewString";
                return str;
            }

            public int changeX(int x) {
                x = x*5;
                return x;
            }
        }

        TestClass testClass = new TestClass();

        ArrayList&lt;Object&gt; value = new ArrayList&lt;Object&gt;();
        value.add(23);
        String str = "FirstString";
        int x = 2;
        System.out.println(value + " " + str + " " + x); //[23] FirstString 2

        ArrayList&lt;Object&gt; value2 = new ArrayList&lt;Object&gt;();
        value2 = value;
        value2 = testClass.changeObjectValue(value2);
        
        String str2 = str;
        str2 = testClass.changeStr(str2);
        
        int x2 = testClass.changeX(x);

        System.out.println(value + " " + str + " " + x); //[999] FirstString 2
        System.out.println(value2 + " " + str2 + " " + x2); //[999] NewString 10
        System.out.println(value.equals(value2) + " " + str.equals(str2) + " " + (x2 == x)); //true false false</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0047 seconds] -->
<p></p>
<ol>
<li>Создаем ссылочный объект <span style="color: #920000;">value</span> и добавляем в него&nbsp;объект (Integer=23). Так же создаем строку <span style="color: #920000;">str=»FirstString»</span> и примитивное число <span style="color: #920000;">x= 2</span>.</li>
<li>Отдельно создаем объект value2 и выделяем под него память; Сейчас это выглядит что-то вроде <span style="color: #920000;">value</span>={ArrayList@450}, <span style="color: #920000;">value2</span>={ArrayList@453}, т.е. видно, что это разные ссылки на объекты (разные области памяти).</li>
<li><span style="color: #920000;">value2</span>={ArrayList@450}, <span style="color: #920000;">value</span>={ArrayList@450} после присвоения оба объекта ссылаются на одну область памяти.&nbsp;Теперь попытаемся изменить их с помощью методов в тестовом классе</li>
</ol>
<ul>
<li>Объекты передаются по копии указателя на область памяти. Т.к. <span style="color: #920000;">value</span> и <span style="color: #920000;">value2</span> указывают на один объект в памяти, то после изменения в методе&nbsp;<span style="color: #920000;">changeObjectValue</span> одного объекта, поменяется и второй.</li>
<li>Строка (String) всегда создается новая. Хоть<span style="color: #920000;"> str2 = str</span> и указывали на одну область вначале, но после изменения <span style="color: #920000;">str2</span> на новое значение <span style="color: #920000;">NewString</span>, значение первой строки осталось прежним.</li>
<li>Т.к. примитивные типы передаются по копии значения (в данном случае <span style="color: #920000;">2</span>), то изменение в методе примитивного типа никак не отразилось на значении исходной переменной <span style="color: #920000;">x</span><span style="color: #000000;"> (значение в области памяти для x осталось прежним)</span>.</li>
</ul>
<p>Если всё же остались вопросы, то гуглите по&nbsp;<strong>Java pass-by-value.</strong></p>
<h4>9.&nbsp;Что вы знаете о функции main, какие обязательные условия ее определения?</h4>
<p>Обязательная запись&nbsp;
			<span style="font-size: 14px !important; line-height: 18px !important;font-size: 14px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-familiar crayon-theme-familiar-inline crayon-font-arial" id="crayon-58cdd51dc49ba855173843"><span style="font-size: 14px !important; line-height: 18px !important;font-size: 14px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;" class="crayon-pre crayon-code"><span class="crayon-m">public</span><span class="crayon-h"> </span><span class="crayon-m">static</span><span class="crayon-h"> </span><span class="crayon-t">void</span><span class="crayon-h"> </span><span class="crayon-e">main</span><span class="crayon-sy">(</span><span class="crayon-t">String</span><span class="crayon-sy">[</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-v">args</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-c">/*тело метода*/</span><span class="crayon-h"> </span><span class="crayon-sy">}</span></span></span></p>
<p>Метод main() &mdash; точка входа в программу. Может быть несколько методов main. Входные параметры &mdash; только массив строк. Если этого метода не будет, то компиляция возможна, но при запуске будет <span style="color: #920000;">Error: Main method not found.</span></p>
<h4>10. Какие логические операции и операторы вы знаете?<br>
11. В чем разница краткой и полной схемы записи логических операторов?</h4>
<p>Логические операции: &gt;, &lt;, &lt;=, &gt;=, ==, !=;</p>
<table class="table">
<tbody>
<tr>
<th>Оператор</th>
<th>Описание</th>
</tr>
<tr>
<td>&amp;</td>
<td>Логическое AND (И)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Сокращённое AND</td>
</tr>
<tr>
<td>|</td>
<td>Логическое OR (ИЛИ)</td>
</tr>
<tr>
<td>||</td>
<td>Сокращённое OR</td>
</tr>
<tr>
<td>^</td>
<td>Логическое XOR (исключающее OR (ИЛИ))</td>
</tr>
<tr>
<td>!</td>
<td>Логическое унарное NOT (НЕ)</td>
</tr>
<tr>
<td>&amp;=</td>
<td>AND с присваиванием</td>
</tr>
<tr>
<td>|=</td>
<td>OR с присваиванием</td>
</tr>
<tr>
<td>^=</td>
<td>XOR с присваиванием</td>
</tr>
<tr>
<td>==</td>
<td>Равно</td>
</tr>
<tr>
<td>!=</td>
<td>Не равно</td>
</tr>
<tr>
<td>?:</td>
<td>Тернарный (троичный) условный оператор</td>
</tr>
</tbody>
</table>
<p>Если оба операнда имеют значение true, тогда операторы &amp; и &amp;&amp; возвращают true.</p>
<p>Если хотя бы один операнд имеет значение true, тогда операторы | и || возвращают true.</p>
<p>Операторы &amp; и | всегда проверяют значение обоих операндов. &amp;&amp; и || носят название операторов короткой схемы, так как если результат булевого выражения может быть определён из левого операнда, правый операнд не вычисляется.</p>
<p>Примечание: || и &amp;&amp; могут быть использованы только в логических выражениях.</p>
<h4>12.&nbsp;Что такое таблица истинности?</h4>
<p>Таблица истинности &mdash; это таблица, описывающая логическую функцию.</p>
<table class="table">
<tbody>
<tr>
<th>A</th>
<th>B</th>
<th>A | B</th>
<th>A &amp; B</th>
<th>A ^ B</th>
<th>!A</th>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<h4>13. Что такое тернарный оператор выбора?</h4>
<p>В языке Java есть также специальный тернарный условный оператор, которым можно заменить определённые типы операторов <span style="color: #920000;">if-then-else</span> &mdash; это оператор <span style="color: #920000;">?:</span></p>
<p>Тернарный оператор использует три операнда. Выражение записывается в следующей форме:<br>
<span style="color: #920000;">логическоеУсловие ? выражение1 : выражение2</span><br>
Если <span style="color: #920000;">логическоеУсловие</span> равно <span style="color: #920000;">true</span>, то вычисляется<span style="color: #920000;"> выражение1</span> и его результат становится результатом выполнения всего оператора. Если же <span style="color: #920000;">логическоеУсловие</span> равно <span style="color: #920000;">false</span>, то вычисляется<span style="color: #920000;"> выражение2</span>, и его значение становится результатом работы оператора. Оба операнда <span style="color: #920000;">выражение1</span> и <span style="color: #920000;">выражение2</span> должны возвращать значение одинакового (или совместимого) типа.</p>
<h4>14.&nbsp;Какие унарные и бинарные арифметические операции вы знаете?</h4>
<p>Унарные операции выполняются над одним&nbsp;операндом, бинарные &mdash; над двумя операндами, а также тернарные &mdash;&nbsp;выполняются над тремя операндами. Операндом является переменная или&nbsp;значение (например, число), участвующее в операции.</p>
<p>Пример унарных арифметических операций:</p>
<ul class="op_list">
<li><i>++</i> &mdash; постфиксный/префиксный инкремент, увеличивает значение целочисленной переменной на 1;</li>
<li><i>&mdash;</i>&nbsp;(двойной минус) &mdash; постфиксный/префиксный декремент, уменьшает значение целочисленной переменной на 1;</li>
<li><i>+</i> &mdash; оставляет знак числа;</li>
<li><i>&mdash;</i> &mdash; изменяет знак числа.</li>
</ul>
<p>Слово <dfn>постфиксный</dfn> означает, что операция применится к операнду после вычисления всего выражения, в которое операнд входит. Аналогично <dfn>префиксный</dfn> означает, что операция применится до вычисления выражения.</p>
<p>Пример бинарных арифметических операций:</p>
<ul class="op_list">
<li><i>+</i> &mdash; сложение чисел или строк;</li>
<li><i>&mdash;</i> &mdash; вычитание чисел;</li>
<li><i>*</i> &mdash; умножения чисел;</li>
<li><i>/</i> &mdash; деления чисел;</li>
<li><i>%</i> &mdash; вычисление остатка от деления чисел.</li>
</ul>
<p>Операция вычисления остатка от деления применима как к целым числам, так и к вещественным.</p>
<h4>15.&nbsp;Какие побитовые операции вы знаете?</h4>
<table class="table">
<tbody>
<tr>
<td>~</td>
<td>Побитовый унарный оператор NOT</td>
</tr>
<tr>
<td>&amp;</td>
<td>Побитовый AND</td>
</tr>
<tr>
<td>&amp;=</td>
<td>Побитовый AND с присваиванием</td>
</tr>
<tr>
<td>|</td>
<td>Побитовый OR</td>
</tr>
<tr>
<td>|=</td>
<td>Побитовый OR с присваиванием</td>
</tr>
<tr>
<td>^</td>
<td>Побитовый исключающее XOR</td>
</tr>
<tr>
<td>^=</td>
<td>Побитовый исключающее XOR с присваиванием</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Сдвиг вправо (деление&nbsp;на 2 в степени сдвига)</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>Сдвиг вправо с присваиванием</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>Сдвиг вправо с заполнением нулями</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Сдвиг влево&nbsp;(умножение на 2 в степени сдвига)</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>Сдвиг влево с присваиванием</td>
</tr>
<tr>
<td>&gt;&gt;&gt;=</td>
<td>Сдвиг вправо с заполнением нулями с присваиванием</td>
</tr>
</tbody>
</table>
<h5>Подробнее&nbsp;http://developer.alexanderklimov.ru/android/java/bitwise.php</h5>
<h4>16.&nbsp;Какова роль и правила написания оператора выбора (switch)?</h4>
<p>Оператор switch сравнивает аргумент на равенство с предложенным значением.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49c2082264663">
		
			<div class="crayon-plain-wrap"><pre>switch(ВыражениеДляСравнения) {
    case Совпадение1: 
	    команда;
		break;
	case Совпадение2: 
	    команда;
		break;
	case Совпадение3: 
	    команда;
		break;
	default: 
	    оператор;
	    break;
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>Обязательно необходимо ставить <span style="color: #920000;">break;</span> после завершения тело команды, иначе будет продолжаться выполнение ниже по строчкам.</p>
<h5>Подробнее http://developer.alexanderklimov.ru/android/java/switch.php</h5>
<h4>17. Какие циклы вы знаете, в чем их отличия?</h4>
<p>В Java используются циклы for, while, do-while.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49c5747849896">
		
			<div class="crayon-plain-wrap"><pre>while(условие) {
    // тело цикла
}

do {
    // тело цикла }
while(условие-логическое выражение)

for(инициализация; логическое выражение (условие); шаг (итерация)) {
    // тело цикла
}

for(Object object : objects) {
    // тело цикла 
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>do-while всегда выполнится хотя бы один раз, т.к. проверка идет после тела цикла.</p>
<h4>18. Что такое “итерация цикла”?</h4>
<p>Это одноразовое выполнение кода, размещенного в теле цикла.</p>
<h4>19. Какие параметры имеет цикл for, можно ли их не задать?</h4>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49c8596751863">
		
			<div class="crayon-plain-wrap"><pre>for(инициализация; логическое выражение (условие); шаг (итерация)) {
    // тело цикла
}
// можно записать вот так
for(;;) { 
}
//такая запись эквивалентна while(true) {}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>20. Какой оператор используется для немедленной остановки цикла?21. Какой оператор используется для перехода к следующей итерации цикла?</h4>
<p>break; &mdash; выход из цикла (не затрагивает внешний цикл).</p>
<p>continue; &mdash; заканчивает выполнение кода в этом теле цикла. Переход к следующей итерации.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49cb077877972">
		
			<div class="crayon-plain-wrap"><pre>for (int i=0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 4; j++) {
                if (j == 2) {
                    System.out.println("#A# i: " + i + " j: " + j + " break (end j loop). Will not see #C#");
                    break;
                }
                if (j == 1) {
                    System.out.println("#B# i: " + i + " j: " + j + " continue (j++).Will not see #C#");
                    continue;
                }
                System.out.println("#C# i: " + i + " j: " + j);
            }
        }
#C# i: 0 j: 0
#B# i: 0 j: 1 continue (j++).Will not see #C#
#A# i: 0 j: 2 break (end j loop). Will not see #C#
#C# i: 1 j: 0
#B# i: 1 j: 1 continue (j++).Will not see #C#
#A# i: 1 j: 2 break (end j loop). Will not see #C#
#C# i: 2 j: 0
#B# i: 2 j: 1 continue (j++).Will not see #C#
#A# i: 2 j: 2 break (end j loop). Will not see #C#</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0049 seconds] -->
<p></p>
<h4>22. Что такое массив?</h4>
<p>Массив (в некоторых языках программирования также таблица, ряд, матрица) &mdash; тип или структура данных в виде набора компонентов (элементов массива), расположенных в памяти непосредственно друг за другом. При этом доступ к отдельным элементам массива осуществляется с помощью индексации, то есть ссылки на массив с указанием номера (индекса) нужного элемента. За счёт этого, в отличие от списка, массив является структурой с произвольным доступом.</p>
<p>Размерность массива &mdash; это количество индексов, необходимое для однозначного доступа к элементу массива. Форма или структура массива &mdash; количество размерностей плюс размер (протяжённость) массива для каждой размерности; может быть представлена одномерным массивом.</p>
<p>В Java массивы являются объектами. Это значит, что имя, которое даётся каждому массиву, лишь указывает на адрес какого-то фрагмента данных в памяти. Кроме адреса в этой переменной ничего не хранится. Индекс массива, фактически, указывает на то, насколько надо отступить от начального элемента массива в памяти, чтоб добраться до нужного элемента.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd51dc49cf939369902">
		
			<div class="crayon-plain-wrap"><pre>тип[] имя;
тип  имя[];

тип[] имя  = new тип[размер];
тип[] имя = {эл0, эл1, …, элN};</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>23. Какие виды массивов вы знаете?</h4>
<p>В Java &mdash; одномерные и многомерные массивы.</p>
<h4>24. Что вы знаете о классах оболочках?</h4>
<p>Для каждого примитивного типа есть соответствующий класс (<span style="color: #920000;">Byte</span>, <span style="color: #920000;">Double</span>, <span style="color: #920000;">Float</span>, <span style="color: #920000;">Integer</span>, <span style="color: #920000;">Long</span>, <span style="color: #920000;">Short</span>). Числовые классы имеют общего предка &mdash; абстрактный класс Number, в котором описаны шесть методов, возвращающих числовое значение, содержащееся в классе, приведенное к соответствующему примитивному типу: <span style="color: #920000;">byteValue()</span>, <span style="color: #920000;">doubleValue()</span>, <span style="color: #920000;">floatValue()</span>, <span style="color: #920000;">intValue()</span>, <span style="color: #920000;">longValue()</span>, <span style="color: #920000;">shortValue()</span>. Эти методы переопределены в каждом из шести числовых классов-оболочек.</p>
<p><img src="pics/primitiveWrapper.jpg"/></p>
<h4>25.Что такое автоупаковка (boxing/unboxing)?</h4>
<p>Это автоматическое преобразование из примитивных типов данных к ссылочным и наоборот.</p></div>

<h2>2 ООП </h2>
<a href="http://javastudy.ru/interview/java-oop/">src2</a>
<div class="entry-body">
	            
<h3>Список всех вопросов по ООП</h3>
<p>1. Назовите принципы ООП и расскажите о каждом.<br>
2. Дайте определение понятию “класс”.<br>
3. Что такое поле/атрибут класса?<br>
4. Как правильно организовать доступ к полям класса?<br>
5. Дайте определение понятию “конструктор”.<br>
6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?<br>
7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.<br>
8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.<br>
9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?<br>
10. Дайте определение понятию “метод”.<br>
11. Что такое сигнатура метода?<br>
12. Какие методы называются перегруженными?<br>
13. Могут ли нестатические методы перегрузить статические?<br>
14. Расскажите про переопределение методов.<br>
15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?<br>
16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?<br>
17. Как получить доступ к переопределенным методам родительского класса?<br>
18. Какие преобразования называются нисходящими и восходящими?<br>
19. Чем отличается переопределение от перегрузки?<br>
20. Где можно инициализировать статические/нестатические поля?</p>

<p>21. Зачем нужен оператор instanceof?<br>
22. Зачем нужны и какие бывают блоки инициализации?<br>
23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?<br>
24. Где и для чего используется модификатор abstract?<br>
25. Можно ли объявить метод абстрактным и статическим одновременно?<br>
26. Что означает ключевое поле static?<br>
27. К каким конструкциям Java применим модификатор static?<br>
28. Что будет, если в static блоке кода возникнет исключительная ситуация?<br>
29. Можно ли перегрузить static метод?<br>
30. Что такое статический класс, какие особенности его использования?<br>
31. Какие особенности инициализации final static переменных?<br>
32. Как влияет модификатор static на класс/метод/поле?<br>
33. О чем говорит ключевое слово final?<br>
34. Дайте определение понятию “интерфейс”.<br>
35. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?<br>
36. Почему нельзя объявить метод интерфейса с модификатором final или static?<br>
37. Какие типы классов бывают в java (вложенные… и.т.д.)<br>
38. Какие особенности создания вложенных классов: простых и статических.<br>
39. Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о&nbsp;нарушении инкапсуляции.<br>
40. В чем разница вложенных и внутренних классов?<br>
41. Какие классы называются анонимными?<br>
42. Каким образом из вложенного класса получить доступ к полю внешнего класса?</p>

<p>43. Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле&nbsp;этого метода? Есть ли какие-нибудь ограничения для такой переменной?<br>
44. Как связан любой пользовательский класс с классом Object?<br>
45. Расскажите про каждый из методов класса Object.<br>
46. Что такое метод equals(). Чем он отличается от операции ==.<br>
47. Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?<br>
48. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?<br>
49. В чем особенность работы методов hashCode и equals? Каким образом реализованы методы hashCode и equals в&nbsp;классе Object? &nbsp;Какие правила и соглашения существуют для реализации этих методов? Когда они применяются?<br>
50. Какой метод возвращает строковое представление объекта?<br>
51. Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?<br>
52. Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?<br>
53. Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap&nbsp;изменится поле, которое участвует в определении hashCode?<br>
54. Чем отличается абстрактный класс о интерфейса, в каких случаях что вы будете использовать?<br>
55. Можно ли получить доступ к private переменным класса и если да, то каким образом?<br>
56. Что такое volatile и transient? Для чего и в каких случаях можно было бы использовать default?<br>
57. Расширение модификаторов при наследовании, переопределение и сокрытие методов. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?<br>
58. Имеет ли смысл объявлять метод private final?<br>
59. Какие особенности инициализации final переменных?<br>
60. Что будет, если единственный конструктор класса объявлен как final?<br>
61. Что такое finalize? Зачем он нужен? Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.<br>
62. Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?</p>

<h3>Ответы ооп. Часть 1</h3>
<h4>1. Назовите принципы ООП и расскажите о каждом.</h4>
<p>Объе́ктно-ориенти́рованное программи́рование (ООП) &mdash; это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.</p>
<p>Основные принципы ООП: абстракция, инкапсуляция, наследование, полиморфизм.</p>
<p><strong>Абстракция</strong> &mdash;&nbsp;&nbsp;означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.</p>
<p>Пример: описание должностей в компании. Здесь название должности значимая информация, а описание обязанностей у каждой должности это второстепенная информация. К примеру главной характеристикой для «директор» будет то, что это должность чем-то управляет, а чем именно (директор по персоналу, финансовый директор, исполнительный директор) это уже второстепенная информация.</p>
<p><strong>Инкапсуляция</strong> &mdash;&nbsp;свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». Пример из жизни &mdash; пульт от телевизора. Мы нажимаем кнопочку «увеличить громкость» и она увеличивается, но в этот момент происходят десятки процессов, которые скрыты от нас. Для Java: можно создать класс с 10 методами, например вычисляющие площадь сложной фигуры, но сделать из них 9 private. 10й метод будет называться «вычислитьПлощадь()» и объявлен public, а в нем уже будут вызываться необходимые скрытые от пользователя методы. Именно его и будет вызывать пользователь.</p>
<p><strong>Наследование</strong> &mdash;&nbsp;свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс &mdash; потомком, наследником, дочерним или производным классом.</p>
<p><strong>Полиморфизм&nbsp;</strong>&mdash;&nbsp;свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Пример (чуть переделанный) из Thinking in Java:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac21481900741">
		
			<div class="crayon-plain-wrap"><pre>public interface Shape {
    void draw();
    void erase();
}
public class Circle implements Shape {
    public void draw() {
        System.out.println("Circle.draw()");
    }
}
public class Triangle implements Shape {
    public void draw() {
        System.out.println("Triangle.draw()");
    }
}

public class TestPol {

    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Triangle();
        testPoly(shape1);
        testPoly(shape2);
    }

    public static void testPoly(Shape shape) {
        shape.draw();
    }
}
//Вывод в консоль:
//Circle.draw()
//Triangle.draw()</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0028 seconds] -->
<p>Есть общий интерфейс «Фигура» и две его реализации «Треугольник» и «Круг». У каждого есть метод «нарисовать». Благодаря полиморфизму нам нет нужды писать отдельный метод для каждой из множества фигур, чтобы вызвать метод «нарисовать».&nbsp; Вызов полиморфного метода позволяет одному типу выразить свое отличие от другого, сходного типа, хотя они и происходят от одного базового типа. Это отличие выражается различным действием методов, вызываемых через базовый класс (или интерфейс).<br>
Здесь приведен пример&nbsp;полиморфизма (также называемый динамическим связыванием, или поздним связыванием, или связыванием во время выполнения), в котором продемонстрировано как во время выполнения программы будет выполнен тот метод, который&nbsp;принадлежит передаваемому объекту.</p>
<p>Если бы не было полиморфизма и позднего связывания, то эта же программа выглядела бы примерно так:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac2d994827897">
		
			<div class="crayon-plain-wrap"><pre>public static void testPolyCircle(Circle circle) {
        circle.draw();
    }
    public static void testPolyTriangle(Triangle triangle) {
        triangle.draw();
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>Т.е. для каждого класса (фигуры) мы бы писали отдельный метод. Здесь их два, а если фигур (классов) сотни?</p>
<h4>2. Дайте определение понятию “класс”.</h4>
<p>Класс &ndash; это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.</p>
<h4>3. Что такое поле/атрибут класса?</h4>
<p>Поле (атрибут) класса &mdash; это характеристика объекта. Например для фигуры это может быть название, площадь, периметр.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac31877296880">
		
			<div class="crayon-plain-wrap"><pre>public class Circle implements Shape {

    private String name;
    private Double area;
    private String perimeter;

}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>4. Как правильно организовать доступ к полям класса?</h4>
<p>Модификатор доступа &mdash; private. Доступ через методы get\set.</p>
<h4>5. Дайте определение понятию “конструктор”.</h4>
<p>Конструктор &mdash; это специальный метод, который вызывается при создании нового объекта.&nbsp;Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac35290801486">
		
			<div class="crayon-plain-wrap"><pre>public class Circle implements Shape {

   public Circle() {
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h4>6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?</h4>
<p>Конструктор по умолчанию не принимает никаких параметров. Конструктор копирования принимает в качестве параметра объект&nbsp;класса. Конструктор с параметрами принимает на вход параметры (обычно необходимые для инициализации полей класса).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac38817404507">
		
			<div class="crayon-plain-wrap"><pre>    //конструктор по умолчанию
    public Circle() {
    }

    //конструктор копирования
    public Circle(Circle circle) {
        this(circle.getName(), circle.getArea(), circle.getPerimeter()); //будет вызван конструктор с параметрами ниже
    }
    
    //конструктор с параметрами
    public Circle(String name, Double area, String perimeter) {
        this.name = name;
        this.area = area;
        this.perimeter = perimeter;
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0016 seconds] -->
<p>Обращаю внимание, что тема копирования (clone()) достаточно глубокая с возможностью возникновения множества неявных проблем. Немного можно почитать здесь&nbsp;http://habrahabr.ru/post/246993/.</p>
<h4>7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.</h4>
<ul>
<li>private (закрытый)&nbsp;&mdash; доступ к члену класса не предоставляется никому, кроме методов этого класса. Другие классы того же пакета также не могут обращаться к private-членам.</li>
<li>default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует &mdash;&nbsp;члена класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.Т.е. если <span style="color: #920000;">package2.Class2</span> extends <span style="color: #920000;">package1.MainClass</span>, то в <span style="color: #920000;">Class2</span> методы <strong>без идентификатора</strong> из <span style="color: #920000;">MainClass</span> видны <strong>не будут</strong>.</li>
<li>protected (защищённый) &mdash; доступ в пределах пакета и классов наследников. Доступ в классе из другого пакета будет к методам public и protected главного класса.&nbsp;Т.е. если<span style="color: #920000;"> package2.Class2</span> extends <span style="color: #920000;">package1.MainClass</span>, то внутри <span style="color: #920000;">package2.Class2</span> методы&nbsp;с&nbsp;идентификатором <span style="color: #920000;">protected</span> из <span style="color: #920000;">MainClass</span> будут видны.</li>
<li>public (открытый)&nbsp;&mdash; доступ для всех из любого другого кода проекта</li>
</ul>
<p>Модификаторы в списке расположены по возрастающей видимости в программе.</p>
<h4>8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.</h4>
<p>Невозможно создать объект класса у которого единственный private конструктор за пределами класса. Поэтому нельзя унаследоваться от такого класса. При попытке унаследоваться будет выдаваться ошибка:&nbsp;<span style="color: #920000;">There is no default constructor available in имяКласса</span>. А при попытке создать объект этого класса: <span style="color: #920000;">ИмяКласса()&nbsp;has private access in ИмяКласса</span></p>
<h4>9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?</h4>
<p>super &mdash; используется для обращения&nbsp;к базовому классу, а this к текущему. Пример:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac3d269527363">
		
			<div class="crayon-plain-wrap"><pre>public class Animal {

    public void eat() {
        System.out.println("animal eat");
    }
}

public class Dog extends Animal {

    public void eat() {
        System.out.println("Dog eat");
    }
    public void thisEat() {
        System.out.println("Call Dog.eat()");
        this.eat();
    }

    public void superEat() {
        System.out.println("Call Animal.eat()");
        super.eat();
    }

}

public class Test {

    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.thisEat();
        dog.superEat();
    }
}
Dog eat
Call Dog.eat()
Dog eat
Call Animal.eat()
animal eat</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0029 seconds] -->
<p>Если написать super(), то будет вызван конструктор базового класса, а если this(), то конструктор текущего класса. Это можно использовать, например, при вызове конструктора с параметрами:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac40059281816">
		
			<div class="crayon-plain-wrap"><pre>public Dog() {
        System.out.println("Call empty constructor");
    }

    public Dog(String name) {
        System.out.println("Call constructor with Name");
        this.name = name;

    }

    public Dog(String name, Double weight) {
        this(name);
        this.weight = weight;
        System.out.println("Call constructor with Name and Weight");
    }
}
..
 public static void main(String[] args) {
 Dog dog1 = new Dog("name", 25.0);
}
//Вывод 
Call constructor with Name
Call constructor with Name and Weight</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0021 seconds] -->
<p></p>
<h4>10. Дайте определение понятию “метод”.</h4>
<p>Метод &mdash; это последовательность команд, которые вызываются по определенному имени. Можно сказать что это функция и процедура (в случае void метода).</p>
<h4>11. Что такое сигнатура метода?</h4>
<p>Сигнатура метода в Java &mdash; это имя метода плюс параметры (причем порядок параметров имеет значение).<br>
В сигнатуру метода не входит возвращаемое значение, бросаемые им исключения, а также модификаторы.</p>
<p>Ключевые слова public, protected, private, abstract, static, final, synchronized, native, strictfp в т.ч. аннотации для метода &mdash; это модификаторы и не являются частью сигнатуры.</p>
<h5>http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2</h5>
<h4>12. Какие методы называются перегруженными?</h4>
<p>Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac44526498629">
		
			<div class="crayon-plain-wrap"><pre>public void method() { }

public void method(int a) { }

public void method(String str) { }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>13. Могут ли нестатические методы перегрузить статические?</h4>
<p>Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.</p>
<h4>14. Расскажите про переопределение методов. Могут ли быть переопределены статические методы?</h4>
<p>Метод в классе-наследнике, совпадающий по сигнатуре с методом из родительского класса называется переопределенным методом. Переопределить базовый статический метод нельзя: <span style="color: #920000;">Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс</span></p>
<h4>15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?</h4>
<p>Да. Запись имеет вид <span style="color: #920000;">method(type … val)</span>. Например <span style="color: #920000;">public void method(String … strings)</span>, где <span style="color: #920000;">strings</span> это массив, т.е. можно записать</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac48656858058">
		
			<div class="crayon-plain-wrap"><pre> public void method (String ... strings) {
        for (String s : strings) {
            
        }
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</h4>
<p>При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass). Изменить тип возвращаемого значения при переопределении&nbsp;метода нельзя, будет ошибка <span style="color: #920000;">attempting to use incompatible return type.&nbsp;</span>Но можно сузить возвращаемое значение, если они совместимы. Например:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac4b294451646">
		
			<div class="crayon-plain-wrap"><pre>public class Animal {

    public Animal eat() {
        System.out.println("animal eat");
        return null;
    }
    
    public Long calc() {
        return null;
    }

}
public class Dog extends Animal {

    public Dog eat() {
        return new Dog();
    }
/*attempting to use incompatible return type
    public Integer calc() {
        return null;
    }
*/
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0013 seconds] -->
<p></p>
<h4>17. Как получить доступ к переопределенным методам родительского класса?</h4>
<p>super.method();</p>
<h4>18. Какие преобразования называются нисходящими и восходящими?</h4>
<p>Преобразование от потомка к предку называется восходящим, от предка к потомку &mdash; нисходящим. Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.</p>
<p>Например:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac4e933828097">
		
			<div class="crayon-plain-wrap"><pre>Animal dog = new Dog(); //восходящее преобразование. Будет потерян доступ ко всем методам, которые есть только у класса Dog.

int x = 100;
byte y = (byte) x;  //нисходящее преобразование. Должно быть указано явно</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>19. Чем отличается переопределение от перегрузки?</h4>
<p>Переопределение используется тогда, когда вы переписываете (переделываете, переопределяете) УЖЕ существующий метод. Перегрузка &mdash; это использование одного имени, но с разными входными параметрами. Например нам нужно, чтобы метод toString() для нашего класса выдавал какой-то осмысленный текст. Тогда мы переопределяем метод из класса Object и реализуем этот метод так, как нам это нужно.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce3056bac52951474462">
		
			<div class="crayon-plain-wrap"><pre>@Override
public String toString() {
return "Хочу чтобы писался текст, а не название класса@2234SD!"
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>Тогда как перегрузка обычно используется, чтобы не придумывать каждый раз новое имя, когда методы отличаются только входными параметрами. При перегрузке необходимый метод определяется на этапе компиляции на основе сигнатуры вызываемого метода, тогда как при переопределении нужный метод будет выявлен во время выполнения исходя из реального типа объекта.</p>
<h4>20. Где можно инициализировать статические/нестатические поля?</h4>
<p>Статические поля можно инициализировать при объявлении, в статическом или динамическом блоке инициализации. Нестатические поля можно инициализировать при объявлении, в динамическом блоке инициализации или в конструкторе.</p>	</div>

<div class="entry-body">
<h3>Вопросы ооп. Часть 2</h3>
<h4>21. Зачем нужен оператор instanceof?</h4>
<p>Оператор instanceof возвращает true, если объект является экземпляром класса или его потомком.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240acf052845514">
		
			<div class="crayon-plain-wrap"><pre>public class MainClass {
    public static void main(String[] a) {

    String s = "Hello";
    int i = 0;
    String g;
    if (s instanceof java.lang.String) {
       // попадем сюда, т.к. выражение будет true
       System.out.println("s is a String");
    }
    if (i instanceof Integer) {
       // это отобразится, т.к. будет использована автоупаковка (int -&gt; Integer)
       System.out.println("i is an Integer");
    }
    if (g instanceof java.lang.String) {
       // g не инициализирована и поэтому сюда мы не попадем, т.к.
       // g - null и instanceof вернет false для null. 
       System.out.println("g is a String");
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p></p>
<h4>22. Зачем нужны и какие бывают блоки инициализации?</h4>
<p>Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов. Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора. Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса. Блок инициализации способен генерировать исключения, если их объявления перечислены в предложениях throws всех конструкторов класса.</p>
<p>Бывают статические и нестатические блоки инициализации. Так же возможно создать такой блок в анонимном классе.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240ad9786195310">
		
			<div class="crayon-plain-wrap"><pre>class Foo {
	static List&lt;Character&gt; abc;
	static {
		abc = new LinkedList&lt;Character&gt;();
		for (char c = 'A'; c &lt;= 'Z'; ++c) {
			abc.add( c );
		}
	}
}
//Пример нестатического блока инициализации
class Bar {
	{
		System.out.println("Bar: новый экземпляр");
	}
}
//Пример инициализации в анонимном классе
JFrame frame = new JFrame() {{
	add(new JPanel() {{
		add(new JLabel("Хабрахабр?") {{
			setBackground(Color.BLACK);
			setForeground(Color.WHITE);
		}});
	}});
}};</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0022 seconds] -->
<p></p>
<h4>23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?</h4>
<p>Сначала вызываются все статические блоки от первого предка до последнего наследника. Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка).</p>
<p>Хорошая картинка, демонстрирующая что происходит на самом деле при инициализации с ресурса javarush.ru:</p>
<p><img src="pics/blockInitOrder.png" width="800px" /></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240ade293883780">
		
			<div class="crayon-plain-wrap"><pre>public class Pet {
    private String name;
    static {
        System.out.println("Static block in Pet");
    }
    {
        System.out.println("First block in Pet");
    }
    {
        System.out.println("Second block in Pet");
    }

    public Pet() {
        System.out.println("Pet empty constructor");
    }

    public Pet(String name) {
        System.out.println("Pet constructor with Name " + name);
        this.name = name;
    }
}

public class Cat extends Pet {

    private String name;
    static {
        System.out.println("Static block in Cat");
    }
    {
        System.out.println("First block in Cat");
    }
    {
        System.out.println("Second block in Cat");
    }

    public Cat() {
        System.out.println("Cat empty constructor");
    }

    public Cat(String name) {
        super(name); // without this will call super(). Если эту строчку убрать, то будет вызван конструктор Pet();
        System.out.println("Cat constructor with Name: " + name);
        this.name = name;
    }

}

public class TestInitOrder {

    public static void main(String[] args) {
        Cat cat = new Cat("Rizhick");
    }
}
//Вывод
Static block in Pet
Static block in Cat
First block in Pet
Second block in Pet
Pet constructor with Name Rizhick
First block in Cat
Second block in Cat
Cat constructor with Name: Rizhick</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0045 seconds] -->
<p></p>
<h4>24. Где и для чего используется модификатор abstract?</h4>
<p>Абстрактным называется класс, на основе которого не могут создаваться объекты. При этом наследники класса могут быть не абстрактными, на их основе объекты создавать, соответственно, можно.&nbsp;Для того, чтобы превратить класс в абстрактный перед его именем надо указать модификатор abstract.</p>
<p>Абстрактный метод &mdash; метод, который не имеет реализации. Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240ae2413832329">
		
			<div class="crayon-plain-wrap"><pre>public abstract class Fighter {
    abstract void fight();
}

public class JudoFighter extends Fighter {
    @Override
    void fight() {
        System.out.println("Учу ушу, руками машу! Бью с лету в душу...");
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>Использование абстрактных классов и методов позволяет описать некую абстракцию, которая должна быть реализована в других классах. Например, мы можем создать абстрактный класс Fighter и объявить в нём абстрактный метод <span style="color: #920000;">fight()</span>. Т.к. стилей борьбы может быть много, то,&nbsp;например, для <span style="color: #920000;">JudoFighter extends Fighter</span>&nbsp;метод <span style="color: #920000;">fight()</span> будет описывать приемы в стиле дзюдо и т.д.</p>
<h4>25. Можно ли объявить метод абстрактным и статическим одновременно?</h4>
<p>Нет. Получите: <span style="color: #920000;">Illegal combination of modifiers: ‘abstract’ and ‘static’</span>. Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот метод будет доступен по имени класса.</p>
<h4>26. Что означает ключевое поле static?</h4>
<p>Модификатор static говорит о том, что метод или поле класса принадлежат не объекту, а классу. Т.е. доступ можно будет получить и не создавая объекта класса. Поля помеченные static инициализируются при инициализации класса. К примеру,&nbsp;Class.forName(«MyClass», true, currentClassLoader), где второй параметр&nbsp;указывает на необходимость проведения&nbsp;инициализации.</p>
<p>На методы, объявленные как static, накладывается ряд ограничений.</p>
<ul>
<li>Они могут вызывать только другие статические методы.</li>
<li>Они должны осуществлять доступ только к статическим переменным.</li>
<li>Они не могут ссылаться на члены типа this или super.</li>
</ul>
<h4>27. К каким конструкциям Java применим модификатор static?</h4>
<ul>
<li>К методу.</li>
<li>К внутреннему классу.</li>
<li>К полю.</li>
<li>К импортируемым классам (с 5-ой java). Например,&nbsp;<span style="color: #920000;">import static org.junit.Assert.assertThat;</span></li>
</ul>
<h4>28. Что будет, если в static блоке кода возникнет исключительная ситуация?</h4>
<p>Если в явном виде написать любое исключение в <span style="color: #920000;">static-блоке</span>, то компилятор не скомпилирует исходники. Это все от того, что компилятор умный. В остальном, взаимодействие с исключениями такое же как и в любом другом месте. Если <span style="color: #920000;">unchecked</span> исключение вывалится в <span style="color: #920000;">static-блоке</span>, то класс не будет инициализирован.<br>
Какое исключение выбрасывается при ошибке в блоке инициализации?</p>
<p>Для <span style="color: #920000;">static</span>:</p>
<ul>
<li><span style="color: #920000;">java.lang.ExceptionInInitializerError</span> &mdash; если исключение наследуется от <span style="color: #920000;">RuntimeException</span>.</li>
</ul>
<p>Для <span style="color: #920000;">init</span>:</p>
<ul>
<li><span style="color: #920000;">exception</span>, который и вызвал исключение, если он наследуется от <span style="color: #920000;">RuntimeException</span>.</li>
</ul>
<p>Верно для <span style="color: #920000;">static </span>и <span style="color: #920000;">init</span>:</p>
<ul>
<li><span style="color: #920000;">java.lang.Error</span> &mdash; если исключение вызвано <span style="color: #920000;">Error</span>.</li>
<li><span style="color: #920000;">java.lang.ThreadDeath</span> &mdash; смерть потока. Ничего не вываливается.</li>
</ul>
<h4>29. Можно ли перегрузить static метод?</h4>
<p>Перегрузить можно, но переопределить нельзя.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240ae8881217594">
		
			<div class="crayon-plain-wrap"><pre>    public Animal eat() {
        System.out.println("animal eat");
        return null;
    }
    public static Animal eat(String s) {
        System.out.println("test static overload");
        return null;
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p></p>
<h4>30. Что такое статический класс, какие особенности его использования?</h4>
<p>Это вложенный класс, который может обращаться только к статическим полям обертывающего его класса, в том числе и приватным. Доступ к нестатическим полям обрамляющего класса может быть осуществлен только через ссылку на экземпляр обрамляющего объекта. <strong>К</strong> <strong>классу высшего уровня</strong>&nbsp;модификатор <span style="color: #920000;">static</span> <strong>неприменим</strong>.</p>
<p>В примере показано, что для инициализации внутреннего статического класса нет нужды в инициализации родителя. Но в случае обычного внутреннего класса такой номер не пройдет:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240aeb497271462">
		
			<div class="crayon-plain-wrap"><pre>public class Test { 
  class A { } 
  static class B { }
  public static void main(String[] args) { 
    /*will fail - compilation error, you need an instance of Test to instantiate A*/
    A a = new A(); 
    /*will compile successfully, no instance of Test is needed to instantiate B */
    B b = new B(); 
  }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p>Статические вложенные классы, не имеют доступа к нестатическим полям и методам обрамляющего класса, что в некотором роде аналогично статическим методам, объявленным внутри класса. Доступ к нестатическим полям и методам может осуществляться только через ссылку на экземпляр обрамляющего класса. В этом плане static nested классы очень похожи на любые другие классы верхнего уровня.</p>
<h4>31. Какие особенности инициализации final static переменных?</h4>
<p>Переменные должны быть инициализированы во время объявления или в static блоке.</p>
<h4>32. Как влияет модификатор static на класс/метод/поле?</h4>
<p>Модификатор static говорит о том, что метод или поле класса принадлежат не объекту, а классу.</p>
<p>Внутри static метода нельзя вызвать не статический метод по имени класса.</p>
<p>Про static класс смотрите ответ выше.</p>
<h4>33. О чем говорит ключевое слово final?</h4>
<p>Может быть применено к полям, методам или классам. В зависимости к какой сущности приложено данное ключевое слово &mdash; будет и различный смысл в его применении.</p>
<ul>
<li>Для класса. Класс помеченный при помощи <span style="color: #920000;">final</span> не может иметь наследников.</li>
<li>Для метода. Метод помеченный при помощи <span style="color: #920000;">final </span>не может быть переопределен в классах наследниках.</li>
<li>Для поля. Поле помеченное при помощи слова <span style="color: #920000;">final </span>не может изменить свое значение после инициализации (инициализируется либо при описании, либо в конструкторе, статическом или динамическом блоке).</li>
<li>Значение локальных переменных, а так же параметров метода помеченных при помощи слова <span style="color: #920000;">final </span>не могут быть изменены после присвоения.</li>
</ul>
<h4>34. Дайте определение понятию “интерфейс”.</h4>
<p>Ключевое слово <b>interface</b> используется для создания полностью абстрактных классов. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не тела методов.</p>
<p>Наличие слова <b>interface</b> означает, что именно так должны выглядеть все классы, которые реализуют данный интерфейс. Таким образом, любой код, использующий конкретный интерфейс, знает только то, какие методы вызываются для этого интерфейса, но не более того.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240af1207555769">
		
			<div class="crayon-plain-wrap"><pre>public interface SomeName{
    void method();
    int getSum();
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h4>35. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h4>
<p>Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.</p>
<h4>36. Почему нельзя объявить метод интерфейса с модификатором final или static?</h4>
<p>Вообще с 8й версии можно static, но нужно чтобы было тело метода. Например</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54240af4876163683">
		
			<div class="crayon-plain-wrap"><pre>public interface Shape {
    static void draw() {
        System.out.println("Wow! It is impossible!");
    };
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>final модификатор просто бессмысленный. Все методы по умолчанию абстрактные, т.е. их невозможно создать не реализовав где-то еще, но это нельзя будет сделать, если у метода идентификатор&nbsp;<span style="color: #920000;">final</span>.</p>
<h4>37. Какие типы классов бывают в java (вложенные… и.т.д.)<br>
38. Какие особенности создания вложенных классов: простых и статических.</h4>
<ul>
<li>Обычные классы (<code>Top level classes</code>)</li>
<li>Интерфейсы (<code>Interfaces</code>)</li>
<li>Перечисления (<code>Enum</code>)</li>
<li>Статические вложенные классы (<code>Static nested classes</code>)
<ul>
<li>Есть возможность обращения к внутренним статическим полям и методам класса обертки.</li>
<li>Внутренние статические интерфейсы могут содержать только статические методы.</li>
</ul>
</li>
<li>Внутренние классы-члены (<code>Member inner classes</code>)
<ul>
<li>Есть возможность обращения к внутренним полям и методам класса обертки.</li>
<li>Не может иметь статических объявлений.</li>
<li>Нельзя объявить таким образом интерфейс. А если его объявить без идентификатора <code>static</code>, то он автоматически будет добавлен.</li>
<li>Внутри такого класса нельзя объявить перечисления.</li>
<li>Если нужно явно получить <code>this</code> внешнего класса &mdash; <code>OuterClass.this</code></li>
</ul>
</li>
<li>Локальный класс (<code>Local inner classes</code>)
<ul>
<li>Видны только в пределах блока, в котором объявлены.</li>
<li>Не могут быть объявлены как <code>private</code>/<code>public</code>/<code>protected</code> или <code>static</code> (по этой причине интерфейсы нельзя объявить локально).</li>
<li>Не могут иметь внутри себя статических объявлений (полей, методов, классов).</li>
<li>Имеют доступ к полям и методам обрамляющего класса.</li>
<li>Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором <code>final</code>.</li>
</ul>
</li>
<li>Анонимные классы (<code>Anonymous inner classes</code>)
<ul>
<li>Локальный класс без имени.</li>
</ul>
</li>
</ul>
<h4>39. Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о&nbsp;нарушении инкапсуляции.<br>
40. В чем разница вложенных и внутренних классов?<br>
41. Какие классы называются анонимными?</h4>
<p>Вложенный класс &mdash; это класс, который объявлен внутри объявления другого класса. Вложенные классы делятся на статические и нестатические (non-static). Собственно нестатические вложенные классы имеют и другое название &mdash; внутренние классы (inner classes).</p>
<p>Внутренние классы в Java делятся на такие три вида:</p>
<ul>
<li>внутренние классы-члены (member inner classes);</li>
<li>локальные классы (local classes);</li>
<li>анонимные классы (anonymous classes).</li>
</ul>
<p>Внутренние классы-члены ассоциируются не с самим внешним классом, а с его экземпляром. При этом они имеют доступ ко всем его полям и методам.</p>
<p>Локальные классы (local classes) определяются в блоке Java кода. На практике чаще всего объявление происходит в методе некоторого другого класса. Хотя объявлять локальный класс можно внутри статических и нестатических блоков инициализации.</p>
<p>Анонимный класс (anonymous class) &mdash; это локальный класс без имени.</p>
<p>Использование вложенных классов всегда приводит к некоторому нарушению инкапсуляции &mdash; вложенный класс может обращаться к закрытым членам внешнего класса (но не наоборот!). Если это обстоятельство учитывается в архитектуре вашего приложения, не стоит уделять ему особого внимания, поскольку внутренний класс всего лишь является специализированным членом внешнего класса.</p>
<h5>Подробнее&nbsp;http://www.quizful.net/post/inner-classes-java</h5>
<h4>42. Каким образом из вложенного класса получить доступ к полю внешнего класса?</h4>
<p>Если вложенный класс не статический и поле не статическое, то можно просто обратиться к этому полю из внутреннего класса, если только у внутреннего класса не существует поля с таким же литералом, в этом случае нужно обраться через ссылку на внешний класс так &mdash; <span style="color: #920000;">OuterClass.this.имяПоля</span></p>
<p>*Из комментария к статье: достаточно, чтобы класс был не статическим, а поле статическое или нет &mdash; значения не имеет для Member Inner Class.</p></div>

<div class="entry-body">
<h3>Ответы ооп. Часть 3</h3>
<h4>43. Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле&nbsp;этого метода? Есть ли какие-нибудь ограничения для такой переменной?</h4>
<p>Также как и локальные классы, анонимные могут захватывать переменные, доступ к локальным переменным происходит по тем же правилам:</p>
<ul>
<li>Анонимный класс имеет доступ к полям внешнего класса.</li>
<li>Анонимный класс не имеет доступ к локальным переменным области, в которой он определен, если они не финальные (final) или неизменяемые (effectively final).</li>
<li>Как и у других внутренних классов, объявление переменной с именем, которое уже занято, затеняет предыдущее объявление.</li>
</ul>
<ul>
<li>Вы не можете определять статические члены анонимного класса.</li>
</ul>
<p>Анонимные классы также могут содержать в себе локальные классы. Конструктора в анонимном классе быть не может.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdcba68cfd4340091180">
		
			<div class="crayon-plain-wrap"><pre>public class Animal {
    
    Integer classAreaVar2 = 25;

    public void anonymousClassTest() {
        final Integer[] localAreaVar = {25};
        //Анонимный класс
        ActionListener listener = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                //можно использовать переменные класса без указания final
                classAreaVar2 = classAreaVar2 + 25;

                //нельзя использовать локальные переменные, если они не final;
                /*Local variable is accessed from within inner class: needs to be declared final */
                localAreaVar[0] = localAreaVar[0] +5;
            }
        };
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0019 seconds] -->
<p></p>
<h4>44. Как связан любой пользовательский класс с классом Object?</h4>
<p>Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object o может ссылаться на объект любого другого класса.</p>
<h4>45. Расскажите про каждый из методов класса Object.</h4>
<ul>
<li><span style="color: #920000;">public final native Class getClass()</span>&nbsp;&mdash;&nbsp;возвращает в рантайме класс данного объекта.</li>
<li><span style="color: #920000;">public native int hashCode()</span> &mdash; возвращает хеш-код</li>
<li><span style="color: #920000;">public boolean equals(Object obj)</span> &mdash; сравнивает объекты.</li>
<li><span style="color: #920000;">protected native Object clone() throws CloneNotSupportedException</span> &mdash; клонирование объекта</li>
<li><span style="color: #920000;">public String toString()</span> &mdash; возвращает строковое представление объекта.</li>
<li><span style="color: #920000;">public final native void notify()</span>&nbsp;&mdash;&nbsp;просыпается один поток, который ждет на “мониторе” данного объекта.</li>
<li><span style="color: #920000;">public final native void notifyAll()</span>&nbsp;&mdash; просыпаются все потоки, которые ждут на “мониторе” данного объекта.</li>
<li><span style="color: #920000;">public final native void wait(long timeout) throws InterruptedException</span></li>
<li><span style="color: #920000;">public final void wait() throws InterruptedException</span>&nbsp;&mdash;&nbsp;приводит данный поток в ожидание, пока другой поток не вызовет <span style="color: #920000;">notify()</span> или <span style="color: #920000;">notifyAll()</span> методы для этого объекта.</li>
<li><span style="color: #920000;">public final void wait(long timeout, int nanos) throws InterruptedException</span>&nbsp;&mdash;&nbsp;приводит данный поток в ожидание, пока другой поток не вызовет <span style="color: #920000;">notify()</span> или <span style="color: #920000;">notifyAll()</span> для этого метода, или пока не истечет указанный промежуток времени.</li>
<li><span style="color: #920000;">protected void finalize() throws Throwable</span>&nbsp;&mdash; вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.</li>
</ul>
<h4>46. Что такое метод equals(). Чем он отличается от операции ==.<br>
47. Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?<br>
47. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?<br>
49. В чем особенность работы методов hashCode и equals? Каким образом реализованы методы hashCode и equals в&nbsp;классе Object? Какие правила и соглашения существуют для реализации этих методов? Когда они применяются?</h4>
<p>Метод, определенный в <span style="color: #920000;">Object</span>, который служит для сравнение объектов на равенство. При сравнении&nbsp;объектов при помощи <span style="color: #920000;">==</span> идет сравнение по ссылкам. При сравнении по <span style="color: #920000;">equals()</span> идет сравнение по состояниям объектов (реализация метода equals для нового созданного класса ложится на плечи разработчиков).&nbsp;С точки зрения математики&nbsp;equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.</p>
<ul>
<li><b>Рефлексивность</b>: для любого ненулевого x, x.equals(x) вернет true;</li>
<li><b>Транзитивность</b>: для любого ненулевого x, y и z, если x.equals(y) и y.equals(z) вернет true, тогда и x.equals(z) вернет true;</li>
<li><b>Симметричность:</b><b> </b>для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true<b>.</b></li>
<li>Также для любого ненулевого<b> </b>x, x.equals(null) должно вернуть false</li>
</ul>
<div>При переопределении equals() обязательно нужно переопределить&nbsp;метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.<b> </b></div>
<div></div>
<p>Хеш-код &mdash; это число. Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. В терминах Java, хеш-код &mdash; это целочисленный результат работы метода, которому в качестве входного параметра передан объект.</p>
<p>Этот метод реализован таким образом, что для одного и того-же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом <span style="color: #920000;">int</span>, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: “Множество объектов мощнее множества хеш-кодов”. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.</p>
<p>Здесь главное понять, что:</p>
<ul>
<li>Если хеш-коды разные, то и входные объекты гарантированно разные.</li>
<li>Если хеш-коды равны, то входные объекты не всегда равны.</li>
</ul>
<p>Ситуация, когда у <i>разных </i>объектов <i>одинаковые </i>хеш-коды называется &mdash; коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.</p>
<h5>Статья с хабра по equals и hashCode:&nbsp;http://habrahabr.ru/post/168195/</h5>
<h4>50. Какой метод возвращает строковое представление объекта?</h4>
<p>someObject.<span style="color: #920000;">toString()</span>;</p>
<h4>51. Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?</h4>
<p>Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта <span style="color: #920000;">HashMap</span> это может привести к тому, что пара, которая была помещена в Map&nbsp;возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.</p>
<h4>52. Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?</h4>
<p>Те, которые используют при определении метода <code>equals()</code>. Хэш код должен быть равномерно распределен на области возможных принимаемых значений.</p>
<h4>53. Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap&nbsp;изменится поле, которое участвует в определении hashCode?</h4>
<p>Будут. При обращении по ключу мы можем&nbsp;не найти значение.</p>
<h4>54. Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?</h4>
<p>Абстрактные классы используются только тогда, когда есть «is a» тип отношений; интерфейсы могут быть реализованы классами которые не связаны друг с другом.</p>
<p>Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы и начиная с 8й версии.</p>
<p>Интерфейс может описывать константы и методы. Все методы интерфейса по умолчанию являются публичными (public) и абстрактными (abstract), а поля &mdash; public static final. С java 8 в интерфейсах можно реализовывать default и статические методы.</p>
<p>В Java класс может наследоваться (реализовывать) от многих интерфейсов, но только от одного абстрактного класса.</p>
<p>С абстрактными классами вы теряете индивидуальность класса, наследующего его; с интерфейсами вы просто расширяете функциональность каждого класса.</p>
<h4>55. Можно ли получить доступ к private переменным класса и если да, то каким образом?</h4>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdcba68cfe5043341339">
		
			<div class="crayon-plain-wrap"><pre>public class SomeClass {

    private String name = "SomeNameString";
    private Integer x = 25;

}

public class TestPrivateAccess {

    public static void main(String[] args) {
        SomeClass someClass = new SomeClass();

        try {
            Field reflectField = SomeClass.class.getDeclaredField("name"); //NoSuchFieldException e
            Field reflectField2 = SomeClass.class.getDeclaredField("x"); //NoSuchFieldException e

            /* Если не дать доступ, то будет ошибка
            java.lang.IllegalAccessException: Class .. .TestPrivateAccess
            can not access a member of class .. .SomeClass with modifiers "private"
            */
            reflectField.setAccessible(true);
            reflectField2.setAccessible(true);

            String fieldValue = (String) reflectField.get(someClass); //IllegalAccessException ex
            Integer fieldValue2 = (Integer) reflectField2.get(someClass); //IllegalAccessException ex
            System.out.println(reflectField);//private java.lang.String ru.javastudy.interview.oop.privateFieldAccess.SomeClass.name
            System.out.println(fieldValue); //SomeNameString

            System.out.println(reflectField2);//private java.lang.Integer ru.javastudy.interview.oop.privateFieldAccess.SomeClass.x
            System.out.println(fieldValue2); //25
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();;
        }

    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0036 seconds] -->
<p></p>
<h4>56. Что такое volatile и transient? Для чего и в каких случаях можно было бы использовать default?</h4>
<p><span style="color: #920000;">volatile &nbsp;</span>&mdash; не используется кэш (имеется ввиду область памяти в которой JVM может сохранять локальную копию переменной, чтобы уменьшить время обращения к переменной) при обращении к полю. Для volatile переменной JVM гарантирует синхронизацию для операций чтения/записи, но не гарантирует для операций изменения значения переменной.</p>
<p><span style="color: #920000;">transient</span> &mdash; указание того, что при сериализации/десериализации данное поле не нужно сериализовать/десериализовывать.</p>
<h4>57. Расширение модификаторов при наследовании, переопределение и сокрытие методов. Если у класса-родителя есть&nbsp;метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить&nbsp;видимость?</h4>
<p>Действует общий принцип: расширять видимость можно, сужать нельзя. <span style="color: #920000;">private&nbsp;</span>методы видны только внутри класса, для потомков они не видны. Поэтому их и расширить нельзя.</p>
<h4>58. Имеет ли смысл объявлять метод private final?</h4>
<p>Нет, такой метод&nbsp;и так&nbsp;не виден для наследников, а значит не может быть ими переопределен.</p>
<h4>59. Какие особенности инициализации final переменных?</h4>
<ul>
<li>Для поля. Поле помеченное при помощи слова <span style="color: #920000;">final</span> не может изменить свое значение после инициализации.<br>
Не статическое final поле можно инициализировать: при описании, в конструкторе (во всех), в статическом блоке, в динамическом блоке.<br>
Статическое final поле (static final) инициализируется либо в статическом блоке, либо при описании.</li>
<li>Значение локальных переменных, а так же параметров метода помеченных при помощи слова <span style="color: #920000;">final</span> не могут быть изменены после присвоения.</li>
</ul>
<h4>60. Что будет, если единственный конструктор класса объявлен как final?</h4>
<p>К конструктору не применимо ключевое слово <span style="color: #920000;">final</span>.</p>
<h4>61. Что такое finalize? Зачем он нужен? Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.</h4>
<p>Метод <span style="color: #920000;">finalize()</span> вызывается перед тем, как объект будет удален garbage collector (сборщик мусора, далее&nbsp;<span style="color: #920000;">gc</span>). Существует много различных реализаций <span style="color: #920000;">gc</span>. Основа работы следующая, <span style="color: #920000;">gc </span>помечает объекты на которых больше не ссылаются другие объекты для их удаления. Затем на одном из проходов помеченные объекты удаляются.<br>
Вызов<span style="color: #920000;"> finalize()</span> не гарантируется, т.к. приложение может быть завершено до того, как будет запущена ещё одна сборка мусора. Да, можно отменить сборку объекта с помощью метода <span style="color: #920000;">finalize()</span>, присвоив его ссылку какому-то статистическому методу.</p>
<h4>62. Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?</h4>
<p>Это указывает на то, что хоть метод и есть в классе <span style="color: #920000;">Object</span>, но если им разработчик желает воспользоваться, то его нужно переопределить. Для этого нужно реализовать интерфейс <span style="color: #920000;">Clonable</span>, чтобы соблюсти контракт.</p></div>


<h2>3 исключения (exceptions)</h2>
<a href="http://javastudy.ru/interview/exceptions/">src3</a>
<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Дайте определение понятию “исключение”<br>
2. Какова иерархия исключений.<br>
3. Можно/нужно ли обрабатывать ошибки jvm?<br>
4. Какие существуют способы обработки исключений?<br>
5. О чем говорит ключевое слово throws?<br>
6. В чем особенность блока finally? Всегда ли он исполняется?<br>
7. Может ли не быть ни одного блока catch при отлавливании исключений?<br>
8. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?<br>
9. Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований)?<br>
10. Что вы знаете об обрабатываемых и не обрабатываемых (catched/uncatched) исключениях?<br>
11. В чем особенность RuntimeException?<br>
12. Как написать собственное (“пользовательское”) исключение? Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?<br>
13. Какой оператор позволяет принудительно выбросить исключение?<br>
14. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?<br>
15. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?<br>
16. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?<br>
17. Что вы знаете о OutOfMemoryError?<br>
18. Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?<br>
19. Что такое Error? В каком случае используется Error. Приведите пример Error’а.<br>
20. Какая конструкция используется в Java для обработки исключений?<br>
21. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?<br>
22. Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?</p>
<h3>Ответы</h3>
<h4>1. Дайте определение понятию “исключение”</h4>
<p><strong>Исключение </strong>&mdash; это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:</p>
<ol>
<li>Пользователь ввел некорректные данные.</li>
<li>Файл, к которому обращается программа, не найден.</li>
<li>Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.</li>
</ol>
<p>Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.</p>
<h4>2. Какова иерархия исключений.</h4>
<p><img src="pics/exceptionsInJavaHierarchy.png" width="1000px" /></p>
<p>Исключения делятся на несколько классов, но все они имеют общего предка &mdash; класс Throwable. Его потомками являются подклассы Exception и Error.</p>
<p>Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.</p>
<p>Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.</p>
<p>В Java все исключения делятся на два&nbsp;типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).</p>
<p>Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).</p>
<h4>3. Можно/нужно ли обрабатывать ошибки jvm?</h4>
<p>Обрабатывать можно, но делать этого не стоит. Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.</p>
<h4>4. Какие существуют способы обработки исключений?</h4>
<div>В Java есть пять ключевых слов для работы с исключениями:</div>
<div>
<ol>
<li><strong>try </strong>&mdash; данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.</li>
<li><strong>catch </strong>&mdash; ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.</li>
<li><strong>finally </strong>&mdash; ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок ‘finally’ в любом случае.</li>
<li><strong>throw </strong>&mdash; служит для генерации исключений.</li>
<li><strong>throws </strong>&mdash; ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.</li>
</ol>
<p>Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b042d824493421">
		
			<div class="crayon-plain-wrap"><pre>try{ 
//здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e ){ //в скобках указывается класс конкретной ожидаемой ошибки  
//здесь описываются действия, направленные на обработку исключений 
} 
finally{ 
//выполняется в любом случае ( блок finally  не обязателен) 
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>
</p></div>
<h5>Подробнее&nbsp;http://www.quizful.net/post/java-exceptions</h5>
<h4>5. О чем говорит ключевое слово throws?</h4>
<p><strong>throws </strong>&mdash; ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.</p>
<h4>6. В чем особенность блока finally? Всегда ли он исполняется?</h4>
<p>Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм <b>finally</b>.</p>
<p>Ключевое слово <b>finally</b> создаёт блок кода, который будет выполнен после завершения блока <b>try/catch</b>, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор <b>finally</b> не обязателен, однако каждый оператор <b>try</b> требует наличия либо <b>catch</b>, либо <b>finally</b>. Код в блоке <strong>finally</strong> будет выполнен <strong>всегда</strong>.</p>
<h4>7. Может ли не быть ни одного блока catch при отлавливании исключений?</h4>
<p>Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04aa452052039">
		
			<div class="crayon-plain-wrap"><pre>String x = "z";
try {
   x="234";
} finally {
    x = "Finally";
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>8. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?</h4>
<p>Не всегда. Например&nbsp;в такой ситуации:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04b0790630695">
		
			<div class="crayon-plain-wrap"><pre>try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>Здесь finally недостижим, так как происходит системный выход из программы.&nbsp;Общими словами: когда jvm умирает, ей не до finally (отсюда можете придумать другие примеры как убить jvm и ответить на вопрос в заголовке).</p>
<h4>9. Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований)?</h4>
<div>В <strong>Java 7</strong> стала доступна новая конструкция, с помощью которой можно перехватывать несколько исключений одни блоком catch:</div>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04b3891306139">
		
			<div class="crayon-plain-wrap"><pre>try {  
 ... 
} catch( IOException | SQLException ex ) {  
  logger.log(ex); 
  throw ex; 
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>10. Что вы знаете об обрабатываемых и не обрабатываемых (catched/uncatched) исключениях?</h4>
<p>Все исключительные ситуации делятся на «проверяемые» (checked) и «непроверяемые» (unchecked) (смотрите картинку в начале статьи). Это свойство присуще «корневищу» (Throwable, Error, Exception, RuntimeException) и передается по наследству. Никак не видимо в исходном коде класса исключения.<br>
В дальнейших примерах просто учтите, что&mdash; Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) &mdash; checked<br>
&mdash; Error и RuntimeException и все их наследники &mdash; unchecked<br>
checked exception = проверяемое исключение, проверяемое компилятором.</p>
<p>Тема достаточно обширная для того, чтобы уместить ее в одном ответе. К примеру, можно разобрать примеры Головача:&nbsp;http://habrahabr.ru/company/golovachcourses/blog/225585/</p>
<p>И еще с quizful.net</p>
<p>1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.<br>
2. Unchecked исключения в Java &mdash; наследованные от RuntimeException, checked &mdash; от Exception (не включая unchecked).</p>
<p>Checked исключения отличаются от Unchecked исключения в Java, тем что:<br>
1)Наличие\обработка <strong>Checked</strong> исключения проверяются <strong>на этапе компиляции</strong>. Наличие\обработка <strong>Unchecked</strong> исключения происходит <strong>на этапе выполнения</strong>.</p>
<h4>11. В чем особенность RuntimeException?</h4>
<p>public class RuntimeException extends Exception &mdash; базовый класс для ошибок во время выполнения. Относится к необрабатываемым&nbsp;исключениям (uncatched\unchecked). Как сказано в описании класса &mdash; это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.</p>
<h4>12. Как написать собственное (“пользовательское”) исключение? Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?</h4>
<p>Необходимо унаследоваться от базового класса требуемого типа исключений (например от Exception или RuntimeException).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04b8334902113">
		
			<div class="crayon-plain-wrap"><pre>public class ExcClass extends Exception {

    private String someString;

    public ExcClass (String string) {
        this.someString = string;
        System.out.println("Exception ExcClass");
    }

    public void myOwnExceptionMsg() {
        System.err.println("This is exception massage for srting: " + someString);
    }
}

public class TestExc {

    public static void main(String[] args) {
        try {
            String s = "SomeString";
            throw new ExcClass(s);
        } catch (ExcClass ex) {
            ex.myOwnExceptionMsg();
        }
    }
}
//Вывод
Exception ExcClass
This is exception massage for srting: SomeString</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0023 seconds] -->
<p>Руководствоваться нужно определением типа исключения. В зависимости от того, что вы хотите обрабатывать или видеть нужно и наследоваться от нужного класса.</p>
<h4>13. Какой оператор позволяет принудительно выбросить исключение?</h4>
<p><span style="color: #920000;">throw</span> new Exception();</p>
<h4>14. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?</h4>
<p>Если это проверяемое исключение, то оно должно быть задекларировано в сигнатуре метода.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04bb377106304">
		
			<div class="crayon-plain-wrap"><pre> public void someMethod() throws Exception {
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h4>15. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</h4>
<p>Может и оно будет передано в виртуальную машину Java (JVM).</p>
<h4>16. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?</h4>
<p>Вернется из блока finally.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04bf275127411">
		
			<div class="crayon-plain-wrap"><pre>    public static void main(String[] args) {
       String what =  method();
        System.out.println(what);
    }

    public static String method() {
        try {
            return "SomeString";
        } finally {
            return "Finally message";
        }
    }
//Вывод
Finally message</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p></p>
<h4>17. Что вы знаете о OutOfMemoryError?</h4>
<p>OutOfMemoryError выбрасывается, когда виртуальная машина Java не может выделить (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить ещё.</p>
<p>Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места.<br>
<img src="pics/outOfMemoryTypes.png" /></p>
<p>1. java.lang.OutOfMemoryError: Java heap space<br>
Не хватает места&nbsp;в куче, а именно, в области памяти в которую помещаются объекты, создаваемые программно в вашем приложении. Размер задается параметрами -Xms и -Xmx. Если вы пытаетесь создать объект, а места в куче не осталось, то получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество, и интернет просто пестрит статьями на эту тему.</p>
<p>2. java.lang.OutOfMemoryError: PermGen space<br>
Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.</p>
<p>3. java.lang.OutOfMemoryError: GC overhead limit exceeded<br>
Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и GC постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать, а либо решать проблему утечки памяти, либо выделять больше объема, либо менять настройки GC.</p>
<p>4. java.lang.OutOfMemoryError: unable to create new native thread</p>
<p>Выбрасывается, когда нет возможности создать еще потоки.</p>
<h5>Подробнее в статье&nbsp;http://habrahabr.ru/post/117274/</h5>
<h4>18. Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?</h4>
<p>SQLException предоставляет информацию об ошибках доступа к базе данных или других ошибках связанных с работой с базами данных.</p>
<p>SQLException относится к checked исключениям, а значит проверяется на этапе компиляции.</p>
<p>Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к unchecked runtime исключениям.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04c3426800940">
		
			<div class="crayon-plain-wrap"><pre>try {
    // make some SQL call(s)
} catch {SQLException e) { 
    // log the exception
    return; // and give up
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p>Аргумент&nbsp;Joshua Bloch из&nbsp;Effective Java Second Edition такой: сделав SQLException проверяемым &mdash; это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции.</p>
<h4>19. Что такое Error? В каком случае используется Error. Приведите пример Error’а.</h4>
<p>Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.</p>
<p>За примером посмотрите картинку иерархии исключений вначале статьи. Как пример &mdash; OutOfMemoryError.</p>
<h4>20. Какая конструкция используется в Java для обработки исключений?</h4>
<p>Можно использовать try-catch-finally и c 7й Java try-with-resources. Первый способ:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04c8247355259">
		
			<div class="crayon-plain-wrap"><pre>try{ 
//здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e ){ //в скобках указывается класс конкретной ожидаемой ошибки  
//здесь описываются действия, направленные на обработку исключений 
} 
finally{ 
//выполняется в любом случае ( блок finally  не обязателен) 
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p>Try с ресурсами:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04cb240319282">
		
			<div class="crayon-plain-wrap"><pre>try(открываем файл и т.п. здесь){
 //...
}
//после блока файл закроется автоматически.</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>Пример:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04cd837929646">
		
			<div class="crayon-plain-wrap"><pre>Старый способ
 BufferedReader br = new BufferedReader(new FileReader(path));
   try {
            return br.readLine();
        } finally {
            if (br != null) {
                br.close();
            }
        }

JDK 7

 try (BufferedReader br =
                   new BufferedReader(new FileReader(path)) ) {
        return br.readLine();
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0015 seconds] -->
<p>Так же смотрите ответ к «Какие существуют способы обработки исключений?»</p>
<h4>21. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение.&nbsp;Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?</h4>
<p>Ответ аналогичный случаю с двумя return &mdash; будет обработано в finally блоке. Если было выброшено два исключения &mdash; одно в try, второе в finally, то исключение в finally «проглотит» исключение выше (см. пример). Если до блока finally исключение было обработано, то мы можем получить информацию об исключение в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04d1597433242">
		
			<div class="crayon-plain-wrap"><pre>public class TestExc {

    public static void main(String[] args) {
        Exception ex = twoExceptionsMethod();
        System.out.println(ex.getClass());

        String s = twoExceptionsMethod2();
        System.out.println(s);
    }

    public static Exception twoExceptionsMethod() {
        try {
            return new IndexOutOfBoundsException();
        } finally {
            return new NullPointerException();
        }
    }

    public static String twoExceptionsMethod2() {
        try {
            throw new NullPointerException();
        }catch (NullPointerException ex) {
            System.out.println(ex.getMessage()+ " catch");;
        }
        finally {
            Exception ex2 = new Exception();
            return ex2.getMessage() + "finally";
        }
    }
}
//Вывод
class java.lang.NullPointerException
null catchBlock
null finallyBlock</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0030 seconds] -->
<p></p>
<h4>22. Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?</h4>
<p>Общие правило &mdash; обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок <span style="color: #920000;">catch(Exception e) {}</span>, иначе&nbsp;все дальнейшие блоки <span style="color: #920000;">catch()</span> уже ничего не смогут обработать, т.к. любое исключение будет&nbsp;попадать под ExceptionName extends Exception.</p>
<p>Таким образом сначала нужно обработать <span style="color: #920000;">public class FileNotFoundException extends IOException</span>, а затем уже IOException.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce2466b04d5823060341">
		
			<div class="crayon-plain-wrap"><pre>    public static void ioExcAndFileNotFoundEx() {
        try {
            //TODO: some code
            String x = "abc";
            if (x.equals("abc")) {
                throw new IOException();
            } else {
                throw new FileNotFoundException();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.getMessage();
        }
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0016 seconds] -->
<p>&nbsp;</p></div>

<h2>4  коллекции (Collections)</h2>
<a href="http://javastudy.ru/interview/collections/">src4</a>
<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Дайте определение понятию “коллекция”.<br>
2. Назовите преимущества использования коллекций.<br>
3. Какие данные могут хранить коллекции?<br>
4. Какова иерархия коллекций?<br>
5. Что вы знаете о коллекциях типа List?<br>
6. Что вы знаете о коллекциях типа Set?<br>
7. Что вы знаете о коллекциях типа Queue?<br>
8. Что вы знаете о коллекциях типа Map, в чем их принципиальное отличие?<br>
9. Назовите основные реализации List, Set, Map.<br>
10. Какие реализации SortedSet вы знаете и в чем их особенность?<br>
11. В чем отличия/сходства List и Set?<br>
12. Что разного/общего у классов ArrayList и LinkedList, когда лучше использовать ArrayList, а когда LinkedList?<br>
13. В каких случаях разумно использовать массив, а не ArrayList?<br>
14. Чем отличается ArrayList от Vector?<br>
15. Что вы знаете о реализации классов HashSet и TreeSet?<br>
16. Чем отличаются HashMap и TreeMap? Как они устроены и работают? Что со временем доступа к объектам, какие зависимости?<br>
17. Что такое Hashtable, чем она отличается от HashMap? На сегодняшний день она deprecated, как все-таки использовать нужную функциональность?<br>
18. Что будет, если в Map положить два значения с одинаковым ключом?<br>
19. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?<br>
20. Дайте определение понятию “итератор”.<br>
21. Какую функциональность представляет класс Collections?<br>
22. Как получить не модифицируемую коллекцию?<br>
23. Какие коллекции синхронизированы?<br>
24. Как получить синхронизированную коллекцию из не синхронизированной?<br>
25. Как получить коллекцию только для чтения?<br>
26. Почему Map не наследуется от Collection?<br>
27. В чем разница между Iterator и Enumeration?<br>
28. Как реализован цикл foreach?<br>
29. Почему нет метода iterator.add() чтобы добавить элементы в коллекцию?<br>
30. Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?<br>
31. В чем разница между Iterator и ListIterator?<br>
32. Какие есть способы перебора всех элементов List?<br>
33. В чем разница между fail-safe и fail-fast свойствами?<br>
34. Что делать, чтобы не возникло исключение ConcurrentModificationException?<br>
35. Что такое стек и очередь, расскажите в чем их отличия?<br>
36. В чем разница между интерфейсами Comparable и Comparator?<br>
37. Почему коллекции не наследуют интерфейсы Cloneable и Serializable?</p>
<h3>Ответы</h3>
<p>Тема коллекций невероятно обширная и для того, чтобы ответить на каждый вопрос глубоко нужна отдельная статья почти под каждый вопрос. При проработке этого раздела&nbsp;рекомендую прочитать дополнительный материал, указанный в ответах.</p>
<h4>1. Дайте определение понятию “коллекция”.</h4>
<p>Коллекциями/контейнерами в Java принято называть классы, основная цель которых &ndash; хранить набор других элементов.</p>
<h4>2. Назовите преимущества использования коллекций.</h4>
<p>Массивы обладают значительными недостатками. Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива. Другим &mdash; индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов.&nbsp;Чтобы избавиться от этих недостатков уже несколько десятилетий программисты используют <b>рекурсивные типы данных</b>, такие как&nbsp;<b>списки</b> и <b>деревья</b>. Стандартный набор коллекций Java служит для избавления программиста от необходимости самостоятельно реализовывать эти типы данных и снабжает его дополнительными возможностями.</p>
<h4>3. Какие данные могут хранить коллекции?</h4>
<p>Коллекции могут хранить любые ссылочные типы данных.</p>
<h4>4. Какова иерархия коллекций?</h4>
<p><img src="pics/CollectionsHierarchy.png"/></a></p>
<p>Здесь следует обратить внимание, что interface Map не входит в иерархию interface Collection.</p>
<p>С&nbsp;Java 1.6 классы TreeSet и TreeMap имплементируют интерфейсы NavigableSet и NavigableMap, которые расширяют интерфейсы SortedSet и SortedMap соответственно (SortedSet и SortedMap расширяют Set и Map).</p>
<h5>Подробная статья про коллекции с описанием основных методов:&nbsp;http://www.quizful.net/post/Java-Collections</h5>
<h4>5. Что вы знаете о коллекциях типа List?</h4>
<p>List &mdash; это упорядоченный список. Объекты хранятся в порядке их добавления в список. Доступ к элементам списка осуществляется по индексу.</p>
<h4>6. Что вы знаете о коллекциях типа Set?</h4>
<p>Set &mdash; множество <strong>неповторяющихся</strong> объектов.&nbsp;В коллекции этого типа разрешено наличие только одной ссылки типа <span class="texample">null</span>.</p>
<h4>7. Что вы знаете о коллекциях типа Queue?</h4>
<p>Queue &mdash; коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции вставки, получения и контроля.</p>
<p>Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out, «первым вошел &mdash; первым вышел») порядке.</p>
<p>Метод <span style="color: #920000;">offer()</span> вставляет элемент в очередь, если это не удалось &mdash; возвращает <span style="color: #920000;">false</span>. Этот метод отличается от метода <span style="color: #920000;">add()</span> интерфейса Collection тем, что метод <span style="color: #920000;">add()</span> может неудачно добавить элемент только с использованием unchecked исключения.</p>
<p>Методы <span style="color: #920000;">remove()</span> и <span style="color: #920000;">poll()</span> удаляют верхушку очереди и возвращают ее. Какой элемент будет удален (первый или последний) зависит от реализации очереди. Методы <span style="color: #920000;">remove()</span> и <span style="color: #920000;">poll()</span> отличаются лишь поведением, когда очередь пустая: метод <span style="color: #920000;">remove()</span> генерирует исключение, а метод <span style="color: #920000;">poll()</span> возвращает <span style="color: #920000;">null</span>.</p>
<p>Методы <span style="color: #920000;">element()</span> и <span style="color: #920000;">peek()</span> возвращают (но не удаляют) верхушку очереди.</p>
<p><strong>java.util.Queue&lt;E&gt;</strong> реализует FIFO&ndash;буфер. Позволяет добавлять и получать объекты. При этом объекты могут быть получены в том порядке, в котором они были добавлены.</p>
<p><strong>Реализации</strong>: <span style="color: #920000;">java.util.ArrayDeque&lt;E&gt;</span>, <span style="color: #920000;">java.util.LinkedList&lt;E&gt;</span>.</p>
<p><strong>java.util.Deque&lt;E&gt;</strong> наследует <span style="color: #920000;">java.util.Queue&lt;E&gt;</span>. Двунаправленная очередь. Позволяет добавлять и удалять объекты с двух концов. Так же может быть использован в качестве стека.</p>
<p><strong>Реализации</strong>: <span style="color: #920000;">java.util.ArrayDeque&lt;E&gt;</span>, <span style="color: #920000;">java.util.LinkedList&lt;E&gt;</span>.</p>
<h5>Подробнее&nbsp;http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-queue.html</h5>
<h4>8. Что вы знаете о коллекциях типа Map, в чем их принципиальное отличие?</h4>
<p>Интерфейс <span style="color: #920000;">java.util.Map&lt;K,V&gt;</span> используется для отображения каждого элемента из одного множества объектов (ключей) на другое (значений). При этом, каждому элементу из множества ключей ставится в соответствие ровно 1 элемент из множества значений. В то же время одному элементу из множества значений может соответствовать 1, 2 и более элементов из множества ключей. Интерфейс <span style="color: #920000;">java.util.Map&lt;K,V&gt;</span> описывает функциональность ассоциативных массивов.</p>
<p><strong>Реализации</strong>: <span style="color: #920000;">java.util.HashMap&lt;K,V&gt;</span>, <span style="color: #920000;">java.util.LinkedHashMap&lt;K,V&gt;</span>, <span style="color: #920000;">java.util.TreeMap&lt;K,V&gt;</span>, <span style="color: #920000;">java.util.WeakHashMap&lt;K,V&gt;</span>.</p>
<p><span style="color: #920000;">java.util.SortedMap&lt;K,V&gt;</span> наследует <span style="color: #920000;">java.util.Map&lt;K,V&gt;</span>. Реализации этого интерфейса обеспечивают хранение элементов множества ключей в порядке возрастания (см. java.util.SortedSet).&nbsp;<strong>Реализации</strong>: <span style="color: #920000;">java.util.TreeMap&lt;K,V&gt;</span>.</p>
<h5>http://developer.alexanderklimov.ru/android/java/map.php</h5>
<h4>9. Назовите основные реализации List, Set, Map.</h4>
<table class="table_example">
<tbody>
<tr>
<th width="30%">Интерфейс</th>
<th width="35%">Класс/Реализация</th>
<th width="35%">Описание</th>
</tr>
<tr class="blue_text">
<td rowspan="4">List</td>
<td>ArrayList</td>
<td>Список</td>
</tr>
<tr class="blue_text">
<td>LinkedList</td>
<td>Список</td>
</tr>
<tr class="blue_text">
<td>Vector</td>
<td>Вектор</td>
</tr>
<tr class="blue_text">
<td>Stack</td>
<td>Стек</td>
</tr>
<tr class="green_text">
<td rowspan="3">Set</td>
<td>HashSet</td>
<td>Множество</td>
</tr>
<tr class="green_text">
<td>TreeSet</td>
<td>Множество</td>
</tr>
<tr class="green_text">
<td>SortedSet</td>
<td>Отсортированное множество</td>
</tr>
<tr class="orange_text">
<td rowspan="4">Map</td>
<td>HashMap</td>
<td>Карта/Словарь</td>
</tr>
<tr class="orange_text">
<td>TreeMap</td>
<td>Карта/Словарь</td>
</tr>
<tr class="orange_text">
<td>SortedMap</td>
<td>Отсортированный словарь</td>
</tr>
<tr class="orange_text">
<td>Hashtable</td>
<td>Хеш-таблица</td>
</tr>
</tbody>
</table>
<h4>10. Какие реализации SortedSet вы знаете и в чем их особенность?</h4>
<p><span style="color: #920000;">java.util.SortedSet&lt;E&gt;</span>&nbsp;наследует <span style="color: #920000;">java.util.Set&lt;E&gt;</span>. Реализации этого интерфейса, помимо того что следят за уникальностью хранимых объектов, поддерживают их в порядке возрастания. Отношение порядка между объектами может быть определено, как с помощью метода compareTo интерфейса <span style="color: #920000;">java.lang.Comparable&lt;T&gt;</span>, так и при помощи специального класса-компаратора, наследующего интерфейс <span style="color: #920000;">java.util.Comparator&lt;T&gt;</span>.</p>
<p>Реализации: <span style="color: #920000;">java.util.TreeSet&lt;E&gt;</span> &mdash; коллекция, которая хранит свои элементы в виде упорядоченного по значениям дерева. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно-черное дерево для хранения элементов. TreeSet хорош тем, что для операций add, remove и contains потребуется гарантированное время log(n).</p>
<h4>11. В чем отличия/сходства List и Set?</h4>
<p>Оба унаследованы от <span style="color: #920000;">Collection</span>, а значит имеют одинаковый набор и&nbsp;сигнатуры методов. <span style="color: #920000;">List</span> хранит объекты в порядке вставки, элемент можно получить по индексу. <span style="color: #920000;">Set</span> не может хранить одинаковых элементов.</p>
<h4>12. Что разного/общего у классов ArrayList и LinkedList, когда лучше использовать ArrayList, а когда LinkedList?</h4>
<p><b>ArrayList</b> реализован внутри <span class="green_text">в виде обычного массива</span>. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем <span class="violet_text">быстро реализованы</span> взятие и изменение элемента &ndash; <span class="violet_text">операции get, set</span>, так как в них мы просто обращаемся к соответствующему элементу массива.</p>
<p><img src="pics/ArrayListAndLinkedList.gif" /></p>
<p><b>LinkedList</b> реализован внутри по-другому. Он <span class="green_text">реализован в виде связного списка</span>: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. <span class="orange_text">А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130.</span> Другими словами<span class="violet_text"> операции set и get</span> тут&nbsp;<span class="violet_text">реализованы очень медленно</span>. Посмотри на таблицу:</p>
<table class="table_example">
<tbody>
<tr>
<th width="40%">Описание</th>
<th width="20%">Операция</th>
<th width="20%">ArrayList</th>
<th width="20%">LinkedList</th>
</tr>
<tr>
<td>Взятие элемента</td>
<td>get</td>
<td class="green_text">Быстро</td>
<td class="red_text">Медленно</td>
</tr>
<tr>
<td>Присваивание элемента</td>
<td>set</td>
<td class="green_text">Быстро</td>
<td class="red_text">Медленно</td>
</tr>
<tr>
<td>Добавление элемента</td>
<td>add</td>
<td class="green_text">Быстро</td>
<td class="green_text">Быстро</td>
</tr>
<tr>
<td>Вставка элемента</td>
<td>add(i, value)</td>
<td class="red_text">Медленно</td>
<td class="green_text">Быстро</td>
</tr>
<tr>
<td>Удаление элемента</td>
<td>remove</td>
<td class="red_text">Медленно</td>
<td class="green_text">Быстро</td>
</tr>
</tbody>
</table>
<p>Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях &ndash; ArrayList.</p>
<p>LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто идут по порядку</p>
<h5>Из лекции javarush.ru</h5>
<h5>Структуры данных в картинках. LinkedList:&nbsp;http://habrahabr.ru/post/127864/</h5>
<h4>13. В каких случаях разумно использовать массив, а не ArrayList?</h4>
<p>Если коротко, то Oracle пишет &mdash; используйте ArrayList вместо массивов. Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: массивы могут быть быстрее и кушать меньше памяти. Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок. Плюс к этому, что размер списка увеличивается не на 1, а на большее кол-во элементов (+15)*. Так же доступ к [10] в массиве может быть быстрее чем вызов get(10) у списка.</p>
<p>*Читатель прислал комментарий «У ArrayList увеличение происходит в 1.5 раза. int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);».</p>
<h5>Структуры данных в картинках. ArrayList: http://habrahabr.ru/post/128269/</h5>
<h5>Еще о ArrayList на сайте http://developer.alexanderklimov.ru/android/java/arraylist.php</h5>
<h4>14. Чем отличается ArrayList от Vector?</h4>
<p>Vector deprecated.&nbsp;У Vector некоторые методы синхронизированы и поэтому они медленные. В любом случае Vector не рекомендуется использовать вообще.</p>
<h4>15. Что вы знаете о реализации классов HashSet и TreeSet?</h4>
<p>Название Hash… происходит от понятия хэш-функция. Хэш-функция &mdash; это функция, сужающая множество значений объекта до некоторого подмножества целых чисел. Класс <span style="color: #920000;">Object </span>имеет метод <span style="color: #920000;">hashCode()</span>, который используется классом <span style="color: #920000;">HashSet </span>для эффективного размещения объектов, заносимых в коллекцию. В классах объектов, заносимых в <span style="color: #920000;">HashSet</span>, этот метод должен быть переопределен (override).</p>
<p><span style="color: #920000;">HashSet</span> реализован на основе хеш-таблицы, а <span style="color: #920000;">TreeSet</span> &mdash; на основе бинарного дерева.</p>
<h5>Подробнее о&nbsp;Set, HashSet, LinkedHashSet, TreeSet: http://developer.alexanderklimov.ru/android/java/set.php</h5>
<p><span style="color: #920000;">HashSet</span> гораздо быстрее чем <span style="color: #920000;">TreeSet</span> (константное время против логарифмического для большинства операций, таких как <span style="color: #920000;">add</span>, <span style="color: #920000;">remove</span>, <span style="color: #920000;">contains</span>), но <span style="color: #920000;">TreeSet</span> гарантирует упорядоченность объектов. Оба не синхронизированы.</p>
<p>HashSet</p>
<ul>
<li>предоставляет константное время для <span style="color: #920000;">add()</span>, <span style="color: #920000;">remove()</span>, <span style="color: #920000;">contains()</span>&nbsp;и&nbsp;<span style="color: #920000;">size()</span></li>
<li>порядок элементов в контейнере может меняться</li>
<li>производительность итерации по контейнеру зависит от емкости и «коэффициента загрузки» (рекомендуется оставлять load factor&nbsp;значением по умолчанию равным 0.75, что является хорошим компромиссом между временем доступа и объемом хранимых данных)</li>
</ul>
<p>TreeSet</p>
<ul>
<li>время для базовых операций <span style="color: #920000;">add()</span>, <span style="color: #920000;">remove()</span>, <span style="color: #920000;">contains()</span> &mdash; log(n)</li>
<li>гарантирует порядок элементов</li>
<li>не предоставляет каких-либо параметров для настройки производительности</li>
<li>предоставляет дополнительные методы для упорядоченного списка: <span style="color: #920000;">first()</span>, <span style="color: #920000;">last()</span>, <span style="color: #920000;">headSet()</span>, <span style="color: #920000;">tailSet()</span> и т.д.</li>
</ul>
<h5>Годный ответ на StackOverflow&nbsp;http://stackoverflow.com/questions/1463284/hashset-vs-treeset</h5>
<h4>16. Чем отличаются HashMap и TreeMap? Как они устроены и работают? Что со временем доступа к объектам, какие зависимости?</h4>
<p>В целом ответ про <span style="color: #920000;">HashSet</span> и <span style="color: #920000;">TreeSet</span> подходит и к этому вопросу.</p>
<p><span style="color: #920000;">HashMap</span> работает строго быстрее <span style="color: #920000;">TreeMap</span>.</p>
<p><span style="color: #920000;">TreeMap</span> реализован на красно-черном дереве, время добавления/поиска/удаления элемента &mdash; O(log N), где N &mdash; число элементов в <span style="color: #920000;">TreeMap</span> на данный момент.</p>
<p>У <span style="color: #920000;">HashMap</span> время доступа к отдельному элементу &mdash; O(1) при условии, что хэш-функция (<span style="color: #920000;">Object.hashCode()</span>) определена нормально (что является правдой в случае <span style="color: #920000;">Integer</span>).</p>
<p>Общая рекомендация &mdash; если не нужна упорядоченность, использовать <span style="color: #920000;">HashMap</span>. Исключение &mdash; ситуация с вещественными числами, которые в качестве ключей почти всегда очень плохи. Для них нужно использовать <span style="color: #920000;">TreeMap</span>, предварительно поставив ему компаратор, который сравнивает вещественные числа так, как это нужно в данной задаче. Например, для обычных геометрических задач два вещественных числа могут считаться равными, если отличаются не более, чем на 1e-9.</p>
<h5>Структуры данных в картинках. HashMap: http://habrahabr.ru/post/128017/</h5>
<h4>17. Что такое Hashtable, чем она отличается от HashMap? На сегодняшний день она deprecated, как все-таки использовать нужную функциональность?</h4>
<p>Некоторые методы <span style="color: #920000;">HashTable</span> синхронизированы, поэтому она медленнее <span style="color: #920000;">HashMap</span>.</p>
<ul>
<li><span style="color: #920000;">HashTable</span> синхронизирована, а <span style="color: #920000;">HashMap</span> нет.</li>
<li><span style="color: #920000;">HashTable</span> не позволяет иметь <span style="color: #920000;">null</span> ключи или значения. <span style="color: #920000;">HashMap</span> позволяет иметь один <span style="color: #920000;">null</span> ключ и сколько угодно null значений.</li>
<li>У&nbsp;<span style="color: #920000;">HashMap</span> есть подкласс <span style="color: #920000;">LinkedHashMap</span>, который добавляет возможности по итерации. Если вам нужна эта функциональность, то можно легко переключаться между классами.</li>
</ul>
<p>Общее замечание &mdash; не рекомендуется использовать <span style="color: #920000;">HashTable</span> даже в многопоточных приложениях. Для этого есть <span style="color: #920000;">ConcurrentHashMap</span>.</p>
<h5>http://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable</h5>
<h4>18. Что будет, если в Map положить два значения с одинаковым ключом?</h4>
<p>Последнее значение перезапишет предыдущее.</p>
<h4>19. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?</h4>
<p>Класс <span style="color: #920000;">ТгееМар</span> полностью реализует интерфейс <span style="color: #920000;">SortedMap</span>. Он реализован как бинарное дерево поиска, значит его элементы хранятся в упорядоченном виде. Это&nbsp; значительно ускоряет поиск нужного элемента.&nbsp;Порядок задается либо естественным следованием элементов, либо объектом, реализующим интерфейс сравнения <span style="color: #920000;">Comparator</span>.</p>
<p>В этом классе четыре конструктора:</p>
<p><span style="color: #920000;">ТгееМар()</span> &mdash; создает пустой объект с естественным&nbsp; порядком элементов;<br>
<span style="color: #920000;">TreeМар(Comparator с)</span> &mdash; создает пустой объект, в котором порядок задается объектом сравнения с;<br>
<span style="color: #920000;">ТгееМар(Map f)</span> &mdash; создает объект, содержащий все элементы отображения f, с естественным порядком его элементов;<br>
<span style="color: #920000;">ТгееМар(SortedMap sf)</span> &mdash; создает объект, содержащий все элементы отображения sf, в том же порядке.</p>
<p>Интерфейс <span style="color: #920000;">Comparator</span> описывает два метода сравнения:</p>
<p><span style="color: #920000;">int compare(Object obj1, object obj2)</span> &mdash; возвращает отрицательное число, если <span style="color: #920000;">obj1</span>&nbsp;в каком-то смысле меньше <span style="color: #920000;">obj2</span>; нуль, если они считаются равными; положительное число, если <span style="color: #920000;">obj1</span> больше <span style="color: #920000;">obj2</span>. Для читателей, знакомых с теорией множеств, скажем, что этот метод сравнения обладает свойствами тождества, антисимметричности и транзитивности;</p>
<p><span style="color: #920000;">boolean equals(Object obj)</span> &mdash; сравнивает данный объект с объектом <span style="color: #920000;">obj</span>, возвращая <span style="color: #920000;">true</span>, если объекты совпадают в каком-либо смысле, заданном этим методом.</p>
<p>Для каждой коллекции можно реализовать эти два метода, задав конкретный способ сравнения элементов, и определить объект класса <span style="color: #920000;">SortedMap</span> вторым конструктором. Элементы коллекции будут автоматически отсортированы в заданном порядке.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd55d128b4635107120">
		
			<div class="crayon-plain-wrap"><pre>  public static void main(String[] args) {
        Comparator comparator = new Comparator&lt;String&gt;() {
            @Override
            public int compare(String obj1, String obj2) {
                if (obj1 == null) {
                    return -1;
                }
                if (obj2 == null) {
                    return 1;
                }
                if (obj1.equals(obj2)) {
                    return 0;
                }
                return obj1.compareTo(obj2);
            }
        };
        TreeMap&lt;String, String&gt; treeMap1 = new TreeMap&lt;&gt;(comparator);

        //or
        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o1,o2);
            }
        });
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0030 seconds] -->
<p></p>
<h4>20. Дайте определение понятию “итератор”.</h4>
<p>Итератор &mdash; объект, позволяющий перебирать элементы коллекции. Например foreach реализован с использованием итератора. Одним из ключевых методов интерфейса <span style="color: #920000;">Collection</span> является метод <span style="color: #920000;">Iterator&lt;E&gt; iterator()</span>. Он возвращает итератор &mdash; то есть объект, реализующий интерфейс <span style="color: #920000;" class="bb">Iterator</span>.</p>
<p>Интерфейс <span style="color: #920000;">Iterator</span> имеет следующее определение:</p>
<div></div>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd55d128c1726736586">
		
			<div class="crayon-plain-wrap"><pre>public interface Iterator &lt;E&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;E next();
&nbsp;&nbsp;&nbsp;&nbsp;boolean hasNext();
&nbsp;&nbsp;&nbsp;&nbsp;void remove();
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>21. Какую функциональность представляет класс Collections</h4>
<p>Некоторые из методов</p>
<table class="table table-bordered">
<tbody>
<tr>
<td>Сигнатура метода</td>
<td>Описание</td>
</tr>
<tr>
<td>Collections.sort(List myList)</td>
<td>Сортирует список в естественном порядке.</td>
</tr>
<tr>
<td>Collections.sort(List, Comparator c)</td>
<td>Сортировка с использованием компаратора.</td>
</tr>
<tr>
<td>Collections.shuffle(List myList)</td>
<td>Перемешивает коллекцию в случайном порядке.</td>
</tr>
<tr>
<td>Collections.reverse(List myList)</td>
<td>Переворачивает коллекцию в обратном порядке.</td>
</tr>
<tr>
<td>Collections.binarySearch(List mlist, T key)</td>
<td>поиск в коллекции по ключу с использованием бинарного поиска.</td>
</tr>
<tr>
<td>Collections.copy(List dest, List src)</td>
<td>Копирует коллекцию источник src в dest.</td>
</tr>
<tr>
<td>Collections.frequency(Collection c, Object o)</td>
<td>Возвращает число вхождений объекта в коллекции.</td>
</tr>
<tr>
<td>Collections.synchronizedCollection(Collection c)</td>
<td>Возвращает синхронизированную (потокобезопасную) коллекцию.</td>
</tr>
</tbody>
</table>
<h4>22. Как получить не модифицируемую коллекцию?</h4>
<p>Коллекцию, доступную только для чтения можно получить с помощью методов:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd55d128c6043630413">
		
			<div class="crayon-plain-wrap"><pre> public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) {
        return new UnmodifiableSortedSet&lt;&gt;(s);
    }

public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) {
    return (list instanceof RandomAccess ?
            new UnmodifiableRandomAccessList&lt;&gt;(list) :
            new UnmodifiableList&lt;&gt;(list));
}
и т.д. для каждого типа (Map, SortedMap и т.п.)</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0016 seconds] -->
<p></p>
<h4>23. Какие коллекции синхронизированы?</h4>
<p>Для этого используется пакет <span style="color: #920000;">Concurrent</span>. А так <span style="color: #920000;">@Deprecated HashTable</span>, <span style="color: #920000;">Vector</span>.</p>
<h4>24. Как получить синхронизированную коллекцию из не синхронизированной?</h4>
<p>Используйте следующие методы:</p>
<ul>
<li><span style="color: #920000;">Collections.synchronizedList(list)</span>;</li>
<li><span style="color: #920000;">Collections.synchronizedSet(set)</span>;</li>
<li><span style="color: #920000;">Collections.synchronizedMap(map)</span>;</li>
</ul>
<p>Все они принимают коллекцию в качестве параметра, и возвращают потокобезопасную коллекцию с теми же элементами внутри.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd55d128ca095044057">
		
			<div class="crayon-plain-wrap"><pre> public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {
        return new SynchronizedSet&lt;&gt;(s);
    }

и т.д. для каждого типа коллекции</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>25. Как получить коллекцию только для чтения?</h4>
<p>Используйте следующие методы:</p>
<ul>
<li><span style="color: #920000;">Collections.unmodifiableList(list)</span>;</li>
<li><span style="color: #920000;">Collections.unmodifiableSet(set)</span>;</li>
<li><span style="color: #920000;">Collections.unmodifiableMap(map)</span>;</li>
</ul>
<p>Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.</p>
<h4>26. Почему Map не наследуется от Collection?</h4>
<p>Они не совместимы, т.к. созданы для различных структур данных. Map использует пару ключ-значение.</p>
<h4>27. В чем разница между Iterator и Enumeration?</h4>
<p><span style="color: #920000;">Enumeration</span> в два раза быстрее <span style="color: #920000;">Iterator</span> и использует меньше памяти. <span style="color: #920000;">Iterator</span> потокобезопасен, т.к. не позволяет другим потокам модифицировать коллекцию при переборе. <span style="color: #920000;">Enumeration</span> можно использовать только для read-only коллекций. Так же у него отсутствует метод <span style="color: #920000;">remove()</span>;</p>
<div>Enumeration:&nbsp;<span style="color: #920000;">hasMoreElement()</span>,&nbsp;<span style="color: #920000;">nextElement()</span></div>
<div></div>
<div>Iterator:&nbsp;<span style="color: #920000;">hasNext()</span>,&nbsp;<span style="color: #920000;">next()</span>,&nbsp;<span style="color: #920000;">remove()</span></div>
<h4>28. Как реализован цикл foreach?</h4>
<p>Реализован на основе <span style="color: #920000;">Iterator</span>.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd55d128ce853661661">
		
			<div class="crayon-plain-wrap"><pre>for(тип итер_пер : коллекция) блок_операторов</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h4>29. Почему нет метода iterator.add() чтобы добавить элементы в коллекцию?</h4>
<p>Единственная задача итератора это перебор коллекции. Каждая коллекция имеет метод <span style="color: #920000;">add()</span> которым вы можете воспользоваться. Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и неупорядоченными, и метод <span style="color: #920000;">add()</span> при этом должен быть устроен по разному.</p>
<h4>30. Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?</h4>
<p>Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет <i>доступ к элементу</i>) и содержит функции для перехода к другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным). Таким образом без курсора просто нельзя будет реализовать безошибочное передвижение по коллекции.</p>
<h4>31. В чем разница между Iterator и ListIterator?</h4>
<p>Есть три различия:</p>
<ol>
<li><span style="color: #920000;">Iterator</span> может использоваться для перебора элементов <span style="color: #920000;">Set</span>, <span style="color: #920000;">List</span> и <span style="color: #920000;">Map</span>. В отличие от него, <span style="color: #920000;">ListIterator</span> может быть использован только для перебора элементов коллекции <span style="color: #920000;">List</span></li>
<li><span style="color: #920000;">Iterator</span> позволяет перебирать элементы только в одном направлении, при помощи метода <span style="color: #920000;">next()</span>. Тогда как <span style="color: #920000;">ListIterator</span> позволяет перебирать список в обоих направлениях, при помощи методов <span style="color: #920000;">next()</span> и <span style="color: #920000;">previous()</span></li>
<li>При помощи <span style="color: #920000;">ListIterator</span> вы можете модифицировать список, добавляя/удаляя элементы с помощью методов <span style="color: #920000;">add()</span> и <span style="color: #920000;">remove()</span>. Iterator не поддерживает данного функционала</li>
</ol>
<h4>32. Какие есть способы перебора всех элементов List?</h4>
<p>Есть 4 способа:</p>
<ul>
<li>Цикл с итератором</li>
<li>Цикл for</li>
<li>Расширенный цикл for</li>
<li>Цикл while</li>
</ul>
<h4>33. В чем разница между fail-safe и fail-fast свойствами?</h4>
<p>В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.<br>
Итератор коллекции <span style="color: #920000;">CopyOnWriteArrayList</span> и итератор представления keySet коллекции <span style="color: #920000;">ConcurrentHashMap</span> являются примерами итераторов fail-safe.</p>
<h4>34. Что делать, чтобы не возникло исключение ConcurrentModificationException?</h4>
<p>Первым делом, можно подобрать другой итератор, работающий по принципу fail-safe. К примеру, если вы используете <span style="color: #920000;">List</span>, то можете взять <span style="color: #920000;">ListIterator</span>. Если же вам нужна устаревшая коллекция &mdash; то используйте перечислители.<br>
В том случае, когда вышеизложенное вам не подходит, у вас есть три варианта:<br>
При использовании JDK 1.5 или выше, вам подойдут классы <span style="color: #920000;">ConcurrentHashMap</span> и <span style="color: #920000;">CopyOnWriteArrayList</span>. Это самый лучший вариант<br>
Вы можете преобразовать список в массив и перебирать массив<br>
Вы можете блокировать изменения списка на время перебора с помощью блока <span style="color: #920000;">synchronized</span><br>
Обратите внимание, что последние два варианта негативно скажутся на производительности.</p>
<h4>35. Что такое стек и очередь, расскажите в чем их отличия?</h4>
<p>Коллекции, созданные для того чтобы хранить элементы для дальнейшей обработки. Кроме базовых операций интерфейса <span style="color: #920000;">Collection</span>, очереди поддерживают дополнительные операции добавления, удаления и проверки состояния элемента.<br>
Обычно, но не обязательно очереди работают по принципу FIFO &mdash; первым пришел, первым ушел.<br>
Стэк &mdash; почти как очередь, но работает по принципу LIFO &mdash; последним пришел, первым ушел.<br>
Независимо от порядка добавления/удаления, голова очереди это элемент, который будет удален при вызове методов <span style="color: #920000;">remove()</span> или <span style="color: #920000;">poll()</span>. Также обратите внимание на то, что <span style="color: #920000;">Stack</span> и <span style="color: #920000;">Vector</span> оба потокобезопасны.</p>
<p>Использование: используйте очередь если вы хотите обрабатывать поток элементов в том же порядке в котором они поступают. Хорошо для списка заданий и обработки запросов.<br>
Используйте стэк если вы хотите класть и удалять элементы только с вершины стэка, что полезно в рекурсивных алгоритмах.</p>
<h4>36. В чем разница между интерфейсами Comparable и Comparator?</h4>
<p>В Java все коллекции, поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера таких классов мы можем указать <span style="color: #920000;">TreeSet</span>, <span style="color: #920000;">TreeMap</span> и т.д.<br>
Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки как <span style="color: #920000;">Integer</span>, <span style="color: #920000;">Double</span> и <span style="color: #920000;">String</span> реализуют интерфейс <span style="color: #920000;">Comparable</span>.<br>
Интерфейс <span style="color: #920000;">Comparable</span> помогает сохранять естественную сортировку, тогда как <span style="color: #920000;">Comparator</span> позволяет сортировать элементы по разным особым шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает. Следует отметить, что&nbsp;интерфейс <span style="color: #920000;">Comparable</span> может быть реализован именно элементами коллекции или ключами Map, а <span style="color: #920000;">Comparator</span> реализуется отдельным объектом (это удобно, так как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).</p>
<h4>37. Почему коллекции не наследуют интерфейсы Cloneable и Serializable?</h4>
<p>Ну, простейший ответ &mdash; «потому что не надо». Функционал предоставляемый интерфейсами <span style="color: #920000;">Cloneable</span> и <span style="color: #920000;">Serializable</span> просто не нужен для коллекций.</p>
<p>Еще одна причина &mdash; далеко не всегда нужен подкласс <span style="color: #920000;">Cloneable</span> потому что каждая операция клонирования потребляет очень много памяти, и неопытные программисты могут расходовать ее сами не понимая последствий.</p>
<p>И последняя причина &mdash; клонирование и сериализация являются очень узкоспецифичными операциями, и реализовывать их нужно только когда это необходимо. Многие классы коллекции реализуют данные интерфейсы, но совершенно незачем закладывать их для всех коллекций вообще. Если вам нужно клонирование и сериализация &mdash; просто воспользуйтесь теми классами где она есть, если нет &mdash; остальными классами.</p></div>

<a href="http://info.javarush.ru/translation/2013/10/08/%D0%A7%D0%B0%D1%81%D1%82%D0%BE-%D0%B7%D0%B0%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D0%BD%D0%B0-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%D1%85-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BF%D0%BE-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%D0%BC-%D0%B2-Java-%D0%A7%D0%B0%D1%81%D1%82%D1%8C-1-.html#3">Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 2) javarush.ru</a><br>
<a href="http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1">Вопросы и ответы на собеседовании по теме Java Collection Framework. Часть 1.</a> <br>
<a href="http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-2"> Вопросы и ответы на собеседовании по теме Java Collection Framework. Часть 2.</a> <br>
<a href="http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-3"> Вопросы и ответы на собеседовании по теме Java Collection Framework. Часть 3.</a> <br>

<h2>5 работа со строками (String in Java)</h2>
<a href="http://javastudy.ru/interview/strings/">src5</a>
<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Какие “строковые” классы вы знаете?<br>
2. Какие основные свойства “строковых” классов (их особенности)?<br>
3. Можно ли наследовать строковый тип, почему?<br>
4. Дайте определение понятию конкатенация строк.<br>
5. Как преобразовать строку в число?<br>
6. Как сравнить значение двух строк?<br>
7. Как перевернуть строку?<br>
8. Как работает сравнение двух строк?<br>
9. Как обрезать пробелы в конце строки?<br>
10. Как заменить символ в строке?<br>
11. Как получить часть строки?<br>
12. Дайте определение понятию “пул строк”.<br>
13. Какой метод позволяет выделить подстроку в строке?<br>
14. Как разбить строку на подстроки по заданному разделителю?<br>
15. Какой метод вызывается для преобразования переменной в строку?<br>
16. Как узнать значение конкретного символа строки, зная его порядковый номер в строке?<br>
17. Как найти необходимый символ в строке?<br>
18. Можно ли синхронизировать доступ к строке?<br>
19. Что делает метод intern()?<br>
20. Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?<br>
21. Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?<br>
22.&nbsp;Почему строка неизменная и финализированная в Java?<br>
23. Почему массив символов предпочтительнее строки для хранения пароля?<br>
24. Почему строка является популярным ключом в HashMap в Java?<br>
25. Напишите метод удаления данного символа из строки.</p>
<h3>Ответы</h3>
<h4>1. Какие “строковые” классы вы знаете?</h4>
<ul>
<li>public final class <strong>String&nbsp;</strong>implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</li>
<li>public final class <strong>StringBuffer&nbsp;</strong>extends AbstractStringBuilder&nbsp;implements java.io.Serializable, CharSequence</li>
<li>public final class <strong>StringBuilder&nbsp;</strong>extends AbstractStringBuilder&nbsp;implements java.io.Serializable, CharSequence</li>
</ul>
<h4>2. Какие основные свойства “строковых” классов (их особенности)?</h4>
<p>Все строковые классы &mdash; final (следовательно от них нельзя унаследоваться).</p>
<p><strong>String</strong>.<br>
Строка &mdash; объект, что представляет последовательность символов. Для создания и манипулирования строками Java платформа предоставляет общедоступный финальный (не может иметь подклассов) класс <b>java.lang.String</b>. Данный класс является неизменяемым (<i>immutable</i>) &mdash; созданный объект класса <b>String</b> не может быть изменен.</p>
<p><strong>StringBuffer</strong><br>
Строки являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь расходует драгоценную память. Для решения этой проблемы был создан класс <b>java.lang.StringBuffer</b>, который позволяет более эффективно работать над модификацией строки. Класс является <i>mutable</i>, то есть изменяемым &mdash; используйте его, если Вы хотите изменять содержимое строки. <b>StringBuffer</b> может быть использован в многопоточных средах, так как все необходимые методы являются синхронизированными.</p>
<p><strong>StringBuilder</strong><br>
<b>StringBuilder</b> &mdash; класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет полностью идентичный API с <b>StringBuffer</b>. Единственное отличие &mdash; <b>StringBuilder</b> не синхронизирован. Это означает, что его использование в многопоточных средах нежелательно. Следовательно, если вы работаете с многопоточностью, Вам идеально подходит<b>StringBuffer</b>, иначе используйте <b>StringBuilder</b>, который работает намного быстрее в большинстве реализаций.</p>
<h5>Обработка строк в Java. Часть I: String, StringBuffer, StringBuilder:&nbsp;http://habrahabr.ru/post/260767/</h5>
<h4>3. Можно ли наследовать строковый тип, почему?</h4>
<p>Классы объявлены final, поэтому наследоваться не получится.</p>
<h4>4. Дайте определение понятию конкатенация строк.</h4>
<p>Конкатенация &mdash; операция объединения строк, что возвращает новую строку, что является&nbsp;результатом объединения второй строки с окончанием первой. Операции&nbsp;конкатенации могут быть выполнены так:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a6e0440546605">
		
			<div class="crayon-plain-wrap"><pre>StringBuffer stringBuffer = new StringBuffer();
StringBuilder stringBuilder = new StringBuilder();

String str = "ABC";
str += "DEF";

String str2 = "one".concat("two").concat("three");

stringBuffer.append("DDD").append("EEE");
stringBuilder.append("FFF").append("GGG");
System.out.println(str + " " +str2 + " " + stringBuffer.toString() + " " + stringBuilder.toString());//ABCDEF onetwothree DDDEEE FFFGGG</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0017 seconds] -->
<p>Сравнение производительности конкатенации строк:<br>
Оператор ‘+=’ &gt;<strong> 92.243 с</strong>;<br>
String.concat() &gt; <strong>1.254 с</strong>;<br>
StringBuffer &gt; <strong>1.208 с</strong>;<br>
StringBuilder &gt; <strong>1.121 с</strong>.</p>
<h5>Конкатенация и настройки JVM: http://microfork.com/string-concatenation-java/</h5>
<h4>5. Как преобразовать строку в число?</h4>
<p>У каждой обертки для примитивов есть свой метод <span style="color: #920000;">valueOf(String s)</span>, который возвращает преобразованное численное значение из строки. При этом форматы строки и принимаемого типа должны совпадать. Например:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a6ed197828265">
		
			<div class="crayon-plain-wrap"><pre>String x = "523.5";
Double xd = Double.valueOf(x);
/*
Integer xy = Integer.valueOf(x); //java.lang.NumberFormatException: For input string: "523.5"
*/
System.out.println(xd); //523.5</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>6. Как сравнить значение двух строк?</h4>
<p>Оператор <span style="color: #920000;">==</span> работает с ссылками объекта <span style="color: #920000;">String</span>. Если две переменные <span style="color: #920000;">String</span> указывают на один и тот же объект в памяти, сравнение вернет результат <span style="color: #920000;">true</span>. В противном случае результат будет <span style="color: #920000;">false</span>, несмотря на то что текст может содержать в точности такие же символы. Оператор <span style="color: #920000;">==</span> не сравнивает сами данные типа <span style="color: #920000;">char</span>. Для сравнения посимвольно необходимо использовать метод <span style="color: #920000;">equals();</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a6f5281366202">
		
			<div class="crayon-plain-wrap"><pre>        String s1 = new String("ABC");
        String s2 = new String("ABC");
        String s3 = "ABC";
        String s4 = "ABC";
        System.out.println(s1==s2); //false
        System.out.println(s3==s4); //true. Т.к. один набор литералов будет указывать на одну область памяти
        System.out.println(s1.equals(s2));//true

        s1=s2;
        System.out.println(s1==s2); //true
        if("someString" == "someString") { //true
            System.out.println("true"); 
        }
        System.out.println(s1.compareTo(s2)); //0
        System.out.println("C".compareTo("A")); //2
        System.out.println("A".compareTo("C")); //-2</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0025 seconds] -->
<p></p>
<h4>7. Как перевернуть строку?</h4>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a6fb121143049">
		
			<div class="crayon-plain-wrap"><pre>String s = "ABCDEFG";
StringBuilder stringBuilder = new StringBuilder(s);
stringBuilder.reverse();
System.out.println(stringBuilder.toString()); //GFEDCBA</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Можно и алгоритмом переставляя каждый <span style="color: #920000;">char</span>, но это на ваше усмотрение:).</p>
<h4>8. Как работает сравнение двух строк?</h4>
<p>Строка в Java &mdash; это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Просто Java в случае с логическим оператором <span style="color: #920000;">==</span> (а также <span style="color: #920000;">!=</span>) сравнивает ссылки на объекты.</p>
<p>Метод equals сравнивает посимвольно на эквивалентность.</p>
<h4>9. Как обрезать пробелы в конце строки?</h4>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a701857245200">
		
			<div class="crayon-plain-wrap"><pre>String s = "a    ";
System.out.println(s.trim() + "b");//ab
System.out.println(s + "b");//a    b</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>10. Как заменить символ в строке?</h4>
<p>Можно использовать метод <span style="color: #920000;">replace(CharSequence target, CharSequence replacement)</span>, который меняет символы в строке. Можно преобразовать в массив символов и заменить символ там. Можно использовать <span style="color: #920000;">StringBuilder</span> и метод <span style="color: #920000;">setCharAt(int index, char ch)</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a707767444370">
		
			<div class="crayon-plain-wrap"><pre>String sb = "AABAA";
String s = "ABCDEF".replace("C", "**");

String sb2 = sb.replace(sb, "##");
System.out.println(s + " " + sb2); //AB**DEF and ##

String fs = "123456789";
char[] charSequence = fs.toCharArray();
charSequence[3] = '$';
String nStr = String.valueOf(charSequence);
System.out.println(nStr); //123$56789

StringBuilder str = new StringBuilder("AMIT"); //0-A, 1-M, 2-I, 3-T
str.setCharAt(3, 'L');
//AMIL</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p></p>
<h4>11. Как получить часть строки?</h4>
<p>Метод <span style="color: #920000;">substring(int beginIndex, int lastIndex)</span> &mdash; возвращает часть строки по указанным индексам.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a70c508432715">
		
			<div class="crayon-plain-wrap"><pre>String fs = "123456789";
String sub = fs.subSequence(3,6).toString();
String sub2 = fs.substring(3,6);
System.out.println(sub2); //456</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<h4>12. Дайте определение понятию “пул строк”.</h4>
<p>Пул строк &ndash; это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.<br>
Диаграмма ниже объясняет, как пул строк размещается в памяти Java heap и что происходит, когда мы используем различные способы создания строк.</p>
<p><img src="pics/poolStrings.png"/></p>
<p>Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк также является примером паттерна Приспособленец (Flyweight).<br>
Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.<br>
Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.<br>
Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод <span style="color: #920000;">intern()</span> для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.</p>
<p>Ниже приведен пример, показывающий работу пула строк.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a713594492725">
		
			<div class="crayon-plain-wrap"><pre>String s1 = "Cat";
String s2 = "Cat";
String s3 = new String("Cat");

System.out.println("s1 == s2 :"+(s1==s2)); //s1 == s2 :true
System.out.println("s1 == s3 :"+(s1==s3)); //s1 == s3 :false</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p></p>
<h4>13. Какой метод позволяет выделить подстроку в строке?</h4>
<p>В дополнении к «как получить часть строки» можно использовать метод <span style="color: #920000;">string.indexOf(char c)</span>, который вернет индекс первого вхождения символа. Таким образом потом можно использовать этот номер для выделения подстроки с помощью <span style="color: #920000;">substring();</span></p>
<h4>14. Как разбить строку на подстроки по заданному разделителю?</h4>
<p>Мы можем использовать метод <span style="color: #920000;">split(String regex)</span> для разделения строки на массив символов, используя в качестве разделителя регулярное выражение.&nbsp;Метод <span style="color: #920000;">split(String regex, int numOfStrings)</span> является перегруженным методом для разделения строки на заданное количество строк. Мы можем использовать обратную черту для использования специальных символов регулярных выражений в качестве обычных символов.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a719626147423">
		
			<div class="crayon-plain-wrap"><pre>String line = "I am a java developer";
String[] words = line.split(" ");
String[] twoWords = line.split(" ", 2);

System.out.println("String split with delimiter: "+Arrays.toString(words));//String split with delimiter: [I, am, a, java, developer]
System.out.println("String split into two: "+Arrays.toString(twoWords));//String split into two: [I, am a java developer]

//split string delimited with special characters

String wordsWithNumbers = "I|am|a|java|developer";
String[] numbers = wordsWithNumbers.split("\\|");

System.out.println("String split with special character: "+ Arrays.toString(numbers));//String split with special character: [I, am, a, java, developer]</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0018 seconds] -->
<p></p>
<h4>15. Какой метод вызывается для преобразования переменной в строку?</h4>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a71f267847035">
		
			<div class="crayon-plain-wrap"><pre>toStringpublic static String valueOf(Object obj) {
        return (obj == null) ? "null" : obj.toString();
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>16. Как узнать значение конкретного символа строки, зная&nbsp;его порядковый номер в строке?</h4>
<p><span style="color: #920000;">str.charAt(int i)</span> вернет символ в по индексу.</p>
<h4>17. Как найти необходимый символ в строке?</h4>
<p><span style="color: #920000;">str.indexOf(char ch)</span> или <span style="color: #920000;">lastIndexOf(ch c)</span> &mdash; вернет индекс первого и последнего вхождения символа.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a724192390174">
		
			<div class="crayon-plain-wrap"><pre>String fs = "12345678904";
int a = fs.indexOf("456"); //3
int b = fs.lastIndexOf("4"); //10</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>18. Можно ли синхронизировать доступ к строке?</h4>
<p>String сам по себе потокобезопасный класс. Если мы работаем с изменяемыми строками, то нужно использовать <span style="color: #920000;">StringBuffer</span>.</p>
<h4>19. Что делает метод intern()?</h4>
<p>Когда метод <span style="color: #920000;">intern()</span> вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом <span style="color: #920000;">equals(Object)</span>, тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.<br>
Этот метод всегда возвращает строку, которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.<br>
Ниже приведен пример работы метода <span style="color: #920000;">intern()</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a72a436509651">
		
			<div class="crayon-plain-wrap"><pre>String a = "string a";
String b = new String("string a");
String c = b.intern();

System.out.println(a == b); //false
System.out.println(b == c); //false
System.out.println(a == c); //true</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<h4>20. Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?</h4>
<p>В дополнение к ответу вначале приведу сравнение производительности классов.</p>
<p>Сравнение производительности. Linux</p>
<table>
<tbody>
<tr>
<th>Класс</th>
<th>Open JDK 1.6.0_18</th>
<th>HotSpot 1.6.0_20</th>
<th>JRockit 4.0.1</th>
</tr>
<tr>
<td>String</td>
<td>27390ms</td>
<td>26850ms</td>
<td>26940ms</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>35.55ms</td>
<td>34.87ms</td>
<td>15.41ms</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>33.01ms</td>
<td>31.78ms</td>
<td>12.82ms</td>
</tr>
</tbody>
</table>
<p>Сравнение производительности. Windows XP:</p>
<table>
<tbody>
<tr>
<th>Класс</th>
<th>HotSpot 1.6.0_20</th>
<th>JRockit 4.0.1</th>
</tr>
<tr>
<td>String</td>
<td>55260ms</td>
<td>45330ms</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>19.38ms</td>
<td>14.50ms</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>16.83ms</td>
<td>12.76ms</td>
</tr>
</tbody>
</table>
<h4>21. Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?</h4>
<p>Привести их к одному типу и сравнить.</p>
<h4>22.&nbsp;Почему строка неизменная и финализированная в Java?</h4>
<p>Есть несколько преимуществ в неизменности строк:</p>
<ol>
<li>Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.</li>
<li>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.</li>
<li>Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными нитями. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.</li>
<li>Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.</li>
<li>Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.</li>
</ol>
<h4>23. Почему массив символов предпочтительнее строки для хранения пароля?</h4>
<p>Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, он остается доступным в памяти некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.<br>
Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, свойственного строке.</p>
<h4>24. Почему строка является популярным ключом в HashMap в Java?</h4>
<p>Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap.</p>
<h4>25. Напишите метод удаления данного символа из строки.</h4>
<p>Мы можем использовать метод replaceAll для замены всех вхождений в строку другой строкой. Обратите внимание на то, что метод получает в качестве аргумента строку, поэтому мы используем класс Character для создания строки из символа, и используем её для замены всех символов на пустую строку.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd5628a736244977135">
		
			<div class="crayon-plain-wrap"><pre>public static String removeChar(String str, char ch) {
        if (str == null)
            return null;
        return str.replaceAll(Character.toString(ch), "");
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>&nbsp;</p>
<h5>http://goo.gl/K38JMG &mdash;&nbsp;Java String. Вопросы к собеседованию и ответы на них, ч.1. info.javarush.ru<br>
http://goo.gl/OxO2I0 &mdash;&nbsp;Java String. Вопросы к собеседованию и ответы на них, ч.2</h5></div>

<h2>6 потоки ввода/вывода</h2>
<a href="http://javastudy.ru/interview/input-output/">src6</a>
<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Какие существуют виды потоков ввода/вывода?<br>
2. Назовите основные предки потоков ввода/вывода.<br>
3. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?<br>
4. Что вы знаете о RandomAccessFile?<br>
5. Какие есть режимы доступа к файлу?<br>
6. В каких пакетах лежат классы-потоки?<br>
7. Что вы знаете о классах-надстройках?<br>
8. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?<br>
9. Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?<br>
10. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?<br>
11. Какой класс предназначен для работы с элементами файловой системы (ЭФС)?<br>
12. Какой символ является разделителем при указании пути к ЭФС?<br>
13. Как выбрать все ЭФС определенного каталога по критерию (например, с определенным расширением)?<br>
14. Что вы знаете об интерфейсе FilenameFilter?<br>
15. Что такое сериализация?<br>
16. Какие условия “благополучной” сериализации объекта?<br>
17. Какие классы позволяют архивировать объекты?</p>
<h3>Ответы</h3>
<h4>1. Какие существуют виды потоков ввода/вывода?</h4>
<p>Разделяют два вида потоков ввода/вывода: байтовые и символьные.</p>
<p><img src="pics/ioHierarchy.png"/></p>
<h5>Система ввода/вывода: http://developer.alexanderklimov.ru/android/java/io.php</h5>
<h5>Oracle Lesson: Basic I/O tutorial:&nbsp;https://docs.oracle.com/javase/tutorial/essential/io/</h5>
<h4>2. Назовите основные предки потоков ввода/вывода.</h4>
<p>Байтовые: java.io.InputStream, java.io.OutputStream;</p>
<p>Символьные: java.io.Reader, java.io.Writer;</p>
<h4>3. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?</h4>
<p>Базовый класс <b>InputStream</b> представляет классы, которые получают данные из различных источников:<br>
&mdash; массив байтов<br>
&mdash; строка (String)<br>
&mdash; файл<br>
&mdash; канал (pipe): данные помещаются с одного конца и извлекаются с другого<br>
&mdash; последовательность различных потоков, которые можно объединить в одном потоке<br>
&mdash; другие источники (например, подключение к интернету)</p>
<p>Класс <b>OutputStream</b> &mdash; это абстрактный класс, определяющий потоковый байтовый вывод.&nbsp;В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String; предполагается что вы сможете создать их из массива байтов), в файл или канал.</p>
<p>Символьные потоки имеют два основных абстрактных класса <b>Reader</b> и <b>Writer</b>, управляющие потоками символов Unicode. Класс Reader &mdash;&nbsp;абстрактный класс, определяющий символьный потоковый ввод. Класс <b>Writer</b> &mdash; абстрактный класс, определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение <b>IOException</b>.</p>
<h4>4. Что вы знаете о RandomAccessFile?</h4>
<p>Класс RandomAccessFile наследуется напрямую от Object и не наследуется от вышеприведенных базовых классов ввода\вывода. Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому.</p>
<p>Работа с классом <b>RandomAccessFile</b> напоминает использование совмещенных в одном классе потоков <b>DataInputStream</b> и&nbsp;<b>DataOutputStream</b> (они реализуют те же интерфейсы <b>DataInput</b> и <b>DataOutput</b>). Кроме того, метод <b>seek()</b> позволяет переместиться к определенной позиции и изменить хранящееся там значение.</p>
<p>При использовании <b>RandomAccessFile</b> необходимо знать структуру файла. Класс <b>RandomAccessFile</b> содержит методы для чтения и записи примитивов и строк UTF-8.</p>
<h4>5. Какие есть режимы доступа к файлу?</h4>
<p><b>RandomAccessFile</b> может открываться в режиме чтения («r») или чтения/записи («rw»). Также есть режим «rws», когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.</p>
<h4>6. В каких пакетах лежат классы-потоки?</h4>
<p>Классы потоков ввода\вывода лежат в java.io; С JDK 7 добавлен более современный способ работы с потоками &mdash; Java NIO. Классы лежат в java.nio. Для работы с архивами используются классы из пакета java.util.</p>
<h4>7. Что вы знаете о классах-надстройках?</h4>
<p>Классы-надстройки наделяют существующий поток дополнительными свойствами. Примеры классов: <span style="color: #920000;">BufferedOutputStream</span>, <span style="color: #920000;">BufferedInputStream</span>,&nbsp;<span style="color: #920000;">BufferedWriter</span> &mdash; буферизируют поток и повышают производительность.</p>
<h4>8. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?</h4>
<p>Для чтения байтовых данных (не строк) применяется класс <b>DataInputStream</b>. В этом случае необходимо использовать классы из группы&nbsp;<b>InputStream</b>.</p>
<p>Для преобразования строки в массив байтов, пригодный для помещения в поток <b>ByteArrayInputStream</b>, в классе <b>String</b> предусмотрен метод <b>getBytes()</b>. Полученный <b>ByteArrayInputStream</b> представляет собой поток <b>InputStream</b>, подходящий для передачи&nbsp;<b>DataInputStream</b>.</p>
<p>При побайтовом чтении символов из форматированного потока <b>DataInputStream</b> методом <b>readByte()</b> любое полученное значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. Вместо этого можно использовать метод <b>available()</b>, который сообщает, сколько еще осталось символов.</p>
<p>Класс <b>DataInputStream</b> позволяет читать элементарные данные из потока через интерфейс <b>DataInput</b>, который определяет методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в файле двоичных данных.</p>
<p>Конструктор:&nbsp;DataInputStream(InputStream stream)<br>
Методы:&nbsp;readDouble(),&nbsp;readBoolean(),&nbsp;readInt()</p>
<h4>9. Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?</h4>
<p>Для этого используются классы, позволяющие буферизировать поток:<br>
java.io.BufferedInputStream(InputStream in) ||&nbsp;BufferedInputStream(InputStream in, int size),<br>
java.io.BufferedOutputStream(OutputStream out) ||&nbsp;BufferedOutputStream(OutputStream out, int size),<br>
java.io.BufferedReader(Reader r) ||&nbsp;BufferedReader(Reader in, int sz),<br>
java.io.BufferedWriter(Writer out) ||&nbsp;BufferedWriter(Writer out, int sz)</p>
<h4>10. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?</h4>
<p>OutputStreamWriter &mdash; мост между классом OutputStream и классом Writer. Символы, записанные в поток, преобразовываются в байты.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd566c3b4f576396935">
		
			<div class="crayon-plain-wrap"><pre>OutputStream outputStream       = new FileOutputStream("c:\\data\\output.txt");
Writer       outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-8");

outputStreamWriter.write("Hello World");

outputStreamWriter.close();</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>InputStreamReader &mdash; аналог для чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd566c3b5e536154470">
		
			<div class="crayon-plain-wrap"><pre>InputStream inputStream       = new FileInputStream("c:\\data\\input.txt");
Reader      inputStreamReader = new InputStreamReader(inputStream, "UTF-8");

int data = inputStreamReader.read();
while(data != -1){
    char theChar = (char) data;
    data = inputStreamReader.read();
}

inputStreamReader.close();</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p></p>
<h4>11. Какой класс предназначен для работы с элементами файловой системы (ЭФС)?</h4>
<p>В отличие от большинства классов ввода/вывода, класс <b>File</b> работает не с потоками, а непосредственно с файлами. Данный класс позволяет получить информацию о файле: права доступа, время и дата создания, путь к каталогу. А также осуществлять навигацию по иерархиям подкаталогов.&nbsp;Класс <b>java.io.File</b> может представлять имя определённого файла, а также имена группы файлов, находящихся в каталоге. Если класс представляет каталог, то его метод <b>list()</b> возвращает массив строк с именами всех файлов.</p>
<p>Для создания объектов класса <b>File</b> можно использовать один из следующих конструкторов:<br>
File(File dir, String name) &mdash; указывается объект класса File (каталог) и имя файла<br>
File(String path) &mdash; указывается путь к файлу без указания имени файла<br>
File(String dirPath, Sring name) &mdash; указывается путь к файлу и имя файла<br>
File(URI uri) &mdash; указывается объекта URI, описывающий файл</p>
<h4>12. Какой символ является разделителем при указании пути к ЭФС?</h4>
<p>Для различных систем символ разделителя различается. Вытащить его можно используя file.separator, а так же в статическом поле File.separator. &nbsp;Для Windows это ‘\’.</p>
<p>*На stackoverflow встречал утверждение со ссылкой на документацию, что можно безопасно использовать слэш ‘/’ для всех систем. В комментарии читатель&nbsp;подтвердил это.</p>
<h4>13. Как выбрать все ЭФС определенного каталога по критерию (например, с определенным расширением)?</h4>
<p>Метод File.listFiles() возвращает массив объектов File, содержащихся в каталоге. Метод может принимать в качестве параметра объект класса, реализующего FileFilter. Это позволяет включить список только те элементы, для которые метода&nbsp;accept возвращает true (критерием может быть длина имени файла или его расширение).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd566c3b70329632604">
		
			<div class="crayon-plain-wrap"><pre>public class FileDemo {
   public static void main(String[] args) {
      
      File f = null;
      File[] paths;
      
      try{      
         // create new file
         f = new File("c:/test");
         
         // returns pathnames for files and directory
         paths = f.listFiles();
         
         // for each pathname in pathname array
         for(File path:paths)
         {
            // prints file and directory paths
            System.out.println(path);
         }
      }catch(Exception e){
         // if any error occurs
         e.printStackTrace();
      }
   }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0018 seconds] -->
<p></p>
<h4>14. Что вы знаете об интерфейсе FilenameFilter?</h4>
<p>Интерфейс <span style="color: #920000;">FilenameFilter</span> применяется для проверки попадает ли объект <span style="color: #920000;">File</span> под некоторое условие. Этот интерфейс содержит единственный метод <span style="color: #920000;">boolean accept(File pathName)</span>. Этот метод необходимо переопределить и реализовать. Например:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd566c3b77248127429">
		
			<div class="crayon-plain-wrap"><pre>public boolean accept(File file) {
    if (file.isDirectory()) {
      return true;
    } else {
      String path = file.getAbsolutePath().toLowerCase();
      for (int i = 0, n = extensions.length; i &lt; n; i++) {
        String extension = extensions[i];
        if ((path.endsWith(extension) &amp;&amp; (path.charAt(path.length() 
                  - extension.length() - 1)) == '.')) {
          return true;
        }
      }
    }
    return false;
}
//OR
String yourPath = "insert here your path..";
File directory = new File(yourPath);
String[] myFiles = directory.list(new FilenameFilter() {
    public boolean accept(File directory, String fileName) {
        return fileName.endsWith(".txt");
    }
});</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0031 seconds] -->
<p></p>
<h4>15. Что такое сериализация?</h4>
<p><i>Сериализация</i> это процесс сохранения состояния объекта в последовательность байт; <i>десериализация</i> это процесс восстановления объекта, из этих байт. Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов.</p>
<h5>Сериализация в Java:&nbsp;http://habrahabr.ru/post/60317/</h5>
<h5>Изучите секреты Java Serialization API:&nbsp;http://www.ccfit.nsu.ru/~deviv/courses/oop/java_ser_rus.html</h5>
<h5>Как работает сериализация в Java (info.javarush.ru): &nbsp;http://goo.gl/K8GzJl</h5>
<h4>16. Какие условия “благополучной” сериализации объекта?</h4>
<p>Чтобы обладать способностью к сериализации, класс должен реализовывать интерфейс-метку Serializable. Так же все атрибуты и подтипы сериализуемого класса должны быть сериализуемы. Если класс предок был несереализуемым, то этот суперкласс должен содержать доступный (public, protected) конструктор без параметров для инициализации полей.</p>
<h4>17. Какие классы позволяют архивировать объекты?</h4>
<p>DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream, &nbsp;GZIPInputStream,&nbsp;GZIPOutputStream.</p>
<p>Пример из&nbsp;http://www.concretepage.com/java/how_to_zip_file_java.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd566c3b80573226938">
		
			<div class="crayon-plain-wrap"><pre>package com.concretepage;
 
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
 
public class ZipOutputStreamTest {
 
    public static void main(String... args) throws IOException {
 
        String source="D:/page/file.txt";
 
        File sfile= new File(source);
 
        String dest="D:/page/file.zip";
 
        File dfile= new File(dest);
 
        FileInputStream fis= new FileInputStream(sfile);
 
        FileOutputStream fos= new FileOutputStream(dfile);
 
        ZipOutputStream zos= new ZipOutputStream(fos);
 
        ZipEntry ze= new ZipEntry(source);
 
        //begins writing a new zip file and sets the the position to the start of data
        zos.putNextEntry(ze);
 
        byte[] buf = new byte[1024];
        int len;
        while((len=fis.read(buf))&gt;0){
            zos.write(buf, 0, len);
        }
        System.out.println("File created:"+dest);
        fis.close();
        zos.close();
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0039 seconds] -->
<p>&nbsp;</p></div>

<h2>7 многопоточность </h2>
<a href="http://javastudy.ru/interview/concurrent/">src7</a>
<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Дайте определение понятию “процесс”.<br>
2. Дайте определение понятию “поток”.<br>
3. Дайте определение понятию “синхронизация потоков”.<br>
4. Как взаимодействуют программы, процессы и потоки?<br>
5. В каких случаях целесообразно создавать несколько потоков?<br>
6. Что может произойти если два потока будут выполнять один и тот же код в программе?<br>
7. Что вы знаете о главном потоке программы?<br>
8. Какие есть способы создания и запуска потоков?<br>
9. Какой метод запускает поток на выполнение?<br>
10. Какой метод описывает действие потока во время выполнения?<br>
11. Когда поток завершает свое выполнение?<br>
12. Как синхронизировать метод?<br>
13. Как принудительно остановить поток?<br>
14. Дайте определение понятию “поток-демон”.<br>
15. Как создать поток-демон?<br>
16. Как получить текущий поток?<br>
17. Дайте определение понятию “монитор”.<br>
18. Как приостановить выполнение потока?<br>
19. В каких состояниях может пребывать поток?<br>
20. Что является монитором при вызове нестатического и статического метода?<br>
21. Что является монитором при выполнении участка кода метода?<br>
22. Какие методы позволяют синхронизировать выполнение потоков?<br>
23. Какой метод переводит поток в режим ожидания?<br>
24. Какова функциональность методов notify и notifyAll?<br>
25. Что позволяет сделать метод join?<br>
26. Каковы условия вызова метода wait/notify?<br>
27. Дайте определение понятию “взаимная блокировка”.<br>
28. Чем отличаются методы interrupt, interrupted, isInterrupted?<br>
29. В каком случае будет выброшено исключение InterruptedException, какие методы могут его выбросить?<br>
30. Модификаторы volatile и метод yield().<br>
31. Пакет java.util.concurrent<br>
32. Есть некоторый метод, который исполняет операцию i++. Переменная i типа int. Предполагается, что код будет исполнятся в многопоточной среде. Следует ли синхронизировать блок?<br>
33. Что используется в качестве mutex, если метод объявлен static synchronized? Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?<br>
34. Предположим в методе run возник RuntimeException, который не был пойман. Что случится с потоком? Есть ли способ узнать о том, что Exception произошел (не заключая все тело run в блок try-catch)? Есть ли способ восстановить работу потока после того как это произошло?<br>
35. Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?<br>
36.Что такое ThreadGroup и зачем он нужен?<br>
37.Что такое ThreadPool и зачем он нужен?<br>
38.Что такое ThreadPoolExecutor и зачем он нужен?<br>
39.Что такое «атомарные типы» в Java?<br>
40.Зачем нужен класс ThreadLocal?<br>
41.Что такое Executor?<br>
42.Что такое ExecutorService?<br>
43.Зачем нужен ScheduledExecutorService?</p>
<h3>Ответы</h3>
<h4>1. Дайте определение понятию “процесс”.</h4>
<p>Процесс &mdash; это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.&nbsp;Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств).&nbsp;Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.</p>
<h5>Многопоточность в Java:&nbsp;http://habrahabr.ru/post/164487/</h5>
<h4>2. Дайте определение понятию “поток”.</h4>
<p>Один поток («нить» или «трэд») &ndash; это одна единица исполнения кода. Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.</p>
<h5>Thinking in Java.Параллельное выполнение.&nbsp;http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html</h5>
<h4>3. Дайте определение понятию “синхронизация потоков”.</h4>
<p>Синхронизация относится к многопоточности. Синхронизированный блок кода может быть выполнен только одним потоком одновременно.</p>
<p>Java поддерживает несколько потоков для выполнения. Это может привести к тому, что два или более потока получат доступ к одному и тому же полю или объекту. Синхронизация &mdash; это процесс, который позволяет выполнять все параллельные потоки в программе синхронно. Синхронизация позволяет избежать ошибок согласованности памяти, вызванных непоследовательным доступом к общей памяти.<br>
Когда метод объявлен как синхронизированный &mdash; нить держит монитор для объекта, метод которого исполняется. Если другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, пока другой поток не отпустит монитор.<br>
Синхронизация достигается в Java использованием зарезервированного слова synchronized. Вы можете использовать его в своих классах определяя синхронизированные методы или блоки. Вы не сможете использовать synchronized в переменных или атрибутах в определении класса.</p>
<h5>Синхронизация потоков, блокировка объекта и блокировка класса info.javarush.ru: http://goo.gl/gW4ONp</h5>
<h4>4. Как взаимодействуют программы, процессы и потоки?</h4>
<p>Чаще всего одна программа состоит из одного процесса, но бывают и исключения (например, браузер Chrome создает отдельный процесс для каждой вкладки, что дает ему некоторые преимущества, вроде независимости вкладок друг от друга). В каждом процессе может быть создано множество потоков. Процессы разделены между собой (&gt;программы), потоки в одном процессе могут взаимодействовать друг с другом (методы wait, notify, join и т.д.).</p>
<h4>5. В каких случаях целесообразно создавать несколько потоков?</h4>
<p>Многопоточные приложения применяются в случаях, когда можно разделить программу на несколько относительно независимых частей. В этом случае чтобы один код не ждал другой их помещают в различные потоки. В качестве примера можно привести программу с графическим интерфейсом &mdash; пока выполняются какие-либо длительные вычисления в одном потоке, интерфейс может быть доступен пользователю и не зависать, если он выполняется в другом потоке.</p>
<h4>6. Что может произойти если два потока будут выполнять один и тот же код в программе?</h4>
<p>Если используются не синхронизированные данные, то может произойти ситуация, когда код работает уже с устаревшими данными. Например, в первом потоке идет изменение каких-либо полей, а в это время второй поток читает эти поля.</p>
<h4>7. Что вы знаете о главном потоке программы?</h4>
<p>Маленькие программы на Java обычно состоят из одной нити, называемой «главной нитью» (main thread). Но программы побольше часто запускают дополнительные нити, их еще называют «дочерними нитями». Главная нить выполняет метод main и завершается. Аналогом такого метода main, для дочерних нитей служит метод run интерфейса Runnable. Много потоков &mdash; много методов main (run()).</p>
<h4>8. Какие есть способы создания и запуска потоков?</h4>
<p>Существует несколько способов создания и запуска потоков.</p>
<p>С помощью класса, реализующего <span style="color: #920000;">Runnable</span></p>
<ul>
<li>Создать объект класса <span style="color: #920000;">Thread</span>.</li>
</ul>
<ul>
<li>Создать объект класса, реализующего интерфейс <span style="color: #920000;">Runnable</span></li>
<li>Вызвать у созданного объекта Thread метод <span style="color: #920000;">start()</span> (после этого запустится метод <span style="color: #920000;">run()</span> у переданного объекта, реализующего <span style="color: #920000;">Runnable</span>)</li>
</ul>
<p>С помощью класса, расширяющего <span style="color: #920000;">Thread</span></p>
<ul>
<li>Создать объект класса <span style="color: #920000;">ClassName extends</span>&nbsp;<span style="color: #920000;">Thread</span>.</li>
<li>Переопределить <span style="color: #920000;">run()</span> в этом классе (смотрите примере ниже, где передается имя потока ‘Second’)</li>
</ul>
<p>С помощью класса, реализующего <span style="color: #920000;">java.util.concurrent.Callable</span></p>
<ul>
<li>Создать объект класса, реализующего интерфейс <span style="color: #920000;">Callable</span></li>
<li>Создать объект <span style="color: #920000;">ExecutorService</span> с указанием пула потоков.</li>
<li>Создать объект Future. Запуск происходит через метод <span style="color: #920000;">submit()</span>; Сигнатура:&nbsp;<span style="color: #920000;">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d078355792238">
		
			<div class="crayon-plain-wrap"><pre>    public static void howToRunThreads() {
        ThreadClass threadClass = new ThreadClass("First");
        threadClass.start(); //method ThreadClass.run()

        Thread thread = new Thread(new RunnableClass("Second"));
        Thread thread2 = new Thread(new RunnableClass("Third"));
        Thread thread3 = new Thread(new RunnableClass("Fourth"));
        thread.start(); //method RunnableClass.run()
        thread2.start(); //method RunnableClass.run()
        thread3.start(); //method RunnableClass.run()
    }

public class RunnableClass implements Runnable {

    private String localName;

    public RunnableClass() {
    }

    public RunnableClass(String localName) {
        this.localName = localName;
    }

    @Override
    public void run() {
        System.out.println("run() " + localName + " running");
    }

    public String getLocalName() {return localName;}
    public void setLocalName(String localName) {this.localName = localName;}
}

public class ThreadClass extends Thread {

    public ThreadClass() {
    }

    public ThreadClass(String name) {
        super(name);
    }

    public ThreadClass(Runnable target) {
        super(target);
        System.out.println(target + " will running");
    }

    @Override
    public void run() {
         System.out.println("ThreadClass run() method " + "Thread name is: " + this.getName());
    }
}
//Вывод
ThreadClass run() method Thread name is: First
run() Third running
run() Fourth running
run() Second running //обратите внимание, поменялись местами при выполнении.</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0058 seconds] -->
<p>Пример с интерфейсом <span style="color: #920000;">Callable</span>:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d083349847429">
		
			<div class="crayon-plain-wrap"><pre>public class CallableExample {

  public static class WordLengthCallable
        implements Callable {
    private String word;
    public WordLengthCallable(String word) {
      this.word = word;
    }
    public Integer call() {
      return Integer.valueOf(word.length());
    }
  }

  public static void main(String args[]) throws Exception {
    ExecutorService pool = Executors.newFixedThreadPool(3);
    Set&lt;Future&lt;Integer&gt;&gt; set = new HashSet&lt;Future&lt;Integer&gt;&gt;();
    for (String word: args) {
      Callable&lt;Integer&gt; callable = new WordLengthCallable(word);
      Future&lt;Integer&gt; future = pool.submit(callable);
      set.add(future);
    }
    int sum = 0;
    for (Future&lt;Integer&gt; future : set) {
      sum += future.get();
    }
    System.out.printf("The sum of lengths is %s%n", sum);
    System.exit(sum);
  }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0037 seconds] -->
<p></p>
<h4>9. Какой метод запускает поток на выполнение?</h4>
<p>Thread.start() запускает дочерний поток. Для интерфейса Callable запуск потока осуществляется с помощью метода submit().</p>
<h4>10. Какой метод описывает действие потока во время выполнения?</h4>
<p>Метод run() или метод call() для дочерних потоков. Метод main() для главного потока.</p>
<h4>11. Когда поток завершает свое выполнение?</h4>
<p>Поток закончит выполнение, когда завершится его метод run() или call(). Для главного потока это метод main().</p>
<h4>12. Как синхронизировать метод?</h4>
<p>Или указать в сигнатуре модификатор synchronized или использовать конструкцию&nbsp;synchronized {} внутри метода.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d088750424681">
		
			<div class="crayon-plain-wrap"><pre>    public void swap()
    {
        synchronized (this)
        {
           //someCode
        }
    }

    public synchronized void swap1EqualsSwap()
    {
       //someCode
    }

    public static synchronized void swap2()
    {
       //someCode
    }

    public static void swap3EqualsSwap2()
    {
        synchronized (JoinClass.class)
        {
            //someCode
        }
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0015 seconds] -->
<p></p>
<h4>13. Как принудительно остановить поток?</h4>
<p>В Java 8 нет метода, который бы принудительно останавливал поток.&nbsp;Никто не гарантирует, что нить можно остановить. Она может остановиться только сама.&nbsp;Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство).</p>
<p>Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя способами. Первый способ &mdash; вызвать метод bool isInterrupted() объекта потока, второй &mdash; вызвать статический метод bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает состояние флага и сбрасывает его. Заметьте что Thread.interrupted() &mdash; статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.</p>
<p>У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность &mdash; если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d08c362237471">
		
			<div class="crayon-plain-wrap"><pre>public class JoinClass implements Runnable {

    @Override
    public void run() {
        for (int i=0; i&lt;100; i++) {
            if(!Thread.interrupted()) {
                System.out.println(i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    System.out.println("InterruptedException!");
                    System.err.println("Exception msg: " + e.getMessage());
                    return;
                }
            } else {
                System.out.println("Interrupted!");
                return;
            }
        }
    }
}
public class TestClass {

    public static void main(String[] args) {
        Thread thread = new Thread(new JoinClass());
        thread.start();
        try {
            Thread.sleep(1000L); // выключаем поток main, чтобы в JoinClass.run() что-то успело посчитаться
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
//Вывод
0
1
...
8
9 //счетчик был до 100
InterruptedException!
Exception msg: sleep interrupted</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0040 seconds] -->
<p></p>
<ul>
<li>В методе <span style="color: #920000;">main()</span> создаем объект класса <span style="color: #920000;">JoinClass</span> и запускаем его методом&nbsp;<span style="color: #920000;">run()</span>. Сначала проверяется не завершен ли уже этот поток, а затем каждые 100мс выводится значение счетчика.</li>
<li>Главному методу приказывает подождать 1000мс, чтобы счетчик успел немножко посчитать.</li>
<li>Вызываем interrupt метод у объекта класса <span style="color: #920000;">JoinClass</span>. После этого в цикле сразу ловится исключение и срабатывает <span style="color: #920000;">return</span> в блоке <span style="color: #920000;">catch</span>.</li>
</ul>
<h4>14. Дайте определение понятию “поток-демон”.</h4>
<p>Потоками-демонами называются потоки, работающие в фоновом режиме для нашей программы.</p>
<p>В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.<br>
Однако это правило не относится к особому виду потоков &ndash; демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.</p>
<h4>15. Как создать поток-демон?</h4>
<p>Объявить поток демоном достаточно просто &mdash; нужно перед запуском потока вызвать его метод <span style="color: #920000;">setDaemon(true);</span><br>
Проверить, является ли поток демоном, можно вызвав его метод <span style="color: #920000;">boolean isDaemon();</span></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d092162216572">
		
			<div class="crayon-plain-wrap"><pre>Thread thread = new Thread(new DaemonClass());
thread.setDaemon(true);
System.out.println(thread.isDaemon()); //true</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>16. Как получить текущий поток?</h4>
<p>Вызвать в коде статический метод&nbsp;<span style="color: #920000;">Thread.currentThread()</span>, который вернет текущий поток.</p>
<h4>17. Дайте определение понятию “монитор”.</h4>
<p>Несколько нитей могут мешать друг другу при обращении к одним и тем же данным. Для решения&nbsp;этой проблемы придуман мьютекс (он же монитор). Он имеет два состояния &mdash; объект занят и объект свободен.&nbsp;Монитор(мьютекс) &mdash; высокоуровневый механизм взаимодействия и синхронизации процессов, обеспечивающий доступ к неразделяемым ресурсам.</p>
<p>Когда какой-то нити нужен общий для всех нитей объект, она проверяет мютекс, связанный с этим объектом. Если мютекс свободен, то нить блокирует его (помечает как занятый) и начинает использование общего ресурса. После того, как она сделала свои дела, мютекс разблокируется (помечается как свободен).</p>
<p>Если же нить хочет использовать объект, а мютекс заблокирован, то нить засыпает в ожидании. Когда мютекс, наконец, освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе.&nbsp;Мютекс встроен в класс Object и следовательно он есть у каждого объекта.</p>
<p>Когда одна нить заходит внутрь блока кода, помеченного словом synchronized, то Java-машина тут же блокирует мютекс у объекта, который указан в круглых скобках после слова synchronized. Больше ни одна нить не сможет зайти в этот блок, пока наша нить его не покинет. Как только наша нить выйдет из блока, помеченного synchronized, то мютекс тут же автоматически разблокируется и будет свободен для захвата другой нитью.&nbsp;Если же мютекс был занят, то наша нить будет стоять на месте и ждать когда он освободится.</p>
<h4>18. Как приостановить выполнение потока?</h4>
<p>Thread.sleep() &mdash; статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван. Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение InterruptedException).</p>
<p>Возможен вопрос про старые методы&nbsp;suspend, stop и resume &mdash; они deprecated.</p>
<h4>19. В каких состояниях может пребывать поток?</h4>
<p>Поток может быть в следующем состоянии: созданный, запущенный, блокированный, остановленный.</p>
<h4>20. Что является монитором при вызове нестатического и статического метода?</h4>
<p>Для нестатического метода &mdash; текущий объект this. Для статического метода &mdash; объекта типа Class, соответствующий классу, в котором определен этот метод.</p>
<h4>21. Что является монитором при выполнении участка кода метода?</h4>
<p>Монитором является объект, указанный в блоке synchronized участка кода:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d098876946359">
		
			<div class="crayon-plain-wrap"><pre>        synchronized (synchedList) {
...
                synchedList.wait();
...
        }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>22. Какие методы позволяют синхронизировать выполнение потоков?</h4>
<p>К этим методам относятся notify(), notifyAll(), wait();</p>
<h5>А как же всё-таки работает многопоточность? Часть I: синхронизация:&nbsp;http://habrahabr.ru/post/143237/</h5>
<h4>23. Какой метод переводит поток в режим ожидания?</h4>
<p>Метод wait().</p>
<h4>24. Какова функциональность методов notify и notifyAll?</h4>
<p>Метод notify пробуждает один из потоков, который вызвал метод wait() у этого монитора. Метод notifyAll пробуждает все потоки. Очередность выполнения в этом случае будет определяться приоритетом потока.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d09c708738272">
		
			<div class="crayon-plain-wrap"><pre>public class NotifyClass {

    private List synchedList;

    public NotifyClass() {
        // create a new synchronized list to be used
        synchedList = Collections.synchronizedList(new LinkedList());
    }

    // method used to remove an element from the list
    public String removeElement() throws InterruptedException {
        synchronized (synchedList) {
            // while the list is empty, wait
            while (synchedList.isEmpty()) {
                System.out.println("List is empty...");
                synchedList.wait();
                System.out.println("Waiting...");
            }
            String element = (String) synchedList.remove(0);

            return element;
        }
    }

    // method to add an element in the list
    public void addElement(String element) {
        System.out.println("Opening...");
        synchronized (synchedList) {
            // add an element and notify all that an element exists
            synchedList.add(element);
            System.out.println("New Element:'" + element + "'");

            synchedList.notifyAll();
            System.out.println("notifyAll called!");
        }
        System.out.println("Closing...");
    }

    public static void main(String[] args) {
        final NotifyClass demo = new NotifyClass();

        Runnable runA = new Runnable() {

            public void run() {
                try {
                    String item = demo.removeElement();
                    System.out.println("" + item);
                } catch (InterruptedException ix) {
                    System.out.println("Interrupted Exception!");
                } catch (Exception x) {
                    System.out.println("Exception thrown.");
                }
            }
        };

        Runnable runB = new Runnable() {

            // run adds an element in the list and starts the loop
            public void run() {
                demo.addElement("Hello!");
            }
        };

        try {
            Thread threadA1 = new Thread(runA, "A");
            threadA1.start();

            Thread.sleep(500);

            Thread threadA2 = new Thread(runA, "B");
            threadA2.start();

            Thread.sleep(500);

            Thread threadB = new Thread(runB, "C");
            threadB.start();

            Thread.sleep(1000);

            threadA1.interrupt();
            threadA2.interrupt();
        } catch (InterruptedException x) {
        }
    }

}
//Вывод
List is empty...
List is empty...
Opening...
New Element:'Hello!'
notifyAll called!
Closing...
Waiting...
Waiting...
List is empty...
Hello!
Interrupted Exception!</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0088 seconds] -->
<p></p>
<h4>25. Что позволяет сделать метод join?</h4>
<p>Одна нить (поток) может вызвать метод join() у другой нити. В результате первый поток (который вызвал метод) приостанавливает свою работу и ждет окончания работы второго потока (у объекта которого был вызван метод join()).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0a1395585925">
		
			<div class="crayon-plain-wrap"><pre>public class TestClass {

    public static void main(String[] args) {
        Thread threadExample = new Thread(new JoinClass());
        threadExample.start();
        try {
            threadExample.join(); //public static void TestClass.main() connect to threadExample and wait for it.
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("END: " + Calendar.getInstance().getTime());
    }
}

public class JoinClass implements Runnable {

    @Override
    public void run() {
              System.out.println("JoinClass.run() " + Calendar.getInstance().getTime());
        try {
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("afterSleep " + Calendar.getInstance().getTime());
    }
}
//Вывод
JoinClass.run() Tue Jan 19 00:00:37 MSK 2016
afterSleep Tue Jan 19 00:00:42 MSK 2016
END: Tue Jan 19 00:00:42 MSK 2016</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0041 seconds] -->
<p>После запуска метода <span style="color: #920000;">main</span> создается главный поток класса <span style="color: #920000;">TestClass</span>.</p>
<ul>
<li>Затем мы создаем тестовый поток <span style="color: #920000;">threadExample</span> и запускаем его.Заставляем поток протупить 5 секунд внутри метода <span style="color: #920000;">JoinClass.run().</span></li>
<li>После чего вызываем метод <span style="color: #920000;">join() </span>у второго потока. В этот момент главный поток подсоединяется к нашему второму потоку и ждет его завершения.</li>
<li>Смотрим какое прошло время &mdash; 5 секунд. Т.е. главный поток ждал пока завершится <span style="color: #920000;">threadExample</span> до перехода к методу <span style="color: #920000;">System.out.println()</span>. В противном случае <span style="color: #920000;">System.out.println(«END: «)</span>&nbsp;выполнился сразу без ожидания пока отойдет threadExample.</li>
</ul>
<h4>26. Каковы условия вызова метода wait/notify?</h4>
<p>Методы должны вызываться на объекте-мониторе только из синхронизированного кода. Поток, который вызывает эти методы должен владеть монитором, иначе будет выдано исключение&nbsp;<span style="color: #920000;">java.lang.IllegalMonitorStateException</span>.</p>
<h4>27. Дайте определение понятию “взаимная блокировка”.</h4>
<p>Deadlock, он же взаимная блокировка, явление при котором все потоки находятся в режиме ожидания. Чтобы уменьшить шанс появления deadlock’a не рекомендуется использовать методы wait() и notify().</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0a6934168910">
		
			<div class="crayon-plain-wrap"><pre>    final Object lock1 = new Object();
    final Object lock2 = new Object();
    
//Здесь будет дедлок
    void method01() {
        synchronized(lock1) {
            synchronized(lock2) {
               //doSomething()
            }
        }
    }
    
    void method1() {
        synchronized(lock2) {
            synchronized(lock1) {
               //doSomething()
            }
        }
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0015 seconds] -->
<p>Чтобы избежать дедлока можно использовать только один блок synchronized, отказаться от wait-notify или использовать такую конструкцию:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0a9115494866">
		
			<div class="crayon-plain-wrap"><pre>//Чтобы избежать дедлока, лучше использовать один lock.
//Если нельзя использовать только один lock, то применяйте такую схему   
    void method2() {
        if (identityHashCode(lock1)&gt;=identityHashCode(lock2)) {
            synchronized(lock1) {
                synchronized(lock2) {
                  //doSomething()
                }
            }
        }
        else {
            synchronized(lock2) {
                synchronized(lock1) {
                   //doSomething()
                }
            }
        }
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p></p>
<h5>Java &mdash; Thread Deadlock: http://www.tutorialspoint.com/java/java_thread_deadlock.htm</h5>
<h5>Взаимная блокировка(deadlock) в Java и методы борьбы с ней:&nbsp;http://www.developersonthe.net/ru/posts/post_id/34-Vzaimnaja-blokirovkadeadlock-v-Java-i-metody-borby-s-nej/</h5>
<h4>28. Чем отличаются методы interrupt, interrupted, isInterrupted?</h4>
<ul>
<li>Метод interrupt()&nbsp;&mdash; устанавливает флаг прерывания потока.</li>
<li>Метод bool isInterrupted() объекта потока&nbsp;возвращает состояние флага прерывания и оставляет этот флаг нетронутым.</li>
<li>Статический метод bool Thread.interrupted() &mdash; возвращает состояние флага и сбрасывает его.</li>
</ul>
<h4>29. В каком случае будет выброшено исключение InterruptedException, какие методы могут его выбросить?</h4>
<p>Методы, требующие обработку этого исключения: wait, sleep, join. Исключение будет выброшено, если флаг interrupt у потока true.</p>
<h4>30. Модификаторы volatile и метод yield().</h4>
<p>Помещение модификатора volatile перед определением переменной заставляет&nbsp;принудительно всегда читать&nbsp;и писать&nbsp;значение только в обычную (медленную) память (а не кэшировать). Записывается как:&nbsp;private volatile boolean&nbsp;varName;</p>
<p>Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0ae535048743">
		
			<div class="crayon-plain-wrap"><pre>//Ожидание поступления сообщения
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>31. Пакет java.util.concurrent</h4>
<h5>Обзор java.util.concurrent.*: &nbsp;http://habrahabr.ru/company/luxoft/blog/157273/</h5>
<h4>32. Есть некоторый метод, который исполняет операцию i++. Переменная i типа int. Предполагается, что код будет исполнятся в многопоточной среде. Следует ли синхронизировать блок?</h4>
<p>Да, иначе будет состояние гонки (race condition).</p>
<h4>33. Что используется в качестве mutex, если метод объявлен static synchronized? Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?</h4>
<p>Да, можно создать новый экземпляр класса, пока его static synchronized метод выполняется. Мои рассуждения: статик методы классов создаются в единственном экземпляре во время загрузки класса класслоадером и принадлежат объекту Class.MyClass. Во время выполнения в потоке static synchronized метода захватывается блокировка именно этого объекта. Следовательно нам ни что не мешает создать новый экземпляр класса.&nbsp;Загрузчиков может быть несколько, соответственно, экземпляров Class&lt;MyClass&gt; &mdash; тоже несколько, по одному на загрузчик.&nbsp;Создавать новые инстанции ничего не мешает, т.к. это типа выделение машиной памяти под объект и вызов метода &lt;init&gt;, который не synchronized.</p>
<h4>34. Предположим в методе run возник RuntimeException, который не был пойман. Что случится с потоком? Есть ли способ узнать о том, что Exception произошел (не заключая все тело run в блок try-catch)? Есть ли способ восстановить работу потока после того как это произошло?</h4>
<p>Если в дочернем потоке упадет Exception, то метод run() аварийно завершится и исключение будет передано&nbsp;в главный поток. Далее в консоль будет выведен стектрейс, приведенный ниже.</p>
<p>Если исключение не обрабатывать, то нить (вызванная в методе run()) просто аварийно завершится. Восстановить работу нити после такого сценария нельзя, можно только создать нить заново.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0b3275215244">
		
			<div class="crayon-plain-wrap"><pre>Exception in thread "Thread-0" java.lang.NullPointerException
Thread-0
	at ru.javastudy.interview.multithreading.JoinClass.exceptionChecker(JoinClass.java:101)
	at ru.javastudy.interview.multithreading.JoinClass.run(JoinClass.java:24)
	at java.lang.Thread.run(Thread.java:745)</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p></p>
<h4>35. Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?</h4>
<p>Читайте выше о пакете concurrent. Реализация стандартными пакетами в статье от ibm:</p>
<h5>Теория и практика Java: Пулы потоков и очередь действий:&nbsp;http://www.ibm.com/developerworks/ru/library/j-jtp0730/index.html</h5>
<h4>36.Что такое ThreadGroup и зачем он нужен?</h4>
<p>ThreadGroup представляет собой набор нитей, которые так же могут содержать в себе другие группы потоков. Группа нитей образует дерево, в котором каждая другая группа нитей имеет родителя (кроме исходной). Поток имеет право доступа к данным из своей группы нитей, но не имеет такого доступа к другим группам или к родительской группе потоков.</p>
<h5>Управление потоками, безопасность и ThreadGroup Java &mdash;&nbsp;http://src-code.net/upravlenie-potokami-bezopasnost-i-threadgroup-java/</h5>
<h4>37.Что такое ThreadPool и зачем он нужен?</h4>
<p>Пулы потоков (нитей) представляют собой управляемую коллекцию потоков, которые доступны для выполнения различных задач. Пулы нитей, как правило, обеспечивают:</p>
<ul>
<li>Повышение производительности при выполнении большого количества задач в связи с сокращением накладных расходов на вызов каждой задачи.</li>
<li>Является средством ограничивающим расход ресурсов при выполнении набора задач.</li>
<li>Избавляют от необходимости управления жизненным циклом нитей.</li>
</ul>
<h4>38.Что такое ThreadPoolExecutor и зачем он нужен?</h4>
<p>ThreadPoolExecutor &mdash; реализация ExecutorService. Он выполняет переданную задачу (Callable или Runnable), используя одну из внутренних доступных нитей из пула. Пул потоков содержит в себе&nbsp;ThreadPoolExecutor, который может содержать изменяющееся число нитей. Число нитей в пуле задается с помощью&nbsp;corePoolSize и&nbsp;maximumPoolSize.</p>
<h5>http://tutorials.jenkov.com/java-util-concurrent/threadpoolexecutor.html</h5>
<h4>39.Что такое «атомарные типы» в Java?</h4>
<p>Все атомарные классы переменных имеют базовый элемент Сравнение и назначение (compare-and-set) (аналогичный элементу Сравнение и замена), который реализуется при помощи самого быстрого собственного структурного компонента, кооторый имеется в платформе (Сравнение и замена, Загрузить в связке, Сохранить при условии или в крайнем случае спин-блокировками). В пакет java.util.concurrent.atomic входят 9 видов атомарных переменных (AtomicInteger; AtomicLong; AtomicReference; AtomicBoolean; формы для массивов атомарных целых чисел; длинные (long); ссылки; а также атомарные с пометкой Класс эталона (reference), которые атомарно обновляют две величины).<br>
Классы атомарных переменных можно рассматривать как обобщение volatile переменных, если расширить понятие изменяемых переменных до переменных с поддержкой атомарных обновлений методом Сравнение и назначение. Чтение и запись атомарных переменных имеет такую же семантику памяти как доступ к чтению и записи изменяемых переменных.</p>
<p>Пример атомарной переменной AtomicLong:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0b9148041898">
		
			<div class="crayon-plain-wrap"><pre>private volatile long value;

public final long get() {
    return value;
}

public final long getAndAdd(long delta) {
    while (true) {
        long current = get();
        long next = current + delta;
        if (compareAndSet(current, next))
            return current;
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>Переменные current и next &mdash; локальные, а следовательно у каждого потока свои экземпляры этих переменных.&nbsp;Следует обратить внимание&nbsp;лишь на&nbsp;разделяемое состояние, т.е. переменную value. Т.к. переменная value объявлена с модификатором volatile, то гарантируется выполнение отношения happens-before, что ведет к тому, что измененное значение этой переменной увидят все потоки.</p>
<p>Метод compareAndSet представляет из себя механизм оптимистичной блокировки и позволяет изменить значение value, только если оно равно ожидаемому значению (т.е. current).</p>
<p>Если же значение value было изменено в другом потоке, то оно не будет равно ожидаемому значению. Следовательно метод compareAndSet вернет значение false, что приведет к новой итерации цикла while в методе getAndAdd. Т.е. новое значение value будет перезачитано в переменную current, после чего будет произведено сложение и новая попытка записи получившегося значения (т.е. next).</p>
<h5>http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/</h5>
<h4>40.Зачем нужен класс ThreadLocal?</h4>
<p>ThreadLocal предоставляет абстракцию над переменными локальными по отношению к потоку исполнения java.lang.Thread. ThreadLocal переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной, доступ к которой он получает через методы get() или set().&nbsp;У каждого потока &mdash; т.е. экземпляра класса Thread &mdash; есть ассоциированная с ним таблица ThreadLocal-переменных. Ключами таблицы являются cсылки на объекты класса ThreadLocal, а значениями &mdash; ссылки на объекты, «захваченные» ThreadLocal-переменными.</p>
<h5>http://samolisov.blogspot.ru/2011/04/threadlocal.html</h5>
<h5>http://articles.javatalks.ru/articles/17</h5>
<h4>41.Что такое Executor?</h4>
<p>Executor &mdash; интерфейс, который может выполнять подтвержденные задачи. Интерфейс предоставляет возможность избежать вникания в механику выполнения задачи и деталей использования выполняемого потока.&nbsp;Executor обычно используется для явного создания нитей. Например так:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0bf423057953">
		
			<div class="crayon-plain-wrap"><pre>//Вместо
Thread(new(RunnableTask())).start():
//Лучше использовать
Executor executor = anExecutor;
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
...</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<h5>https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html</h5>
<h4>42.Что такое ExecutorService?</h4>
<p>ExecutorService исполняет асинхронный код в одном или нескольких потоках. Создание инстанса ExecutorService’а делается либо вручную через конкретные имплементации (ScheduledThreadPoolExecutor или ThreadPoolExecutor), но проще будет использовать фабрики класса Executors. Например, если надо создать пул с 2мя потоками, то делается это так:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0c2168741155">
		
			<div class="crayon-plain-wrap"><pre>ExecutorService service = Executors.newFixedThreadPool(2);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0c6186987307">
		
			<div class="crayon-plain-wrap"><pre>ExecutorService service = Executors.newCachedThreadPool();</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p>Если требуется запустить асинхронный код несколько раз, то это будет выполняться&nbsp;так:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0c9681775153">
		
			<div class="crayon-plain-wrap"><pre>ExecutorService service = Executors.newCachedThreadPool();
for(int i = 0; i &lt; 10; i++) {
 service.submit(new Runnable() {
  public void run() {
   // snip... piece of code
  }
 });
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>Метод submit также возвращает объект Future, который содержит информацию о статусе исполнения переданного Runnable или Callable (который может возвращать значение). Из него можно узнать выполнился ли переданный код успешно, или он еще выполняется. Вызов метода get на объекте Future возвратит значение, который возвращает Callable (или null, если используется Runnable). Метод имеет 2 checked-исключения: InterruptedException, который бросается, когда выполнение прервано через метод interrupt(), или ExecutionException если код в Runnable или Callable бросил RuntimeException, что решает проблему поддержки исключений между потоками.</p>
<h5>Многопоточность в Java: ExecutorService &mdash; https://habrahabr.ru/post/116363/</h5>
<h4>43.Зачем нужен ScheduledExecutorService?</h4>
<p>Иногда требуется выполнение кода асихронно и периодически или требуется выполнить код через некоторое время, тогда на помощь приходит ScheduledExecutorService. Он позволяет поставить код выполняться в одном или нескольких потоках и сконфигурировать интервал или время, на которое выполненение будет отложено. Интервалом может быть время между двумя последовательными запусками или время между окончанием одного выполнения и началом другого. Методы ScheduledExecutorService возвращают ScheduledFuture, который также содержит значение отсрочки для выполнения ScheduledFuture.</p>
<p>Если требуется отложить выполнение на 5 секунд, потребуется следующий код:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0cd694026546">
		
			<div class="crayon-plain-wrap"><pre>ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.schedule(new Runnable() { ... }, 5, TimeUnit.SECONDS);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>Если требуется назначить выполнение каждую секунду:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0d0952513456">
		
			<div class="crayon-plain-wrap"><pre>ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.scheduleAtFixedRate(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>И, наконец, если требуется назначить выполнение кода с промежутком 1 секунда между выполнениями:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce4eab2d0d3826017204">
		
			<div class="crayon-plain-wrap"><pre>ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.scheduleWithFixedDelay(new Runnable() { ... }, 0, 1, TimeUnit.SECONDS);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h5>Многопоточность в Java: ExecutorService &mdash; https://habrahabr.ru/post/116363/</h5></div>

</body>
</html>