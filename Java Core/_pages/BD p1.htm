<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>BD p1</title>
<link rel="stylesheet" href="../../Git Guide/grey.css">
</head>
<body>


<h3>
<ul>
<li>Что такое База Данных?</li>
</ul>
</h3>
<div>
Под
 базой данных (БД) понимается некий организованный набор информации. В 
качестве примера простейшей БД можно привести список товаров, каждый из 
которых обладает набором стандартных характеристик (наименование, 
единица измерения, количество, цена и т. д.).<br>
<br></div>
<h3>
<ul>
<li>Модель данных в реляционных СУБД?</li>
</ul>
</h3>
<div>
Прежде
 чем сохранять какие-либо данные в СУБД, необходимо описать их модель. 
По типу модели данных СУБД делятся на сетевые, объектные, иерархические и
 реляционные. СУБД реляционного типа являются наиболее распространенными
 и часто используемыми. В качестве примеров можно привести Oracle и 
Microsoft SQL Server.<br>
<br></div>
<h3>
<ul>
<li>Что такое нормализация?<a name="more"></a></li>
</ul>
</h3>
<div>
Процесс
 приведения базы данных к виду, в котором она будет соответствовать 
правилам нормальных форм, называется нормализацией базы данных.&nbsp;Нормализация
 базы данных сводит к минимуму количество избыточной информации. Ее 
целью является сохранять данные только один раз, но в нужном месте.</div>
<div>
Нормализованная
 база данных исключает дублирование и многократное обслуживание данных, а
 также появление проблем с целостностью данных, возникающих при 
повторном вводе одинаковых данных.&nbsp;Первоначально
 доктором Эдгаром Коддом были определены только 3 нормальные формы. 
Дальнейшая разработка реляционной теории привела к появлению еще 
нескольких форм и на данный момент их насчитывается 8.&nbsp;На практике соответствие базы данных правилам 3-ей нормальной формы вполне достаточно.</div>
<div>
<ul>
<li>Первая нормальная форма гласит: информация в каждом поле таблицы является неделимой и не может быть разбита на подгруппы.</li>
<li>Вторая
 нормальная форма гласит: таблица соответствует 1НФ и в таблице нет 
неключевых атрибутов, зависящих от части сложного (состоящего из 
нескольких столбцов) первичного ключа.</li>
<li>Третья
 нормальная форма гласит: таблица соответствует первым двум НФ, и все 
неключевые атрибуты зависят только от первичного ключа и не зависят друг
 от друга.</li>
</ul>
<ul>
</ul>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Какие есть типы связей в базе данных. Приведите пример.</li>
</ul>
</h3>
<div>
Связь
 работает путем сопоставления данных в ключевых столбцах; обычно это 
столбцы с одним и тем же именем в обеих таблицах. В большинстве случаев 
связь сопоставляет первичный ключ одной таблицы, являющийся уникальным 
идентификатором каждой строки этой таблицы, с записями внешнего ключа 
другой таблицы.</div>
<div>
Существует три типа связей между таблицами. Тип создаваемой связи зависит от того, как определены связанные столбцы.</div>
<div>
Один-к-одному
 - в связи "одному к одному" строке таблицы А может сопоставляться 
только одна строка таблицы Б, и наоборот. Связь "один к одному" 
создается, если для обоих связанных ключей определены ограничения 
первичного ключа или уникальности.</div>
<div>
Этот
 тип связи обычно не используется, так как большую часть связанных таким
 образом данных можно хранить в одной таблице. Связь "один к одному" 
можно использовать для:</div>
<div>
<ul>
<li>Разделения таблицы со многими столбцами.</li>
<li>Изоляции части таблицы из соображений безопасности.</li>
<li>Хранения кратковременных данных, которые можно легко удалить вместе со всей таблицей.</li>
<li>Хранения данных, которые относятся только к части основной таблицы.</li>
</ul>
</div>
<div>
Столбец,
 являющийся первичным ключом в связи "один к одному", отмечается 
символом ключа. Столбец, являющийся внешним ключом, также отмечается 
символом ключа.</div>
<div>
Один-ко-многим
 - самая распространенная. В этом типе связей у строки таблицы А может 
быть несколько совпадающих строк таблицы Б, но каждой строке таблицы Б 
может соответствовать только одна строка из А. Например, между таблицами
 publishers и titles установлена связь "один ко многим": каждый издатель
 публикует много книг, но каждая книга публикуется только у одного 
издателя.</div>
<div>
Используйте
 связь "один ко многим", если только у одного из связанных столбцов есть
 ограничение первичного ключа или уникальности.</div>
<div>
Столбец,
 являющийся первичным ключом в связи "один ко многим", отмечается 
символом ключа. Столбец, являющийся внешним ключом в связи "один ко 
многим", отмечается символом бесконечности.</div>
<div>
Многие-ко-многим
 - строке таблицы А может сопоставляться несколько строк таблицы Б, и 
наоборот. Такие связи создаются определением третьей таблицы, которая 
называется таблицей соединения, чей первичный ключ состоит из внешних 
ключей А и Б. Например, между таблицами authors и titles связь "многие 
ко многим" определена через связи "один ко многим" каждой из этих таблиц
 с таблицей titleauthors. Первичный ключ таблицы titleauthors 
представляет собой сочетание столбца au_id (первичный ключ таблицы 
authors) и столбца title_id (первичный ключ таблицы titles).<br>
<br></div>
<div>
<h3>
<ul>
<li>Что такое primary key (первичный ключ)?</li>
</ul>
</h3>
</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-s06e24-Y3ag/VpXfu288__I/AAAAAAAAAK0/8rxQfPSkqQU/s1600/primary_key.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="BD%20p1_files/primary_key.jpg" height="235" border="0" width="640"></a></div>
Первичный
 ключ (или главный ключ, primary key, PK). Представляет собой столбец 
или совокупность столбцов, значения которых однозначно идентифицируют 
строки. В данном примере первичным ключом в таблице Сотрудники является 
столбец Табельный №, ибо в одной организации не бывает сотрудников с 
одинаковыми табельными номерами. Очевидно, что в таблице Отделы 
первичным ключом является столбец, содержащий номер отдела.<br>
<br>
<h3>
<ul>
<li>Что такое foreign key (внешний ключ)?</li>
</ul>
</h3>
Вторичный
 (или внешний ключ, foreign key, FK). Столбец или совокупность столбцов,
 которые в данной таблице не являются первичными ключами, но являются 
первичными ключами в другой таблице. В рассматриваемом примере(в 
предыдущем вопросе) столбец № отдела таблицы Сотрудники содержит 
вторичный ключ, с помощью которого может быть установлена логическая 
взаимосвязь строк таблицы с соответствующими строками таблицы Отделы.<br>
<br>
<h3>
<ul>
<li>Что такое индексы в базе данных? Для чего их используют? Чем они хороши и чем плохи?</li>
</ul>
</h3>
Индексы
 - это специальные структуры в базах данных, которые позволяют ускорить 
поиск и сортировку по определенному полю или набору полей в таблице, а 
также используются для обеспечения уникальности данных. Проще всего 
индексы сравнить с указателями в книгах. Если нет указателя, то нам 
придется просмотреть всю книгу, чтобы найти нужное место, а с указателем
 то же действие можно выполнить намного быстрее.<br>
Обычно
 чем больше индексов, тем больше производительность запросов к базе 
данных. Однако при излишнем увеличении количества индексов падает 
производительность операций изменения данных 
(вставка/изменение/удаление), увеличивается размер БД, поэтому к 
добавлению индексов следует относиться осторожно.<br>
Некоторые общие принципы, связанные с созданием индексов:<br>
<ul>
<li>индексы 
необходимо создавать для столбцов, которые используются в джойнах, по 
которым часто производится поиск и операции сортировки. При этом 
необходимо учесть, что индексы всегда автоматически создаются для 
столбцов, на которые накладывается ограничение primary key. Чаще всего 
они создаются и для столбцов с foreign key (в Access - автоматически);</li>
<li>индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности;</li>
<li>лучше всего
 индексы создавать для тех полей, в которых - минимальное число 
повторяющихся значений и данные распределены равномерно. В Oracle есть 
специальные битовые индексы для столбцов с большим количеством 
повторяющихся значений, в SQL Server и Access такой разновидности 
индексов не предусмотрено;</li>
<li>если поиск 
постоянно производится по определенному набору столбцов (одновременно), 
то в этом случае, возможно, есть смысл создать композитный индекс 
(только в SQL Server) - один индекс для группы столбцов;</li>
<li>при 
внесении изменений в таблицы автоматически изменяются и индексы, 
наложенные на эту таблицу. В результате индекс может быть сильно 
фрагментирован, что сказывается на производительности. Периодически 
следует проверять степень фрагментации индексов и дефрагментировать их. 
При загрузке большого количества данных иногда есть смысл вначале 
удалить все индексы, а после завершения операции создать их заново;</li>
<li>индексы 
можно создавать не только для таблиц, но и для представлений (только в 
SQL Server). Преимущества - возможность вычислять поля не в момент 
запроса, а в момент появления новых значений в таблицах.</li>
</ul>
<br>
<h3>
<ul>
<li>Какие есть типы индекса?</li>
</ul>
</h3>
В
 базе данных, в зависимости от ее функциональных возможностей, можно 
создавать индексы четырех&nbsp;типов: уникальный, кластерный, полнотекстовый и
 индекс первичного ключа. Индексы создаются в конструкторе баз данных. 
Сведения о функциях индексации, поддерживаемых в той или иной базе 
данных.<br>
<ul>
<li>Уникальный 
индекс - уникальным является индекс, в котором не может быть двух строк с
 одним и тем же значением индекса. В большинстве баз данных не 
допускается сохранение таблицы с созданным в ней уникальным индексом, 
если в существующих данных имеются повторяющиеся значения ключа. В базе 
данных может быть также запрещено добавление новых данных, приводящее к 
появлению дубликатов значений ключа в таблице. Например, если создать 
уникальный индекс по фамилии сотрудника (lname) в таблице employee, в 
ней не должно быть двух сотрудников с одинаковыми фамилиями.</li>
<li>Индекс 
первичного ключа - в таблице базы данных обычно имеется столбец или 
комбинация столбцов, значения которых однозначно идентифицируют каждую 
строку таблицы. Такой столбец называется первичным ключом таблицы. 
Определение первичного ключа для таблицы в схеме базы данных 
автоматически приводит к созданию индекса первичного ключа, который 
является разновидностью уникального индекса. Этот индекс требует 
уникальности каждого значения первичного ключа. Он также обеспечивает 
быстрый доступ к данным при использовании индекса первичного ключа в 
запросах.&nbsp;</li>
<li>Кластерный 
индекс - в кластерном индексе физический порядок строк в таблице 
совпадает с логическим (индексированным) порядком значений ключа. У 
таблицы может быть только один кластерный индекс. Если индекс не 
кластеризован, физический порядок строк таблицы отличается от 
логического порядка значений ключа. Кластерный индекс обычно 
обеспечивает более быстрый доступ к данным, чем прочие индексы.</li>
<li>Полнотекстовый
 индекс - полнотекстовый индекс создается, если нужно выполнять 
полнотекстовый поиск по текстовым столбцам таблиц базы данных. 
Полнотекстовый индекс зависит от обычного индекса, поэтому сначала надо 
будет создать его. Обычный индекс должен быть создан для одного столбца,
 не допускающего значения NULL, и лучше всего выбирать столбцы с 
маленькими значениями, а не большими.</li>
</ul>
</div>	

</body></html>