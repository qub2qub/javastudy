<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>JMS p1</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>

<h3>
<ul>
<li><b style="font-family: arial, helvetica, sans-serif;">Что такое JNDI?</b></li>
</ul>
</h3>
<div>
JNDI
 - это API-интерфейс для доступа к службам каталогов, позволяющий 
клиентам осуществлять привязку и поиск объектов по имени. JNDI 
определяется в Java SE и не зависит от базовой реализации, то есть вы 
можете выполнять поиск объектов в каталоге Lightweight Directory Access 
Protocol (LDAP) или системе доменных имен (DNS), используя стандартный 
API-интерфейс.</div>
<div>
<br></div>
<h3>
<ul>
<li>Что такое JMS?</li>
</ul>
</h3>
<div>
JMS,
 Java Message Service - это Java API (то есть набор интерфейсов и 
классов) для работы с Message-Oriented Middleware, изначально 
разработанная компанией Sun, чтобы предоставить разработчикам создавать 
гибкие и слабосвязанные приложения с использованием асинхронного обмена 
данными между приложениями (клиентами/серверами) через посредника. 
Асинхронность - это главная причина создания и использования JMS.</div>
<div>
Данный
 набор определен в пакете javax.jms в дереве пакетов J2EE. JMS 
поддерживает две модели обмена сообщениями: point-to-point(точка - 
точка) и publish-subscribe(издатель-подписчик).</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Что такое MOM?</li>
</ul>
</h3>
</div>
<div>
MOM,
 Message-Oriented Middleware (промежуточное программное обеспечение) - 
подпрограммное обеспечение промежуточного слоя, ориентированное на обмен
 сообщениями в распределённом окружении. Прежде всего предназначено для 
реализации отложенного обмена сообщениями, на основе которого и строится
 Messaging System.</div>
<div>
В
 отличие от традиционных систем, &nbsp;в Messaging System приложения 
общаются не напрямую, а посредством MOM. Если один компонент системы 
хочет послать сообщение другому компоненту, он посылает данное сообщение
 MOM, а MOM затем пересылает его адресату.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Из каких компонентов состоит архитектура обмена сообщениями?</li>
</ul>
</h3>
</div>
<div>
На высоком уровне архитектура обмена сообщениями состоит из следующих компонентов.</div>
<div>
<ul>
<li>Поставщик.
 JMS - это только API, поэтому он нуждается в реализации способа обмена 
сообщениями, то есть в поставщике (также известном как брокер 
сообщений). Поставщик обрабатывает буферизацию и доставку сообщений.</li>
<li>Клиенты.
 Клиентом является любое приложение Java или компонент, который 
производит или потребляет сообщение с помощью поставщика. "Клиент" - это
 общий термин для производителя, отправителя, издателя, потребителя, 
приемника и подписчика.</li>
<li>Сообщения. Это объект, которые клиенты отправляют или получают от поставщика.</li>
<li>Администрируемые
 объекты. Брокер сообщений должен предоставить клиенту администрируемые 
объекты (фабрики подключений и места назначения) с помощью поиска JNDI 
или внедрения (как вы увидите далее).</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие модели обмена сообщениями в JMS вы знаете? Опишите их.</li>
</ul>
</h3>
</div>
<div>
Существует две "основных" модели обмена сообщениями:</div>
<div>
<ul>
<li>Модель
 Точка-Точка (Point-to-Point, P2P) - в этой модели место назначения, 
используемое для хранения сообщений, называется очередью. Объект Queue. В
 этой модели один клиент помещает сообщение в очередь, а другой получает
 сообщение. Как только получение сообщения подтверждено, поставщик 
сообщений удаляет его из очереди.</li>
<li>Модель
 Подписчик-Издатель (Publisher-Subscriber) - место назначения называется
 темой. Объект Topic. При использовании данной модели клиент публикует 
сообщение в теме и все абоненты этой темы получают сообщение.</li>
</ul>
</div>
<div>
<h3>
<br></h3>
<h3>
<ul>
<li>Назовите основные интерфейсы JMX, для чего они предназначены.</li>
</ul>
</h3>
</div>
<div>
Рассмотрим главные интерфейсы:</div>
<div>
<ul>
<li>ConnectionFactory
 - это обьект, ответственный за создание JMS Connection. Администратор 
МОМ создает данный обьект и связывает его с деревом JNDI, так что клиент
 JMS может получить доступ к ConnectionFactory используя стандартный 
JNDI lookup-механизм. В параметре инициализации нужно передавать данные 
вашего JMS сервера. В случае point-to-point модели используется 
javax.jms.QueueConnectionFactory, в случае pub-sub модели - 
javax.jms.TopicConnectionFactor</li>
<li>Connection
 - абстрактное представление реального соединения между клиентом JMS и 
MOM. Создает объект Session. В случае point-to-point модели используется
 javax.jms.QueueConnection, в случае pub-sub модели - 
javax.jms.TopicConnection.</li>
<li>Session
 - обьект, создаваемый JMS Connection и используемый клиентами для 
посылки и принятия сообщений. В случае point-to-point используется 
javax.jms.QueueSession, в случае pub-sub - javax.jms.TopicSession. 
Фактически, это главная "рабочая лошадка" JMS.</li>
<li>Destination
 - это либо queue, либо topic - в зависимости от используемой модели: 
javax.jms.Queue или javax.jms.Topic. Как и ConnectionFactory, 
destination связывается с деревом JNDI.</li>
<li>MessageProducer
 - обьект, который, собственно, и посылает сообщения. В случае 
point-to-point модели это javax.jms.QueueSender, в случае pub-sub - 
javax.jms.TopicPublisher.</li>
<li>MessageConsumer
 - обьект, принимающий сообщения. В случае point-to-point модели это 
javax.jms.QueueReceiver, в случае pub-sub - javax.jms.TopicSubscriber.</li>
<li>Message - сообщение. О типах сообщений будет сказано ниже.</li>
</ul>
</div>
<div>
<h3>
<br><ul>
<li>Как выглядит алгоритм создания программ, работающих с JMS?</li>
</ul>
</h3>
</div>
<div>
Весь алгоритм, можно просчитать по таблице интерфейсов. Выглядит он так:</div>
<div>
<ul>
<li>Подключаемся к серверу, используя ConnectionFactory.</li>
<li>Получаем соединение Connection из ConnectionFactory.</li>
<li>Создаем однопоточный контекст Session из соединения.</li>
<li>Получаем буфер Destination привязанный к определенному адресу для создания интерфейсов отправки и получения сообщений.</li>
<li>Создание объектов MessageProducer для отправки или MessageConsumer для получения сообщений.</li>
<li>Отдельно идет этап создания сообщения для отправки.</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие стандартные типы сообщений определены JMX?</li>
</ul>
</h3>
</div>
<div>
В JMX определены следующие стандартные типы сообщений:</div>
<div>
<ul>
<li>StreamMessage - это поток примитивных типов Java. Считывать можно со стандартных интерфейсов ввода/вывода.</li>
<li>MapMessage - содержит информацию на подобии коллекций в виде ключ-значение (String, Object).</li>
<li>TextMessage - обычное текстовое сообщение содержащее строку</li>
<li>ObjectMessage - для передачи Serializable-объектов.</li>
<li>ByteMessage - список не интерпретированных байт. С его помощью можно передавать файлы.</li>
</ul>
</div>
<div>
Кроме того, некоторые имплементации (например, OpenFusion и WebLogic) предоставляют еще один "почти стандартный" тип:</div>
<div>
<ul>
<li>XMLMessage - расширение TextMessage, используется для доставки XMLсообщений</li>
</ul>
</div>
<div>
Все типы сообщений являются подклассами javax.jms.Message.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Из каких частей JMS сообщение?</li>
</ul>
</h3>
</div>
<div>
Любое JMS сообщение имеет в себе 3 составные части:</div>
<div>
<ul>
<li>Заголовок
 (header). Набор свойств, поставляемый по умолчанию для любого 
сообщения, содержит стандартную информацию для идентификации и 
маршрутизации сообщений.</li>
<li>Свойства
 (properties). Пары «имя/значение», которые приложение может установить 
или считать; свойства также позволяют месту назначения фильтровать 
сообщения на основе их значений.</li>
<li>Тело (body). фактически содержит сообщение и может иметь один из нескольких форматов (текст, байты, объект и т. д.).</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие параметры может содержать заголовок сообщения?</li>
</ul>
</h3>
</div>
<div>
Заголовок
 сообщения содержит дополнительную информацию, которую разработчик может
 использовать в своем приложении. JMS предоставляет get и set методы для
 каждого поля заголовка. Некоторые из них устанавливаются автоматически,
 другие могут быть использованы разработчиком приложения.</div>
<div>
<ul>
<li>JMSDestination(тип String) - содержит имя destination, в который посылается сообщение.</li>
<li>JMSDeliveryMode
 (тип int) - определяет, является ли сообщение сохраняемым или нет. 
Может иметь только два значения: DeliveryMode.PERSISTENT и 
DeliveryMode.NON_PERSISTENT. Персистентное сообщение доставляется "один 
раз и только один раз"; не персистентное сообщение доставляется "не 
более одного раза". "Не более одного раза" подразумевает возможность 
отсутствия доставки.</li>
<li>JMSExpiration
 (тип long) - определяет, когда сообщение устареет и будет удалено из 
системы. 0 - означает что сообщение будет жить пока оно не будет 
доставлено.</li>
<li>JMSPriority (тип int) - как и следует из названия, определяет приоритет сообщения (от 0 до 9). По умолчанию равно 4.</li>
<li>JMSMessageID (тип String) - уникальный идентификатор сообщения</li>
<li>JMSTimestamp (тип long)- содержит информацию, когда именно MOM приняла сообщение от producer.</li>
<li>JMSCorrelationID
 (тип String) - может быть использовано разработчиком для согласования 
сообщений: например, если вы хотите переслать ряд сообщений, 
обьединенных в одну логическую группу (такую как набор товаров в заказе,
 при этом в каждое сообщение о товаре вы можете добавить в данное поле 
заголовка номер заказа).</li>
<li>JMSReplyTo
 (тип Destination) - может быть использовано разработчиком для того, 
чтобы consumer знал, кому (то есть в какой destination) при желании 
отсылать ответ.</li>
<li>JMSType
 (тип String) - поле может быть использовано разработчиком для того, 
чтобы дать приложению информацию, как обращаться с данным сообщением. 
Тип здесь понимается как application-specific type, а не тот, что 
использован выше в разделе "типы сообщений".</li>
<li>JMSRedelivered (тип Boolean) - означает, что сообщение было доставлено получателю, но он не подтвердил прием сообщения.</li>
</ul>
</div>
<div>
<h3>
<br><ul>
<li>Какие модели подтверждения получения сообщения вы знаете?</li>
</ul>
</h3>
</div>
<div>
JMS поддерживает три "основных" модели подтверждения получения сообщения.</div>
<div>
<ul>
<li>AUTO_ACKNOWLEDGE
 - в случае синхронного получения сообщений, подтверждение получения 
будет произведено автоматически, когда метод receive() возвратит 
значение не вызвав никакой исключительной ситуации. В случае 
асинхронного получения сообщений, подтверждение получения будет 
произведено, когда метод onMessage() вернет значение.</li>
<li>DUPS_OK_ACKNOWLEDGE
 - работа по подтверждению получения сообщения перекладывается на 
Session. Сообщения будут вновь доставлены в случае возникновения ошибки 
или "гибели" системы.</li>
<li>CLIENT_ACKNOWLEDGE
 - клиент должен вызвать метод acknowledge() интерфейса 
javax.jms.Message для того, чтобы явно подтвердить получение сообщения. 
При вызове данного метода будет подтверждено получение текущего и всех 
предадущих полученных сообщений.</li>
</ul>
</div>
<link href="https://plus.google.com/105527202953364202368" rel="author">

<p></p>
	

</body></html>