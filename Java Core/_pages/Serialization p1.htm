<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Serialization p1</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Что такое сериализация?</li>
</ul>
</h3>
<div>
Сериализация
 - это процес чтения или записи объекта. Это процесс сохранения 
состояния объекта и считывание этого состояния. Для реализации 
сериализации нужен интерфейс - маркер Serializable. Обратная операция - 
перевод байтов в объект, называется десериализацией.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как исключить поля из сериализации?</li>
</ul>
</h3>
<div>
Для того чтоб исключить поля из сериализуемого потока, необходимо пометить поле модификатором transient.</div>
<div>
<br></div>
<h3>
<ul>
<li>transient что значит?</li>
</ul>
</h3>
<div>
Свойства класса, помеченные модификатором transient, не сериализуются.&nbsp;Обычно
 в таких полях хранится промежуточное состояние объекта, которое, к 
примеру, проще вычислить, чем сериализовать, а затем десериализавать. 
Другой пример такого поля - <br>
<a name="more"></a>ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.</div>
<div>
<br></div>
<h3>
<ul>
<li><b style="font-family: Arial, Helvetica, sans-serif;">Как изменить стандартное поведение сериализации/десериализации?</b></li>
</ul>
</h3>
<div>
В
 большинстве случаев мы не определяем поведение вручную, а полагаемся на
 стандартную реализацию, и очень не удобно постоянно переопределять 
какие-то методы сериализации + постоянно следить за добавлением новых 
полей, добавлять их в методы. Ну и специально для этих целей есть 
Externalizable.</div>
<div>
Тем
 не менее, мы знаем, что можно изменить стандартное поведение 
сериализации предопределив и поместив в свои файлы классов два метода:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-hiuLy14Et2s/VzVfqXtpOgI/AAAAAAAAAp0/upsRxpWdcSQ68QfVKgXO_rZem8RV2BcTACLcB/s1600/q004_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Serialization%20p1_files/q004_p01.jpg" height="32" border="0" width="640"></a></div>
<div>
Обратите
 внимание, что оба метода объявлены как private, поскольку это 
гарантирует что методы не будут переопределены или перезагружены. Весь 
фокус в том, что виртуальная машина при вызове соответствующего метода 
автоматически проверяет, не были ли они объявлены в классе объекта. 
Виртуальная машина в любое время может вызвать private методы вашего 
класса, но другие объекты этого сделать не смогут. Таким образом 
обеспечивается целостность класса и нормальная работа протокол 
сериализации.</div>
<div>
<br></div>
<h3>
<ul>
<li><b style="font-family: Arial, Helvetica, sans-serif;">Вы создали 
класс, чей суперкласс сериализуемый, но при этом вы не хотите чтобы ваш 
класс был сериализуемым, как остановить сериализацию?</b></li>
</ul>
</h3>
<div>
</div>
<div>
Вы
 не можете "разреализовать" интерфейс, поэтому если суперкласс реализует
 Serializable, то и созданный вами новый класс также будет реализовать 
его. Чтобы остановить автоматическую сериализацию вы можете применить 
private методы для создания исключительной ситуации 
NotSerializableException. Вот как это можно сделать:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-d2m04NwlIXw/VzVgATJBoII/AAAAAAAAAp4/VRv-fj4pAl0ZXs9MmnaSSMQvxpLtu7BCACLcB/s1600/q005_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Serialization%20p1_files/q005_p01.jpg" height="108" border="0" width="640"></a></div>
<div>
Любая
 попытка записать или прочитать этот объект теперь приведет к 
возникновению исключительной ситуации. Запомните, если методы объявлены 
как private, никто не сможет модифицировать ваш код не изменяя исходный 
код класса. Java не позволяет переопределять такие методы.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как создать собственный протокол сериализации?</li>
</ul>
</h3>
<div>
</div>
<div>
Вместо реализации интерфейса Serializable, вы можете реализовать интерфейс Externalizable, который содержит два метода:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-ln-xWv05K4s/VzVgT8aPYKI/AAAAAAAAAqA/zQPdOwnnWck1ZQjdrXtv8rKUwcw3-AjewCLcB/s1600/q006_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Serialization%20p1_files/q006_p01.jpg" height="36" border="0" width="640"></a></div>
<div>
Для
 создания собственного протокола нужно просто переопределить эти два 
метода. В отличие от двух других вариантов сериализации, здесь ничего не
 делается автоматически. Протокол полностью в ваших руках. Хотя это и 
наиболее сложный способ, при этом он наиболее контролируемый.</div>
<div>
<br></div>
<h3>
<ul>
<li>Какая роль поля serialVersionUID в сериализации?</li>
</ul>
</h3>
<div>
Поле
 private static final long serialVersionUID содержит уникальный 
идентификатор версии сериализованного класса. Оно вычисляется по 
содержимому класса - полям, их порядку объявления, методам, их порядку 
объявления. Соответственно, при любом изменении в классе это поле 
поменяет свое значение.</div>
<div>
Это
 поле записывается в поток при сериализации класса. Кстати, это, 
пожалуй, единственный известный случай, когда static-поле сериализуется.</div>
<div>
<br></div>
<h3>
<ul>
<li>В чем проблема сериализации Singleton-ов?</li>
</ul>
</h3>
<div>
Проблема
 в том что после десериализации мы получим другой объект. Таким образом,
 сериализация дает возможность создать Singleton еще раз, что не совсем 
не нужно. Конечно можно запретить сериализовать Singleton-ы, но это, 
фактически, уход от проблемы, а не ее решение.</div>
<div>
</div>
<div>
Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-6PjojebOvSA/VzVgcjY18pI/AAAAAAAAAqE/CQGNk_unbwY141IJRtHR3mialELDpOGxwCLcB/s1600/q008_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Serialization%20p1_files/q008_p01.jpg" height="24" border="0" width="640"></a></div>
<div>
Модификатор
 доступа может быть private, protected и по умолчанию (default). Можно, 
наверное, сделать его и public, но смысла я в этом не вижу. Назначение 
этого метода - возвращать замещающий объект вместо объекта, на котором 
он вызван.</div>	

</body></html>