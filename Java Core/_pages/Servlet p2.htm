<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Servlet p2</title>
<link rel="stylesheet" href="grey.css">
</head>
<body>
<h3>
<ul>
<li>Каков жизненный цикл сервлета и когда какие методы вызываются?</li>
</ul>
</h3>

<div>
Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:</div>
<div>
<ul>
<li>Загрузка
 класса сервлета - когда контейнер получает запрос для сервлета, то 
происходит загрузка класса сервлета в память и вызов конструктора без 
параметров.</li>
<li>Инициализация
 класса сервлета - после того как класс загружен контейнер 
инициализирует объект ServletContext для этого сервлета и внедряет его 
через init() метод. Это и есть место где сервлет класс преобразуется из 
обычного класса в сервлет.</li>
<li>Обработка
 запросов - после инициализации сервлет готов к обработке запросов. Для 
каждого запроса клиента сервлет контейнер порождает новую нить (поток) и
 вызывает метод service() путем передачи ссылки на объект ответы и 
запроса.<a name="more"></a></li>
<li>Удаление
 из Service - когда контейнер останавливается или останавливается 
приложение, то контейнер сервлетов уничтожает классы сервлетов путем 
вызова destroy() метода.</li>
</ul>
</div>
<div>
Можно описать как последовательность вызова методов: init(), service(), destroy().</div>
<div>
<ul>
<li>public
 void init(ServletConfig config) - используется контейнером для 
инициализации сервлета. Вызывается один раз за время жизни сервлета.</li>
<li>public
 void service(ServletRequest request, ServletResponse response) - 
вызывается для каждого запроса. Метод не может быть вызван раньше 
выполнения init() метода.</li>
<li>public void destroy() - вызывается для уничтожения сервлета (один раз за время жизни сервлета).</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Какие методы необходимо определить при создании сервлетов?</li>
</ul>
</h3>
</div>
<div>
Чтобы создать сервлет, необходимо описать сервлет с помощью:</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-LPGN63ZZxWw/V0HRlzfMaLI/AAAAAAAAAus/56vLNbbE88MHGg5e55mKUYbHKdHG9IFQwCLcB/s1600/q023_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Servlet%20p2_files/q023_p01.jpg" border="0"></a></div>
Затем расширить класс сервлета от класса HttpServlet.<br>
Реализовать метод service() или doGet(), doPost() (или первый или вторые).<br>
<br>
<h3>
<ul>
<li>В каком случае вы будете переопределять метод service()?</li>
</ul>
</h3>
Метод
 service() переопределяется, когда мы хотим, чтобы сервлет обрабатывал 
как GET так и POST запросы в одном методе. Когда контейнер сервлетов 
получает запрос клиента, то происходит вызов метода service(), который в
 свою очередь вызывает doGet(), doPost() методы, основанные на HTTP 
методе запроса. Есть мнение, что метод service() переопределять особого 
смысла нет, кроме указанного вначале случая использования одного метода 
на два типа запросов.<br>
<br>
<h3>
<ul>
<li>Есть ли смысл определить конструктор для сервлета? Как лучше инициализировать данные?</li>
</ul>
</h3>
Такая
 возможность есть, но считается бессмысленной. Инициализировать данные 
лучше переопределив метод init(), в котором получить доступ к параметрам
 инициализации сервлета через использование объекта ServletConfig.<br>
<br>
<h3>
<ul>
<li>В чем отличия GenericServlet и HttpServlet?</li>
</ul>
</h3>
Абстрактный
 класс GenericServlet - независимая от используемого протокола 
реализация интерфейса Servlet. HttpServlet, как понятно из название, 
реализация интерфейса сервлета для протокола HTTP. Следует отметить, что
 HttpServlet extends GenericServlet.<br>
<br>
<h3>
<ul>
<li>Как вызвать из сервлета другой сервлет этого же и другого приложения?</li>
</ul>
</h3>
Если
 необходимо вызывать сервлет из того же приложения, то необходимо 
использовать механизм внутренней коммуникации сервлетов. Мы можем 
вызвать другой сервлет с помощью RequestDispatcher forward() и include()
 методов для доступа к дополнительным атрибутам в запросе для 
использования в другом сервлете. Метод forward() используется для 
передачи обработки запроса в другой сервлет. Метод include() 
используется, если мы хотим вложить результат работы другого сервлета в 
возвращаемый ответ.<br>
Если
 необходимо вызывать сервлет из другого приложения, то использовать 
RequestDispatcher уже не получится (определен для приложения). Поэтому 
можно использовать ServletResponse sendRedirect() метод и предоставить 
полный URL из другого сервлета. Для передачи данных можно использовать 
cookies как часть ответа сервлета, а потом использовать их в нашем 
сервлете.<br>
<br>
<h3>
<ul>
<li>Стоит ли волноваться о "многопоточной безопасности" работая с сервлетами?</li>
</ul>
</h3>
Методы
 класса HTTPServlet init() и destroy() вызываются один раз за жизненный 
цикл сервлета - поэтому по поводу них беспокоиться не стоит. Методы 
doGet(), doPost() вызываются на каждый запрос клиента и т.к. сервлеты 
используют многопоточность, то здесь нужно задумываться о 
потокобезопасной работе.<br>
В
 случае наличия локальных переменных в этих методах нет необходимости 
думать о многопоточной безопасности, т.к. они будут созданы отдельно для
 каждой нити. Но если используются глобальные ресурсы, то необходимо 
использовать синхронизацию как и в любом многопоточном приложении Java.<br>
<br>
<h3>
<ul>
<li>Какой метод HTTP не является неизменяемым?</li>
</ul>
</h3>
HTTP
 метод называется неизменяемым, если он всегда возвращает одинаковый 
результат. HTTP методы GET, PUT, DELETE, HEAD, OPTIONS являются 
неизменяемыми. Необходимо реализовывать приложение так, чтобы эти методы
 возвращали одинаковый результат. К изменяемым методам относится HTTP 
метод POST. Post метод используется для реализации чего-либо, что 
изменяется при каждом запросе.<br>
К
 примеру, для доступа к HTML странице или изображению необходимо 
использовать метод GET, т.к. он возвращает одинаковый результат. Но если
 нам необходимо сохранить информацию о заказе в базе данных, то нужно 
использовать POST метод. Неизменяемые методы так же известны как 
безопасные методы и нет необходимости заботится о повторяющихся запросах
 от клиента для этих методов.<br>
<br>
<h3>
<ul>
<li>Какие есть методы отправки данных с клиента на сервер? Чем они отличаются?</li>
</ul>
</h3>
Метод
 doGet() - используется для запроса содержимого указанного ресурса, 
изображения или гипертекстового документа. Вместе с за просом могут 
передаваться дополнительные параметры как часть URI, значения могут 
выбираться из полей формы или передаваться непосредственно через URL. 
При этом запросы кэшируются и имеют ограничения на размер. Этот метод 
является основным методом взаимодействия браузера клиента и веб-сервера.<br>
Метод
 doPost() - используется для передачи пользовательских данных в 
содержимом HTTP-запроса на сервер. Пользовательские данные упакованы в 
тело запроса согласно полю заголовка Content-Type и/или включены в URI 
запроса. При использовании метода POST под URI подразумевается ресурс, 
который будет обрабатывать запрос.<br>
<br>
<h3>
<ul>
<li>Методы сервлета (обычно имеется ввиду HttpServlet).</li>
</ul>
</h3>
В спецификации HTTP определены методы: GET, HEAD, POST, PUT, DELETE, OPTIONS и TRACE.<br>
<ul>
<li>Метод
 GET (method="GET") используется для запроса содержимого указанного 
ресурса, изображения или гипертекстового документа. Вместе с запросом 
могут передаваться дополнительные параметры как часть URI, значения 
могут выбираться из полей формы или передаваться непосредственно через 
URL. При этом запросы кэшируются и имеют ограничения на размер. Этот 
метод является основным методом взаимодействия браузера клиента и 
веб-сервера.</li>
<li>Метод
 POST используется для передачи пользовательских данных в содержимом 
HTTP-запроса на сервер. Пользовательские данные упакованы в тело запроса
 согласно полю заголовка Content-Type и/или включены в URI запроса. При 
использовании метода POST под URI подразумевается ресурс, который будет 
обрабатывать запрос.</li>
<li>Метод
 PUT схож с методом POST за тем исключением, что здесь URI подразумевает
 ресурс, который будет создан или сохранен на сервере в результате 
выполнения PUT-запроса.</li>
<li>Метод DELETE предназначен для удаления целевого ресурса.</li>
</ul>
Оба эти действия на некоторых серверах могут запрещаться из-за угрозы внутренней безопасности.<br>
<ul>
<li>Метод
 HEAD предполагает возврат сервером такого же ответа, как и при 
использовании GET, но без тела ответа. Метод обычно используется для 
того, чтобы проверить существование ресурса либо узнать, изменился ли 
запрашиваемый ресурс с момента последнего обращения.</li>
<li>Метод OPTIONS должен возвращать информацию о возможностях вебсервера или параметрах соединения для конкретного ресурса.</li>
<li>Метод
 TRACE возвращает клиенту запрос в том виде, в каком он пришел на сервер
 - используется для отладки, определяя заголовки, добавляемые 
промежуточными серверами, а также для тестирования настроек соединения.</li>
</ul>
<br>
<h3>
<ul>
<li>Почему HttpServlet класс объявлен как абстрактный?</li>
</ul>
</h3>
Класс
 HTTPServlet предоставляет реализацию HTTP протокола сервлета (а 
следовательно помогает избежать постоянного кодинга повторяющейся 
информации), но он не имеет реализованных методов doGet() и doPost() (у 
них по умолчанию возвращение HTTP 405 Method Not Implemented error), а 
следовательно объявлен абстрактным. Реализация этих методов 
перекладывается на разработчика.<br>
<br>
<h3>
<ul>
<li>В чем разница между методами GET и POST?</li>
</ul>
</h3>
Основные отличия:<br>
<ul>
<li>GET метод является неизменяемым, тогда как POST - изменяемый.</li>
<li>С
 помощью метода GET можно посылать ограниченное кол-во данных, которые 
будут пересланы в заголовке URL. В случае POST метода мы можем 
пересылать большие объемы данных, т.к. они будут находится в теле 
метода.</li>
<li>Данные
 GET метода передаются в открытом виде, что может использоваться в 
зловредных целях. POST данные передаются в теле запроса и скрыты от 
пользователя.</li>
<li>GET метод является HTTP методом по умолчанию, а POST метод необходимо указывать явно, чтобы отправить запрос.</li>
<li>GET метод используется гиперссылками на странице.</li>
</ul>
<br>
<h3>
<ul>
<li>Назовите преимущества Servlet над CGI?</li>
</ul>
</h3>
Технология
 сервлетов была создана для преодоления недостатков Common Gateway 
Interface (общий интерфейс шлюза). Можно выделить следующие преимущества
 сервлетов над CGI:<br>
<ul>
<li>Сервлеты
 предоставляют лучшую производительность в условиях обработки запросов, 
лучшее использование памяти за счет использования преимущества 
многопоточности (на каждый запрос создается новая нить, что быстрее 
выделения памяти под новый объект для каждого запроса, как это 
происходит в CGI).</li>
<li>Сервлеты,
 платформа и система являются независимыми. Таким образом веб приложение
 написанное с использованием сервлетов может быть запущена в любом 
контейнере сервлетов, реализующим стандарт и в любой операционной 
системе.</li>
<li>Использование
 сервлетов повышает надежность программы, т.к. контейнер сервлетов 
самостоятельно заботится о жизненном цикле сервлетов (а значит и за 
утечками памяти), безопасности и сборщике мусора.</li>
<li>Сервлеты
 относительно легки в изучении и поддержке, т.к. разработчику необходимо
 заботится только о бизнес логике приложения, а не внутренней реализации
 веб технологий.</li>
</ul>
<br>
<h3>
<ul>
<li>Каковы наиболее распространенные задачи выполняются в Servlet контейнере?</li>
</ul>
</h3>
Некоторые из них:<br>
<ul>
<li>Поддержка
 обмена данными. Контейнер сервлетов предоставляет легкий способ обмена 
данными между веб клиентом (браузером) и сервлетом. Благодаря контейнеру
 нет необходимости создавать слушателя сокета на сервере для 
отслеживания запросов от клиента, а также разбирать запрос и 
генерировать ответ. Все эти важные и комплексные задачи решаются с 
помощью контейнера и разработчик может сосредоточиться на бизнес логике 
приложения.</li>
<li>Управления
 жизненным циклом сервлетов и ресурсов. Начиная от загрузки сервлета в 
память, инициализации, внедрения методов и заканчивая уничтожением 
сервлета. Контейнер так же предоставляет дополнительные утилиты, 
например JNDI, для управления пулом ресурсов.</li>
<li>Поддержка
 многопоточности. Контейнер самостоятельно создает новую нить для 
каждого запроса и предоставляет ей запрос и ответ для обработки. Таким 
образом сервлет не инициализируется заново для каждого запроса и тем 
самым сохраняет память и уменьшает время до обработки запроса.</li>
<li>Поддержка
 JSP. JSP классы не похожи на стандартные классы джавы, но контейнер 
сервлетов преобразует каждую JSP в сервлет и далее управляется 
контейнером как обычным сервлетом.</li>
<li>Различные
 задачи. Контейнер сервлетов управляет пулом ресурсов, памятью 
приложения, сборщиком мусора. Предоставляются возможности настройки 
безопасности и многое другое.</li>
</ul>
<br>
<h3>
<ul>
<li>В чем разница между PrintWriter и ServletOutputStream?</li>
</ul>
</h3>
<h3>
</h3>
PrintWriter
 - это класс для работы с символьным потоком, а ServletOutputStream - 
класс для работы байтовым потоком. PrintWriter используется для записи 
информации на основе символов, вроде массива символов или строки в 
ответ, в то время как ServletOutputStream используется для записи в 
ответ массива байтов. Для получения экземпляра ServletOutputStream 
используется метод ServletResponse getOutputStream(), а для PrintWriter -
 метод ServletResponse getWriter().<br>
<br>
<h3>
<ul>
<li>Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?</li>
</ul>
</h3>
Мы
 не можем создать два объекта этих классов в одном сервлете. При попытке
 внедрить оба метода getWriter() и getOutputStream() в ответе, мы 
получим исключение java.lang.IllegalStateException с сообщением, что уже
 другой метод был вызван для этого ответа.<br>
<br>
<h3>
<ul>
<li>Расскажите об интерфейсе SingleThreadModel.</li>
</ul>
</h3>
Интерфейс
 был создан, чтобы гарантировать потокобезопасность и невозможность 
создания двух нитей в сервис методе сервлета. Однако интерфейс 
SingleThreadModel не решает всех проблем потокобезопасности. Например, 
атрибуты сессии или статические переменные могут быть доступны различным
 запросам в различных потоках в одно и тоже время (даже при 
использовании этого интерфейса). Интерфейс объявлен deprecated начиная с
 Servlet 2.4.<br>
<br>
<h3>
<ul>
<li>Какие существуют атрибуты у сервлетов и какая сфера их применения?</li>
</ul>
</h3>
Атрибуты
 сервлетов используются для внутренней коммуникации сервлетов. Мы можем 
использовать атрибуты set, get, remove в веб приложении.<br>
Интерфейсы
 ServletRequest, HttpSession и ServletContext предоставляют методы для 
get(), set(), remove() атрибутов из request scope, session scope, 
application scope.<br>
<br>
<h3>
<ul>
<li>Почему необходимо переопределить только init() метод без аргументов?</li>
</ul>
</h3>
Если
 нам необходимо инициализировать какие-то ресурсы до того как сервлет 
начнет обрабатывать запросы, то необходимо переопределить метод init(). 
Если переопределить метод init(ServletConfig config), то первым должен 
быть вызван метод super(config), который обеспечит вызов метода 
init(ServletConfig config) суперкласса. Именно поэтому GenericServlet 
предоставляет другой метод init() без параметров, который будет 
вызываться в конце метода init(ServletConfig config). Разработчик должен
 использовать переопределенный метод init() без параметров для 
инициализации переменных для избежания каких-либо проблем, например не 
указав вызов super() в переопределенном методе init(ServletConfig 
config).<br>
<br>
<h3>
<ul>
<li>Что означает URL encoding? Зачем нужны методы encode() и decode()?</li>
</ul>
</h3>
URL
 Encoding - процесс преобразования данных в форму CGI (Common Gateway 
Interface), который позволит путешествовать по сети без проблем. URL 
Encoding разделяет пробелы и заменяет специальные символы с помощью 
escape-символов. Например, для кодирования строки используется метод 
&nbsp;java.net.URLEncoder.encode(String str, String unicode). Обратная 
операция декодирования возможна благодаря методу 
java.net.URLDecoder.decode(String str, String unicode). Пример работы 
метода: строка “ Java programing language” будет преобразована в 
“Java%20programing%20language ”.<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/05/jsp-servlets-jstl-3.html">JSP, Servlets, JSTL (часть 3).</a></h3>
</div>	

</body></html>