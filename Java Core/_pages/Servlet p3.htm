<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Servlet p3</title>
<link rel="stylesheet" href="../../Git Guide/grey.css">
</head>
<body>
<h3>
<ul>
<li>Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?</li>
</ul>
</h3>

<div>
HttpServletResponse
 предоставляет методы преобразования URL в HTML гиперссылки с 
преобразованием спец символов и пробелов, а так же добавления session id
 к URL. Такое поведение аналогично URLEncoder encode(), но с добавлением
 дополнительного параметра jsessionid в конец URL.</div>
<div>
Метод
 HttpServletResponse encodeRedirectUrl() применяется для преобразования 
redirect URL в ответе. Таким образом при предоставлении поддержки URL 
rewriting для HTML гиперссылок необходимо использовать encodeURL(), а 
для редирект URL’ов использовать encodeRedirectUrl().</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие различные методы управления сессией в сервлетах вы знаете?</li>
</ul>
</h3>
</div>
<div>
Сессия
 является обычным состоянием взаимодействия сервера и клиента и может 
содержать в себе множество запросов и ответов клиент-сервер. Т.к. HTTP и
 веб сервер не запоминают состояния (stateless), то единственным<br>
<a name="more"></a>
 способом поддерживать сессию является пересылка уникальной информации 
(session id) в каждом запросе и ответе между клиентом и сервером.</div>
<div>
Существуют несколько распространенных способов управления сессией в сервлетах:</div>
<div>
<ul>
<li>Аутентификация пользователя</li>
<li>HTML hidden field (скрытое поле)</li>
<li>Cookies</li>
<li>URL Rewriting</li>
<li>Session Management API</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Что означает URL Rewriting?</li>
</ul>
</h3>
</div>
<div>
Для
 управления сессией в сервлетах мы можем использовать HTTPSession, но он
 работает с Cookies, а их иногда отключают. Для этого случая в сервлетах
 предусмотрена возможность URL Rewriting. С точки зрения 
программирования необходимо всего одно действие - кодирование URL. 
Другим достоинством является то, что этот метод является как бы запасным
 и включается только при выключенных куках.</div>
<div>
Применяя
 метод HttpServletResponse encodeURL() мы можем закодировать URL. Если 
необходим редирект к другому ресурсу, то для предоставления информации о
 сессии применяется метод encodeRedirectURL().<br>
<br></div>
<div>
<h3>
<ul>
<li>Что такое Cookie?</li>
</ul>
</h3>
</div>
<div>
Cookie
 - это небольшие блоки текстовой информации, которые сервер посылает 
клиенту для сохранения в файлах cookies. Клиент может запретить браузеру
 прием файлов cookies. Браузер возвращает информацию обратно на сервер 
как часть заголовка HTTP, когда клиент повторно заходит на тот же 
веб-ресурс.<br>
<br></div>
<div>
<h3>
<ul>
<li>Как применяются Cookies в сервлетах?</li>
</ul>
</h3>
</div>
<div>
Cookies
 (куки) используются в клиент-серверном взаимодействии и они не являются
 чем-то конкретным в Java. Servlet API предоставляет поддержку cookies 
через класс javax.servlet.http.Cookie implements Serializable, 
Cloneable. Для получения массива cookies из запроса необходимо 
воспользоваться методом HttpServletRequest getCookies(). Для добавления 
cookies в запрос методов не предусмотрено.</div>
<div>
Аналогично
 HttpServletResponse addCookie(Cookie c) - может добавить cookie в 
response header, но не существует геттера для этого типа передачи 
данных.<br>
<br></div>
<div>
<h3>
<ul>
<li>Как уведомить объект в сессии, что сессия недействительна или закончилась?</li>
</ul>
</h3>
</div>
<div>
Чтобы
 быть уверенным об оповещение объекта о прекращении сессии, объект 
должен реализовывать интерфейс 
javax.servlet.http.HttpSessionBindingListener. Два метода этого 
интерфейса: valueBound() и valueUnbound() применяются для реализации 
логики при добавлении объекта в качестве атрибута к сессии и при 
уничтожения сессии.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?</li>
</ul>
</h3>
</div>
<div>
Сервлет
 фильтры используются для перехвата всех запросов между контейнером 
сервлетов и сервлетом. Поэтому логично использовать фильтр для проверки 
необходимой информации (например валидности сессии) в запросе.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Как мы можем обеспечить transport layer security для нашего веб приложения?</li>
</ul>
</h3>
</div>
<div>
Для
 этого необходимо настроить SSL для вашего сервлет контейнера. Как это 
сделать описано в мануалах для конкретной реализации контейнера.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?</li>
</ul>
</h3>
</div>
<div>
При
 работе с большим количеством подключений к базе данных рекомендуется 
инициализировать их в servlet context listener и установить в качестве 
атрибута контекста для возможности использования другими сервлетами. 
Логирование Log4j подключается с помощью конфигурации XML (или файла 
property) и далее эта информация используется при конфигурировании 
context listener’а.<br>
<br></div>
<div>
<h3>
<ul>
<li>Какие особенности Servlet 3?</li>
</ul>
</h3>
</div>
<div>
Особенности Servlet 3.0:<br>
<ul>
<li>Servlet
 Annotations. До Servlet 3 весь маппинг был в web.xml, что приводило к 
ошибкам и банально неудобно при большом количестве сервлетов. Примеры 
аннотаций: &nbsp;@WebServlet, @WebInitParam, @WebFilter, @WebListener.</li>
<li>Web
 Fragments. С появлением веб фрагментов мы можем содержать множество 
модулей в одностраничном веб приложении. Все модули прописываются в 
fragment.xml в META-INF директории. Это позволяет разделять веб 
приложение на отдельные модули, включенные как JAR файлы в отдельной lib
 директории.</li>
<li>Динамическое
 добавление веб компонентов. Используя ServletContext объект, мы можем 
программно добавлять фильтры и слушатели. Это помогает построить 
динамическую систему, в которой необходимый объект будет вызван только 
по необходимости. Для этого применяются методы addServlet(), 
addFilter(), addListener().</li>
<li>Асинхронное
 выполнение. Поддержка асинхронной обработки позволяет передать 
выполнение запроса в другой поток без удержания всего сервера занятым.</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Каковы различные способы аутентификации сервлета?</li>
</ul>
</h3>
</div>
<div>
Контейнер сервлетов предоставляет различные способы аутентификации:</div>
<div>
<ul>
<li>HTTP Basic Authentication</li>
<li>HTTP Digest Authentication</li>
<li>HTTPS Authentication</li>
<li>Form Based Login</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Что такое Java Server Pages (JSP)?</li>
</ul>
</h3>
</div>
<div>
JSP
 (Java Server Pages) - технология, позволяющая веб-разработчикам 
динамически генерировать HTML, XML и другие веб-страницы. JSP был 
включен в состав Java EE - программной платформы для программирования 
веб-приложений. Технология позволяет вставлять Java-код, в статический 
содержимое страницы. Также могут использоваться библиотеки JSP тегов для
 вставки их в JSP-страницы. Страницы компилируются JSP-компилятором в 
сервлеты, которые являются Java-классами, и выполняются на сервере. 
Сервлеты также могут быть написаны разработчиком, не используя 
JSP-страницы. Эти технологии дополняют друг друга.<br>
<br></div>
<div>
<h3>
<ul>
<li>Опишите, как обрабатываются JSP страницы, начиная от запроса к серверу, заканчивая ответом пользователю.</li>
</ul>
</h3>
</div>
<div>
Когда
 пользователь переходит по ссылке, назовем ее index.jsp, он отправляет 
http запрос на сервер в виде "GET /index.jsp". Затем на основе этой 
страницы, сервер генерирует, компилирует и выполняет Java сервлет, 
который приходит ответом пользователю в виде отображения этой страницы. 
Такой жизненный цикл можно разделить на 6 шагов:</div>
<div>
<ol>
<li>Запрос от пользователя.</li>
<li>Чтение .jsp страницы сервером.</li>
<li>Генерация java класса на основе этой .jsp страницы.</li>
<li>Компиляция в class файл.</li>
<li>Выполнение class файла.</li>
<li>Отправка ответа пользователю в виде html страницы.</li>
</ol>
<br></div>
<div>
<h3>
<ul>
<li>Расскажите об этапах (фазах) жизненного цикла jsp.</li>
</ul>
</h3>
</div>
<div>
Если
 посмотреть код внутри созданной JSP страницы, то он будет выглядеть как
 HTML и не будет похож на java класс. Конвертацией JSP страниц в HTML 
код занимается контейнер, который так же создает сервлет для 
использования в веб приложении. Жизненный цикл JSP состоит из нескольких
 фаз:</div>
<div>
<ul>
<li>Translation
 - JSP контейнер проверяет код JSP страницы, парсит ее для создания кода
 сервлета. К примеру, в Tomcat вы можете найти классы сервлетов в 
директории TOMCAT/work/Catalina/localhost/WEBAPP/org/apache/jsp. Если 
страница JSP называется home.jsp, то созданный сервлет обычно будет 
иметь имя home_jsp и имя файла - home_jsp.java.</li>
<li>Compilation - JSP контейнер компилирует исходный код jsp класса и создает класс на этой фазе.</li>
<li>Class Loading - контейнер загружает классы в память на этой фазе.</li>
<li>Instantiation - внедрение конструкторов без параметров созданных классов для инициализации в памяти классов.</li>
<li>Initialization
 - в контейнере вызывается init метод объекта JSP класса и 
инициализируется конфигурация сервлета с init параметрами, которые 
указаны в дескрипторе развертывания (web.xml). После этой фазы JSP 
способен обрабатывать запросы клиентов.Обычно эти фазы происходят после 
первого запроса клиента (т.е. ленивая загрузка), но можно настроить 
загрузку и инициализацию JSP на старте приложения по аналогии с 
сервлетами.</li>
<li>Request
 Processing - длительный жизненный цикл &nbsp;обработки запросов клиента
 JSP страницей. Обработка является многопоточной и аналогична сервлетам -
 для каждого запроса создается новая нить, создаются объекты 
ServletRequest и ServletResponse и происходит внедрение сервис методов 
JSP.</li>
<li>Destroy
 - последняя фаза жизненного цикла JSP на которой JSP класс удаляется из
 памяти. Обычно это происходит при выключении сервера или андеплое 
приложения.</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Расскажите о методах жизненного цикла jsp.</li>
</ul>
</h3>
</div>
<div>
Методы жизненного цикла JSP:</div>
<div>
<ul>
<li>jspInit()
 - метод объявлен в JSP странице &nbsp;и реализуется с помощью 
реализаций контейнера. Этот метод вызывается один раз в жизненном цикле 
JSP для того, чтобы инициализировать конфигурационные параметры, 
указанные в дескрипторе развертывания. Этот метод можно переопределить с
 помощью определения элемента JSP scripting и указания необходимых 
параметров для инициализации.</li>
<li>_jspService()
 - этот JSP метод внедряется JSP контейнером для каждого запроса клиента
 с помощью передачи объекта запроса и ответа. Отметьте, что имя метода 
начинается с нижнего подчеркивания и отличается от других методов 
жизненного цикла тем, что его невозможно переопределить. Весь JSP код 
проходит через этот метод и он переопределен по умолчанию. Этот метод 
определен в HttpJspPage интерфейсе.</li>
<li>jspDestroy()
 - метод вызывается контейнером JSP для удаления объекта из памяти (на 
последней фазе жизненного цикла JSP - Destroy). Метод вызывается только 
один раз и мы можем его переопределить для очищения любых ресурсов, 
которые были созданы в JSP init методе.</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие методы жизненного цикла JSP могут быть переопределены?</li>
</ul>
</h3>
</div>
<div>
Мы
 можем переопределить jspInit() и jspDestroy() методы с помощью 
использования скриптов JSP. Метод jspInit() переопределяется для 
создания общих ресурсов, которые мы хотели бы использовать в методе 
обслуживания JSP, а jspDestroy() метод переопределяется, чтобы 
освободить общие ресурсы на фазе уничтожения.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Как можно предотвратить прямой доступ к JSP странице из браузера?</li>
</ul>
</h3>
</div>
<div>
Директория
 WEB-INF не имеет прямого доступа из веб приложения. Поэтому мы можем 
положить JSP страницы внутри этой папки и тем самым запретить доступ к 
странице из браузера. Однако в этом случае необходимо настраивать 
дескриптор развертывания наподобие сервлетов. Простая конфигурация 
дескриптора web.xml показана ниже.</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-IKuNgyeYWnU/V0HSQ1MbHWI/AAAAAAAAAuw/e2Ppzys5J-cINGcgOtS7TscWj9XQhoNMgCLcB/s1600/q058_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="Servlet%20p3_files/q058_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<div>
<h3>
<ul>
<li>Какая разница между динамическим и статическим содержимым JSP?</li>
</ul>
</h3>
</div>
<div>
Динамические
 ресурсы. Результаты их деятельности изменяются во время выполнения 
приложения. Обычно представлены в виде выражений Expression Language, 
библиотек тегов и тегов разработчика.</div>
<div>
Статические ресурсы. Не изменяются сами в процессе работы (HTML, JavaScript, изображения и т. д.).</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Как закомментировать код в jsp?</li>
</ul>
</h3>
</div>
<div>
JSP предоставляет две возможности закомментировать код:</div>
<div>
<ul>
<li>HTML комментарии - &lt;-- HTML Comment --&gt; . Такие комментарии будут видны клиенту при просмотре кода страницы.</li>
<li>JSP
 комментарии - &lt;%-- JSP Comment --%&gt;. Такие комментарии создаются в
 созданном сервлете и не посылаются клиенту. Для любых комментариев по 
коду или отладочной информации необходимо использовать этот тип 
комментариев.</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие основные теги в JSP?</li>
</ul>
</h3>
</div>
<div>
В спецификации JSP 1.2 были объявлены только пять основных тегов:</div>
<div>
<ul>
<li>&lt;%@ директива %&gt; - используется для установки параметров серверной страницы JSP;</li>
<li>&lt;%!
 объявление %&gt; - (нежелателен в современном программировании) 
содержит поля и методы, которые вызываются в expression-блоке и 
становятся полями и методами генерируемого сервлета.</li>
<li>&lt;%
 скриптлет %&gt; - (нежелателен) вживление java-кода в JSP-страницу. 
Скриптлеты обычно используют маленькие блоки кода и выполняются во время
 обработки запроса клиента.</li>
<li>&lt;%=
 вычисляемое выражение %&gt; - (нежелателен) содержит операторы языка 
Java, которые вычисляются, после чего результат вычисления преобразуется
 в строку String и посылается в поток out;</li>
<li>&lt;%-- JSP-комментарий --%&gt; - комментарий, который не отображается в исходных кодах JSP-страницы после этапа выполнения.</li>
</ul>
</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие типы EL операторов вы знаете?</li>
</ul>
</h3>
</div>
<div>
Стандартные операторы отношения:</div>
<div>
<ul>
<li>== (или eq), != (или ne), &lt; (или lt), &gt; (или gt), &lt;= (или le), &gt;= (или ge).</li>
<li>Арифметические операторы: +, -, *, / (или div), % (или mod).</li>
<li>Логические операторы: &amp;&amp; (или and), || (или or), ! (или not).</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Взаимодействие JSP - сервлет - JSP.</li>
</ul>
</h3>
</div>
<div>
Такая
 архитектура построения приложений носит название MVC 
(Model/View/Controller). Model - классы бизнес-логики и длительного 
хранения, View - страницы JSP, Controller - сервлет.<br>
<br></div>
<div>
<h3>
<ul>
<li>Что такое сессия?</li>
</ul>
</h3>
Сессия
 &nbsp;- это сеанс между клиентом и сервером, устанавливаемая на 
определенное время, за которое клиент может отправить на сервер сколько 
угодно запросов. Сеанс устанавливается непосредственно между клиентом и 
веб-сервером в момент получения первого запроса к веб-приложению. Каждый
 клиент устанавливает с сервером свой собственный сеанс, который 
сохраняется до окончания работы с приложением.<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/05/jsp-servlets-jstl-4.html">JSP, Servlets, JSTL (часть 4).</a></h3>
</div>	

</body></html>