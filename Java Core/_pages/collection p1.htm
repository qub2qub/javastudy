<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Collection p1</title>
<link rel="stylesheet" href="grey.css">
</head>
<body>
<h3>
<ul>
<li><b style="font-family: Arial, Helvetica, sans-serif;">Что такое Коллекция?</b></li>
</ul>
</h3>
<div>
Коллекции
 - это хранилища или контейнеры, поддерживающие различные способы 
накопления и упорядочения объектов с целью обеспечения возможностей 
эффективного доступа к ним. Они представляют собой реализацию 
абстрактных структур данных, поддерживающих три основные операции:</div>
<div>
добавление нового элемента в коллекцию;</div>
<div>
<ul>
<li>удаление элемента из коллекции;</li>
<li>изменение элемента в коллекции.</li>
</ul>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Назовите основные интерфейсы коллекций и их имплементации.</li>
</ul>
</h3>
<div>
Сollection расширяет три интерфейса: List, Set, Queue.<br>
<a name="more"></a></div>
<div>
List - хранит упорядоченные елементы(могут быть одинаковые); Имеет такие реализации как&nbsp;LinkedList, ArrayList и Vector.</div>
<div>
<ul>
<li>Vector синхронизирован, и по этому в одном потоке, он работает медленней&nbsp;остальных реализаций.</li>
<li>ArrayList - его преимущество в навигации по коллекции.</li>
<li>LinkedList - Его преимущество в во вставке и удалении элементов в коллекции.</li>
</ul>
</div>
<div>
<br>
Set - коллекции, которые не содержат повторяющихся элементов.</div>
<div>
Основные реализации: HashSet, TreeSet, LinkedHashSet</div>
<div>
<ul>
<li>TreeSet - упорядочивает элементы по их значениям;</li>
<li>HashSet
 - упорядочивает элементы по их хэш ключах, хотя на первый взляд может 
показаться что элементы хранятся в случайном порядке.</li>
<li>LinkedHashSet - хранит элементы в порядке их добавления</li>
</ul>
</div>
<div>
<br>
Queue - интерфейс для реализации очереди в джава.</div>
<div>
Основные реализации: LinkedList, PriorityQueue.</div>
<div>
Очереди работают по принципу FIFO – first in first out.</div>
<div>
<br>
Map - интерфейс для реализации так называемой карты, где элементы хранятся с их ключами.</div>
<div>
Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap</div>
<div>
<ul>
<li>HashTable - синхронизированна, объявлена уставревшей.</li>
<li>HashMap - порядок елементов рассчитывается по хэш ключу;</li>
<li>TreeMap - элементы хранятся в отсортированном порядке</li>
<li>LinkedHashMap - элементы хранятся в порядке вставки</li>
</ul>
</div>
<div>
Ключи в Мар не могут быть одинаковыми!</div>
<div>
Синхронизировать
 не синхронизированные коллекции и карты можно посредством класса 
Collections.synchronizedMap(MyMap)\ synchronizedList(MyList).</div>
<div>
<br></div>
<h3>
<ul>
<li>Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?</li>
</ul>
</h3>
<div>
Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, а LinkedList - в виде списка (двунаправленного).<br>
В
 ArrayList быстрее происходит сортировка, т.к. для ее выполнения данные 
списка копируются в массив (а копировать из массива ArrayList в массив 
для сортировки быстрее). При большом числе операций добавления и 
удаления LinkedList должен быть более удачным выбором, т.к. при этих 
операциях не приходится перемещать части массива.<br>
Если
 при добавлении в ArrayList превышается его объем, размер массива 
увеличивается, новая емкость рассчитывается по формуле (oldCapacity * 3)
 / 2 + 1, поэтому лучше указывать размер при создании или, если он не 
известен, использовать LinkedList (но это может быть существенно при 
слишком уж больших объемах данных).<br>
<br></div>
<h3>
<ul>
<li>Чем отличается HashMap от Hashtable?</li>
</ul>
</h3>
<div>
Класс
 HashMap по функционалу очень похож на Hashtable. Главное отличие в том,
 что методы класса Hashtable синхронизированы, а HashMap - нет. Кроме 
этого класс HashMap в отличии от Hashtable разрешает использование null в
 качестве ключей и значений.</div>
<div>
&nbsp;Наличие
 синхронизации в Hashtable уменьшает производительность кода, 
использующего данный класс. Поэтому классы JCF (Java Collections 
Framework, появившийся в Java 2), в том числе и HashMap, 
несинхронизированы. Если синхронизация все же нужна, можно использовать 
методы класса Collections: Collections.synchronizedMap(map), 
Collections.synchronizedList(list) или Collections.synchronizedSet(set).</div>
<div>
&nbsp;Данные
 методы возвращают синхронизированный декоратор переданной коллекции. 
При этом все равно в случае итерирования по коллекции требуется ручная 
синхронизация.</div>
<div>
&nbsp;Начиная
 с Java 6 JCF был расширен специальными коллекциями, поддерживающими 
многопоточный доступ, такими как CopyOnWriteArrayList и 
ConcurrentHashMap.</div>
<div>
<br></div>
<h3>
<div>
<ul>
<li>Чем отличается ArrayList от Vector?</li>
</ul>
</div>
</h3>
<div>
Методы класса Vector синхронизированы, в то время как ArrayList - нет.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как сравниваются елементы коллекций?</li>
</ul>
</h3>
<div>
Для сравнения элементов коллекций &nbsp;используется метод equals() и hashcode();Эти методы унаследованы от класса Object.</div>
<div>
<ul>
<li>Если наш пользовательский класс &nbsp;переопределяет equals(), то он должен и переопределить hashcode()</li>
<li>Если &nbsp;два объекта эквивалентны, то и &nbsp;хэш коды этих объектов тоже должны быть равны</li>
<li>Если &nbsp;поле не используется в equals(), то оно и не должно использоваться в hashcode().</li>
</ul>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Расположите
 в виде иерархии следующие интерфейсы: List, Set, Map, SortedSet, 
&nbsp;SortedMap, Collection,Iterable, Iterator, NavigableSet, 
NavigableMap.</li>
</ul>
</h3>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-Q_s7doySHYI/VpH_bPyXoXI/AAAAAAAAAHU/V719xtIumUs/s1600/collection_hierarchy.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/collection_hierarchy.jpg" height="316" border="0" width="400"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Почему Map - это не Collection, в то время как List и Set являются Collection?</li>
</ul>
</h3>
<div>
Коллекция
 (List и Set) представляет собой совокупность некоторых элементов 
(обычно экземпляров одного класса).Map -это совокупность пар 
"ключ"-"значение".</div>
<div>
Соответственно
 некоторые методы интерфейса Collection нельзя использовать в Map. 
Например, метод remove(Object o) в интерфейсе Collection предназначен 
для удаления элемента, тогда как такой же метод remove(Object key) в 
интерфейсе Map - удаляет элемент по заданному ключу.<br>
<br>
<br>
<h3>
<ul>
<li>Дайте определение понятию "iterator".</li>
</ul>
</h3>
Итератор
 - объект, позволяющий перебирать элементы коллекции. Например foreach 
реализован с использованием итератора. Одним из ключевых методов 
интерфейса Collection является метод Iterator&lt;E&gt; iterator(). Он 
возвращает итератор - то есть объект, реализующий интерфейс Iterator.<br>
Интерфейс Iterator имеет следующее определение:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-1RyU_iZNL4M/WE7xZ_fAD0I/AAAAAAAABYc/2RnSl9WBWtomiYAIE-tXaGWDzM8csnA-ACLcB/s1600/iterator.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/iterator.jpg" height="103" border="0" width="640"></a></div>
<br></div>
<div>
<h3>
<ul>
<li>Что вы знаете об интерфейсе Iterable?</li>
</ul>
</h3>
Все
 коллекции из java.util реализуют интерфейс Collection, который, в свою 
очередь, расширяет интерфейс Iterable. В интерфейсе Iterable описан 
только один метод:<br>
Iterator iterator();<br>
Он возвращает Iterator, т.е. объект, который поочерёдно возвращает все элементы коллекции.<br>
<div>
<br></div>
</div>
<h3>
<div>
<ul>
<li>Как одной строчкой преобразовать HashSet в ArrayList?</li>
</ul>
</div>
</h3>
<div>
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-TeYrTL28gYw/VpIBpevG7tI/AAAAAAAAAHc/DnUckW4fB1M/s1600/hashSet_to_arrayList.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/hashSet_to_arrayList.jpg" height="125" border="0" width="400"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Как одной строчкой преобразовать ArrayList в HashSet?</li>
</ul>
</h3>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-CsKJw9MKV9M/VpIB4KnTCZI/AAAAAAAAAHk/7F4BhFUEBCM/s1600/arrayList_to_hashSet.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/arrayList_to_hashSet.jpg" height="126" border="0" width="400"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Как перебрать все ключи Map учитывая, что Map - это не Iterable?</li>
</ul>
</h3>
<div>
Использовать метод keySet(), который возвращает множество (Set&lt;K&gt;) ключей.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как перебрать все значения Map учитывая, что Map - это не Iterable?</li>
</ul>
</h3>
<div>
Использовать метод values(), который возвращает коллекцию (Collection&lt;V&gt;) значений.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как перебрать все пары ключ-значение в Map учитывая, что Map - это не Iterable?</li>
</ul>
</h3>
<div>
Использовать метод entrySet(), который возвращает множество (Set&lt;Map.Entry&lt;K, V&gt;) пар "ключ"-"значение".</div>
<div>
<br></div>
<h3>
<ul>
<li>В чем проявляется “сортированность” SortedMap, кроме того, что toString() &nbsp;выводит все по порядку?</li>
</ul>
</h3>
<div>
Естественное
 упорядочивание (natural ordering) отражается при итерации по коллекции 
ключей или значений хэш-таблицы (возвращаемых методами keySet(), 
values() и entrySet()).</div>
<div>
<br></div>
<div>
</div>
<h3>
<ul>
<li>Как одним вызовом копировать элементы из любой Collection в массив?</li>
</ul>
</h3>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-D1Swg0zDSYw/VpIDH0shNdI/AAAAAAAAAHw/d2-5Jm7xh_Q/s1600/collection_to_array.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/collection_to_array.jpg" height="179" border="0" width="640"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(), removeAll(), retainAll()).</li>
</ul>
</h3>
<div>
</div>
<div>
Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-tO8NHPp0eC8/VpIDezzKqaI/AAAAAAAAAH4/4HeaQHAMWuM/s1600/symmetric_difference_collection.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p1_files/symmetric_difference_collection.jpg" height="261" border="0" width="640"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Сравните Enumeration и Iterator.</li>
</ul>
</h3>
<div>
Оба
 интерфейса предназначены для обхода коллекций. Интерфейс Iterator был 
введен несколько позднее в Java Collections Framework и его 
использование предпочтительнее.</div>
<div>
Основные различия Iterator по сравнению с Enumeration:</div>
<div>
<ul>
<li>наличие метода remove() для удаления элемента из коллекции при обходе;</li>
<li>исправлены имена методов для повышения читаемости кода.</li>
</ul>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Как между собой связаны Iterable и Iterator?</li>
</ul>
</h3>
<div>
Интерфейс Iterable имеет только один метод - iterator(), который возвращает итератор коллекции для её обхода.</div>
<div>
<br></div>
<h3>
<ul>
<li>Как между собой связаны Iterable, Iterator и «for-each» введенный в Java 5?</li>
</ul>
</h3>
<div>
Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в конструкции foreach.</div>
<div>
<br></div>
<h3>
<div>
<ul>
<li>Сравните Iterator и ListIterator.</li>
</ul>
</div>
</h3>
<div>
ListIterator
 расширяет интерфейс Iterator, позволяя клиенту осуществлять обход 
коллекции в обоих направлениях, изменять коллекцию и получать текущую 
позицию итератора.</div>
<div>
При
 этом важно помнить, что ListIterator не указывает на конкретный 
элемент, а его текущая позиция располагается между элементами, которые 
возвращают методы previous() и next(). Таким образом, модификация 
коллекции осуществляется для последнего элемента, который был возвращен 
методами previous() и next().</div>
<div>
<br></div>
<h3>
<ul>
<li>Что произойдет, если я вызову Iterator.next() не «спросив» Iterator.hasNext()?</li>
</ul>
</h3>
<div>
Если
 итератор указывает на последний элемент коллекции, то возникнет 
исключение NoSuchElementException, иначе будет возвращен следующий 
элемент.</div>
<div>
<br></div>
<h3>
<ul>
<li>Что произойдет, если я вызову Iterator.next() перед этим 10 раз вызвав &nbsp;Iterator.hasNext()? Я пропущу 9 элементов?</li>
</ul>
</h3>
<div>
Нет, hasNext() осуществляет только проверку наличия следующего элемента.</div>
<div>
<br></div>
<h3>
<ul>
<li>Если у меня есть коллекция и порожденный итератор, изменится ли коллекция, если я вызову iterator.remove()?</li>
</ul>
</h3>
<div>
Вызов
 метода iterator.remove() возможен только после вызова метода 
iterator.next() хотя бы раз, иначе появится исключение 
IllegalStateException().</div>
<div>
Если iterator.next() был вызван прежде, то iterator.remove() удалит элемент, на который указывает итератор.</div>
<div>
<br></div>
<h3>
<ul>
<li>Если у меня есть коллекция и порожденный итератор, изменится ли итератор, если я вызовуcollection.remove(..)?</li>
</ul>
</h3>
<div>
Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException.</div>
<div>
<br></div>
<h3>
<ul>
<li>Зачем добавили ArrayList, если уже был Vector?</li>
</ul>
</h3>
<div>
Обе
 структуры данных предназначены для хранения коллекции элементов, в том 
числе дупликатов и null. Они основаны на использовании массивов, 
динамически расширяющихся при необходимости.</div>
<div>
Класс
 Vector был введен в JDK 1.0 и не является частью Java Collection 
Framework. Методы класса Vector синхронизированы, что обеспечивает 
потокобезопасность, но это приводит к снижению производительности, 
поэтому и был введен класс ArrayList, методы которого не 
синхронизированы.</div>
<div>
<br></div>
<h3>
<ul>
<li>В
 реализации класса ArrayList есть следующие поля: Object[] elementData, 
int size. Объясните, зачем хранить отдельно size, если всегда можновзять
 elementData.length?</li>
</ul>
</h3>
<div>
Размер
 массива elementData представляет собой вместимость (capacity) 
ArrayList, которая всегда больше переменной size - реального количества 
хранимых элементов. С добавлением новых элементов вместимость 
автоматически возрастает при необходимости.</div>
<div>
<br></div>
<h3>
<ul>
<li>LinkedList - это односвязный, двусвязный или четырехсвязный список?</li>
</ul>
</h3>
<div>
</div>
<div>
Двухсвязный список: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы.<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/01/java-collections-framework-2.html">Java Collections Framework (часть 2).</a></h3>
</div>

</body></html>