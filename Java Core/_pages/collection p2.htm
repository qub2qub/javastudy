<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Collection p2</title>
<link rel="stylesheet" href="grey.css">
</head>
<body>
<h3>
<ul>
<li>Какое худшее время работы метода contain() для элемента, который есть в LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?</li>
</ul>
</h3>

<div>
O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.<br>
<br></div>
<div>
<h3>
<ul>
<li>Какое худшее время работы метода contain() для элемента, который есть в ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?</li>
</ul>
</h3>
O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.<br>
<br>


<h3>
<ul>
<li>Какое худшее время работы метода add() для LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?<a name="more"></a></li>
</ul>
</h3>
O(N).
 Здесь стоит заметить, что добавление элемента в конец списка с помощью 
методом add(value), addLast(value) и добавление в начало списка с 
помощью addFirst(value) выполняется за время O(1).<br>
O(N)
 - будет при добавление элемента в отсортированный список, а также при 
добавлении элемента с помощью метода add(index, value).<br>
<br>
<h3>
<ul>
<li>Какое худшее время работы метода add() для ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?</li>
</ul>
</h3>
O(N).
 Вставка элемента в конец списка осуществляется за время O(1), но если 
вместимость массива недостаточна, то происходит создание нового массива с
 увеличенным размером и копирование всех элементов из старого массива в 
новый.<br>
<br>
<h3>
<ul>
<li>Сколько выделяется элементов в памяти при вызове ArrayList.add()?</li>
</ul>
</h3>
Если
 в массиве достаточно места для размещения нового элемента, то 
дополнительное место в памяти не выделяется. Иначе происходит создание 
нового массива с размером:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-UNyV-9oBSTU/VpI68-iVjEI/AAAAAAAAAII/hav8p8WE44Q/s1600/arrayList_capacity.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/arrayList_capacity.jpg" border="0"></a></div>
<div>
<div>
Другими
 словами, создается новый массив, размер которого вычисляется как 
умножение старого размера на 1.5 (это верно для JDK 1.7, в более ранних 
версиях вычисления отличаются).<br>
<br></div>
<h3>
<ul>
<li>Сколько выделяется элементов в памяти при вызове LinkedList.add()?</li>
</ul>
</h3>
<div>
Создается один новый экземпляр вложенного класса Node.<br>
<br></div>
<h3>
<ul>
<li>Оцените количество памяти на хранение одного примитива типа byte в &nbsp;LinkedList?</li>
</ul>
</h3>
<div>
Каждый
 элемент LinkedList хранит ссылку на предыдущий элемент, следующий 
элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 
бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. 
Размер каждого объекта в Java кратен 8, соответственно получаем 24 
байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы 
упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 
JVM около 32 байтоввыделяется для хранения одного значения типа byte в 
LinkedList.</div>
<div>
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны.</div>
<div>
<br>
</div>
<h3>
<ul>
<li>Оцените количество памяти на хранение одного примитива типа byte в ArrayList?</li>
</ul>
</h3>
<div>
ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.</div>
<div>
<br>
</div>
<h3>
<ul>
<li>Я
 добавляю элемент в середину List-а: list.add(list.size()/2, newElem). 
Для кого эта операция медленнее — для ArrayList или для LinkedList?</li>
</ul>
</h3>
<div>
Для ArrayList:</div>
<div>
<ul>
<li>проверка
 массива на вместимость. Если вместимости недостаточно, то увеличение 
размера массива и копирование всех элементов в новый массив ( O(N) );</li>
<li>копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо ( O(N/2));</li>
<li>вставка элемента ( O(1) ).</li>
</ul>
</div>
<div>
Для LinkedList:</div>
<div>
<ul>
<li>поиск позиции вставки ( O(N/2) );</li>
<li>вставка элемента ( O(1) ).</li>
</ul>
</div>
<div>
В
 худшем случае вставка в середину списка эффективнее для LinkedList. В 
остальных - скорее всего, для ArrayList, поскольку копирование элементов
 осуществляется за счет системного метода System.arraycopy().</div>
<div>
<br>
</div>
<h3>
<ul>
<li>Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?</li>
</ul>
</h3>
<div>
Использовать обратный итератор. Для этого в LinkedList есть метод descendingIterator().</div>
<div>
<br>
</div>
<h3>
<ul>
<li>Как одним вызовом из List получить List со всеми элементами, кроме первых и последних 3-х?</li>
</ul>
</h3>
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-mVQ17yKfz9I/VpI78CxFKhI/AAAAAAAAAIU/UaNOFZ-0mCc/s1600/list_sublist.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/list_sublist.jpg" height="36" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: center;">
<br></div>
<div>
<h3>
<ul style="font-family: Arial, Helvetica, sans-serif;">
<li>Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.hashCode() == ref1.hashCode()?</li>
</ul>
</h3>
<div style="font-family: Arial, Helvetica, sans-serif;">
Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.<br>
<br></div>
<h3 style="font-family: Arial, Helvetica, sans-serif;">
<ul>
<li>Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.equals(ref1) == true?</li>
</ul>
</h3>
<div style="font-family: Arial, Helvetica, sans-serif;">
Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals().</div>
<div style="font-family: Arial, Helvetica, sans-serif;">
Если
 используется метод Object.equals(), то для двух ссылок x и y метод 
вернет true тогда и только тогда, когда обе ссылки указывают на один и 
тот же объект (т.е. x == y возвращает true).<br>
<br></div>
<h3 style="font-family: Arial, Helvetica, sans-serif;">
<ul>
<li>Могут ли у разных ссылок на один объект в памяти (ref0 == ref1) быть &nbsp;ref0.equals(ref1) == false?</li>
</ul>
</h3>
<div style="font-family: Arial, Helvetica, sans-serif;">
Нет,
 не может. Метод equals() должен гарантировать свойство рефлексивности: 
для любых ненулевых ссылок xметод x.equals(x) должен возвращать true.<br>
<br></div>
<h3 style="font-family: Arial, Helvetica, sans-serif;">
<ul>
<li>Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?</li>
</ul>
</h3>
<div style="font-family: Arial, Helvetica, sans-serif;">
Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.<br>
<br></div>
<h3 style="font-family: Arial, Helvetica, sans-serif;">
<ul>
<li>Если
 у класса Point{int x, y;} «правильно» реализовать метод equals (return 
ref0.x == ref1.x &amp;&amp; ref0.y == ref1.y), но сделать хэш-код в виде
 int hashCode() {return x;}, то будут ли корректно такие точки 
помещаться и извлекаться из HashSet?</li>
</ul>
</h3>
<div style="font-family: Arial, Helvetica, sans-serif;">
HashSet
 использует HashMap для хранения элементов (в качестве ключа 
используется сам объект). При добавлении элемента в HashMap вычисляется 
хэшкод и позиция в массиве, куда будет вставлен новый элемент. У всех 
экземпляров класса Point одинаковый хэшкод, что приводит в вырождению 
хэш-таблицы в список. При возникновении коллизии осуществляется проверка
 на наличие уже такого элемента в текущем списке:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-tX6NemzaD-M/VpI8j7riCNI/AAAAAAAAAIc/vTlrq4bYHes/s1600/point_hashCode.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/point_hashCode.jpg" height="36" border="0" width="640"></a></div>
<div style="font-family: Arial, Helvetica, sans-serif;">
<div>
Если
 элемент найден, то его значение перезаписывается. В нашем случае для 
разных объектов метод equals() будет возвращать false. Соответственно 
новый элемент будет добавлен в HashSet. Извлечение элемента также будет 
осуществляться успешно.</div>
<div>
Но производительность такого кода будет низкой и преимущества хэш-таблиц использоваться не будут.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>equals()
 порождает отношение эквивалентности. Какими из свойств обладает такое 
отношение: коммутативность, симметричность, рефлексивность, 
дистрибутивность, ассоциативность, транзитивность?</li>
</ul>
</h3>
<div>
Метод equals() должен обеспечивать:</div>
<div>
<ul>
<li>симметричность
 (для любых ненулевых ссылок x и y метод x.equals(y) должен возвращать 
true тогда и только тогда, когда y.equals(x) возвращает true);</li>
<li>рефлексивность (для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.);</li>
<li>транзитивность
 (для любых ненулевых ссылок x, y и z, если x.equals(y) возвращает true и
 y.equals(z)возвращает true, тогда и x.equals(z) должен возвращать 
true).</li>
</ul>
</div>
<div>
Также есть ещё два свойства: постоянство и неравенство null.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Можно ли так реализовать equals(Object that) {return this.hashCode() == that.hashCode()}?</li>
</ul>
</h3>
<div>
Строго
 говоря нельзя, поскольку метод hashCode() не гарантирует уникальность 
значения для каждого объекта. Однако для сравнения экземпляров класса 
Object такой код допустим, т.к. метод &nbsp;hashCode() в классе Object 
возвращает уникальные значения для разных объектов (вычисления основаны 
на использовании адреса объекта в памяти).<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>В
 equals требуется проверять, что аргумент (equals(Object that)) такого 
же типа как и сам объект. В чем разница между this.getClass() == 
that.getClass() и that instanceof MyClass?</li>
</ul>
</h3>
<div>
Оператор
 instanceof сравнивает объект и указанный тип. Его можно использовать 
для проверки является ли данный объект экземпляром некоторого класса, 
либо экземпляром его дочернего класса, либо экземпляром класса, который 
реализует указанный интерфейс.</div>
<div>
getClass() = ... проверяет два типа на идентичность.</div>
<div>
Для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью getClass().<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Можно
 ли реализовать метод equals класса MyClass вот так: class MyClass 
{public boolean equals(MyClass that) {return this == that;}}?</li>
</ul>
</h3>
<div>
Реализовать можно, но данный метод не переопределяет метод equals() класса Object, а перегружает его.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Будет ли работать HashMap, если все ключи будут возвращать int hashCode() {return 42;}?</li>
</ul>
</h3>
<div>
Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Зачем добавили HashMap, если уже был Hashtable?</li>
</ul>
</h3>
<div>
Класс
 Hashtable был введен в JDK 1.0 и не является частью Java Collection 
Framework. Методы класса Hashtable синхронизированы, что обеспечивает 
потокобезопасность, но это приводит к снижению производительности, 
поэтому и был введен класс HashMap, методы которого не синхронизированы.</div>
<div>
Помимо
 этого класс HashMap обладает некоторыми другими отличиями: например, 
позволяет хранить один null ключ и множество null значений.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Согласно
 Кнуту и Кормену существует две основных реализации хэш-таблицы: на 
основе открытой адресацией и на основе метода цепочек. Как реализована 
HashMap? Почему так сделали (по вашему мнению)? В чем минусы и плюсы 
каждого подхода?</li>
</ul>
</h3>
<div>
Класс
 HashMap реализован с использованием метода цепочек, т.е. каждой ячейке 
массива соответствует свой связный список и при возникновении коллизии 
осуществляется добавление нового элемента в этот список.</div>
<div>
Для
 метода цепочек коэффициент заполнения может быть больше 1, с 
увеличением числа элементов производительность убывает линейно. Такие 
таблицы удобно использовать, если заранее неизвестно количество хранимых
 элементов, либо их может быть достаточно много, что приводит к большим 
значениям коэффициента заполнения.</div>
<div>
Среди методов открытой реализации различают:</div>
<div>
<ul>
<li>линейное пробирование;</li>
<li>квадратичное пробирование;</li>
<li>двойное хеширование.</li>
</ul>
</div>
<div>
Основные недостатки структур с методом открытой адресации:</div>
<div>
<ul>
<li>Количество
 элементов в таблице не может превышать размера массива. По мере 
увеличения числа элементов в таблице и повышения коэффициента заполнения
 (load factor) производительность структуры резко падает, поэтому 
необходимо проводить перехеширование.</li>
<li>Сложно организовать удаление элемента.</li>
<li>Также первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.</li>
</ul>
</div>
<div>
Основное
 преимущество хэш-таблицы с открытой адресацией - это отсутствие затрат 
на создание и хранение объектов списка. Также проще организовать 
сериализацию/десериализацию объекта.<br>
<br></div>
<h3 style="font-family: arial, helvetica, sans-serif;">
<ul>
<li>Сколько переходов по ссылкам происходит, когда вы делаете HashMap.get(key) по ключу, который есть в таблице?</li>
</ul>
</h3>
<div>
Возможно, я неправильно понял этот вопрос. За переходы по ссылке в данном ответе я считаю вызовы методов.</div>
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-vlEmE7DfsW8/VpI9_vCw8jI/AAAAAAAAAIo/CBxcqn8lw9g/s1600/hashMap_get_key.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/hashMap_get_key.jpg" border="0"></a></div>
<div style="font-family: Arial, Helvetica, sans-serif;">
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
Рассмотрим первый случай, когда ключ равен&nbsp;null: выполняем метод&nbsp;getForNullKey().<o:p></o:p></div>
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-pvizqQ6DCgQ/VpI-IM0hVuI/AAAAAAAAAIw/RX-bzsvXG28/s1600/hashMap_getForNullKey.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/hashMap_getForNullKey.jpg" border="0"></a></div>
<div>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
В
 цикле&nbsp;foreach&nbsp;проходимся по списку значений для ключа и 
возвращаем нужное значение. Таким образом, получаем&nbsp;1 переход.<o:p></o:p></div>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
Второй случай: ключ не равен&nbsp;null. Выполняем метод&nbsp;getEntry(key).<o:p></o:p></div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-n79J0T7rwbM/VpI-RHFVWwI/AAAAAAAAAI4/1iwEdCDpkVU/s1600/hashMap_getEntry.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="collection%20p2_files/hashMap_getEntry.jpg" height="189" border="0" width="640"></a></div>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
Вычисляется
 хэш-код ключа (метод hash(key)), затем определяется индекс ячейки 
массива, в которой будем искать значение (метод indexFor(hash, 
table.length)).</div>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
После
 того, как нашли нужную пару "ключ-значение" возвращаем значение (метод 
entry.getValue()). Таким образом, получаем 4 перехода.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<div>
<ul>
<li>Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?</li>
</ul>
</div>
</h3>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<div>
</div>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
Один новый объект статического вложенного класса Entry&lt;K,V&gt;.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<ul>
<li>Как работает HashMap при попытке сохранить в нее два элемента по ключам с одинаковым hashCode, но для которых equals == false?</li>
</ul>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
По
 значению hashCode вычисляется индекс ячейки массива, в список которой 
будет происходить добавление элемента. Перед добавлением осуществляется 
проверка на наличие уже элементов в этой ячейке. Если элементов нет, то 
происходит добавление. Если возникает коллизия, то итеративно 
осуществляется обход списка в поисках элемента с таким же ключом и 
хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а
 старое - возвращается. Поскольку в условии сказано, что добавляемые 
ключи - разные, то второй элемент будет добавлен в начало списка.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<ul>
<li>HashMap может выродиться в список даже для ключей с разным hashCode. Как это возможно?</li>
</ul>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<ul>
<li>Какое худшее время работы метода get(key) для ключа, которого нет в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?</li>
</ul>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
O(N).
 Худший случай - это поиск ключа в таблице, вырожденной в список, 
перебор ключей которой занимает линейно пропорциональное время 
количеству хранимых элементов.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<ul>
<li>Какое худшее время работы метода get(key) для ключа, который есть в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?</li>
</ul>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
O(N). Аналогичные рассуждения, что и для предыдущего вопроса.<br>
<br></div>
<h3 style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
<ul>
<li>Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).</li>
</ul>
</h3>
<div class="MsoNormal" style="margin: 0cm 0cm 0.0001pt -7.1pt; text-indent: 7.1pt;">
int
 initialCapacity - исходный размер HashMap (количество корзин в 
хэш-таблице в момент её создания), по умолчанию имеет значение 16.<br>
&nbsp;float
 loadFactor - коэффициент заполнения HashMap. Равен отношению числа 
хранимых элементов в таблице к её размеру. loadFactor - является мерой 
заполнения таблицы элементами,&nbsp;при
 превышении количества хранимых таблицей значений , происходит 
автоматическое перехеширование. Значение по умолчанию 0.75 является 
хорошим компромиссом между временем доступа и объемом хранимых данных.<br>
<br>
<h3 style="text-indent: 0px;">
<a href="https://jsehelper.blogspot.nl/2016/01/java-collections-framework-3.html">Java Collections Framework (часть 3).</a></h3>
</div>
</div>
</div>
</div>

</body></html>