<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Core p1</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
<h3>
<ul>
<li>Чем отличается JRE, JVM и JDK?&nbsp;</li>
</ul>
</h3>
<div>
JRE
 кратко - для работы. Java Runtime Environment (сокр. JRE) - минимальная
 реализация виртуальной машины, необходимая для исполнения 
Java-приложений, без компилятора и других средств разработки. Состоит из
 виртуальной машины - Java Virtual Machine и библиотеки Java-классов.</div>
<div>
JDK
 кратко - для программирования. Java Development Kit (сокращенно JDK) - 
бесплатно распространяемый компанией Oracle Corporation (ранее Sun 
Microsystems) комплект разработчика приложений на языке Java, включающий
 в себя компилятор Java (javac), стандартные библиотеки классов Java, 
примеры, документацию, различные утилиты и исполнительную систему Java 
(JRE).</div>
<div>
Java
 Virtual Machine (сокращенно Java VM, JVM) - виртуальная машина Java - 
основная часть исполняющей системы Java, так называемой Java Runtime 
Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java,
 предварительно созданный из исходного текста Java-программы 
компилятором Java (javac). JVM может также&nbsp;использоваться для выполнения программ, написанных на&nbsp;других языках программирования.<br>
<a name="more"></a><br>
<br>
<h3>
<ul>
<li>Опишите модификаторы доступа в Java.</li>
</ul>
</h3>
В Java существуют следующие модификаторы доступа:&nbsp;</div>
<div>
<ul>
<li>private: (используется конструкторах, внутренних классах, методах и полях класса) - Доступ разрешен только в текущем классе.</li>
<li>default
 (package-private): (используется в классах, конструкторах, интерфейсах,
 внутренних классах, методах и полях класса) - Доступ на уровне пакета. 
Если класс будет так объявлен он будет доступен только внутри пакета.</li>
<li>protected:
 (используется конструкторах, внутренних классах, методах и полях 
класса) Модификатор доступа на уровне пакета и в иерархии наследования.</li>
<li>public:
 (используется в классах, конструкторах, интерфейсах, внутренних 
классах, методах и полях класса) - Модификатор доступа общественный, 
доступен всем.</li>
</ul>
</div>
<div>
&nbsp;Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public).<br>
<br>
<br>
<h3>
<ul>
<li>Что такое package level access.</li>
</ul>
</h3>
Доступ из классов одного package-а в классы другого package-a.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Чем абстрактный клас отличается от интерфейса? В каких случаях Вы бы использовали абстрактный класс, а в каких интерфейс?</li>
</ul>
</h3>
Абстрактный
 класс это класс, который помечен как "abstract", он может содержать 
абстрактные методы, а может их и не содержать.&nbsp;</div>
<div>
&nbsp;Экземпляр абстрактного класса нельзя создать.</div>
<div>
Класс,
 который наследуется от абстрактного класса может реализовывать 
абстрактные методы, а может и не реализовывать, тогда класс наследник 
должен быть тоже абстрактным. Также если класс наследник переопределяет 
реализованный в абстрактном классе родители метод, его можно 
переопределить с модификатором абстракт! Т.е отказаться от реализации. 
Соответственно данный класс должен быть также абстрактным также.</div>
<div>
Что
 касается интерфейса, то в нем находятся только абстрактные методы и 
константы, так было до выхода Java 8. Начиная с Java 8 кроме абстрактных
 методов мы также можем использовать в интерфейсах стандартные методы 
(default methods) и статические методы (static methods).&nbsp;<br>
<ul>
<li>Default
 метод в интерфейсе - это метод в интерфейсе с по умолчанию 
реализованной логикой, который не требуется обязательно определять в 
реализации этого интерфейса.</li>
<li>Static методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.</li>
</ul>
При реализации 
интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс 
должен быть помечен как абстрактный. Интерфейс также может содержать 
внутренние классы. И не абстрактные методы в них.<br>
Что же использовать Интерфейс или Абстрактный класс?</div>
<div>
Абстрактный
 класс используется когда нам нужна какая-то реализация по умолчанию. 
Интерфейс используется когда классу нужно указать конкретное поведение. 
Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют 
интерфейс в абстрактном классе, чтоб указать поведение и реализацию по 
умолчанию. Это хорошо видно на примере свига:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-lghJ-bm8ooU/V0yXSVj-fAI/AAAAAAAAAyM/XRjtEcJ5DcYP--l_5CUobne5IfFUqCGVACLcB/s1600/q004_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q004_p01.jpg" border="0"></a></div>
Мы создаем свою модель таблицы с определенным поведением и уже с реализацией по умолчанию.</div>
<div>
&nbsp;ВАЖНО!
 При реализации интерфейса, необходимо реализовать все его методы, иначе
 будет Fatal error, так же это можно избежать, присвоив слово abstract.</div>
<div>
&nbsp;Пример:&nbsp;<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-72P5wK12Qgc/V0yXYZqks-I/AAAAAAAAAyQ/RuiXXS35OrgAI3g0GHhF52OftY0aopwagCLcB/s1600/q004_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q004_p02.jpg" border="0"></a></div>
<br></div>
<div>
<h3>
<ul>
<li>Может ли объект получить доступ к private-переменной класса? Если, да, то каким образом?</li>
</ul>
</h3>
Вообще
 доступ у приватной переменной класса можно получить только внутри 
класса, в котором она объявлена. Также доступ к приватным переменным 
можно осуществить через механизм Java Reflection API.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Для чего в джаве статические блоки?</li>
</ul>
</h3>
Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-PfN6-Xh2-4s/V0yXebvYM-I/AAAAAAAAAyU/wekROlH75PISjL-qs2t3Rb7ijJLXZ5lYgCLcB/s1600/q006_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q006_p01.jpg" border="0"></a></div>
Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы:</div>
<div>
Например:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-iWaqgCGFxhM/V0yXkRWZ64I/AAAAAAAAAyY/Qc1wRKb7mAASKNDitj7uK22G23rwUQwmgCLcB/s1600/q006_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q006_p02.jpg" border="0"></a></div>
Будет создан код:</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-V_cMWyW-Bs0/V0yXpdJ2_MI/AAAAAAAAAyc/p0cWQP4dlfwOTG7Fr5-cT4RiDou7J3ZXgCLcB/s1600/q006_p03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q006_p03.jpg" border="0"></a></div>
<br></div>
<div>
<h3>
<ul>
<li>Можно ли перегрузить static метод?</li>
</ul>
</h3>
Статические
 методы могут перегружаться нестатическими и наоборот - без ограничений.
 А вот в переопределении статического метода смысла нет.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Расскажите про внутренние классы. Когда вы их будете использовать?</li>
</ul>
</h3>
Внутренний
 &nbsp;класс - это класс, который &nbsp;находится внутри класса или 
интерфейса. При этом он получает доступ ко всем полям и методам своего 
внешнего класса.&nbsp;</div>
<div>
Для
 чего он может применятся? Например чтоб обеспечить какую-то 
дополнительную логику класса. Хотя использование внутренних классов 
усложняет программу, рекомендуется избегать их использование.<br>
<br>
<br>
<h3>
<ul>
<li>В чем разница между переменной &nbsp;экземпляра и статической переменной? Приведите пример.</li>
</ul>
</h3>
Статические
 переменные инициализируются при загрузке класса класслодером, и не 
зависят от объекта. Переменная экземпляра инициализируется при создании 
класса.</div>
<div>
<div>
Пример:
 Например нам нужна глобальная переменная для всех объектов класс, 
например число посещений пользователей определенной статьи в интернете. 
При каждом новом посещении статьи создается новый объект и 
инкрементируется переменная посещений.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Приведите пример когда можно использовать статический метод?</li>
</ul>
</h3>
Статические
 методы могут быть использованы для &nbsp;инициализации статических 
переменных. Часто статические методы используются в классах утилитах, 
таких как &nbsp;Collections, Math, Arrrays</div>
<div>
<br>
</div>
<div>
<h3>
<ul>
<li>Расскажите про классы- загрузчики и про динамическую зарузку классов.&nbsp;</li>
</ul>
</h3>
Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком.</div>
<div>
Все
 виртуальные машины джава включают хотябы один загрузчик классов, так 
называем базовый загрузчик. Он загружает все основные классы, это классы
 из rt.jar. Интересно то, что этот загрузчик никак не связан с 
программой, тоесть мы не можем получить например у java.lang.Object имя 
зарузчика, метод getClassLoader() вернет нам null.</div>
<div>
&nbsp; Следующий загрузчик - это &nbsp;загрузчик расширений, он загружает &nbsp;классы из $JAVA_HOME/lib/ext.</div>
<div>
&nbsp; Далее по иерархии идет системный &nbsp;загрузчик, он загружает классы, путь к которым указан в переменно класпас.</div>
<div>
&nbsp; Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его используем. Как идет его загрузка… :</div>
<div>
&nbsp;
 Сначала системный загрузчик пытается найти &nbsp;его в своем кэше 
загрузок его, если найден - класс успешно загружается, иначе управление 
загрузкой передается загрузчику расширений, он также проверяет 
&nbsp;свой кэш загрузок и в случае неудачи &nbsp;передает задачу 
базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его 
загрузить, если загрузка прошла успешно - &nbsp;загрузка закончена. Если
 нет - передает управление загрузчику расширений. Загрузчик 
&nbsp;расширений пытается загрузить класс &nbsp;и в случае неудачи 
передает это &nbsp;дело системному загрузчику. Системный &nbsp;загрузчик
 пытается загрузить класс &nbsp;и в случае неудачи возбуждается 
исключение java.lang.ClassNotFoundException.</div>
<div>
&nbsp; Вот так работает загрузка классов в &nbsp;джава. Так называемое делегирование загрузки.</div>
<div>
&nbsp;
 Если &nbsp;в системе присутствуют пользовательские загрузики, то они 
должны быть унаследованы от класса java.lang.ClassLoader .</div>
<div>
&nbsp; Что же такое статическая и что &nbsp;такое динамическая загрузка класса?</div>
<div>
&nbsp; Статическая загрузка класса происходит при использовании &nbsp;оператора "new".</div>
<div>
&nbsp;
 Динамическая &nbsp;загрузка происходит "на лету" в &nbsp;ходе 
выполнения программы с помощью &nbsp;статического метода класса 
Class.forName(имя класса). Для чего нужна динамическая загрузка? 
Например мы не знаем какой класс нам понадобится и принимаем решение в 
ходе выполнения программы передавая имя класса в статический метод 
forName().<br>
<br>
<br>
<h3>
<ul>
<li>Для чего нужен оператор "assert" в джава?&nbsp;</li>
</ul>
</h3>
</div>
<div>
Это
 так называемый оператор &nbsp;утверждений. Он проверяет некое 
&nbsp;условие, если оно ложно, то &nbsp;генерируется AssertationError</div>
<div>
assert status: "message error";</div>
<div>
Тут проверяется булевская переменная "status".<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Почему в некоторых интерфейсах &nbsp;вообще не определяют методов?&nbsp;</li>
</ul>
</h3>
Это
 так называемые интерфейсы - маркеры. Они просто указывают что класс 
относится к определенной группе классов. Например интерфейс Clonable 
указывает на то, что класс поддерживает механизм клонирования.</div>
<div>
Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений.</div>
<div>
Интерфейси-маркери в Java:</div>
<div>
<ul>
<li>Searilizable interface</li>
<li>Cloneable interface</li>
<li>Remote interface</li>
<li>ThreadSafe interface</li>
</ul>
</div>
<div>
<br>
</div>
<div>
<h3>
<ul>
<li>Какая основная разница между String, StringBuffer, StringBuilder?&nbsp;</li>
</ul>
</h3>
String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку, создается новый объект строки.</div>
<div>
StringBuffer
 и StringBuilder могут изменятся и добавление строки не такое 
дорогостоющее с точки зрения памяти. Первы - синхронизированный, второй -
 нет. Это их единственное различие.</div>
<div>
Правда
 &nbsp;если нам нужно сделать подстроку &nbsp;строки, то лучше 
использовать String, так как ее массив символов не меняется и не 
создается заново для новой строки. А вот в StringBuffer и StringBuilder 
для создания подстроки создается новый массив символов.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Расскажите про потоки ввода-вывода &nbsp;Java.&nbsp;</li>
</ul>
</h3>
Потоки &nbsp;ввода-вывода бывают двух видов:</div>
<div>
<ul>
<li>байтовый поток(InputStream и OutputStream);</li>
<li>символный поток(Reader и Writer);</li>
</ul>
</div>
<div>
Это все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал, например:</div>
<div>
InputStream in = new FileInputStream(new File("file.txt"));<br>
<br></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Что такое Heap и Stack память в Java?</li>
</ul>
</h3>
<div>
Java
 Heap (куча) &nbsp;- динамически распредляемая область памяти, 
создаваемая при старте JVM. Используется Java Runtime для выделения 
памяти под объекты и JRE классы. Создание нового объекта также 
происходит в куче. Здесь работает сборщик мусора: освобождает память 
путем удаления объектов, на которые нет каких-либо ссылок. Любой объект,
 созданный в куче, имеет глобальный доступ и на него могут ссылаться с 
любой части приложения.</div>
<div>
Cтрогими тезами:</div>
<ul style="text-align: left;">
<li>Все обьекты обитают в куче и попадают туда при создании.</li>
<li>обьект состоит из полей класса и методов.</li>
<li>в
 куче выделяется место под сам обьект, количество выделенной памяти 
зависит от полей, если у тебя полем класса, к примеру, служит интовая 
переменная, то не важно, инициализируешь ты ее как "0" или как "1000000"
 - обьект займет в куче свои биты, + столько байт сколько вмещает тип 
int(+32 бита), и так с каждым полем.</li>
</ul>
<div>
Стековая
 память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). 
Всякий раз, когда вызывается метод, в памяти стека создается новый блок,
 который содержит примитивы и ссылки на другие объекты в методе 
расположение в RAM и достижение процессору через указатель стека. Как 
только метод заканчивает работу, блок также перестает использоваться, 
тем самым предоставляя доступ для следующего метода. Размер стековой 
памяти намного меньше объема памяти в куче.</div>
<div>
Cтрогими тезами:</div>
<ul style="text-align: left;">
<li>Все методы обитают в стеке и попадают туда при вызове.</li>
<li>Переменные в методах так же имеют стековую память, по скольку они локальные.</li>
<li>Если
 в методе создается обьект, то он помещается в кучу, но его ссылка все 
еще будет находится в стеке и после того как метод покинет стек - обьект
 станет жертвой сборщика мусора, так как ссылка на него утеряна, и из 
главного стека программы невозможно будет добраться до такого обьекта.</li>
</ul>
<br>
<br>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Какая разница между Stack и Heap памятью в Java?</li>
</ul>
</h3>
<div>
Приведем следующие различия между Heap и Stack памятью в Java.</div>
<ul style="text-align: left;">
<li>Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.</li>
<li>Всякий
 раз, когда создается объект, он всегда хранится в куче, а в памяти 
стека содержится ссылка на него. Память стека содержит только локальные 
переменные примитивных типов и ссылки на объекты в куче.</li>
<li>Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.</li>
<li>Управление памятью в стеке осуществляется по схеме LIFO.</li>
<li>Стековая
 память существует лишь какое-то время работы программы, а память в куче
 живет с самого начала до конца работы программы.</li>
<li>Мы
 можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и 
максимальный размер памяти в куче. Для стека определить размер памяти 
можно с помощью опции -Xss .</li>
<li>Если
 память стека полностью занята, то Java Runtime бросает 
java.lang.StackOverflowError, а если память кучи заполнена, то бросается
 исключение java.lang.OutOfMemoryError: Java Heap Space.</li>
<li>Размер
 памяти стека намного меньше памяти в куче. Из-за простоты распределения
 памяти (LIFO), стековая память работает намного быстрее кучи.</li>
</ul>
<h3>
<br>
</h3>
<h3>
<ul>
<li>Расскажите про модель памяти &nbsp;в джава?</li>
</ul>
</h3>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-btZICcb7S_c/V0yOYppvPOI/AAAAAAAAAx8/QBEUPQSC4jEmKlAEVvEhn-3dugnC_SxlACLcB/s1600/memory%2Bmodel.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/memorymodel.jpg" border="0"></a></div>
<div>
В Джаве память устроена следующим &nbsp;образом, есть два вида:</div>
<div>
</div>
<ul>
<li>куча</li>
<li>стек</li>
</ul>
<br>
<img src="JavaCore_files/java-memory-model-1.png" alt="jmm">
<br>
Куча &nbsp;состоит из статического контекста &nbsp;и самой кучи<br>
<div>
Перейдем &nbsp;к куче. Куча состоит из двух частей:</div>
<div>
</div>
<ul>
<li>Новая куча</li>
<li>Старая куча</li>
</ul>
Новая куча в свою очередь состоит из двух частей:<br>
<div>
</div>
<ul>
<li>Eden(назовем ее первая) куча</li>
<li>Survival(выжившая) куча</li>
</ul>
Краткое описание:<br>
Все описанное далее относится к Sun-овской реализации JVM 
(HotSpot), версий 5.0+, конкретные детали и алгоритмы могут различаться 
для разных версий.
<br>
Итак, память процесса различается на heap (куча) и non-heap (стек) 
память, и состоит из 5 областей (memory pools, memory spaces):

<div>
</div>
<ul>
<li>Eden Space (heap) - в этой области выделятся память под все создаваемые из 
программы объекты. Большая часть объектов живет недолго (итераторы, 
временные объекты, используемые внутри методов и т.п.), и удаляются при 
выполнении сборок мусора это области памяти, не перемещаются в другие 
области памяти. Когда данная область заполняется (т.е. количество 
выделенной памяти в этой области превышает некоторый заданный процент), 
GC выполняет быструю (minor collection) сборку мусора. По сравнению с 
полной сборкой мусора она занимает мало времени, и затрагивает только 
эту область памяти - очищает от устаревших объектов Eden Space и 
перемещает выжившие объекты в следующую область.&nbsp;</li>
<li>Survivor
 Space (heap) – сюда перемещаются объекты из предыдущей, после того, как
 они пережили хотя бы одну сборку мусора. Время от времени долгоживущие 
объекты из этой области перемещаются в Tenured Space.</li>
<li>Tenured
 (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты 
(крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и 
проч.). Когда заполняется эта область, выполняется полная сборка мусора 
(full, major collection), которая обрабатывает все созданные JVM 
объекты.</li>
<li>Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.).&nbsp;</li>
<li>
	Code Cache (non-heap) — эта область используется JVM, когда включена 
JIT-компиляция, в ней кешируется скомпилированный платформенно — 
зависимый код.

</li>
</ul>
<div>
<br>
</div>
<h3>
<ul>
<li>Как работает сборщик мусора (garbage collector)?&nbsp;</li>
</ul>
</h3>
<div>
Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов работы, он не один.</div>
<div>
Когда
 происходит очистка памяти? Если память в Первой куче полностью 
заполнена, то туда идет сборщик мусора и делает свою работу) Какую 
именно, зависит &nbsp;от обстоятельств… Например если в &nbsp;первой 
кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора 
помечает эти объекты, далее те что остались объекты со ссылками он их 
переносит в Выжившую кучу, а в первой куче он просто все удаляет.&nbsp;</div>
<div>
Ситуация
 &nbsp;другая, в первой кучи мало мусора, но очень много рабочих 
объектов. Как поступает в этом случае сборщик &nbsp;мусора?</div>
<div>
Он &nbsp;помечает мусор, удаляет его и &nbsp;оставшиеся объекты компонует.</div>
<div>
Также
 следует заметить что при нехватке места в Выжившей куче, объекты 
&nbsp;переносятся в старую кучу, там &nbsp;хранятся как правило долго 
живущие объекты.</div>
<div>
   </div>
<div>
Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда памяти не хватает.<br>
<br>
</div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Расскажите про приведение типов. &nbsp;Что такое понижение и повышение &nbsp;типа? Когда вы получаете ClassCastException?&nbsp;</li>
</ul>
</h3>
<div>
Приведение &nbsp;типов это установка типа переменной или объекта отличного от текущего. В ждава есть два вида приведения:</div>
<div>
<ul>
<li>автоматическое</li>
<li>не автоматическое</li>
</ul>
</div>
<div>
Автоматическое &nbsp;происходит например:</div>
<div>
byte-&gt; short-&gt;int-&gt;long-&gt;float-&gt;double</div>
<div>
тоесть
 если мы расширяем тип, то явное преобразование не требуется, приведение
 происходит автоматически. Если же мы сужаем, то необходимо явно 
указывать приведение типа.</div>
<div>
В
 случае же с объектами, то мы можем &nbsp;сделать автоматическое 
приведение от наследника к родителю, но никак &nbsp;не наоборот, тогда 
вылетит ClassCastException.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>&nbsp;Что такое статический класс, какие особенности его использования?</li>
</ul>
</h3>
</div>
<div>
Статическим
 классом может быть только внутренний клас(определение класса 
размещается внутри другого класса). В объекте обычного внутреннего 
класса хранится ссылка на объект внешнего класса. Внутри статического 
внутреннего класса такой ссылки нет.</div>
<div>
То
 есть: Для создания объекта статического внутреннего класса не нужен 
объект внешнего класса. Из объекта статического вложенного класса нельзя
 обращаться к нестатическим членам внешнего класса напрямую. И еще 
обычные внутренние классы не могут содержать статические методы и члены.</div>
<div>
Зачем
 вообще нужны внутренние классы? – Каждый внутренний класс способен 
независимо &nbsp;наследовать определенную реализацию. Таким образом 
внутренний класс не ограничен при наследовании в ситуациях, когда 
внешний класс уже наследует реализацию. То есть это как бы вариант 
решения проблемы множественного наследования.<br>
<br>
</div>
<h3>
<ul style="text-align: left;">
<li>Каким образом из вложенного класса получить доступ к полю внешнего класса.</li>
</ul>
</h3>
<div>

Если класс внутренний то: [ВнешнийКласс.this.ПолеВнешнегоКласса] 
 Если класс статический внутренний(вложенный),то в методе нужно создать объект 
внешнего класса, и получить доступ к его полю. 
Или второй вариант &nbsp;объявить это поле внешнего класса как &nbsp;static<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Какие существуют типы вложенных классов? Для чего они используются?&nbsp;</li>
</ul>
</h3>
</div>
table&gt;tr*5&gt;td
ul&gt;li*5
<pre>	Есть 2 вида ВЛОЖЕННЫХ КЛАССов [nested class]:
1) (СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС) [static nested class]
2) (ВНУТРЕННИЙ КЛАСС) - класс экземпляра [inner class]
	2.1 ОБЫЧНЫЙ ВНУТРЕННИЙ КЛАСС [inner class] (внутри внешнего класса, как объявление переменной)
	2.2 ЛОКАЛЬНЫЙ КЛАСС [local class]
	2.3 АНОНИМНЫЙ КЛАСС [anonymous class]
</pre>
<div>
Вложенные
 классы существуют внутри других классов. &nbsp;Нормальный класс - 
полноценный член пакета. Вложенные классы, которые стали доступны 
начиная с Java 1.1, могут быть четырех типов:</div>
<div>

<ol>
<li>статические члены класса</li>
<li>члены класса</li>
<li>локальные классы</li>
<li>анонимные классы</li>
</ol>

</div>
<div>
Статические
 члены классов (static nested classes)&nbsp;- как и любой другой 
статический метод, имеет доступ к любым статическим методам своего 
внешнего класса, в том числе и к приватным. К нестатическим полям и 
методам обрамляющего&nbsp;класса он не может обращатся напрямую. Он 
может использовать их только через ссылку на экземпляр класса родителя.</div>
<div>

Члены класса - ?
<br>
 локальные классы, объявленные внутри блока кода. Эти классы видны только внутри блока.</div>
<div>
Анонимные классы - &nbsp;Эти типы классов не имеют имени и видны только внутри блока.<br>
<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/01/java-core-2.html">Java core (часть 2).</a></h3>
</div></div></body></html>