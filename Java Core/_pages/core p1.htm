<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Core p1</title>
<link rel="stylesheet" href="grey.css">
</head>
<body>
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Чем отличается JRE, JVM и JDK?</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;</span></span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">JRE
 кратко - для работы. Java Runtime Environment (сокр. JRE) - минимальная
 реализация виртуальной машины, необходимая для исполнения 
Java-приложений, без компилятора и других средств разработки. Состоит из
 виртуальной машины - Java Virtual Machine и библиотеки Java-классов.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">JDK
 кратко - для программирования. Java Development Kit (сокращенно JDK) - 
бесплатно распространяемый компанией Oracle Corporation (ранее Sun 
Microsystems) комплект разработчика приложений на языке Java, включающий
 в себя компилятор Java (javac), стандартные библиотеки классов Java, 
примеры, документацию, различные утилиты и исполнительную систему Java 
(JRE).</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Java
 Virtual Machine (сокращенно Java VM, JVM) - виртуальная машина Java - 
основная часть исполняющей системы Java, так называемой Java Runtime 
Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java,
 предварительно созданный из исходного текста Java-программы 
компилятором Java (javac). JVM может также&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">использоваться для выполнения программ, написанных на&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">других языках программирования.</span></span><br>
<a name="more"></a><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
<br>
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Опишите модификаторы доступа в Java.</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">В Java существуют следующие модификаторы доступа:&nbsp;</span></div>
<div style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">private: (используется конструкторах, внутренних классах, методах и полях класса) - Доступ разрешен только в текущем классе.</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">default
 (package-private): (используется в классах, конструкторах, интерфейсах,
 внутренних классах, методах и полях класса) - Доступ на уровне пакета. 
Если класс будет так объявлен он будет доступен только внутри пакета.</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">protected:
 (используется конструкторах, внутренних классах, методах и полях 
класса) Модификатор доступа на уровне пакета и в иерархии наследования.</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">public:
 (используется в классах, конструкторах, интерфейсах, внутренних 
классах, методах и полях класса) - Модификатор доступа общественный, 
доступен всем.</span></li>
</ul>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public).</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
<br>
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Что такое package level access.</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Доступ из классов одного package-а в классы другого package-a.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Чем абстрактный клас отличается от интерфейса? В каких случаях Вы бы использовали абстрактный класс, а в каких интерфейс?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Абстрактный
 класс это класс, который помечен как "abstract", он может содержать 
абстрактные методы, а может их и не содержать.&nbsp;</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;Экземпляр абстрактного класса нельзя создать.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Класс,
 который наследуется от абстрактного класса может реализовывать 
абстрактные методы, а может и не реализовывать, тогда класс наследник 
должен быть тоже абстрактным. Также если класс наследник переопределяет 
реализованный в абстрактном классе родители метод, его можно 
переопределить с модификатором абстракт! Т.е отказаться от реализации. 
Соответственно данный класс должен быть также абстрактным также.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Что
 касается интерфейса, то в нем находятся только абстрактные методы и 
константы, так было до выхода Java 8. Начиная с Java 8 кроме абстрактных
 методов мы также можем использовать в интерфейсах стандартные методы 
(default methods) и статические методы (static methods).&nbsp;</span><br>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Default
 метод в интерфейсе - это метод в интерфейсе с по умолчанию 
реализованной логикой, который не требуется обязательно определять в 
реализации этого интерфейса.</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Static методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.</span></li>
</ul>
<span style="font-family: arial, helvetica, sans-serif;">При реализации 
интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс 
должен быть помечен как абстрактный. Интерфейс также может содержать 
внутренние классы. И не абстрактные методы в них.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Что же использовать Интерфейс или Абстрактный класс?</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Абстрактный
 класс используется когда нам нужна какая-то реализация по умолчанию. 
Интерфейс используется когда классу нужно указать конкретное поведение. 
Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют 
интерфейс в абстрактном классе, чтоб указать поведение и реализацию по 
умолчанию. Это хорошо видно на примере свига:</span><br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-lghJ-bm8ooU/V0yXSVj-fAI/AAAAAAAAAyM/XRjtEcJ5DcYP--l_5CUobne5IfFUqCGVACLcB/s1600/q004_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/q004_p01.jpg" border="0"></span></a></div>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Мы создаем свою модель таблицы с определенным поведением и уже с реализацией по умолчанию.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;ВАЖНО!
 При реализации интерфейса, необходимо реализовать все его методы, иначе
 будет Fatal error, так же это можно избежать, присвоив слово abstract.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;Пример:&nbsp;</span><br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-72P5wK12Qgc/V0yXYZqks-I/AAAAAAAAAyQ/RuiXXS35OrgAI3g0GHhF52OftY0aopwagCLcB/s1600/q004_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/q004_p02.jpg" border="0"></span></a></div>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Может ли объект получить доступ к private-переменной класса? Если, да, то каким образом?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Вообще
 доступ у приватной переменной класса можно получить только внутри 
класса, в котором она объявлена. Также доступ к приватным переменным 
можно осуществить через механизм Java Reflection API.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Для чего в джаве статические блоки?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру.</span><br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-PfN6-Xh2-4s/V0yXebvYM-I/AAAAAAAAAyU/wekROlH75PISjL-qs2t3Rb7ijJLXZ5lYgCLcB/s1600/q006_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/q006_p01.jpg" border="0"></span></a></div>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы:</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Например:</span><br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-iWaqgCGFxhM/V0yXkRWZ64I/AAAAAAAAAyY/Qc1wRKb7mAASKNDitj7uK22G23rwUQwmgCLcB/s1600/q006_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/q006_p02.jpg" border="0"></span></a></div>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Будет создан код:</span></div>
<div style="text-align: justify;">
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-V_cMWyW-Bs0/V0yXpdJ2_MI/AAAAAAAAAyc/p0cWQP4dlfwOTG7Fr5-cT4RiDou7J3ZXgCLcB/s1600/q006_p03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/q006_p03.jpg" border="0"></span></a></div>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Можно ли перегрузить static метод?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статические
 методы могут перегружаться нестатическими и наоборот - без ограничений.
 А вот в переопределении статического метода смысла нет.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Расскажите про внутренние классы. Когда вы их будете использовать?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Внутренний
 &nbsp;класс - это класс, который &nbsp;находится внутри класса или 
интерфейса. При этом он получает доступ ко всем полям и методам своего 
внешнего класса.&nbsp;</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Для
 чего он может применятся? Например чтоб обеспечить какую-то 
дополнительную логику класса. Хотя использование внутренних классов 
усложняет программу, рекомендуется избегать их использование.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
<br>
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">В чем разница между переменной &nbsp;экземпляра и статической переменной? Приведите пример.</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статические
 переменные инициализируются при загрузке класса класслодером, и не 
зависят от объекта. Переменная экземпляра инициализируется при создании 
класса.</span></div>
<div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Пример:
 Например нам нужна глобальная переменная для всех объектов класс, 
например число посещений пользователей определенной статьи в интернете. 
При каждом новом посещении статьи создается новый объект и 
инкрементируется переменная посещений.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Приведите пример когда можно использовать статический метод?</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статические
 методы могут быть использованы для &nbsp;инициализации статических 
переменных. Часто статические методы используются в классах утилитах, 
таких как &nbsp;Collections, Math, Arrrays</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Расскажите про классы- загрузчики и про динамическую зарузку классов.&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Все
 виртуальные машины джава включают хотябы один загрузчик классов, так 
называем базовый загрузчик. Он загружает все основные классы, это классы
 из rt.jar. Интересно то, что этот загрузчик никак не связан с 
программой, тоесть мы не можем получить например у java.lang.Object имя 
зарузчика, метод getClassLoader() вернет нам null.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Следующий загрузчик - это &nbsp;загрузчик расширений, он загружает &nbsp;классы из $JAVA_HOME/lib/ext.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Далее по иерархии идет системный &nbsp;загрузчик, он загружает классы, путь к которым указан в переменно класпас.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его используем. Как идет его загрузка… :</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;
 Сначала системный загрузчик пытается найти &nbsp;его в своем кэше 
загрузок его, если найден - класс успешно загружается, иначе управление 
загрузкой передается загрузчику расширений, он также проверяет 
&nbsp;свой кэш загрузок и в случае неудачи &nbsp;передает задачу 
базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его 
загрузить, если загрузка прошла успешно - &nbsp;загрузка закончена. Если
 нет - передает управление загрузчику расширений. Загрузчик 
&nbsp;расширений пытается загрузить класс &nbsp;и в случае неудачи 
передает это &nbsp;дело системному загрузчику. Системный &nbsp;загрузчик
 пытается загрузить класс &nbsp;и в случае неудачи возбуждается 
исключение java.lang.ClassNotFoundException.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Вот так работает загрузка классов в &nbsp;джава. Так называемое делегирование загрузки.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;
 Если &nbsp;в системе присутствуют пользовательские загрузики, то они 
должны быть унаследованы от класса java.lang.ClassLoader .</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Что же такое статическая и что &nbsp;такое динамическая загрузка класса?</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp; Статическая загрузка класса происходит при использовании &nbsp;оператора "new".</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;
 Динамическая &nbsp;загрузка происходит "на лету" в &nbsp;ходе 
выполнения программы с помощью &nbsp;статического метода класса 
Class.forName(имя класса). Для чего нужна динамическая загрузка? 
Например мы не знаем какой класс нам понадобится и принимаем решение в 
ходе выполнения программы передавая имя класса в статический метод 
forName().</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
<br>
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Для чего нужен оператор "assert" в джава?&nbsp;</span></li>
</ul>
</h3>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Это
 так называемый оператор &nbsp;утверждений. Он проверяет некое 
&nbsp;условие, если оно ложно, то &nbsp;генерируется AssertationError</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">assert status: "message error";</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Тут проверяется булевская переменная "status".</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Почему в некоторых интерфейсах &nbsp;вообще не определяют методов?&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Это
 так называемые интерфейсы - маркеры. Они просто указывают что класс 
относится к определенной группе классов. Например интерфейс Clonable 
указывает на то, что класс поддерживает механизм клонирования.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Интерфейси-маркери в Java:</span></div>
<div style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Searilizable interface</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Cloneable interface</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Remote interface</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">ThreadSafe interface</span></li>
</ul>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Какая основная разница между String, StringBuffer, StringBuilder?&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку, создается новый объект строки.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">StringBuffer
 и StringBuilder могут изменятся и добавление строки не такое 
дорогостоющее с точки зрения памяти. Первы - синхронизированный, второй -
 нет. Это их единственное различие.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Правда
 &nbsp;если нам нужно сделать подстроку &nbsp;строки, то лучше 
использовать String, так как ее массив символов не меняется и не 
создается заново для новой строки. А вот в StringBuffer и StringBuilder 
для создания подстроки создается новый массив символов.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Расскажите про потоки ввода-вывода &nbsp;Java.&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Потоки &nbsp;ввода-вывода бывают двух видов:</span></div>
<div style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">байтовый поток(InputStream и OutputStream);</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">символный поток(Reader и Writer);</span></li>
</ul>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Это все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал, например:</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">InputStream in = new FileInputStream(new File("file.txt"));</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Что такое Heap и Stack память в Java?</span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Java
 Heap (куча) &nbsp;- динамически распредляемая область памяти, 
создаваемая при старте JVM. Используется Java Runtime для выделения 
памяти под объекты и JRE классы. Создание нового объекта также 
происходит в куче. Здесь работает сборщик мусора: освобождает память 
путем удаления объектов, на которые нет каких-либо ссылок. Любой объект,
 созданный в куче, имеет глобальный доступ и на него могут ссылаться с 
любой части приложения.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Cтрогими тезами:</span></div>
<ul style="text-align: left;">
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Все обьекты обитают в куче и попадают туда при создании.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">обьект состоит из полей класса и методов.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">в
 куче выделяется место под сам обьект, количество выделенной памяти 
зависит от полей, если у тебя полем класса, к примеру, служит интовая 
переменная, то не важно, инициализируешь ты ее как "0" или как "1000000"
 - обьект займет в куче свои биты, + столько байт сколько вмещает тип 
int(+32 бита), и так с каждым полем.</span></li>
</ul>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Стековая
 память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). 
Всякий раз, когда вызывается метод, в памяти стека создается новый блок,
 который содержит примитивы и ссылки на другие объекты в методе 
расположение в RAM и достижение процессору через указатель стека. Как 
только метод заканчивает работу, блок также перестает использоваться, 
тем самым предоставляя доступ для следующего метода. Размер стековой 
памяти намного меньше объема памяти в куче.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Cтрогими тезами:</span></div>
<ul style="text-align: left;">
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Все методы обитают в стеке и попадают туда при вызове.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Переменные в методах так же имеют стековую память, по скольку они локальные.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Если
 в методе создается обьект, то он помещается в кучу, но его ссылка все 
еще будет находится в стеке и после того как метод покинет стек - обьект
 станет жертвой сборщика мусора, так как ссылка на него утеряна, и из 
главного стека программы невозможно будет добраться до такого обьекта.</span></li>
</ul>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
<br>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Какая разница между Stack и Heap памятью в Java?</span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Приведем следующие различия между Heap и Stack памятью в Java.</span></div>
<ul style="text-align: left;">
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Всякий
 раз, когда создается объект, он всегда хранится в куче, а в памяти 
стека содержится ссылка на него. Память стека содержит только локальные 
переменные примитивных типов и ссылки на объекты в куче.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Управление памятью в стеке осуществляется по схеме LIFO.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Стековая
 память существует лишь какое-то время работы программы, а память в куче
 живет с самого начала до конца работы программы.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Мы
 можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и 
максимальный размер памяти в куче. Для стека определить размер памяти 
можно с помощью опции -Xss .</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Если
 память стека полностью занята, то Java Runtime бросает 
java.lang.StackOverflowError, а если память кучи заполнена, то бросается
 исключение java.lang.OutOfMemoryError: Java Heap Space.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Размер
 памяти стека намного меньше памяти в куче. Из-за простоты распределения
 памяти (LIFO), стековая память работает намного быстрее кучи.</span></li>
</ul>
<h3 style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></h3>
<h3 style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Расскажите про модель памяти &nbsp;в джава?</span></li>
</ul>
</h3>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-btZICcb7S_c/V0yOYppvPOI/AAAAAAAAAx8/QBEUPQSC4jEmKlAEVvEhn-3dugnC_SxlACLcB/s1600/memory%2Bmodel.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><img src="core%20p1_files/memorymodel.jpg" border="0"></span></a></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">В Джаве память устроена следующим &nbsp;образом, есть два вида:</span></div>
<div style="text-align: justify;">
</div>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">куча</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">стек</span></li>
</ul>
<br>
<img src="core p1_files/java-memory-model-1.png" alt="jmm">
<br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; text-align: justify;">Куча &nbsp;состоит из статического контекста &nbsp;и самой кучи</span><br>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Перейдем &nbsp;к куче. Куча состоит из двух частей:</span></div>
<div style="text-align: justify;">
</div>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Новая куча</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Старая куча</span></li>
</ul>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; text-align: justify;">Новая куча в свою очередь состоит из двух частей:</span><br>
<div style="text-align: justify;">
</div>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Eden(назовем ее первая) куча</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Survival(выжившая) куча</span></li>
</ul>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; text-align: justify;">Краткое описание:</span><br>
<span>Все описанное далее относится к Sun-овской реализации JVM (HotSpot), версий 5.0+, конкретные детали и алгоритмы могут различаться для разных версий.
<br>
Итак, память процесса различается на heap (куча) и non-heap (стек) память, и состоит из 5 областей (memory pools, memory spaces):
</span>
<div style="text-align: justify;">
</div>
<ul>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Eden Space (heap) - в этой области выделятся память под все создаваемые из 
программы объекты. Большая часть объектов живет недолго (итераторы, 
временные объекты, используемые внутри методов и т.п.), и удаляются при 
выполнении сборок мусора это области памяти, не перемещаются в другие 
области памяти. Когда данная область заполняется (т.е. количество 
выделенной памяти в этой области превышает некоторый заданный процент), 
GC выполняет быструю (minor collection) сборку мусора. По сравнению с 
полной сборкой мусора она занимает мало времени, и затрагивает только 
эту область памяти - очищает от устаревших объектов Eden Space и 
перемещает выжившие объекты в следующую область.&nbsp;</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Survivor
 Space (heap) – сюда перемещаются объекты из предыдущей, после того, как
 они пережили хотя бы одну сборку мусора. Время от времени долгоживущие 
объекты из этой области перемещаются в Tenured Space.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Tenured
 (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты 
(крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и 
проч.). Когда заполняется эта область, выполняется полная сборка мусора 
(full, major collection), которая обрабатывает все созданные JVM 
объекты.</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.).&nbsp;</span></li>
<li style="text-align: justify;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">
	Code Cache (non-heap) — эта область используется JVM, когда включена JIT-компиляция, в ней кешируется скомпилированный платформенно — зависимый код.

</span></li>
</ul>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<h3 style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Как работает сборщик мусора (garbage collector)?&nbsp;</span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов работы, он не один.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Когда
 происходит очистка памяти? Если память в Первой куче полностью 
заполнена, то туда идет сборщик мусора и делает свою работу) Какую 
именно, зависит &nbsp;от обстоятельств… Например если в &nbsp;первой 
кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора 
помечает эти объекты, далее те что остались объекты со ссылками он их 
переносит в Выжившую кучу, а в первой куче он просто все удаляет.&nbsp;</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Ситуация
 &nbsp;другая, в первой кучи мало мусора, но очень много рабочих 
объектов. Как поступает в этом случае сборщик &nbsp;мусора?</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Он &nbsp;помечает мусор, удаляет его и &nbsp;оставшиеся объекты компонует.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Также
 следует заметить что при нехватке места в Выжившей куче, объекты 
&nbsp;переносятся в старую кучу, там &nbsp;хранятся как правило долго 
живущие объекты.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"></span>   </span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда памяти не хватает.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; text-align: justify;">Расскажите про приведение типов. &nbsp;Что такое понижение и повышение &nbsp;типа? Когда вы получаете ClassCastException?&nbsp;</span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Приведение &nbsp;типов это установка типа переменной или объекта отличного от текущего. В ждава есть два вида приведения:</span></div>
<div style="text-align: justify;">
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">автоматическое</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">не автоматическое</span></li>
</ul>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Автоматическое &nbsp;происходит например:</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">byte-&gt; short-&gt;int-&gt;long-&gt;float-&gt;double</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">тоесть
 если мы расширяем тип, то явное преобразование не требуется, приведение
 происходит автоматически. Если же мы сужаем, то необходимо явно 
указывать приведение типа.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">В
 случае же с объектами, то мы можем &nbsp;сделать автоматическое 
приведение от наследника к родителю, но никак &nbsp;не наоборот, тогда 
вылетит ClassCastException.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">&nbsp;Что такое статический класс, какие особенности его использования?</span></li>
</ul>
</h3>
</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статическим
 классом может быть только внутренний клас(определение класса 
размещается внутри другого класса). В объекте обычного внутреннего 
класса хранится ссылка на объект внешнего класса. Внутри статического 
внутреннего класса такой ссылки нет.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">То
 есть: Для создания объекта статического внутреннего класса не нужен 
объект внешнего класса. Из объекта статического вложенного класса нельзя
 обращаться к нестатическим членам внешнего класса напрямую. И еще 
обычные внутренние классы не могут содержать статические методы и члены.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Зачем
 вообще нужны внутренние классы? – Каждый внутренний класс способен 
независимо &nbsp;наследовать определенную реализацию. Таким образом 
внутренний класс не ограничен при наследовании в ситуациях, когда 
внешний класс уже наследует реализацию. То есть это как бы вариант 
решения проблемы множественного наследования.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<h3>
<ul style="text-align: left;">
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; text-align: justify;">Каким образом из вложенного класса получить доступ к полю внешнего класса.</span></li>
</ul>
</h3>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">
Если класс внутренний то: [ВнешнийКласс.this.ПолеВнешнегоКласса] 
 Если класс статический внутренний(вложенный),то в методе нужно создать объект 
внешнего класса, и получить доступ к его полю. 
Или второй вариант &nbsp;объявить это поле внешнего класса как &nbsp;static</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br>
</span></div>
<div style="text-align: justify;">
<h3>
<ul>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Какие существуют типы вложенных классов? Для чего они используются?&nbsp;</span></li>
</ul>
</h3>
</div>
table>tr$5>td
ul
<pre>
	Есть 2 вида ВЛОЖЕННЫХ КЛАССов [nested class]:
1) (СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС) [static nested class]
2) (ВНУТРЕННИЙ КЛАСС) - класс экземпляра [inner class]
	2.1 ОБЫЧНЫЙ ВНУТРЕННИЙ КЛАСС [inner class] (внутри внешнего класса, как объявление переменной)
	2.2 ЛОКАЛЬНЫЙ КЛАСС [local class]
	2.3 АНОНИМНЫЙ КЛАСС [anonymous class]
</pre>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Вложенные
 классы существуют внутри других классов. &nbsp;Нормальный класс - 
полноценный член пакета. Вложенные классы, которые стали доступны 
начиная с Java 1.1, могут быть четырех типов:</span></div>
<div style="text-align: justify;">

<ol>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">статические члены класса</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">члены класса</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">локальные классы</span></li>
<li><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">анонимные классы</span></li>
</ol>

</div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Статические
 члены классов (static nested classes)&nbsp;- как и любой другой 
статический метод, имеет доступ к любым статическим методам своего 
внешнего класса, в том числе и к приватным. К нестатическим полям и 
методам обрамляющего&nbsp;класса он не может обращатся напрямую. Он 
может использовать их только через ссылку на экземпляр класса родителя.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">
Члены класса - ?
<br>
 локальные классы, объявленные внутри блока кода. Эти классы видны только внутри блока.</span></div>
<div style="text-align: justify;">
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Анонимные классы - &nbsp;Эти типы классов не имеют имени и видны только внутри блока.</span><br>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<h3>
<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><a href="https://jsehelper.blogspot.nl/2016/01/java-core-2.html">Java core (часть 2).</a></span></h3>
</div></div></body></html>