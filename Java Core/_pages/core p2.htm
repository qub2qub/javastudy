<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Core p2</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>

<h3 style="text-align: left;">
<ul style="text-align: left;">
<li><b >Возможно ли при переопределении (override) метода изменить:&nbsp;</b></li>
</ul>
</h3>
<div>
<ol><ol>
<li><b>Модификатор доступа</b></li>
<li><b>Возвращаемый тип</b></li>
<li><b>Тип аргумента или количество</b></li>
<li><b>Имя аргументов</b></li>
<li><b>Изменять порядок, количество или вовсе убрать секцию throws?</b></li>
</ol>
</ol>
<ol>
<li>Да, если расширять (package -&gt; protected -&gt; public)</li>
<li>Да, если выполняется Upcasting (восходящее преобразование, преобразование вверх по иерархии)</li>
<li>Нет, в таком случае происходит Overload(перегрузка)</li>
<li>Да</li>
<li>Возможно 
изменять порядок. Возможно вовсе убрать секцию throws в методе, так как 
она уже определена. Так же возможно добавлять новые исключения, которые 
наследуются от объявленных или исключения времени выполнения.<a name="more"></a></li>
</ol>
</div>
<div>
Переопределение
 методов действует при наследовании классов, т.е. в классе наследнике 
объявлен метод с такой же сигнатурой что и в классе родителе. Значит 
этот метод переопределил метод своего суперкласса.</div>
<div>
Несколько нюансов по этому поводу:</div>
<div>
<ul>
<li>Модификатор доступа в методе класса наследника должен быть НЕ уже чем в классе родителе, иначе будет ошибка компиляции.</li>
<li>Описание 
исключения в переопределенном методе класса наследника должен быть НЕ 
шире чем в классе родителе, иначе ошибка компиляции.</li>
<li>Метод обьявленный как "private" в классе родителе нельзя переопределить!</li>
</ul>
</div>
<div>
<br></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li><b >Что такое autoboxing?</b></li>
</ul>
</h3>
<div>
Autoboxing/Unboxing
 - автоматическое преобразование между скалярными типами Java и 
соответствующими типами-врапперами (например, между int - Integer). 
Наличие такой возможности сокращает код, поскольку исключает 
необходимость выполнения явных преобразований типов в очевидных случаях.</div>
<div>
<br></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Что такое Generics?</li>
</ul>
</h3>
<div>
"Java Generics"
 - это технический термин, обозначающий набор свойств языка позволяющих 
определять и использовать обобщенные типы и методы. Обобщенные типы или 
методы отличаются от обычных тем, что имеют типизированные 
параметры.&nbsp;</div>
<div>
Примером 
дженериков или обобщенных типов может служить библитека с коллекциями в 
Java. Например, класс LinkedList&lt;E&gt; - типичный обобщенный тип. Он 
содержит параметр E, который представляет тип элементов, которые будут 
храниться в коллекции. Вместо того, чтобы просто использовать 
LinkedList, ничего не говоря о типе элемента в списке, мы можем 
использовать LinkedList&lt;String&gt; или LinkedList&lt;Integer&gt;. 
&nbsp;Создание объектов обобщенных типов происходит посредством замены 
параметризированных типов реальными типами данных. Класс типа 
LinkedList&lt;E&gt; - &nbsp;обобщенный тип, который содержит параметр E.
 Создание объектов, типа LinkedList&lt;String&gt; или 
LinkedList&lt;Integer&gt; называются параметризированными типами, а 
String и Integer - реальные типы аргументов.&nbsp;</div>
<div>
<br></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Какова истинная цель использования обобщенных типов в Java?&nbsp;</li>
</ul>
</h3>
<div>
Обобщенные типы в Java были изобретены, в первую очередь, для реализации обобщенных коллекций.</div>
<div>
<br></div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Каким образом передаются переменные в методы, по значению или по ссылке?</li>
</ul>
</h3>
<div>
В java 
параметры в методы передаются по значению, тоесть создаются копии 
параметров и с ними ведется работа в методе. В случае с примитивными 
типами, то при передачи параметра сама переменная не будет меняться так 
как в метод просто копируется ее значение.</div>
<div>
А вот при 
передачи объекта копируется ссылка на объект, тоесть если в методе мы 
поменяем состояние объекта, то и за методом состояние объекта тоже 
поменяется. Но если мы этой копии ссылки попытаемся присвоить новую 
ссылку на обьект, то старая ссылка у нас не изменится.</div>
<div>
&nbsp;В случае передачи по значению параметр копируется. Изменение параметра не будет заметно на вызывающей стороне.</div>
<div>
&nbsp;В Java объекты всегда передаются по ссылке, а примитивы - по значениюю.</div>
<div>
<br></div>
<h3>
<ul>
<li>Какие методы есть у класса Object?</li>
</ul>
</h3>
<div>
Object это 
базовый класс для всех остальных объектов в Java. Каждый класс 
наследуется от Object. Соответственно все классы наследуют методы класса
 Object.</div>
<div>
Методы класса Object:</div>
<div>
<ul>
<li>public final native Class getClass()</li>
<li>public native int hashCode()</li>
<li>public boolean equals(Object obj)</li>
<li>protected native Object clone() throws CloneNotSupportedException</li>
<li>public String toString()</li>
<li>public final native void notify()</li>
<li>public final native void notifyAll()</li>
<li>public final native void wait(long timeout) throws InterruptedException</li>
<li>public final void wait(long timeout, int nanos) throws InterruptedException</li>
<li>public final void wait() throws InterruptedException</li>
<li>protected void finalize() throws Throwable</li>
</ul>
</div>
<div>
<br></div>
<h3>
<div>
<ul>
<li>Правила переопределения метода Object.equals().</li>
</ul>
</div>
</h3>
<div>
<ol>
<li>Используйте
 оператор == что бы проверить ссылку на объект, переданную в метод 
equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно 
скорее для оптимизации, но может сэкономить время в случае "тяжёлых" 
сравнений.</li>
<li>Используйте оператор instanceof для проверки типа аргумента. Если типы не совпадают, вернуть false.&nbsp;</li>
<li>Преобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно.</li>
<li> Пройтись
 по всем значимым полям объектов и сравнить их друг с другом. Если все 
поля равны - вернуть true. Для сравнения простых типов использовать ==. 
Для полей со ссылкой на объекты использовать equals. float 
преобразовывать в int &nbsp;с помощью Float.floatToIntBits и сравнить с 
помощью ==. double преобразовывать в long &nbsp;с помощью 
Double.doubleToLongBits и сравнить с помощью ==. Для коллекций 
вышеперечисленные правила применяются к каждому элементу коллекции. 
Нужно учитывать возможность null полей/объектов. Очерёдность сравнения 
полей может существенно влиять на производительность.</li>
<li>Закончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и непротиворечивым.</li>
</ol>
</div>
<div>
И ещё несколько дополнительных правил.</div>
<div>
<ul>
<li>Переопределив equals, всегда переопределять hashCode.</li>
<li>Не использовать сложную семантику в equals (типа определения синонимов). equals должен сравнивать поля объектов, не более.</li>
</ul>
</div>
<div>
<br></div>
<h3>
<div>
<ul>
<li>Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?</li>
</ul>
</div>
</h3>
<div>
Метод equals() 
обозначает отношение эквивалентности объектов. Эквивалентным называется 
отношение, которое является симметричным, транзитивным и рефлексивным.</div>
<div>
<ul>
<li>Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;</li>
<li>Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true;</li>
<li>Симметричность:
 для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и 
только тогда, когда y.equals(x) вернет true.</li>
</ul>
</div>
<div>
Также для любого ненулевого x, x.equals(null) должно вернуть false.</div>
<div>
<br></div>
<h3>
<ul>
<li>Какая связь между hashCode и equals?</li>
</ul>
</h3>
<div>

<ol>
	<li>у равных объектов равны и хэшкоды 
	<br>
	[если a.equals(b) = true, тои a.hashCode == b.hashcode]
	</li>
	<li>если хэш коды равны - объекты могут быть разные (не равны)</li>
</ol>
Но необязательно что при равных хэшкодах, будут равны и объекты.
<br>
Т.е. два различных(не равных) объекта могут вернуть одинаковые хэш коды (такая ситуация называется <b>коллизией</b>).
</div>
<div>
<br></div>
<h3>
<ul>
<li>Каким образом реализованы методы hashCode и equals в классе Object?</li>
</ul>
</h3>
<div>
Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-5SRDB4axCyg/V52iqtKtUMI/AAAAAAAAA-k/jzSn4sS6Cb0thMqMRy0uwCw66aDAqW2cACLcB/s1600/q034_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q034_p01.jpg" height="67" border="0" width="640"></a></div>
</div>
<div>
Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java-кода:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-WRFZ5qRDdoQ/V52iz-DOgcI/AAAAAAAAA-o/Pl2DW5dJOOcTg09J57HbJqSNF2pnGlZ2wCLcB/s1600/q034_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q034_p02.jpg" height="26" border="0" width="640"></a></div>
Он обычно возвращает адрес объекта в памяти.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?</li>
</ul>
</h3>
</div>
<div>

[тут чел погнал походу]
Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet.</div>
<div>
Например 
HashSet хранит элементы в случайном (на первый взгляд) порядке. Дело в 
том, что для быстрого поиска HashSet расчитывает для каждлого элемента 
hashCode и именно по этому ключу ищет и упорядочивает элементы внутри 
себя</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?</li>
</ul>
</h3>
</div>
<div>
Есть. 
Необходимо использовать уникальные, лучше примитивные поля, такие как 
id, uuid, например. Причем, если эти поля задействованы при вычислении 
hashCode, то нужно их задействовать при выполнении equals.</div>
<div>
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.<br>
<br></div>
<div>
<h3>
<div>
<ul>
<li>Для чего нужен метод hashCode()?</li>
</ul></div>
</h3>
</div>
<div>
Для ускорения работы при, например, добавлении объекта в коллекция.
Хэшкод быстрее вычисляется, чем если бы сравнивать объекты.
<br>
Существуют  коллекции(HashMap, HashSet), которые используют хэш код, как основу при работе с объектами. А если хэш для равных объектов будет разным[это уже само по себе ошибка], то в  HashMap <strike>будут два равных значения, что является ошибкой</strike> [чел погнал. в этом случае они просто попадут в 1 бакет и в линкед лист]. <br> 
[сначала ищется бакет по хэшкоду, потом если хэшкоды одинаковые ключи сравниваются по equals.]
<br> 
Поэтому необходимо соответствующим образом переопределить метод hashCode().</div>
<div>
Х &nbsp; 
<b>Хеширование</b> - преобразование входного массива данных произвольной длины в
 выходную битовую строку фиксированной длины. Такие преобразования также
 называются хеш-функциями или функциями свёртки, а их результаты 
называют <b>хешем или хеш-кодом</b>.</div>
<div>
 <b>Хеш-таблица</b> -
 это структура данных, реализующая интерфейс ассоциативного массива, а 
именно, она позволяет хранить пары (ключ, значение) и выполнять три 
операции: операцию добавления новой пары, операцию поиска и операцию 
удаления пары по ключу.</div>
<div>
Выполнение 
операции в хеш-таблице начинается с вычисления хеш-функции от ключа. 
Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H.
 Затем выполняемая операция (добавление, удаление или поиск) 
перенаправляется объекту, который хранится в соответствующей ячейке 
массива H[i].</div>
<div>
Одним из 
методов построения хеш-функции есть метод деления с остатком (division 
method) состоит в том, что ключу k ставится в соответствие остаток от 
деления k на m, где m - число возможных хеш-значений.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Правила переопределения метода Object.hashCode().</li>
</ul>
</h3>
</div>
<div>
При реализации 
hashCode используется несколько простых правил. Прежде всего, при 
вычислении хеш-кода следует использовать те же поля, которые 
сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для 
равных обектов, во-вторых, распределено полученное значение будет точно 
так же, как и исходные данные. Теоретически, можно сделать так, чтобы 
хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. 
Другое дело, что ее ценность будет равна тому же самому нулю.</div>
<div>
Далее. Несмотря
 на то, что хеш-коды равных объектов должны быть равны, обратное 
неверно! Два неравных объекта могут иметь равные хеш-коды. Решающее 
значение имеет не уникальность, а скорость вычисления, потому как это 
приходится делать очень часто. Потому, в некоторых случаях имеет смысл 
посчитать хеш-код заранее и просто выдавать его по запросу. Прежде всего
 это стоит делать тогда, когда вычисление трудоемко, а объект неизменен.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Расскажите про клонирование объектов. В чем отличие между поверхностным и глубоким клонированием?</li>
</ul>
</h3>
</div>
<div>
Чтобы объект 
можно было клонировать, он должен реализовать интерфейс 
Cloneable(маркер). Использование этого интерфейса влияет на поведение 
метода "clone" класс Object. Таким образом&nbsp;</div>
<div>
myObj.clone() создаст нам клон нашего объекта, но этот клон будет поверхностный.</div>
<div>
Что значит поверхностным? Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются!</div>
<div>
Для того, чтоб 
произвести глубокое клонирование, необходимо в клонируемом классе 
переопределить метод clone() и в нем произвести клонирование изменяемых 
полей объекта.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Правила переопределения метода Object.clone().</li>
</ul>
</h3>
</div>
<div>
Метод clone() в
 Java используется для клонирования объектов. Т.к. Java работает с 
объектами с помощью ссылок, то простым присваиванием тут не обойдешься, 
ибо в таком случае копируется лишь адрес, и мы получим две ссылки на 
один и тот же объект, а это не то, что нам нужно. Механизм копирования 
обеспечивает метод clone() класса Object.</div>
<div>
&nbsp;clone() 
действует как конструктор копирования. Обычно он вызывает метод clone() 
суперкласса и т.д. пока не дойдет до Object.</div>
<div>
&nbsp;Метод 
clone() класса Object создает и возвращает копию объекта с такими же 
значениями полей. Object.clone() кидает исключение 
CloneNotSupportedException если вы пытаетесь клонировать объект не 
реализующий интерфейс Cloneable. Реализация по умолчанию метода 
Object.clone() выполняет неполное/поверхностное (shallow) копирование. 
Если вам нужно полное/глубокое (deep) копирование класса то в методе 
clone() этого класса, после получения клона суперкласса, необходимо 
скопировать нужные поля.</div>
<div>
&nbsp;Синтаксис вызова clone() следующий:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-VS9Ph1WJaZk/V52j7dRvZ_I/AAAAAAAAA-0/l3tDDk1rsu45f8EjzU-AZzikmVvp-Wk-ACLcB/s1600/q040_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q040_p01.jpg" height="30" border="0" width="640"></a></div>
&nbsp;или чаще:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-_8ET5OheTHg/V52kSd45rWI/AAAAAAAAA-8/kvWvrCEq0VgAj0afvsl08xC2V30Y5OicwCLcB/s1600/q040_p02.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q040_p02.jpg" height="26" border="0" width="640"></a></div>
&nbsp;Один из 
недостатков метода clone(), это тот факт, что возвращается тип Object, 
поэтому требуется нисходящее преобразование типа. Однако начиная с 
версии Java 1.5 при переопределении метода вы можете сузить возвращаемый
 тип.</div>
<div>
&nbsp;Пару слов о clone() и final полях.</div>
<div>
&nbsp;Метод 
clone() несовместим с final полями. Если вы попробуете клонировать final
 поле компилятор остановит вас. Единственное решение - отказаться от 
final.</div>
<div>
&nbsp;Ну и пример использования clone():<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-kNerO5PAWMI/V52kxm5A_fI/AAAAAAAAA_U/sh1UHOUbMyEYikGPvbMM-X_U_QZqQCEGgCEw/s1600/q040_p03.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q040_p03.jpg" height="354" border="0" width="640"></a></div>
&nbsp;Консоль:</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-4jznYjVR3CE/V52lLdqcWyI/AAAAAAAAA_Q/c1UgZdztQvwZFi6S4iwGOeAMl7dqudHlQCLcB/s1600/q040_p04.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q040_p04.jpg" height="46" border="0" width="640"></a></div>
&nbsp;Как видите, изменение объекта a повлекло за собой изменение объекта c, а вот с b всё в порядке.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Где и как вы можете использовать &nbsp;закрытый конструктор?</li>
</ul>
</h3>
</div>
<div>
Например в 
качестве паттерна Синглетон. В том же классе создается статический 
метод. Где и создается экземпляр класса, конечно если он уже не создан, 
тогда он просто возвращается методом.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Что такое конструктор по умолчанию?</li>
</ul>
</h3>
</div>
<div>
В Java если нет
 явным образом опредёленных конструкторов в классе, то компилятор 
использует конструктор по умолчанию, опредёленный неявным способом, 
который аналогичен "чистому", конструктору по умолчанию. Конструктор по 
умолчанию - это довольно простая конструкция, которая сводится к 
созданию для типа конструктора без параметров. Так, например, если при 
объявлении нестатического класса не объявить пользовательский 
конструктор (не важно, с параметрами или без них), то компилятор 
самостоятельно сгенерирует конструктор без параметров. Некоторые 
программисты явным образом задают конструктор по умолчанию по привычке, 
чтобы не забыть в дальнейшем, но это не обязательно</div>
<div>
В Java если 
производный класс не вызывает явным образом конструктор базового класса 
(в Java используя super() в первой строчке), то конструктор по умолчанию
 вызывается неявно. Если базовый класс не имеет конструктора по 
умолчанию, то это считается ошибкой.<br>
<br></div>
<div>
<h3>
<ul>
<li>Опишите метод Object.finalize().</li>
</ul>
</h3>
</div>
<div>
Метод 
finalize(). Java обеспечивает механизм, который является аналогичным 
использованию деструкторов в С ++, который может использоваться для 
того, чтобы произвести процесс очистки перед возвращением управления 
операционной системе.&nbsp;</div>
<div>
Применяя метод 
finalize(), можно определять специальные действия, которые будут 
выполняться тогда, когда объект будет использоваться сборщиком мусора. 
Данный метод вызывается при уничтожении объекта автоматическим сборщиком
 мусора (garbage collector). В классе Object он ничего не делает, однако
 в классе-наследнике позволяет описать все действия, необходимые для 
корректного удаления объекта, такие как закрытие соединений с БД, 
сетевых соединений, снятие блокировок на файлы и т.д. В обычном режиме 
напрямую этот метод вызывать не нужно, он отработает автоматически. Если
 необходимо, можно обратиться к нему явным образом.</div>
<div>
Его синтаксис:&nbsp;</div>
<div>
protected void finalize( ) throws Throwable&nbsp;</div>
<div>
Ссылки не являются собранным мусором; только объекты - собранный мусор.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Чем отличаются слова final, finally и finalize?</li>
</ul>
</h3>
</div>
<div>
final - Нельзя наследоваться от файнал класса. Нельзя переопределить файнал метод. Нельзя изменить сначение файнал поля.</div>
<div>
finally - 
используется при обработке ошибок, вызывается всегда, даже если 
произошла ошибка(кроме System.exit(0)). Удобно использовать для 
освобождения ресурсов.</div>
<div>
<div>
finalize() - 
вызывается перед тем как сборщик мусора будет проводить освобождение 
памяти. Не рекомендуется использовать для освобождения системных 
ресурсов, так как не известно когда сборщик мусора будет производить 
свою очистку. Вообще данный метод мало кто использует. Единственно что 
можно использовать этот метод для закрытия ресурса что должен работать 
на протяжении всей работы программы и закрываться по ее окончанию. Еще 
можно использовать метод для защиты от так называемых «дураков», 
проверять, освобождены ли ресурсы, если нет, то закрыть их.<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/01/java-core-3.html">Java core (часть 3).</a></h3>
	

</div></div></body></html>