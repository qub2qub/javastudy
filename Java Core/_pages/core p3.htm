<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Core p3</title>
<link rel="stylesheet" href="../../Git Guide/grey.css">
</head>
<body>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Опишите иерархию исключений.</li>
</ul>
</h3>
<div>
Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object.&nbsp;<br>
У класса Throwable и у всех его расширений по традиции два конструктора: &nbsp;</div>
<div>
<ul>
<li>Throwable о - конструктор по умолчанию;&nbsp;</li>
<li>Throwable (String message) - создаваемый объект будет содержать произвольное сообщение message.&nbsp;</li>
</ul>
</div>
<div>
Записанное
 в конструкторе сообщение можно получить затем методом getMessage (). 
Если объект создавался конструктором по умолчанию, то данный метод 
возвратит null.&nbsp;<br>
Метод toString возвращает краткое описание события, именно он работал в предыдущих листингах.&nbsp;</div>
<div>
Три метода выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:&nbsp;</div>
<div>
<ul>
<li>printstackTrace() -&nbsp;выводит сообщения в стандартный вывод, как правило, это <a name="more"></a>консоль;&nbsp;</li>
<li>printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream;&nbsp;</li>
<li>printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.&nbsp;</li>
</ul>
</div>
<div>
У
 класса Throwable два непосредственных наследника - классы Error и 
Exception. Они не добавляют новых методов, а служат для разделения 
классов-исключений на два больших семейства - семейство классов-ошибок 
(error) и семейство собственно классов-исключений (exception).&nbsp;</div>
<div>
Классы-ошибки,
 расширяющие класс Error, свидетельствуют о возникновении сложных 
ситуаций в виртуальной машине Java. Их обработка требует глубокого 
понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в 
обычной программе. Не советуют даже выбрасывать ошибки оператором throw.
 He следует делать свои классы-исключения расширениями класса Error или 
какого-то его подкласса.&nbsp;</div>
<div>
&nbsp;Имена классов-ошибок, по соглашению, заканчиваются словом Error.&nbsp;</div>
<div>
Классы-исключения,
 расширяющие класс Exception, отмечают возникновение обычной нештатной 
ситуации, которую можно и даже нужно обработать. Такие исключения 
следует выбросить оператором throw. Классов-исключений очень много, 
более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В 
большинстве случаев вы способны подобрать готовый класс-исключение для 
обработки исключительных ситуаций в своей программе. При желании можно 
создать и свой класс-исключение, расширив класс Exception или любой его 
подкласс.&nbsp;</div>
<div>
&nbsp;Среди
 классов-исключений выделяется класс RuntimeException - прямое 
расширение класса Exception. В нем и его подклассах отмечаются 
исключения, возникшие при работе JVM, но не столь серьезные, как ошибки.
 Их можно обрабатывать и выбрасывать, расширять своими классами, но 
лучше доверить это JVM, поскольку чаще всего это просто ошибка в 
программе, которую надо исправить. Особенность исключений данного класса
 в том, что их не надо отмечать в заголовке метода пометкой 
throws.&nbsp;</div>
<div>
&nbsp;Имена классов-исключений, по соглашению, заканчиваются словом Exception.</div>
<div>
</div>
<div>
<br></div>
<h3 style="text-align: left;">
<div>
<ul style="text-align: left;">
<li>Какие виды исключений в Java вы знаете, чем они отличаются?&nbsp;</li>
</ul>
</div>
</h3>
<div>
Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked).</div>
<div>
Все
 исключения, порождаемые от Throwable, можно разбить на три группы. Они 
определяются тремя базовыми типами: наследниками Throwable - классами 
Errorи Exception, а также наследником Exception - RuntimeException.</div>
<div>
Ошибки,
 порожденные от Exception (и не являющиеся наследниками RuntimeException
 ), являются проверяемыми. Т.е. во время компиляции проверяется, 
предусмотрена ли обработка возможных исключительных ситуаций. Как 
правило, это ошибки, связанные с окружением программы (сетевым, файловым
 вводом-выводом и др.), которые могут возникнуть вне зависимости от 
того, корректно написан код или нет. Например, открытие сетевого 
соединения или файла может привести к возникновению ошибки и компилятор 
требует от программиста предусмотреть некие действия для обработки 
возможных проблем. Таким образом повышается надежность программы, ее 
устойчивость при возможных сбоях.</div>
<div>
Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки.</div>
<div>
Как
 правило, это ошибки программы, которые при правильном кодировании 
возникать не должны (например, IndexOutOfBoundsException- выход за 
границы массива, java.lang.ArithmeticException- деление на ноль). 
Поэтому, чтобы не загромождать программу, компилятор оставляет на 
усмотрение программиста обработку таких исключений с помощью блоков 
try-catch.</div>
<div>
Исключения,
 порожденные от Error, также не являются проверяемыми. Они предназначены
 для того, чтобы уведомить приложение о возникновении фатальной 
ситуации, которую программным способом устранить практически невозможно 
(хотя формально обработчик допускается). Они могут свидетельствовать об 
ошибках программы, но, как правило, это неустранимые проблемы на уровне 
JVM. В качестве примера можно привести StackOverflowError (переполнение 
стека), OutOfMemoryError (нехватка памяти).</div>
<div>
Методы,
 код которых может порождать проверяемые исключения, должны либо сами их
 обрабатывать, либо в заголовке метода должно быть указано ключевое 
слово throws с перечислением необрабатываемых проверяемых исключений. На
 непроверяемые ошибки это правило не распространяется.</div>
<div>
Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода.</div>
<div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Что такое checked и unchecked Exception?</li>
</ul>
</h3>
<div>
Checked
 исключения, это те, которые должны обрабатываться блоком catch или 
описываться в сигнатуре метода. Unchecked могут не обрабатываться и не 
быть описанными.</div>
<div>
&nbsp;Unchecked исключения в Java - наследованные от RuntimeException, Checked - от Exception.</div>
<div>
&nbsp;Пример unchecked исключения - NullPointerException, checked исключения - IOException.</div>
<div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Как создать свой unchecked Exception?</li>
</ul>
</h3>
<div>
Унаследоваться от RuntimeException.</div>
<div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Какие есть Unchecked exeption?</li>
</ul>
</h3>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-QlWwhPtfQ4E/V53E6Oyx4bI/AAAAAAAAA_w/VDXBUiPjDBwW39LaPJ6ZqL7fmzhHUPviACLcB/s1600/q049_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q049_p01.jpg" height="282" border="0" width="640"></a></div>
<br></div>
<h3>
<ul>
<li>Что такое Error?</li>
</ul>
</h3>
<div>
Исключения,
 порожденные от Error, не являются проверяемыми. Они предназначены для 
того, чтобы уведомить приложение о возникновении фатальной ситуации, 
которую программным способом устранить практически невозможно (хотя 
формально обработчик допускается). Они могут свидетельствовать об 
ошибках программы, но, как правило, это неустранимые проблемы на уровне 
JVM. В качестве примера можно привести StackOverflowError (переполнение 
стека), OutOfMemoryError (нехватка памяти).</div>
<div>
Методы,
 код которых может порождать проверяемые исключения, должны либо сами их
 обрабатывать, либо в заголовке метода должно быть указано ключевое 
слово throws с перечислением необрабатываемых проверяемых исключений. На
 непроверяемые ошибки это правило не распространяется.</div>
<div>
<br></div>
<div>
</div>
<div>
</div>
<h3 style="text-align: left;">
<div>
<ul style="text-align: left;">
<li>Опишите работу блока try-catch-finally.</li>
</ul>
</div>
</h3>
<div>
Если срабатывает один из блоков catch, то остальные блоки в данной конструкции try-catch выполняться не будут.</div>
<div>
Cвойством
 транзакционности исключения не обладают - действия, произведенные в 
блоке try до возникновения исключения, не отменяются поcле его 
возникновения.</div>
<div>
</div>
<div>
<br></div>
<div>
</div>
<h3 style="text-align: left;">
<ul style="text-align: left;">
<li>Возможно ли использование блока try-finally (без catch)?</li>
</ul>
</h3>
<div>
try
 может быть в паре с finally, без catch. Работает это точно так же - 
после выхода из блока try выполняется блок finally. Это может быть 
полезно, например, в следующей ситуации. При выходе из метода вам надо 
произвести какое-либо действие. А return в этом методе стоит в 
нескольких местах. Писать одинаковый код перед каждым return 
нецелесообразно. Гораздо проще и эффективнее поместить основной код в 
try, а код, выполняемый при выходе - в finally.</div>
<div>
</div>
<div>
<br></div>
<div>
</div>
<h3>
<ul>
<li>Всегда ли исполняется блок finally?</li>
</ul>
</h3>
<div>
Не всегда например в следующих ситуациях:</div>
<div>
<ol>
<li>Существуют
 потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом
 режиме во время выполнения программы, но при этом не являются ее 
неотъемлеммой частью.Таким образом когда все потоки не демоны 
завершаются, программа завершает свою работу. В потоках демонах блок 
finally не выполняеться, они прерываются внезапно.</li>
<li>System.exit(0)</li>
<li>если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся.</li>
</ol>
<br></div>
<h3>
<div>
<ul>
<li>Какие есть оссобенности класса String? что делает метод intern().</li>
</ul>
</div>
</h3>
<div>
<ol>
<li>Внутреннее
 состояние класса String нельзя изменить после его создания, т.е. этот 
класс неизменяемый (immutable) поэтому когда вы пишете String str = 
"One" + "Two"; создается три! объекта класса String.&nbsp;</li>
<li>От него нельзя унаследоваться, потому что класс String объявлен как final: public final class String</li>
<li>Метод hashCode класса String переписан и возвращает: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&nbsp;</li>
<li>У класса String есть метод public String intern(), который сохраняет/переносит  строку во  внутренний пул строк (в permGen) если её там не было, и тогда вместо String.equals() можно использовать ==.</li>
</ol>
</div>
<div>
Понятно, что оператор сравнения ссылок выполняется гораздо быстрее, чем посимвольное сравнение строк.</div>
<div>
Используют в основном, где приходится сравнивать много строк, например в каких нибудь XML парсерах.</div>
<div>
А
 вообще по увеличению производительности ещё вопрос. Ибо метод intern() 
тогда должен выполняться быстрее чем equals(), каждый раз когда вы 
вызываете метод intern() просматривается пул строк на наличие такой 
строки и если такая уже есть в пуле, то возвращается ссылка на 
нее.Сравниваются они через equal().<br>
<br>
<h3>
<ul>
<li>Можно ли наследовать строковый тип, почему?</li>
</ul>
</h3>
Классы объявлены final, поэтому наследоваться не получится.<br>
<br>
<h3>
<ul>
<li>Почему строка является популярным ключом в HashMap в Java?</li>
</ul>
</h3>
Поскольку
 строки неизменны, их хэшкод кэшируется в момент создания, и не требует 
повторного пересчета. Это делает строки отличным кандидатом для ключа в 
Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот 
почему строки преимущественно используются в качестве ключей HashMap.<br>
<br>
<h3>
<ul>
<li>Дайте определение понятию конкатенация строк.</li>
</ul>
</h3>
Конкатенация
 - операция объединения строк. Результатом является объединения второй 
строки с окончанием первой. Операция конкатенации могут быть выполнены 
так:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-j6GwZqFaVKY/WFZbyLVzAXI/AAAAAAAABY8/Wn1_LKFH4a0FGPQFsYPmXO-qHeri4Is8ACLcB/s1600/q057_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q057_p01.jpg" height="226" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как перевернуть строку?</li>
</ul>
</h3>
Один из способов как это можно сделать:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-7T2vD56wZr0/WFZcEe_m8cI/AAAAAAAABZA/YPq6RKUA23Eqv0Lrp2_m0MFMhUc1ulO5gCLcB/s1600/q058_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q058_p01.jpg" height="74" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как сравнить значение двух строк?</li>
</ul>
</h3>
Строка
 в Java - это отдельный объект, который может не совпадать с другим 
объектом, хотя на экране результат выводимой строки может выглядеть 
одинаково. Оператор == (а также !=) работает с ссылками объекта String. 
Если две переменные String указывают на один и тот же объект в памяти, 
сравнение вернет результат true. В противном случае результат будет 
false, несмотря на то что текст может содержать в точности такие же 
символы.<br>
Для сравнения посимвольно на эквивалентность необходимо использовать метод equals().<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-IhaS3Rh2C0o/WFZcWWrf8bI/AAAAAAAABZE/Au4NbI-_r6UxFWQCAJoEJIOBXly3sicrgCLcB/s1600/q059_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q059_p01.jpg" height="256" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как обрезать пробелы в начале и конце строки?</li>
</ul>
</h3>
Небольшой пример:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-hA19Kfjr_cs/WFZcnECbZNI/AAAAAAAABZM/Y2EX8uo9qTcCcaZWXq7ARwlhCcJKJF0AwCLcB/s1600/q060_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q060_p01.jpg" height="62" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Дайте определение понятию "пул строк".</li>
</ul>
</h3>
Пул
 строк - это набор строк, который хранится в памяти Java heap. Мы знаем,
 что String это специальный класс в Java, и мы можем создавать объекты 
этого класса, используя оператор new точно так же, как и создавать 
объекты, предоставляя значение строки в двойных кавычках.<br>
Диаграмма
 ниже объясняет, как пул строк размещается в памяти Java heap и что 
происходит, когда мы используем различные способы создания строк.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-OfL0KRTcM_0/WFZc9dMhJ0I/AAAAAAAABZU/FCpwxFTKfMMqgJtf_2z701AzYBAZ1sv3QCLcB/s1600/q061_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q061_p01.jpg" height="354" border="0" width="640"></a></div>
Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.<br>
Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.<br>
Когда
 мы используем двойные кавычки для создания строки, сначала ищется 
строка в пуле с таким же значением, если находится, то просто 
возвращается ссылка, иначе создается новая строка в пуле, а затем 
возвращается ссылка.<br>
Тем
 не менее, когда мы используем оператор new, мы принуждаем класс String 
создать новый объект строки, а затем мы можем использовать метод 
intern() для того, чтобы поместить строку в пул, или получить из пула 
ссылку на другой объект String с таким же значением.<br>
<br>
<h3>
<ul>
<li>Можно ли синхронизировать доступ к строке?</li>
</ul>
</h3>
String сам по себе потокобезопасный класс. Если мы мы работаем с изменяемыми строками, то нужно использовать StringBuffer.<br>
<br>
<h3>
<ul>
<li>Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?</li>
</ul>
</h3>
Привести их к одному типу и сравнить.<br>
<br>
<h3>
<ul>
<li>Почему строка неизменная и финализированная в Java?</li>
</ul>
</h3>
Есть несколько преимуществ в неизменности строк:<br>
<ul>
<li>Строковый
 пул возможен только потому, что строка неизменна в Java, таким образом 
виртуальная машина сохраняет много места в памяти(heap space), поскольку
 разные строковые переменные указывают на одну переменную в пуле. Если 
бы строка не была неизмененяемой, тогда бы интернирование строк не было 
бы возможным, потому что если какая-либо переменная изменит значение, 
это отразится также и на остальных переменных, ссылающихся на эту 
строку.</li>
<li>Если
 строка будет изменяемой, тогда это станет серьезной угрозой 
безопасности приложения. Например, имя пользователя базы данных и пароль
 передаются строкой для получения соединения с базой данных и в 
программировании сокетов реквизиты хоста и порта передаются строкой. Так
 как строка неизменяемая, её значение не может быть изменено, в 
противном случае любой хакер может изменить значение ссылки и вызвать 
проблемы в безопасности приложения.</li>
<li>Строки
 используются в Java classloader и неизменность обеспечивает 
правильность загрузки класса при помощи Classloader. К примеру, 
задумайтесь об экземпляре класса, когда вы пытаетесь загрузить 
java.sql.Connection класс, но значение ссылки изменено на 
myhacked.Connection класс, который может осуществить нежелательные вещи с
 вашей базой данных.</li>
<li>Поскольку
 строка неизменная, её hashcode кэшируется в момент создания и нет 
необходимости рассчитывать его снова. Это делает строку отличным 
кандидатом для ключа в Map и его обработка будет быстрее, чем других 
ключей HashMap. Это причина, почему строка наиболее часто используемый 
объект, используемый в качестве ключа HashMap.</li>
</ul>
<br><ul>
</ul>
<h3>
<ul>
<li>Напишите метод удаления данного символа из строки.</li>
</ul>
</h3>
Мы
 можем использовать метод replaceAll для замены всех вхождений в строку 
другой строкой. Обратите внимание на то, что метод получает в качестве 
аргумента строку, поэтому мы используем класс Character для создания 
строки из символа, и используем её для замены всех символов на пустую 
строку.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-n592gK_Is_M/WFZdeeHj6sI/AAAAAAAABZc/du3_P4z7Bs4SwgIYKGOzVlzCx_D2gsTEwCLcB/s1600/q065_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q065_p01.jpg" height="54" border="0" width="640"></a></div>
<br>
<h3>
<a href="https://jsehelper.blogspot.com/2016/12/java-core-4.html">Java core (часть 4).</a></h3>	

</div></body></html>