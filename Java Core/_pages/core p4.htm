<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Core p4</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
<h3>
<ul style="text-align: left;">
<li style="text-align: left;">Что такое рефлексия?</li>
</ul>
</h3>

<div>
<div>
Рефлексия
 используется для получения или модификации информации о типах во время 
выполнения программы. Этот механизм позволяет получить сведения о 
классах, интерфейсах, полях, методах, конструкторах во время исполнения 
программы. При этом не нужно знать имена классов, методов или 
интерфейсов. Также этот механизм позволяет создавать новые объекты, 
выполнять методы и получать и устанавливать значения полей.</div>
</div>
<div>
</div>
<div>
<div>
<div>
<br></div>
</div>
</div>
<div>
<h3>
<ul style="text-align: left;">
<li style="text-align: left;">Что произойдет со сборщиком мусора (GC), если во время выполнения метода finalize() некоторого объекта произойдет исключение?</li>
</ul>
</h3>
</div>
<div>
<div>
Во
 время старта JVM запускается поток finalizer, который работает в фоне. 
Этот поток имеет метод runFinalizer, который игнорирует все исключения 
методов finalize объектов перед сборкой мусора.</div>
</div>
<div>
<div>
То
 есть если во время выполнения метода finalize возникнет исключительная 
ситуация, его выполнение будет остановлено и это никак не скажется на 
работоспособности самого сборщика мусора (garbage collector).</div>
</div>
<div>
</div>
<div>
<div>
<div>
<br></div>
</div>
</div>
<div>
</div>
<h3>
<ul>
<li>Что такое интернационализация, локализация?</li>
</ul>
</h3>
<div>
<div>
Интернационализация
 (internationalization, а для краткости - i18n) - такой способ создания 
приложений, при котором их можно легко адаптировать для разных 
аудиторий, говорящих на разных языках.</div>
</div>
<div>
<div>
<div>
Локализацияlocalization
 а для краткости - l10n) - &nbsp;адаптация интерфейса приложения под 
несколько языков. Добавление нового языка может внести определенные 
сложности в локализацию интерфейса.</div>
</div>
<br>
<h3>

<ul>
<li>Что такое Аннотации в Java?</li>
</ul>
</h3>


<div>
<div>
Аннотации
 - это своего рода метатеги, которые добавляются к коду и применяются к 
объявлению пакетов, классов, конструкторов, методов, полей, параметров и
 локальных переменных. Аннотации всегда обладают некоторой информацией и
 связывают эти "дополнительные данные" и все перечисленные конструкции 
языка.</div>
</div>
<div>
<div>
Фактически
 аннотации представляют собой их дополнительные модификаторы, применение
 которых не влечет за собой изменений ранее созданного кода.</div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие функции выполняет Аннотации?</li>
</ul>
</h3>
<div style="text-align: left;">
Аннотация выполняет следующие функции:</div>
<div>
</div>
<ol>
<li>дает необходимую информацию для компилятора;</li>
<li>дает информацию различным инструментам для генерации другого кода, конфигураций и т. д.;</li>
<li>может использоваться во время работы кода;</li>
</ol>
<div style="text-align: left;">
Самая часто встречаемая аннотация, которую встречал любой программист, даже начинающий это @Override.</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие встроенные аннотации в Java вы знаете?</li>
</ul>
</h3>
<div>
<br></div>
<div>
<div>
В
 языке Java SE определено несколько встроенных аннотаций, большинство из
 их являются специализированными. Четыре типа @Retention, @Documented, 
@Target и @Inherited - из пакета java.lang.annotation.</div>
</div>
<div>
<div>
Из
 оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и 
@SuppressWarnings - из пакета java.lang. Широкое использование аннотаций
 в различных технологиях и фреймворках обуславливается возможностью 
сокращения кода и снижения его связанности.</div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Что делают аннотации @Retention, @Documented, @Target и @Inherited?</li>
</ul>
</h3>
<div style="text-align: left;">
Эти аннотации, имеют следующее значение:</div>
<div>
</div>
<ul>
<li>@Retention
 - эта аннотация предназначена для применения только в качестве 
аннотации к другим аннотациям, позволяет указать жизненный цикл 
аннотации: будет она присутствовать только в исходном коде, в 
скомпилированном файле, или она будет также видна и в процессе 
выполнения. Выбор нужного типа зависит от того, как вы хотите 
использовать аннотацию.&nbsp;</li>
<li>@Documented - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована.</li>
<li>@Target
 - эта аннотация задает тип объявления, к которым может быть применима 
аннотация. Принимает один аргумент, который должен быть константой из 
перечисления ElementType, это может быть поле, метод, тип и т.д. 
Например, чтобы указать, что аннотация применима только к полям и 
локальным переменным: @Targer({ ElementType.FIELD, 
ElementTyle.LOCAL_VARIABLE } )</li>
<li>@Inherited
 - это аннотация-маркер, которая может применяться в другом объявление 
аннотации, она касается только тех аннотаций, что будут использованы в 
объявлениях классов. Эта аннотация позволяет аннотации супер класса быть
 унаследованной в подклассе.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Что делают аннотации @Override, @Deprecated, @SafeVarargs и @SuppressWarnings?</li>
</ul>
</h3>
<div style="text-align: left;">
Эти аннотации предназначены для:</div>
<div>
</div>
<ul>
<li>@Override
 - аннотация-маркер, которая может применяться только к методам. Метод, 
аннотированный как @Override, должен переопределять метод супер класса.</li>
<li>@Deprecated - указывает, что объявление устарело и должно быть заменено более новой формой.</li>
<li>@SafeVarargs
 - аннотация-маркер, применяется к методам и конструкторам. Она 
указывает, что никакие небезопасные действия, связанные с параметром 
переменного количества аргументов, недопустимы. Применяется только к 
методам и конструкторам с переменным количеством аргументов, которые 
объявлены как static или final.</li>
<li>@SuppressWarnings
 - эта аннотация указывает, что одно или более предупреждений, которые 
могут быть выданы компилятором следует подавить.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Какой жизненный цикл аннотации можно указать с помощью @Retention?</li>
</ul>
</h3>
<div style="text-align: left;">
Существует
 3 возможные варианты чтобы указать где аннотация будет жить. Они 
инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это
 SOURSE, CLASS, RUNTIME.</div>
<div>
</div>
<ul>
<li>SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.</li>
<li>CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.</li>
<li>RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения.</li>
</ul>
<br>
<h3>
<ul>
<li>К каким элементам можно применять аннотацию, как это указать?</li>
</ul>
</h3>
<div style="text-align: left;">
Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для этого существует аннотация @Target.</div>
<div>
</div>
<ul>
<li>@Target(ElementType.PACKAGE) - только для пакетов;</li>
<li>@Target(ElementType.TYPE) - только для классов;</li>
<li>@Target(ElementType.CONSTRUCTOR) - только для конструкторов;</li>
<li>@Target(ElementType.METHOD) - только для методов;</li>
<li>@Target(ElementType.FIELD) - только для атрибутов(переменных) класса;</li>
<li>@Target(ElementType.PARAMATER) - только для параметров метода;</li>
<li>@Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.</li>
</ul>
<div style="text-align: left;">
В
 случае если вы хотите, что бы ваша аннотация использовалась больше чем 
для одного типа параметров, то можно указать @Target следующим образом:</div>
<div class="separator" style="clear: both; text-align: justify;">
<a href="https://2.bp.blogspot.com/-CboLSOAq738/WFZe2IHPu4I/AAAAAAAABZo/8Ve01jYOIbs51q2u9k7HeflD1H5PMTm5wCLcB/s1600/q075_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q075_p01.jpg" height="26" border="0" width="640"></a></div>
<div>
<div>
тут мы говорим, аннотацию можно использовать только для параметров метода и для локальных переменных.</div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Как создать свою Аннотацию?</li>
</ul>
</h3>
<div style="text-align: left;">
Написать свою аннотацию не так сложно, как могло бы казаться. В следующем коде приведено объявление аннотации.</div>
<div class="separator" style="clear: both; text-align: justify;">
<a href="https://3.bp.blogspot.com/-uWMuBQOhugI/WFZfBrgWBjI/AAAAAAAABZs/x8RThSF9YOAcsF2FYKWk4m8wU9i149MpgCLcB/s1600/q076_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="JavaCore_files/q076_p01.jpg" height="64" border="0" width="640"></a></div>
<div>
<div>
<div>
как вы видите на месте где обычно пишут class или interface у нас написано @interface.</div>
</div>
</div>
<div>
<div>
Структура практически та же, что и у интерфейсов, только пишется @interface.</div>
</div>
<div>
</div>
<ul>
<li>@interface - указывает на то, что это аннотация</li>
<li>default - говорит про то, что метод по умолчанию будет возвращать определённое значение.</li>
</ul>
<div>
<div>
Аннотация готова теперь ею можно пользоваться, также аннотацию можно сконфигурировать.</div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Атрибуты каких типов допустимы в аннотациях?</li>
</ul>
</h3>
<div style="text-align: left;">
Атрибуты могут иметь только следующие типы:</div>
<div>
<div>
примитивы</div>
</div>
<div>
</div>
<ul>
<li>String</li>
<li>Class или «any parameterized invocation of Class»</li>
<li>enum</li>
<li>annotation</li>
<li>массив элементов любого из вышеперечисленных типов</li>
</ul>
<div>
<br></div>
<div>
<div>
Последний пункт надо понимать как то, что допустимы только одномерные массивы.</div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Что такое &nbsp;JMX?</li>
</ul>
</h3>
<div>
Управленческие
 расширения Java (Java Management Extensions, JMX) - &nbsp;API при 
помощи которого можно контролировать работу приложений и управлять 
различными параметрами удаленно в реальном времени. Причем управлять 
можно фактически чем угодно - лишь бы это было написано на Java. Это 
может быть микро-устройство типа считывателя отпечатка или система, 
включающая тысячи машин, каждая из которых предоставляет определенные 
сервисы. Данные ресурсы представляются MBean-объектами (управляемый Java
 Bean). JMX вошла в поставку Java начиная с версии 5.</div>
<div>
<br></div>
<h3>
<ul>
<li>Какие выгоды предлагает JMX?</li>
</ul>
</h3>
<div>
Вот как эти выгоды описывает Sun</div>
<div>
</div>
<ul>
<li>Простота
 реализации. Архитектура JMX основана на понятии "сервера управляемых 
объектов" который выступает как управляющий агент и может быть запущен 
на многих устройствах/компьютерах, которые поддерживают JAVA.</li>
<li>Масштабируемость.
 Службы агентов JXM являются независимыми и могут быть встроены 
наподобие plug-in’ов в агента JMX. Компонентно-основанаая система 
позволяет создавать масштабируемые решения от крохотных устройств до 
очень крупных систем.</li>
<li>Возможность
 расширять концепцию в будущем. JMX позволяет создавать гибкие решения. 
Например, JMX позволяет создавать удобные решения, которые могут 
находить различные сервисы.</li>
<li>Концентрация
 на управлении. JMX предоставляет сервися, разработанные для работы в 
распределенных средах и его API спроектировано для решений, которые 
управляют приложениями, сетями, сервисами и т.д.&nbsp;</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Что еще умеет JMX кроме дистанционного управления?</li>
</ul>
</h3>
<div>
JMX
 делает гораздо больше, чем просто предоставляет рабочую оболочку для 
дистанционного управления. Она обеспечивает дополнительные услуги 
(services), способные занять ключевое место в процессе разработки. 
Приведу лишь краткое описание:</div>
<div>
</div>
<ul>
<li>Event
 notification: Интерфейсы оповещают исполнителей и слушателей о событиях
 типа изменения атрибута, что позволяет MBean-компонентам общаться с 
другими MBean-компонентами или удалённым "командным пунктом" и 
докладывать об изменениях своего состояния</li>
<li>Monitor
 service: Monitor MBeans может посылать уведомления о событиях 
зарегистрированным слушателям. Слушателем может выступать другой MBean 
или управляющее приложение. В качестве основных атрибутов, для которых 
используется данное свойство, являются counter, gauge или string.</li>
<li>Timer
 service: Timer MBean будет посылать уведомления зарегистрированным 
слушателям, с учётом определённого числа или временного промежутка.</li>
<li>M-let
 service: М-let service может создавать и регистрировать экземпляры 
MBean-серверов. Список MBean-компонентов и имён из классов определяются в
 m-let-файле с помощью MLET -меток. URL указывает на месторасположения 
m-let-файла.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Что такое MBean?</li>
</ul>
</h3>
<div>
MBeans - это Java-объекты, которые реализуют определенный интерфейс. Интерфейс включает:</div>
<div>
</div>
<ol>
<li>некие величины, которые могут быть доступны;</li>
<li>операции, которые могут быть вызваны;</li>
<li>извещения, которые могут быть посланы;</li>
<li>конструкторы.</li>
</ol>
<div>
<br></div>
<h3>
<ul>
<li>Какие типы MBeans существуют?</li>
</ul>
</h3>
<div>
Существует 4 типа MBeans:</div>
<div>
</div>
<ul>
<li>Standard MBeans. Самые простые бины. Их управляющий интерфейс определяется набором методов</li>
<li>Dynamic MBeans. Они реализуют специализированный интерфейс, который делают доступным во время исполнения.</li>
<li>Open MBeans. Это Dynamic MBeans, которые используют только основные типы данных для универсального управления.</li>
<li>Model
 MBeans. Это Dynamic MBeans, которые полностью конфигурируемы и могут 
показать свое описание во время исполнения (нечто вроде Reflection)</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Что такое MBean Server?</li>
</ul>
</h3>
<div>
MBean
 Server - это реестр объектов, которые используются для управления. 
Любой объект зарегистрированный на сервере становится доступным для 
приложений. Надо отметить, что сервер публикует только интерфейсы и не 
дает прямых ссылок на объекты. Любые ресурсы, которыми вы хотите 
управлять должны быть зарегистрированы на сервере как MBean. Сервер 
предоставляет стандартный интерфейс для доступа к MBean. Интересно, что 
регистрировать MBean может любой другой MBean, сам агент или удаленное 
приложение через распределенные сервисы. Когда вы регистрируете MBean вы
 должны дать ему уникальное имя, которое будет использовано для 
обращения к даному объекту.</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие механизмы обеспечивают безопасность в технологии Java?</li>
</ul>
</h3>
<div>
В технологии Java безопасность обеспечивают следующие три механизма:</div>
<div>
</div>
<ul>
<li>структурные
 функциональные возможности языка (например, проверка границ массивов, 
запрет на преобразования непроверенных типов, отсутствие указателей и 
т.д.).</li>
<li>средства
 контроля доступа, определяющие действия, которые разрешается или 
запрещается выполнять в коде (например, может ли код получать доступ к 
файлам, передавать данные по сети и т.д.).</li>
<li>механизм
 цифровой подписи, предоставляющий авторам возможность применять 
стандартные алгоритмы для аутентификации своих программ, а пользователям
 - точно определять, кто создал код и изменился ли он с момента его 
подписания.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Назовите несколько видов проверок которые выполняет верификатор байт-кода Java?</li>
</ul>
</h3>
<div>
Ниже приведены некоторые виды проверок, выполняемых верификатором.</div>
<div>
</div>
<ul>
<li>инициализация переменных перед их использованием.</li>
<li>согласование типов ссылок при вызове метода.</li>
<li>соблюдение правил доступа к закрытым данным и методам.</li>
<li>доступ к локальным переменным в стеке во время выполнения.</li>
<li>отсутствие переполнения стека.</li>
</ul>
<div>
При невыполнении какой-нибудь из этих проверок класс считается поврежденным и загружаться не будет.</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Что вы знаете о "диспетчере защиты" в Java?</li>
</ul>
</h3>
<div>
В
 качестве диспетчера защиты служит класс, определяющий, разрешено ли 
коду выполнять ту или иную операцию. Ниже перечислены операции, 
подпадающие под контроль диспетчера защиты. Существует немало других 
проверок, выполняемых диспетчером защиты в библиотеке Java.</div>
<div>
</div>
<ul>
<li>создание нового загрузчика классов.</li>
<li>выход из виртуальной машины.</li>
<li>получение доступа к члену другого класса с помощью рефлексии.</li>
<li>получение доступа к файлу.</li>
<li>установление соединения через сокет.</li>
<li>запуск задания на печать.</li>
<li>получение доступа к системному буферу обмена.</li>
<li>получение доступа к очереди событий в AWT.</li>
<li>обращение к окну верхнего уровня.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Что такое JAAS?</li>
</ul>
</h3>
<div>
JAAS
 (Java Authentication and Authorization Service - служба аутентификации и
 авторизации Java ) - служба JAAS, по существу, представляет собой 
встраиваемый прикладной интерфейс API, отделяющий прикладные программы 
на Java от конкретной технологии, применяемой для реализации средств 
аутентификации. Помимо прочего, эта служба поддерживает механизмы 
регистрации в UNIX и NT, механизм аутентификации Kerberos и механизмы 
аутентификации по сертификатам.</div>
<div>
<div>
После
 аутентификации за пользователем может быть закреплен определенный набор
 полномочий. Входит в состав платформы Java начиная с версии Java SE 
1.4.</div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Что такое Рефакторинг?</li>
</ul>
</h3>
<div>
Рефакторинг
 - процесс изменения внутренней структуры программы, не затрагивающий её
 внешнего поведения и имеющий целью облегчить понимание её работы. В 
основе рефакторинга лежит последовательность небольших эквивалентных (то
 есть сохраняющих поведение) преобразований..</div>
</div>	

</body></html>