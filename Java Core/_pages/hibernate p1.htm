<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Hib p1</title>
<link rel="stylesheet" href="../../Git Guide/grey.css">
</head>
<body>

<h3>
<ul>
<li>Что такое Hibernate?</li>
</ul>
</h3>
<div>
Это фреймворк для объектно-реляционного отображения сущностей в традиционные реляционные базу данных.</div>
<div>
Основные возможности фреймворка:</div>
<div>
</div>
<ul>
<li>Автоматическая генерация и обновление таблиц в базах данных;</li>
<li>Поскольку
 основные запросы к базе данных (сохранение, обновление, удаление и 
поиск) представлены как методы фрейморка, то значительно сокращается 
код, который пишется разработчиком;</li>
<li>Обеспечивает
 использование SQL подобного языка (HQL - hibernate query language). 
Запросы HQL могут быть записаны рядом объектами данных (POJO классы 
подготовленные для работы с базой данных).</li>
</ul>
<div style="text-align: left;">
<br></div>
<h3>
<ul>
<li>Что такое ORM?</li>
</ul>
</h3>
<div>
ORM (англ. Object-relational mapping, рус. Объектно-реляционное отображение) -&nbsp;технология программирования,<br>
<a name="more"></a>
 которая&nbsp;связывает базы данных с концепциями 
объектно-ориентированных языков программирования, создавая "виртуальную 
объектную базу данных".<br>
<br></div>
<div>
</div>
<h3>
<ul>
<li>Какие преимущства от использования Hibernate?</li>
</ul>
</h3>
<div>
Некоторые из них:<br>
<ul>
<li>Устраняет
 множество повторяющегося кода, который постоянно преследует 
разработчика при работе с JDBC. Скрывает от разработчика множество кода,
 необходимого для управления ресурсами и позволяет сосредоточиться на 
бизнес логике.</li>
<li>Поддерживает XML так же как и JPA аннотации, что позволяет сделать реализацию кода независимой.</li>
<li>Предоставляет
 собственный мощный язык запросов (HQL), который похож на SQL. Стоит 
отметить, что HQL полностью объектно-ориентирован и понимает такие 
принципы, как наследование, полиморфизм и ассоциации (связи).</li>
<li>Hibernate
 легко интегрируется с другими Java EE фреймворками, например, Spring 
Framework поддерживает встроенную интеграцию с Hibernate.</li>
<li>Поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только по необходимости.</li>
<li>Поддерживает разные уровни cache, а следовательно может повысить производительность.</li>
<li>Важно,
 что Hibernate может использовать чистый SQL, а значит поддерживает 
возможность оптимизации запросов и работы с любым сторонним вендором БД.</li>
<li>Hibernate
 - open source проект. Благодаря этому доступны тысячи открытых статей, 
примеров, а так же документации по использованию фреймворка.</li>
</ul>
<br></div>
<div>
</div>
<h3>
<ul>
<li>Как Hibernate помогает в программировании?</li>
</ul>
</h3>
<div>
Hibernate реализует ряд фичь которые значительно упрощают работу разработчика.</div>
<div>
</div>
<ul>
<li>Одной
 из таких фичь является то, что hibernate позволяет разработчику 
избежать написания большинства SQL запросов (они уже реализованы , вам 
надо просто использовать методы которые предоставляет фреймворк).</li>
<li>Под
 бортом у Hibernate есть куча полезных инструментов которые значительно 
ускоряют работу приложения, самыми примечательными из них являются 
двухуровневое кэширования и тонкие настройки lazy и fetch изъятия.</li>
<li>Сам генерирует таблицы в базу данных</li>
</ul>
<div>
<br>
<div>
</div>
</div>
<h3>
<ul>
<li><b style="font-family: arial, helvetica, sans-serif;">Какие преимущества Hibernate над JDBC?</b></li>
</ul>
</h3>
<div>
Hibernate имеет ряд преимуществ перед JDBC API:</div>
<div>
<ul>
<li>Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать.</li>
<li>Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API.</li>
<li>Hibernate
 неявно использует управление транзакциями. Большинство запросов нельзя 
выполнить вне транзакции. При использовании JDBC API для управления 
транзакциями нужно явно использовать commit и rollback.</li>
<li>JDBC
 API throws SQLException, которое относится к проверяемым исключениям, а
 значит необходимо постоянно писать множество блоков try-catch. В 
большинстве случаев это не нужно для каждого вызова JDBC и используется 
для управления транзакциями. Hibernate оборачивает исключения JDBC через
 непроверяемые JDBCException или HibernateException, а значит нет 
необходимости проверять их в коде каждый раз. Встроенная поддержка 
управления транзакциями в Hibernate убирает блоки try-catch.</li>
<li>Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык программирования, чем SQL в JDBC.</li>
<li>Hibernate поддерживает кэширование, а запросы JDBC - нет, что может понизить производительность.</li>
<li>Hibernate
 предоставляет возможность управления БД (например создания таблиц), а в
 JDBC можно работать только с существующими таблицами в базе данных.</li>
<li>Конфигурация
 Hibernate позволяет использовать JDBC вроде соединения по типу JNDI 
DataSource для пула соединений. Это важная фича для энтерпрайз 
приложений, которая полностью отсутствует в JDBC API.</li>
<li>Hibernate
 поддерживает аннотации JPA, а значит код является переносимым на другие
 ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно 
привязан к приложению.</li>
</ul>
</div>
<div>
<br>
</div>
<h3>
<ul>
<li>Что такое конфигурационный файл Hibernate?</li>
</ul>
</h3>
<div>
Файл
 конфигурации Hibernate содержит в себе данные о базе данных и необходим
 для инициализации SessionFactory. В .xml файле необходимо указать 
вендора базы данных или JNDI ресурсы, а так же информацию об 
используемом диалекте, что поможет hibernate выбрать режим работы с 
конкретной базой данных.<br>
<br></div>
<h3>
<ul>
<li>Способы конфигурации работы с Hibernate.</li>
</ul>
</h3>
<div>
Существует четыре способа конфигурации работы с Hibernate :</div>
<div>
</div>
<ul>
<li>используя аннотации;</li>
<li>hibernate.cfg.xml;</li>
<li>hibernate.properties;</li>
<li>persistence.xml.</li>
</ul>
<div>
Самый
 частый способ конфигурации: через аннотации и файл persistence.xml, что
 касается файлов hibernate.properties и hibernate.cfg.xml, то 
hibernate.cfg.xml главнее (если в приложение есть оба файла, то 
принимаются настройки из файла hibernate.cfg.xml). Конфигурация 
аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для 
разных баз данных или для разных ситуаций вы хотите иметь разные 
конфигурацию сущностей, то следует использовать xml файлы конфигураций.</div>
<div>
<br></div>
<h3>
<ul>
<li>Что такое Hibernate mapping file?</li>
</ul>
</h3>
<div>
Файл
 отображения (mapping file) используется для связи entity бинов и 
колонок в таблице базы данных. В случаях, когда не используются 
аннотации JPA, файл отображения .xml может быть полезен (например при 
использовании сторонних библиотек).<br>
<br></div>
<h3>
<ul>
<li>Что такое Переходные объекты (Transient Objects)? (преходящий; кратковременный; мимолётный, скоротечный)</li>
</ul>
</h3>
<div>
Экземпляры
 долгоживущих классов, которые в настоящее время не связаны c Cессией. 
Они, возможно, были инициализированы в приложении и еще не сохранены, 
или же они были инициализированы закрытой Cессией.<br>
<br></div>
<h3>
<ul>
<li>Что такое постоянные объекты (Persistent objects)?</li>
</ul>
</h3>
<div>
Короткоживущие,
 однопоточные объекты, содержащие постоянное состояние и бизнес-функции.
 Это могут быть простые Java Beans/POJOs (Plain Old Java Object). Они 
связаны только с одной Cессией. После того, как Cессия закрыта, они 
будут отделены и свободны для использования в любом протоколе 
прикладного уровня (например, в качестве объектов передачи данных в и из
 представления).<br>
<br></div>
<h3>
<ul>
<li>Что такое TransactionFactory?</li>
</ul>
</h3>
<div>
Фабрика для экземпляров Transaction. Интерфейс не открыт для приложения, но может быть расширен или реализован разработчиком.<br>
<br></div>
<h3>
<ul>
<li>Что такое ConnectionProvider?</li>
</ul>
</h3>
<div>
Фабрика
 и пул JDBC соединений. Интерфейс абстрагирует приложение от основного 
источника данных или диспетчера драйверов. Он не открыт для приложения, 
но может быть расширен или реализован разработчиком.<br>
<br></div>
<h3>
<ul>
<li>Что такое Трансакция (Transaction)?</li>
</ul>
</h3>
<div>
Однопоточный,
 короткоживущий объект, используемый приложением для указания atomic 
переменных работы. Он абстрагирует приложение от основных JDBC, JTA или 
CORBA трансакций. Сессия может охватывать несколько Трансакций в 
некоторых случаях. Тем не менее, разграничение транзакций, также 
используемое в основах API или Transaction, всегда обязателно.<br>
<br></div>
<h3>
<ul>
<li>Какие существуют стратегии загрузки объектов в Hibernate?</li>
</ul>
</h3>
<div>
Существуют следующие типа fetch'a:</div>
<div>
<ul>
<li>Join fetching: hibernate получает ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN</li>
<li>Select
 fetching: использует уточняющий SELECT чтобы получить ассоциированные 
объекты и коллекции. Если вы не установите lazy fetching определив 
lazy="false", уточняющий SELECT будет выполнен только когда вы 
запрашиваете доступ к ассоциированным объектам</li>
<li>Subselect
 fetching: поведение такое же, как у предыдущего типа, за тем 
исключением, что будут загружены ассоциации для все других коллекций, 
"родительским" для которых является сущность, которую вы загрузили 
первым SELECT’ом.</li>
<li>Batch fetching: оптимизированная стратегия вида select fetching. Получает группу сущностей или коллекций в одном SELECT’е.</li>
</ul>
</div>
<div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие бывают id generator классы в Hibernate?</li>
</ul>
</h3>
<div>
<b>increment</b>
 - генерирует идентификатор типа long, short или int, которые будет 
уникальным только в том случае, если другой процесс не добавляет запись в
 эту же таблицу в это же время.</div>
<div>
<b>identity</b>
 - генерирует идентификатор типа long, short или int. Поддерживается в 
DB2, MySQL, MS SQL Server, Sybase и HypersonicSQL.</div>
<div>
<b>sequence</b>
 - использует последовательности в DB2, PostgreSQL, Oracle, SAP DB, 
McKoi или генератор Interbase. Возвращает идентификатор типа long, short
 или int.</div>
<div>
<b>hilo</b>
 - использует алгоритм hi/lo для генерации идентификаторов типа long, 
short или int. Алгоритм гарантирует генерацию идентификаторов, которые 
уникальны только в данной базе данных.</div>
<div>
<b>seqhilo</b>
 - использует алгоритм hi/lo для генерации идентификаторов типа long, 
short или int учитывая последовательность базы данных.</div>
<div>
<b>uuid</b>
 - использует для генерации идентификатора алгоритм 128-bit UUID. 
Идентификатор будет уникальным в пределах сети. UUID представляется 
строкой из 32 чисел.</div>
<div>
<b>guid</b> - использует сгенерированую БД строку GUID в MS SQL Server и MySQL.</div>
<div>
<b>native</b> - использует identity, sequence или hilo в завимисимости от типа БД, с которой работает приложение</div>
<div>
<b>assigned</b>
 - позволяет приложению устанавливать идентификатор объекту, до вызова 
метода save(). Используется по умолчанию, если тег &lt;generator&gt; не 
указан.</div>
<div>
<b>select</b> - получает первичный ключ, присвоенный триггером БД</div>
<div>
<b>foreign</b>
 - использует идентификатор другого, связанного с данным объекта. 
Используется в &lt;one-to-one&gt; ассоциации первичных ключей.</div>
<div>
<b>sequence-identity</b> - специализированный генератор идентификатора.</div>
<div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие ключевые интерфейсы использует Hibernate?</li>
</ul>
</h3>
<div>
Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate:</div>
<div>
</div>
<ul>
<li>Session interface;</li>
<li>SessionFactory interface;</li>
<li>Configuration interface;</li>
<li>Transaction interface;</li>
<li>Query and Criteria interfaces.</li>
</ul>
<div>
</div>
<div>
<br></div>
<h3>
<ul>
<li>Назовите некоторые важные аннотации, используемые для отображения в Hibernate.</li>
</ul>
</h3>
<div>
Hibernate
 поддерживает как аннотации из JPA, так и свои собственные, которые 
находятся в пакете org.hibernate.annotations. Наиболее важные аннотации 
JPA и Hibernate:</div>
<div>
</div>
<ul>
<li>javax.persistence.Entity: используется для указания класса как entity bean.</li>
<li>javax.persistence.Table: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.</li>
<li>javax.persistence.Access:
 определяет тип доступа, поле или свойство. Поле — является значением по
 умолчанию и если нужно, чтобы hibernate использовать методы 
getter/setter, то их необходимо задать для нужного свойства.</li>
<li>javax.persistence.Id: определяет primary key в entity bean.</li>
<li>javax.persistence.EmbeddedId: используется для определения составного ключа в бине.</li>
<li>javax.persistence.Column: определяет имя колонки из таблицы в базе данных.</li>
<li>javax.persistence.GeneratedValue:
 задает стратегию создания основных ключей. Используется в сочетании с 
javax.persistence.GenerationType enum.</li>
<li>javax.persistence.OneToOne:
 задает связь один-к-одному между двумя сущностными бинами. 
Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany.</li>
<li>org.hibernate.annotations.Cascade:
 определяет каскадную связь между двумя entity бинами. Используется в 
связке с org.hibernate.annotations.CascadeType.</li>
<li>javax.persistence.PrimaryKeyJoinColumn:
 определяет внешний ключ для свойства. Используется вместе с 
org.hibernate.annotations.GenericGenerator и 
org.hibernate.annotations.Parameter.</li>
</ul>
<br>
<div>
</div>
<h3>
<ul>
<li>Какая роль интерфейса Session в Hibernate?</li>
</ul>
</h3>
<div>
Session
 - это основной интерфейс, который отвечает за связь с базой данных. Так
 же, он помогает создавать объекты запросов для получение персистентных 
объектов. (персистентный объект - объект который уже находится в базе 
данных; объект запроса - объект который получается когда мы получаем 
результат запроса в базу данных, именно с ним работает приложение). 
Обьект Session можно получить из SessionFactory :<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-pPjKNsT7dE8/Vu7MpXHcohI/AAAAAAAAAX0/eQ3DHi5d8L0W5oS2Xy7gxKNWzukVx4YbQ/s1600/SessionFactory.openSession.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="hibernate%20p1_files/SessionFactory.jpg" border="0"></a></div>
Роль интерфейса Session:</div>
<div>
</div>
<ul>
<li>является оберткой для jdbc подключения к базе данных;</li>
<li>является
 фабрикой для транзакций (согласно официальной документации transaction -
 аllows the application to define units of work, что , по сути, означает
 что транзакция определяет границы операций связанных с базой данных).</li>
<li>является хранителем обязательного кэша первого уровня.</li>
</ul>
<div>
<br></div>
<h3>
<ul>
<li>Какая роль интерфейса SessionFactory в Hibernate?</li>
</ul>
</h3>
<div>
Именно
 из объекта SessionFactory мы получаем объекты типа Session. На все 
приложение существует только одна SessionFactory и она инициализируеться
 вместе со стартом приложения. SessionFactory кэширует мета-дату и SQL 
запросы которые часто используются приложением во время работы. Так же 
оно кэширует информацию которая была получена в одной из транзакций и 
может быть использована и в других транзакциях.</div>
<div>
Обьект SessionFactory можно получить следующим обращением:</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-o119gUWukH0/Vu7M82cfsdI/AAAAAAAAAX4/79cMKTz8m3QoyM9ENCINAvzA5tpY2m_jQ/s1600/buildSessionFactory.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="hibernate%20p1_files/buildSessionFactory.jpg" height="26" border="0" width="640"></a></div>
<br>
<h3>
<ul>
<li>Является ли Hibernate SessionFactory потокобезоспансым?</li>
</ul>
</h3>
Т.к.
 объект SessionFactory immutable (неизменяемый), то да, он 
потокобезопасный. Множество потоков может обращаться к одному объекту 
одновременно.<br>
<br>
<h3>
<div>
<ul>
<li>В чем разница между openSession и getCurrentSession?</li>
</ul>
</div>
</h3>
Hibernate
 SessionFactory getCurrentSession() возвращает сессию, связанную с 
контекстом. Но для того, чтобы это работало, нам нужно настроить его в 
конфигурационном файле hibernate. Так как этот объект session связан с 
контекстом hibernate, то отпадает необходимость к его закрытию. Объект 
session закрывается вместе с закрытием SessionFactory.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-oAvDdSTXpBU/Vu7KaqKOnfI/AAAAAAAAAXo/7QCM8RpE_74mYF6W6ZQkdzvoHF_XVVqfw/s1600/getCurrentSession.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="hibernate%20p1_files/getCurrentSession.jpg" border="0"></a></div>
<div>
<div>
Метод
 Hibernate SessionFactory openSession() всегда создает новую сессию. Мы 
должны обязательно контролировать закрытие объекта сеанса по завершению 
всех операций с базой данных. Для многопоточной среды необходимо 
создавать новый объект session для каждого запроса.</div>
<div>
Существует
 еще один метод openStatelessSession(), который возвращает session без 
поддержки состояния. Такой объект не реализует первый уровень 
кэширования и не взаимодействует с вторым уровнем. Сюда же можно отнести
 игнорирование коллекций и некоторых обработчиков событий. Такие объекты
 могут быть полезны при загрузке больших объемов данных без удержания 
большого кол-ва информации в кэше.</div>
</div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие типы коллекций представлены в Hibernate?</li>
</ul>
</h3>
<div>
Bag, Set, List, Map, Array.</div>
<div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие типы менеджмента транзакций поддерживаются в Hibernate?</li>
</ul>
</h3>
<div>
Hibernate взаимодействует с БД через JDBC-соединение. Таким образом он поддерживает управляемые и не управляемые транзакции.</div>
<div>
Неуправляемые транзакции в web-контейнере:</div>
<div>
</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-5496cMV4J3o/VsFnNQhFsYI/AAAAAAAAAOg/gnkDkSPPGoM/s1600/HibernateTransactionManager.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="hibernate%20p1_files/HibernateTransactionManager.jpg" height="68" border="0" width="640"></a></div>
<div>
Управляемые транзакции на сервере приложений, использующий JTA:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-DU8NCq1ctwA/VsFnn4UhwSI/AAAAAAAAAOk/2f5mRp_zOSc/s1600/HibernateTransactionManager_jta.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="hibernate%20p1_files/HibernateTransactionManager_jta.jpg" height="71" border="0" width="640"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Что собой являет коллекция типа Bag и зачем она используется?</li>
</ul>
</h3>
<div>
Своей
 реализации тип коллекции Bag очень напоминает Set, разница состоит в 
том, что Bag может хранить повторяющиеся значения. Bag хранит 
непроиндексированный список элементов. Большинство таблиц в базе данных 
имеют индексы отображающие положение элемента данных один относительно 
другого, данные индексы имеют представление в таблице в виде отдельной 
колонки. При объектно-реляционном маппинге, значения колонки индексов 
мапится на индекс в Array, на индекс в List или на key в Map. Если вам 
надо получить коллекцию объектов не содержащих данные индексы, то вы 
можете воспользоваться коллекциями типа Bag или Set (коллекции содержат 
данные в неотсортированном виде, но могут быть отсортированы согласно 
запросу).</div>
<div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<div>
<ul>
<li>Какие типы кэша используются в Hibernate?</li>
</ul>
</div>
</h3>
<div>
Hibernate использует 2 типа кэша: кэш первого уровня и кэш второго уровня.</div>
<div>
Кэш
 первого уровня ассоциирован с объектом сесии, в то время, как кэш 
второго уровня ассоциирован с объектом фабрики сессий. По-умолчанию 
Hibernate использует кэш первого уровня для каждой операции в 
транзакции. В первую очередь кэш используется чтобы уменьшить количество
 SQL-запросов. Например если объект модифицировался несколько раз в 
одной и той же транзакции, то Hibernate сгенерирует только один UPDATE.</div>
<div>
Чтобы
 уменьшить трафик с БД, Hibernate использует кэш второго уровня, который
 является общим для всего приложения, а не только для данного 
конкретного пользователя. Таким образом если результат запроса находится
 в кэше, мы потенциально уменьшаем количество транзакций к БД.</div>
<div>
EHCache
 - это быстрый и простой кэш. Он поддерживает read-only и read/write 
кэширование, а так же кэширование в память и на диск. Но не поддерживает
 кластеризацию.</div>
<div>
OSCache
 - это другая opensource реализация кэша. Помимо всего, что поддерживает
 EHCache, эта реализация так же поддерживает кластеризацию через 
JavaGroups или JMS.</div>
<div>
SwarmCache
 - это просто cluster-based решение, базирующееся на JavaGroups. 
Поддерживает read-only и нестрогое read/write кэширование. Этот тип 
кэширование полезен, когда количество операций чтения из БД превышает 
количество операций записи.</div>
<div>
JBoss TreeCache - предоставляет полноценный кэш транзакции.</div>
<div>
</div>
<div>
<div>
<br></div>
</div>
<h3>
<ul>
<li>Какие существуют типы стратегий кэша?</li>
</ul>
</h3>
<div>
<b>Read-only:</b>
 эта стратегия используется когда данные вычитываются, но никогда не 
обновляется. Самая простая и производительная стратегия</div>
<div>
<b>Read/write:</b> может быть использована, когда данные должны обновляться.</div>
<div>
<b>Нестрогий read/write:</b> эта стратегия не гарантирует, что две транзакции не модифицируют одни и те же данные синхронно.</div>
<div>
<b>Transactional:</b> полноценное кэширование транзакций. Доступно только в JTA окружении.<br>
<br>
<h3>
<div>
<ul>
<li>Что вы знаете о кэширование в Hibernate? Объясните понятие кэш первого уровня в Hibernate?</li>
</ul>
</div>
</h3>
Hibernate
 использует кэширование, чтобы сделать наше приложение быстрее. Кэш 
Hibernate может быть очень полезным в получении высокой 
производительности приложения при правильном использовании. Идея 
кэширования заключается в сокращении количества запросов к базе данных.<br>
Кэш
 первого уровня Hibernate связан с объектом Session. Кэш первого уровня у
 Hibernate &nbsp;включен по умолчанию и не существует никакого способа, 
чтобы его отключить. Однако Hibernate предоставляет методы, с помощью 
которых мы можем удалить выбранные объекты из кэша или полностью 
очистить кэш.<br>
Любой
 объект закэшированный в session не будет виден другим объектам session.
 После закрытия объекта сессии все кэшированные объекты будут потеряны.
 <br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/03/object-relational-mapping-orm-hibernate.html">Object relational mapping (ORM), Hibernate (часть 2).</a></h3>
</div>

</body></html>