<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>io p1</title>
<link rel="stylesheet" href="grey.css">
</head>
<body>
	
<h3>
<ul>
<li>Что такоє символьная ссылка?</li>
</ul>
</h3>

<div>
Символьная
 ссылка (Symbolic link, симлинк) - специальный файл в файловой системе, 
содержащий только текстовую строку с указателем. Эта строка трактуется 
как путь к файлу, который должен быть открыт при попытке обратиться к 
данному файлу.</div>
<div>
<br>
<div>
 </div>
</div>
<div>
<h3>
<ul>
<li>Какая разница между I/О и NIO?</li>
</ul>
</h3>
</div>
<div>
I/O
 (input/output, ввод-вывод ) - взаимодействие между обработчиком 
информации и её поставщиком и/или получателем. Ввод - сигнал или данные,
 полученные обработчиком, а вывод - сигнал или данные, посланные им (или
 из него).</div>
<div>
NIO
 (/*в контексте Java*/ Non-blocking I/O, New I/O) - коллекция прикладных
 программных интерфейсов для языка Java, предназначенных для реализации 
высокопроизводительных операций ввода-вывода. Также встречается <br>
<a name="more"></a>аббревиатура NIO.2 - она относится к нововведениям относительно этого направления в Java 7.<br>
<br>

</div>
<div>
<h3>
<ul>
<li>Какие особенности NIO вы знаете?</li>
</ul>
</h3>
</div>
<div>
Ключевые особенности NIO:</div>
<div>
<ul>
<li>Каналы
 и селекторы: NIO поддерживает различные типы каналов. Канал является 
абстракцией объектов более низкого уровня файловой системы (например, 
отображенные в памяти файлы и блокировки файлов), что позволяет 
передавать данные с более высокой скоростью. Каналы не блокируются и 
поэтому Java предоставляет еще такие инструменты, как селектор, который 
позволяет выбрать готовый канал для передачи данных, и сокет, который 
является инструментом для блокировки.</li>
<li>Буферы:
 в Java 7 была введена буферизация для всех классов-обёрток примитивов 
(кроме Boolean). Появился абстрактный класс Buffer, который 
предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы
 предоставляют методы для получения и установки данных.</li>
<li>Кодировки: в Java 7 появились кодировки (java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode.</li>
</ul>
<ul>
</ul>
</div>
<div>
<br></div>
<div>
<div>
<h3>
<ul>
<li>Какие существуют виды потоков ввода/вывода?</li>
</ul>
</h3>
 </div>
</div>
<div>
Потоки
 ввода/вывода используются для передачи данных в файловые потоки, на 
консоль или на сетевые соединения. Существует два вида потоков 
ввода/вывода: байтовые и символьные.</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-5boKm8RgEjI/Vq4BL8MzB_I/AAAAAAAAAN8/VsFyzmbs6_Q/s1600/input_output_stream.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="io%20p1_files/input_output_stream.jpg" border="0"></a></div>
<br></div>
<div>
<h3>
<ul>
<li>Назовите основные классы потоков ввода/вывода.</li>
</ul>
</h3>
<div>
 </div>
</div>
<div>
Байтовые: java.io.InputStream, java.io.OutputStream;</div>
<div>
Символьные: java.io.Reader, java.io.Writer;</div>
<div>
<br>
<div>
 </div>
</div>
<div>
<h3>
<ul>
<li>Чем отличаются OutputStream, InputStream,&nbsp;Writer и Reader?</li>
</ul>
</h3>
</div>
<div>
Класс
 OutputStream - это абстрактный класс, определяющий потоковый байтовый 
вывод. В этой категории находятся классы, определяющие, куда 
направляются ваши данные: в массив байтов (но не напрямую в String; 
предполагается что вы сможете создать их из массива байтов), в файл или 
канал.</div>
<div>
Базовый класс InputStream представляет классы, которые получают данные из различных источников:</div>
<div>
<ul>
<li>массив байтов</li>
<li>строка (String)</li>
<li>файл</li>
<li>канал (pipe): данные помещаются с одного конца и извлекаются с другого</li>
<li>последовательность различных потоков, которые можно объединить в одном потоке</li>
<li>другие источники (например, подключение к интернету)</li>
</ul>
</div>
<div>
<div>
Символьные
 потоки имеют два основных абстрактных класса Reader и Writer, 
управляющие потоками символов Unicode. Класс Reader - абстрактный класс,
 определяющий символьный потоковый ввод. Класс Writer - абстрактный 
класс, определяющий символьный потоковый вывод. В случае ошибок все 
методы класса передают исключение IOException.<br>
<br>
</div>
<div>
<h3>
<div>
<ul>
<li>Какие подклассы базового класса InputStream ви знаєте, для чего они предназначены?</li>
</ul>
</div>
</h3>
</div>
</div>
<div>
Подклассы базового класса InputStream:<br>
<ul>
<li>StringBufferInputStream - превращает строку (String) во входной поток данных InputStream.</li>
<li>SequenceInputStream - сливает два или более потока InputStream в единый поток.</li>
<li>PushbackInputStream - входной поток, поддерживающий однобайтовый возврат во входной поток.</li>
<li>PrintStream - выходной поток, включающий методы print() и println().</li>
<li>PipedInputStream - реализует понятие входного канала.</li>
<li>ObjectInputStream - входной поток для объектов.</li>
<li>InputStream - абстрактный класс, описывающий поток ввода.</li>
<li>FilterInputStream
 - абстрактный класс, предоставляющий интерфейс для классов-надстроек, 
которые добавляют к существующим потокам полезные свойства.</li>
<li>FileInputStream - для чтения информации из файла.</li>
<li>DataInputStream - входной поток, включающий методы для чтения стандартных типов данных Java.</li>
<li>ByteArrayInputStream - позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока.</li>
<li>BufferedInputStream - буферизированный входной поток.</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Что вы знаете о RandomAccessFile?</li>
</ul>
</h3>
<div>
 </div>
</div>
<div>
RandomAccessFile
 это класс который наследуется напрямую от Object и не наследуется от 
вышеприведенных базовых классов ввода\вывода. Предназначен для работы с 
файлами, поддерживая произвольный доступ к их содержимому.</div>
<div>
Работа
 с классом RandomAccessFile напоминает использование совмещенных в одном
 классе потоков DataInputStream и DataOutputStream (они реализуют те же 
интерфейсы DataInput и DataOutput). Кроме того, метод seek() позволяет 
переместиться к определенной позиции и изменить хранящееся там значение.</div>
<div>
При
 использовании RandomAccessFile необходимо знать структуру файла. Класс 
RandomAccessFile содержит методы для чтения и записи примитивов и строк 
UTF-8.<br>
<br></div>
<div>
<h3>
<ul>
<li>Какие есть режимы доступа к файлу есть у RandomAccessFile ?</li>
</ul>
</h3>
</div>
<div>
RandomAccessFile
 может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также
 есть режим "rws", когда файл открывается для операций чтения-записи и 
каждое изменение данных файла немедленно записывается на физическое 
устройство.</div>
<div>
<br>
<div>
 </div>
</div>
<div>
<h3>
<ul>
<li>Какие подклассы базового класса OutputStream ви знаєте, для чего они предназначены?</li>
</ul>
</h3>
</div>
<div>
Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод.</div>
<div>
В
 этой категории находятся классы, определяющие, куда направляются ваши 
данные: в массив байтов (но не напрямую в String; предполагается что вы 
сможете создать их из массива байтов), в файл или канал.</div>
<div>
Подклассы базового класса OutputStream:</div>
<div>
<ul>
<li>PipedOutputStream - реализует понятие выходного канала.</li>
<li>ObjectOutputStream - выходной поток для объектов</li>
<li>FilterOutputStream
 - абстрактный класс, предоставляющий интерфейс для классов-надстроек, 
которые добавляют к существующим потокам полезные свойства.</li>
<li>FileOutputStream - отправка данных в файл на диске. Реализация класса OutputStream.</li>
<li>DataOutputStream - выходной поток, включающий методы для записи стандартных типов данных Java.</li>
<li>ByteArrayOutputStream - создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере.</li>
<li>BufferedOutputStream - буферизированный выходной поток.</li>
</ul>
</div>
<div>
<br>
<div>
 </div>
</div>
<div>
<h3>
<ul>
<li>Для чего используется PushbackInputStream?</li>
</ul>
</h3>
</div>
<div>
Разновидность
 буферизации, обеспечивающая чтение байта с последующим его возвратом в 
поток. Класс PushbackInputStream представляет механизм "заглянуть" во 
входной поток и увидеть, что оттуда поступит в следующий раз, не 
извлекая информации.</div>
<div>
У класса есть дополнительный метод unread().</div>
<div>
<br>
<div>
 </div>
</div>
<div>
<h3>
<ul>
<li>Для чего используется SequenceInputStream?</li>
</ul>
</h3>
</div>
<div>
Класс
 SequenceInputStream позволяет соединять вместе несколько экземпляров 
класса InputStream. Конструктор принимает в качестве аргумента либо пару
 объектов класса InputStream, либо интерфейс Enumeration.</div>
<div>
Во
 время работы класс выполняет запросы на чтение из первого объекта 
класса InputStream и до конца, а затем переключается на второй. При 
использовании интерфейса работа продолжится по всем объектам класса 
InputStream. По достижении конца каждого файла, связанный с ним поток 
закрывается. Закрытие потока, созданного объектом класса 
SequenceInputStream, приводит к закрытию всех открытых потоков.<br>
<br>
</div>
<div>
<h3>
<ul>
<li>Какие подклассы базового класса Reader ви знаєте, для чего они предназначены?</li>
</ul>
</h3>
<div>
 </div>
</div>
<div>
Подклассы базового класса Reader:</div>
<div>
<ul>
<li>StringReader - входной поток, читающий из строки.</li>
<li>Reader - абстрактный класс, описывающий символьный ввод.</li>
<li>PushbackReader - входной поток, позволяющий возвращать символы обратно в поток.</li>
<li>PipedReader - входной канал.</li>
<li>LineNumberReader - входной поток, подсчитывающий строки.</li>
<li>InputStreamReader - входной поток, транслирующий байты в символы.</li>
<li>FilterReader - фильтрующий читатель.</li>
<li>FileReader - входной поток, читающий файл.</li>
<li>CharArrayReader - входной поток, который читает из символьного массива.</li>
<li>BufferedReader - буферизированный входной символьный поток.</li>
</ul>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/02/java-2.html">Потоки ввода/вывода в java (часть 2).</a></h3>
<ul>
</ul>
</div>

</body></html>