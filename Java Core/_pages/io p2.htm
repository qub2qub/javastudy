<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>io p2</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
	
<h3>
<ul>
<li>Какие подклассы базового класса Writer ви знаєте, для чего они предназначены?</li>
</ul>
</h3>

<div>
</div>
<div>
Подклассы базового класса Writer:</div>
<div>
<ul>
<li>Writer - абстрактный класс, описывающий символьный вывод</li>
<li>StringWriter - выходной поток, пишущий в строку</li>
<li>PrintWriter - выходной поток, включающий методы print() и println()</li>
<li>PipedWriter - выходной канал</li>
<li>OutputStreamWriter - выходной поток, транслирующий байты в символы</li>
<li>FilterWriter - фильтрующий писатель</li>
<li>FileWriter - выходной поток, пишущий в файл</li>
<li>CharArrayWriter - выходной поток, который пишет в символьный массив<a name="more"></a></li>
<li>BufferedWriter - буферизированный выходной символьный поток</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Что &nbsp;такое абсолютный путь и относительный путь?</li>
</ul>
</h3>
</div>
<div>
Абсолютный
 путь - это путь, который указывает на одно и то же место в файловой 
системе, вне зависимости от текущей директории. Полный путь всегда 
начинается с корневого каталога.</div>
<div>
Относительный путь - это путь по отношению к текущему рабочему каталогу.</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>В каких пакетах лежат классы-потоки?</li>
</ul>
</h3>
</div>
<div>
Стандартный
 классы ввода\вывода в Java лежат в пакете java.io.*. В JDK 7 добавлен 
более современный способ работы с потоками под названием Java NIO или 
Java New IO ети классы лежат в пакете java.nio.*. Для работы с архивами 
используются классы из пакета java.util.*.</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Что вы знаете о классах-надстройках?</li>
</ul>
</h3>
</div>
<div>
Классы-настройки ето классы которые добавляют к существующим потокам полезные дополнительные свойства.</div>
<div>
Примеры
 классов: BufferedOutputStream, BufferedInputStrem, BufferedWriter , 
BufferedReader - &nbsp;буферезируют поток и повышают производительность.</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?</li>
</ul>
</h3>
</div>
<div>
Для
 чтения байтовых данных (не строк) применяется класс DataInputStream. В 
этом случае необходимо использовать классы из группы InputStream.</div>
<div>
Для
 преобразования строки в массив байтов, пригодный для помещения в поток 
ByteArrayInputStream, в классе String предусмотрен метод getBytes(). 
Полученный ByteArrayInputStream представляет собой поток InputStream, 
подходящий для передачи DataInputStream.</div>
<div>
При
 побайтовом чтении символов из форматированного потока DataInputStream 
методом readByte() любое полученное значение будет считаться 
действительным, поэтому возвращаемое значение неприменимо для 
идентификации конца потока. Вместо этого можно использовать метод 
available(), который сообщает, сколько еще осталось символов.</div>
<div>
Класс
 DataInputStream позволяет читать элементарные данные из потока через 
интерфейс DataInput, который определяет методы, преобразующие 
элементарные значения в форму последовательности байтов. Такие потоки 
облегчают сохранение в файле двоичных данных.</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Какие классы-надстройки позволяют ускорить чтение/запись за счет использования буфера?</li>
</ul>
</h3>
</div>
<div>
Для этого используются классы, позволяющие буферизировать поток:</div>
<div>
<ul>
<li>java.io.BufferedInputStream
 - буферизированный входной поток. Конструкторы: 
BufferedInputStream(InputStream in), BufferedInputStream(InputStream in,
 int size).</li>
<li>java.io.BufferedOutputStream
 - буферизированный выходной поток. Конструкторы: 
BufferedOutputStream(OutputStream out), 
BufferedOutputStream(OutputStream out, int size).</li>
<li>java.io.BufferedReader
 - буферизированный входной символьный поток. Конструкторы: 
BufferedReader(Reader r), BufferedReader(Reader in, int sz).</li>
<li>java.io.BufferedWriter
 - буферизированный выходной символьный поток. Конструкторы: 
BufferedWriter(Writer out), BufferedWriter(Writer out, int sz).</li>
</ul>
</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?</li>
</ul>
</h3>
</div>
<div>
OutputStreamWriter
 - это мост между классом OutputStream и классом Writer. Символы, 
записанные в поток, преобразовываются в байты.</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-T99_yEt1bCw/Vq4BY-zQQ6I/AAAAAAAAAOE/IkbM3I-7ziA/s1600/OutputStream_example.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="io%20p2_files/OutputStream_example.jpg" height="132" border="0" width="640"></a></div>
InputStreamReader
 - аналог для чтения. При помощи методов класса Reader читаются байты из
 потока InputStream и далее преобразуются в символы.</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-qWMY1eQ9gSg/Vq4BdC2oWYI/AAAAAAAAAOM/Ugck__wA1GY/s1600/InputStream_example.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="io%20p2_files/InputStream_example.jpg" height="212" border="0" width="640"></a></div>
<br>
<h3>
<ul>
<li>В чем отличие класса PrintWriter от PrintStream?</li>
</ul>
</h3>
Прежде
 всего, в классе PrintWriter применен усовершенствованный способ работы с
 символами UNICODE и другой механизм буферизации вывода.<br>
В
 классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался
 метод print или println. При использовании класса PrintWriter вы можете
 отказаться от автоматического сброса буферов, выполняя его явным 
образом при помощи метода flush.<br>
В классе PrintWriter предусмотрено два конструктора, позволяющих работать с выходными потоками класса OutputStream:<br>
<ul>
<li>public PrintWriter(OutputStream out); - создает поток без автоматического сброса буферов.</li>
<li>public
 PrintWriter(OutputStream out, boolean autoFlush); - способ сброса 
буферов при использовании второго конструктора зависит от значения 
параметра autoFlush. Если он равен true, автоматический сброс буферов 
выполняется, а если false - нет.</li>
</ul>
Набор
 реализаций основных методов print и println класса PrintWriter 
аналогичен набору реализация этих методов класса PrintStream.<br>
Здесь же мы упомянем только методы flush и checkError.<br>
Метод
 flush вызывает принудительный сброс буфера вывода. Если поток 
PrintWriter создан на базе стандартного потока вывода System.out, то 
записанные в него данные появятся на консоли только после выполнения 
сброса буфера (автоматического или сделанного методом flush).<br>
Что же касается метода checkError, то в случае возникновения ошибок он возвращает значение true.<br>
<div>
<br></div>
</div>
<div>
</div>
<div>
<h3>
<ul>
<li>Какой класс предназначен для работы с элементами файловой системы?</li>
</ul>
</h3>
</div>
<div>
В
 отличие от большинства классов ввода/вывода, класс File работает не с 
потоками, а непосредственно с файлами. Данный класс позволяет получить 
информацию о файле: права доступа, время и дата создания, путь к 
каталогу. А также осуществлять навигацию по иерархиям подкаталогов.</div>
<div>
Класс
 java.io.File может представлять имя определённого файла, а также имена 
группы файлов, находящихся в каталоге. Если класс представляет каталог, 
то его метод list() возвращает массив строк с именами всех файлов.</div>
<div>
Для создания объектов класса File можно использовать один из следующих конструкторов.</div>
<div>
<ul>
<li>File(File dir, String name) - указывается объекта класса File (каталог) и имя файла</li>
<li>File(String path) - указывается путь к файлу без указания имени файла</li>
<li>File(String dirPath, Sring name) - указывается путь к файлу и имя файла</li>
<li>File(URI url) - указывается объекта URI, описывающий файл</li>
</ul>
<br></div>
<div>
<h3>
<ul>
<li>Какой символ является разделителем при указании пути в файловой системе?</li>
</ul>
</h3>
<div>
</div>
</div>
<div>
Для
 различных систем символ разделителя различается. Вытащить его можно 
используя file.separator, а так же в статическом поле File.separator. 
&nbsp;Для Windows это "\".</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Какие методы класса File ви знаєте?</li>
</ul>
</h3>
</div>
<div>
У класса File очень много методов, перечислим некоторые.</div>
<div>
<ul>
<li>getAbsolutePath() - абсолютный путь файла, начиная с корня системы. В Android корневым элементом является символ слеша (/)</li>
<li>canRead() - доступно для чтения</li>
<li>canWrite() - доступно для записи</li>
<li>exists() - файл существует или нет</li>
<li>getName() - возвращает имя файла</li>
<li>getParent() - возвращает имя родительского каталога</li>
<li>getPath() - путь</li>
<li>lastModified() - дата последнего изменения</li>
<li>isFile() - объект является файлом, а не каталогом</li>
<li>isDirectory - объект является каталогом</li>
<li>isAbsolute() - возвращает true, если файл имеет абсолютный путь</li>
<li>renameTo(File
 newPath) - переименовывает файл. В параметре указывается имя нового 
имени файла. Если переименование прошло неудачно, то возвращается false</li>
<li>delete() - удаляет файл. Также можно удалить пустой каталог</li>
</ul>
</div>
<div>
<br>
<div>
</div>
</div>
<div>
<h3>
<ul>
<li>Что вы знаете об интерфейсе FileFilter?</li>
</ul>
</h3>
</div>
<div>
Интерфейс
 FileFilter применяется для проверки, попадает ли объект ли объект File 
под некоторое условие. Этот интерфейс содержит единственный метод 
boolean accept(File pathName). Этот метод необходимо переопределить и 
реализовать.</div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Какие классы позволяют архивировать объекты?</li>
</ul>
</h3>
</div>
<div>
DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream, &nbsp;GZIPInputStream, GZIPOutputStream.</div>

</body></html>