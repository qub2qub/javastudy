<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Java8 p2</title>
<link rel="stylesheet" href="../../Git Guide/grey.css">
</head>
<body>
	
<h3>
<ul>
<li>Что такое StringJoiner?</li>
</ul>
</h3>
<div>
StringJoiner
 используется, чтобы создать последовательность символов, разделенных 
разделителем, может (но это не обязательно) начинаться с префикса и 
заканчиваться суффиксом. Пример:</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-ehxpY3b1xho/VzlRJnsNI7I/AAAAAAAAAq4/lMjQXjdQgQQrDDNbZzExdPk4K8anJcgDwCLcB/s1600/q052_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q052_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Что такое default методы?</li>
</ul>
</h3>
<div>
Начиная
 с Java 8 мы можем использовать в интерфейсах стандартные методы 
(default methods) и статические методы (static methods).&nbsp;</div>
<div>
Default метод - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно<br>
<a name="more"></a> определять в реализации этого интерфейса.</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-5jBnBJfF3LA/VzlRUYhJPqI/AAAAAAAAAq8/e0nsTvTR6GQHp0KPJ88RPMhgJx1f0bB_ACLcB/s1600/q053_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q053_p01.jpg" border="0"></a></div>
<div>
<br></div>
<h3>
<ul>
<li>Что такое static методы?</li>
</ul>
</h3>
<div>
Static-методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.</div>
<div>
</div>
<ul>
<li>Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации.</li>
<li>Статические
 методы в интерфейсе хороши для обеспечения вспомогательных методов, 
например, проверки на null, сортировки коллекций и т.д.</li>
<li>Статические
 методы в интерфейсе помогают обеспечивать безопасность, не позволяя 
классам, которые реализуют интерфейс, переопределить их.</li>
<li>Мы не можем определить статические методы для методов класса Object, потому что получим ошибку компиляции.&nbsp;</li>
</ul>
<br>
<h3>
<ul>
<li>Как вызывать default-метод интерфейса в классе?</li>
</ul>
</h3>
<div>
Используя ключевое слово super вместе с именем интерфейса.</div>
<div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-LiapsEILqKs/VzlSY3BKxzI/AAAAAAAAArM/jutVU1ZbwIQc4gyg--968UDthowXMvufQCLcB/s1600/q055_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q055_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
</div>
<h3>
<ul>
<li>Как вызывать static-метод интерфейса в классе?</li>
</ul>
</h3>
<div>
Используя имя интерфейса.</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-PPhp7ifrB44/VzlSxyAAFDI/AAAAAAAAArU/8dlj0whJncgBDgMLaPDzUSWMxXH4fIXqQCLcB/s1600/q056_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q056_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Что такое потоки(stream) в Java 8?</li>
</ul>
</h3>
<div>
java.util.stream
 - введен для поддержки распараллеливания вычислений в потоках. 
Предоставляет возможность обрабатывать последовательность элементов 
исполняя одну или несколько операций, которые могут выполняться либо 
последовательно либо паралельно. Потоки делятся на последовательные и 
параллельные. Самая большая польза от этого - в работе с коллекциями.</div>
<div>
Операции
 над потоком относятся либо к промежуточным, либо к терминальным. Все 
промежуточные операции возвращают поток, так что мы можем объединять 
несколько промежуточных операций без использования точки с запятой. 
Терминальные операции возвращают void или непотоковый результат.<br>
<br></div>
<div>
<h3>
<ul>
<li>Для чего нужен метод collect Java 8?</li>
</ul>
</h3>
</div>
<div>
Большинство
 операций класса Stream, которые модифицируют набор данных, возвращают 
этот набор в виде потока. Однако бывают ситуации, когда хотелось бы 
получить данные не в виде потока, а в виде обычной коллекции, например, 
ArrayList или HashSet. И для этого у класса Stream определен метод 
collect. Метод принимает в качестве параметра функцию преобразования к 
коллекции:</div>
<div>
&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</div>
<div>
Параметр
 R представляет тип результата метода, параметр Т - тип элемента в 
потоке, а параметр А - тип промежуточных накапливаемых данных. В итоге 
параметр collector представляет функцию преобразования потока в 
коллекцию.<br>
<br>
<h3>
<ul>
<li>В чем разница между коллекцией(Collection) и потоком(Stream)?</li>
</ul>
</h3>
</div>
<div>
Разница
 между коллекцией(Collection) данных и потоком(Stream) из новой JDK8 в 
том что коллекции позволяют работать с элементами по-отдельности, тогда 
как поток(Stream) не позволяет. Например, с использованием коллекций, вы
 можете добавлять элементы, удалять, и вставлять в середину. 
Поток(Stream) не позволяет манипулировать отдельными элементами из 
набора данных, но вместо этого позволяет выполнять функции над данными 
как одним целом.<br>
<br>
<h3>
<ul>
<li>Для чего предназначен метод forEach в потоках(stream)?</li>
</ul>
</h3>
</div>
<div>
Метод
 void forEach(Consumer&lt;? super T&gt; action) - для каждого элемента 
выполняется действие action. forEach является терминальной операцией, 
используется для перебора каждого элемента потока.</div>
<div>
forEach
 не гарантирует последовательности вывода элементов в параллельном 
stream-е, для этого используется метод forEachOrdered - он это 
гарантирует.<br>
<br>
<h3>
<ul>
<li>Как вывести на экран 10 случайных чисел, используя forEach?</li>
</ul>
</h3>
</div>
<div>
Следующий фрагмент кода показывает, как вывести 10 случайных чисел с помощью forEach.</div>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-6mAxQv6Vusg/VzlTMKq9wFI/AAAAAAAAArc/ja4oGUiHOeIWpNy9pCB7bU2JnvZh_O82QCLcB/s1600/q061_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q061_p01.jpg" border="0"></a></div>
<div>
<br></div>
<div>
<h3>
<ul>
<li>Для чего предназначен метод map в потоках(stream)?</li>
</ul>
</h3>
Метод
 &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; 
mapper) - преобразует элементы типа T в элементы типа R и возвращает 
поток с элементами R. map является промежуточной операцией, метод 
используется для преобразования элементов в другой объект при помощи 
переданной функции.<br>
<br>
<h3>
<ul>
<li>Как можно вывести на экран уникальные квадраты чисел используя метод map?</li>
</ul>
</h3>
Следующий фрагмент кода демонстрирует это, используя метод map.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-nspnH6hzD2I/VzlVlc32yWI/AAAAAAAAArs/XwcFIWO3PUUekJlQmKBgw0Ze8lUpvZuMACLcB/s1600/q063_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q063_p01.jpg" height="40" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Какова цель метода filter в потоках(stream)?</li>
</ul>
</h3>
Метод
 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) - 
фильтрует элементы в соответствии с условием в предикате. filter 
является промежуточной операцией, используется для фильтрации массива 
через функцию.<br>
На
 самом деле filter, не выполняет фильтрацию, вместо этого он создается 
новый поток, который по завершению формирования, содержит элементы 
исходного потока, которые соответствуют заданному предикату.<br>
<br>
<h3>
<ul>
<li>Как вывести на экран количество пустых строк с помощью метода filter?</li>
</ul>
</h3>
Следующий фрагмент кода демонстрирует это с помощью метода filter.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-zY911QC27ic/VzlWCygwnNI/AAAAAAAAArw/HvvMt-QgHI8OSZ-Sdq77EEz9tRgp5kLEQCLcB/s1600/q065_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q065_p01.jpg" height="52" border="0" width="640"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Для чего предназначен метод limit в потоках(stream)?</li>
</ul>
</h3>
Метод
 Stream&lt;T&gt; limit(long maxSize) - оставляет в потоке только maxSize
 элементов. limit является промежуточной операцией, используется для 
выборки первых maxSize элементов потока. Этот метод также возвращает 
модифицированный поток, в котором не более maxSize элементов.<br>
<br>
<h3>
<ul>
<li>Для чего предназначен метод sorted в потоках(stream)?</li>
</ul>
</h3>
Метод
 Stream&lt;T&gt; sorted()/Stream&lt;T&gt; sorted(Comparator&lt;? super 
T&gt; comparator) - возвращает отсортированный поток. sorted является 
промежуточной операцией, метод используется для сортировки потока 
используя естественный порядок сравнения его элементов. Существует также
 второй метод sorted(), принимающий либо экземпляр Comparable, либо 
соответствующее ему лямбда-выражение.<br>
<br>
<h3>
<ul>
<li>Как вывести на экран 10 случайных чисел в отсортированном порядке в Java 8?</li>
</ul>
</h3>
Следующий фрагмент кода демонстрирует это:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-hwrvPoKry5c/VzlXBxlmEeI/AAAAAAAAAsA/l6kJ1BfZsQs4IIttrdVlF-hr5faOf28ZwCLcB/s1600/q068_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q068_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Параллельная обработка в Java 8?</li>
</ul>
</h3>
Чтобы
 сделать обычный последовательный поток параллельным, надо вызвать у 
объекта Stream метод parallel. Кроме того, можно также использовать 
метод parallelStream() интерфейса Collection для создания параллельного 
потока из коллекции.<br>
В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.<br>
Следующий фрагмент кода, выводит количество пустых строк с помощью метода parallelStream.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-9Aslxp1s_II/VzlXYv6WF_I/AAAAAAAAAsE/AystaQHLLLo7XiMOkRRTx76vfl403a1ogCLcB/s1600/q069_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q069_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как найти максимальное число в списке Java 8?</li>
</ul>
</h3>
Следующий код выводит наибольшее число которое присутствует в списке.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-0pD_xUKbfuI/VzlX23QT_EI/AAAAAAAAAsM/tCJqhREw_5gqkrsb82djWKjKEAE2kXUJQCLcB/s1600/q070_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q070_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как найти минимальное число в списке Java 8?</li>
</ul>
</h3>
Следующий код выводит минимальное число которое присутствует в списке.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-HeVxs0Hv-J0/VzlYOP26GSI/AAAAAAAAAsU/rhiBTAcxxyYURcVHoP_FMyWq2YNaR88wACLcB/s1600/q071_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q071_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как получить сумму всех чисел в списке, используя Java 8?</li>
</ul>
</h3>
Следующий код выведет сумму всех чисел.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-4Kk6_YFcQy4/VzqletbtAyI/AAAAAAAAAso/cD2-rI0YjT8_Gj2f-bpcxMj-3aAcL-RVgCLcB/s1600/q072_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q072_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как получить среднее значение всех чисел, в списке, используя Java 8?</li>
</ul>
</h3>
Следующий код выведет среднее значение всех чисел.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-URluev3swCg/Vzqlsn9bfmI/AAAAAAAAAss/suF4R-lm0CERvIZjHNrz1LsBK9zSzLRrwCLcB/s1600/q073_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q073_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Что такое Optional?</li>
</ul>
</h3>
Optional
 - это контейнер объекта, он может содержать значение или некоторый тип 
Т, или просто быть null. Он предоставляет много полезных методов 
избавляющие от добавления повторяющихся if null/notNull проверок, что 
позволяет нам сфокусироваться на том, что мы хотим сделать.<br>
Метод
 isPresent() возвращает true если экземпляр Optional содержит не null 
значение и false в противном случае. Метод orElseGet() содержит запасной
 механизм результата, если Optional содержит null, принимая функции для 
генерации значения по умолчанию. Метод map() преобразует текущее 
значение Optional и возвращает новый экземпляр Optional. Метод orElse() 
похож на orElseGet(), но вместо функции он принимает значение по 
умолчанию.<br>
<br>
<h3>
<ul>
<li>Что такое Nashorn?</li>
</ul>
</h3>
Nashorn
 - это движок JavaScript, разрабатываемый полностью на Java компанией 
Oracle. &nbsp;Он призван дать возможность встраивать код JavaScript в 
приложения Java. В сравнении с Rhino, который поддерживается Mozilla 
&nbsp;Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую 
производительность, так как он непосредственно компилирует код в памяти и
 передает байт-код виртуальной машине Java. Nashorn умеет компилировать 
код JavaScript и генерировать классы Java, которые загружаются 
специальным загрузчиком. Возможен вызов кода Java прямо из JavaScript.<br>
<br>
<h3>
<ul>
<li>Что такое jjs в Java 8?</li>
</ul>
</h3>
Nashorn
 поставляется с cmd-утилитой jjs, которая позволяет исполнять JavaScript
 прямо в консоли. jjs принимает список JavaScript файлов исходного кода и
 запускает их. Чтобы запустить файл давайте передадим его как аргумент в
 jjs:<br>
jjs fileName.js<br>
<br>
<h3>
<ul>
<li>Что такое LocalDateTime в Java 8?</li>
</ul>
</h3>
LocalDateTime
 объединяет вместе LocaleDate и LocalTime и содержит дату и время, но 
без часового пояса в календарной системе ISO-8601. Время хранится с 
точностью до наносекунды, так что в LocalTime можно хранить, например, 
величину "13:45.30.123456789". Есть множество удобных методов, таких как
 plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.<br>
<br>
<h3>
<ul>
<li>Что такое ZonedDateTime в Java 8?</li>
</ul>
</h3>
ZonedDateTime
 - аналог java.util.Calendar. Это самый мощный класс с полной 
информацией о временном контексте, включает временную зону. Он содержит 
дату и время в календарной системе ISO-8601.<br>
<br>
<h3>
<ul>
<li>Как получить текущую дату с использованием time API из Java 8?</li>
</ul>
</h3>
Следующий код выводит текущую дату.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-llx6yGQEDdw/VzqnjirpiCI/AAAAAAAAAs8/cnugjp11NEw0-SzOpEZPRP7xaprdezOCwCLcB/s1600/q079_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q079_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как добавить 1 неделю к текущей дате с использованием time API?</li>
</ul>
</h3>
Следующий код добавляет 1 неделю к текущей дате.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-4_j4Am7jAlg/Vzqn08S9exI/AAAAAAAAAtA/9f2UJIzL_IckCrz5LAMJHQ5_eWjJZktUgCLcB/s1600/q080_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q080_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как добавить 1 месяц к текущей дате с использованием time API?</li>
</ul>
</h3>
Следующий код добавляет 1 месяц к текущей дате.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-CjSRX9ceToQ/VzqoER8ZTDI/AAAAAAAAAtE/wj94-8t93yAG_nCUtLEQToCs6p_0EKgVgCLcB/s1600/q081_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q081_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как добавить 1 год к текущей дате с использованием time API?</li>
</ul>
</h3>
Следующий код добавляет 1 год к текущей дате.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-FA0tN89HRBQ/Vzqo0XqcUdI/AAAAAAAAAtQ/YuV5tXjimH0bluhTtOft34VjWpKg5JKGgCLcB/s1600/q082_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q082_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как добавить 10 лет к текущей дате с использованием time API?</li>
</ul>
</h3>
Следующий код добавляет 10 лет к текущей дате.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://1.bp.blogspot.com/-Z93Ktm1vimo/VzqpDn7oxUI/AAAAAAAAAtU/_Oyy-ZhX1RUZALQ53KL-48k7LpFvgJ55ACLcB/s1600/q083_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q083_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как получить следующий вторник используя time API?</li>
</ul>
</h3>
Следующий код возвращает следующий вторник.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-IPY2vu8N0tw/VzqpmPpaAzI/AAAAAAAAAtc/Snd95mM5aIkPDeV9_2zXi51vzOVRG-U6QCLcB/s1600/q084_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q084_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как получить вторую субботу текущего месяца используя time API?</li>
</ul>
</h3>
Следующий код демонстрирует это.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://4.bp.blogspot.com/-DyeBBJxqTrE/Vzqp2kN8bVI/AAAAAAAAAtk/szmCCoh70ZQPS6eoS6V9HxwPXpO70vAEACLcB/s1600/q085_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q085_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Как получить текущею дату в миллисекундах используя time API?</li>
</ul>
</h3>
Следующий код возвращает дату в миллисекундах.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://2.bp.blogspot.com/-r2ZkjLLRknc/VzqqHVlXWHI/AAAAAAAAAto/KwMugQUNVcYSGaIo5gWTK4CbJU_Ls1q0ACLcB/s1600/q086_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q086_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Як получить текущею дату по местному времени в миллисекундах используя используя time API?</li>
</ul>
</h3>
Следующий код демонстрирует это.<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://3.bp.blogspot.com/-3Gi2vW3p8LI/VzqqZeVp9VI/AAAAAAAAAtw/5LMVRWTZA10ZGi11v1E1DNSSikKtoIAPwCLcB/s1600/q087_p01.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="java8%20p2_files/q087_p01.jpg" border="0"></a></div>
<div class="separator" style="clear: both; text-align: justify;">
<br></div>
<h3>
<ul>
<li>Какой класс появился в Java 8 для декодирования данных?</li>
</ul>
</h3>
В
 Java 8 для этого появился класс public static class Base64.Decoder - 
этот класс реализует декодер для декодирования байт данных, используя 
схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс 
безопасен для использования несколькими параллельными потоками.<br>
<br>
<h3>
<ul>
<li>Какой класс появился в Java 8 для кодирования данных?</li>
</ul>
</h3>
В
 Java 8 для этого появился класс public static class Base64.Encoder - 
этот класс реализует &nbsp;кодер для кодирования байт данных, используя 
схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс 
безопасен для использования несколькими параллельными потоками.<br>
<br>
<h3>
<ul>
<li>Как создать Base64 декодировщик?</li>
</ul>
</h3>
Используя
 метод getDecoder() класса Base64 он возвращает декодировщик 
Base64.Decoder, который декодирует данные с помощью схемы кодирования 
base64.<br>
<br>
<h3>
<ul>
<li>Как создать Base64 кодировщик?</li>
</ul>
</h3>
Используя
 метод getEncoder() класса Base64 он возвращает кодировщик 
Base64.Encoder, который кодирует данные с помощью схемы кодирования 
base64.</div>


</body></html>