<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Multithreading p1</title>
</head>
<body>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Чем отличается процесс от &nbsp;потока?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Процесс это 
некоторая единица операционной системы, которой выделена память и другие
 ресурсы. Поток это единица исполнения кода. Поток имеет стэк - 
некоторую свою память для исполнения. Остальная память процесса - общая 
для всех его потоков. Потоки исполняются на ядрах процессора.&nbsp;</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">В некоторых OS разница между процессами и потоками сведена к минимуму.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Каким образом можно создать поток?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-size: 12pt; text-indent: 7.1pt;">Е</span>сть несколько способов создания и запуска потоков:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">С помощью класса, реализующего Runnable:</span></li>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать объект класса Thread.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать объект класса, реализующего интерфейс Runnable.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Вызвать у 
созданного объекта Thread метод start() (после этого запустится метод 
run() у переданного объекта, реализующего Runnable).</span></li>
</ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">С помощью класса, расширяющего Thread:</span></li>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать объект класса ClassName extends Thread.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').<a name="more"></a></span></li>
</ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">С помощью класса, реализующего java.util.concurrent.Callable:</span></li>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать объект класса, реализующего интерфейс Callable.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать объект ExecutorService с указанием пула потоков.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Создать 
объект Future. Запуск происходит через метод submit(); Сигнатура: 
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task).</span></li>
</ul>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<ul>
</ul>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что такое монитор?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Контроль за 
доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор 
экземпляра может иметь только одного владельца. При попытке 
конкурирующего доступа к объекту, чей монитор имеет владельца, желающий 
заблокировать объект-ресурс поток должен подождать освобождения монитора
 этого объекта и только после этого завладеть им и начать использование 
объекта-ресурса.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Какие способы синхронизации в Java?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Ниже приведены некоторые способы синхронизации в Java:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Системная синхронизация с использованием wait/notify.&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Поток,
 который ждет выполнения каких-либо условий, вызывает у этого объекта 
метод wait, предварительно захватив его монитор. На этом его работа 
приостанавливается. Другой поток может вызвать на этом же самом объекте 
метод notify (опять же, предварительно захватив монитор объекта), в 
результате чего, ждущий на объекте поток "просыпается" и продолжает свое
 выполнение.&nbsp;</span></span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Системная синхронизация с использованием join.&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Метод
 join, вызванный у экземпляра класса Thread, позволяет текущему потоку 
остановиться до того момента, как поток, связаный с этим экземпляром, 
закончит работу.&nbsp;</span></span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Использование классов из пакета java.util.concurrent,&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">который
 предоставляет набор классов для организации межпоточного 
взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. 
Концепция данного подхода заключается в использовании атомарных операций
 и переменных.</span></span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<ul>
</ul>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Как работают методы wait и notify/notifyAll?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Как работают 
эти методы. Во-первых они могут вызваны только потоком, который захватил
 монитор объекта, для которого эти методы вызываются. То есть они 
вызываются внутри блока synchronized и для объекта, монитор которого 
этим synchronized захвачен. Если внутри synchronized метода - то для 
класса, к которому относятся эти методы.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Что делает 
метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что
 другие потоки теперь могут его (монитор) захватить, то есть войти в 
блок synchronized для этого объекта. Затем метод wait() переходит в 
состояние ожидания, до тех пор пока другой поток не вызывет метод 
notify() или notifyAll() для этого же объекта. После чего поток, в 
котором был вызван wait(), пытается снова захватить монитор объекта и 
когда монитор становится свободным, то есть когда другой поток 
освобождает его, захватывает монитор и продолжает выполнение со 
следующего после wait() оператора. Причем у потока вызвашего wait() нет 
никакого преимущества перед другими потоками, ожидающими захвата того же
 монитора.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Что делают 
методы notify(), notifyAll(). Они "пробуждают" поток, ожидающий методом 
wait() (если такой есть), и переводят его в состояние ожидания 
освобождения монитора. Разница между notify() и notifyAll() в том, что 
notify() пробуждает только один поток , ожидающий методом wait(), какой 
именно будет пробужден - определить нельзя, а notifyAll() - все такие 
потоки.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Чем отличается работа метода wait с параметром и без параметра?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Разница методов в следующем:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">final void 
wait() &nbsp;- метод используется в многопоточной среде, может 
вызываться только потоком, владеющим объектом синхронизации. При этом 
объект синхронизации освобождается, а текущий поток переходит в режим 
ожидания сигнала освобождения объекта синхронизации другим потоком путем
 вызова метода notify() либо notifyAll().</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">final void 
wait(long time) &nbsp;- аналогично wait() данный метод используется в 
многопоточной среде, переходит текущий поток в режим ожидания сигнала 
освобождения объекта синхронизации другим потоком путем вызова метода 
notify() либо notifyAll(), или ожидание происходит заданное время time, 
затем выполнение продолжается безусловно.</span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Основные отличия:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">метод&nbsp;yield()
 - пытается сказать планировщику потоков, что нужно выполнить другой 
поток, что ожидает в очереди на выполнение. Метод не пытается перевести 
текущий поток в состояние блокировки, сна или ожидания. Он просто 
пытается его перевести из состояние "работающий" в состояние 
"работоспособный". Однако выполнение метода может вообще не произвести 
никакого эффекта. состояние потока остатается RUNNABLE&nbsp;</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">метод&nbsp;wait() - меняет состояние потока на WAITING&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">может
 быть вызвано только у объекта владеющего блокировкой, в противном 
случае выкинется исключение IllegalMonitorStateException. при 
срабатывании метода блокировка отпускается, что позволяет продолжить 
работу другим потокам ожидающим захватить ту же самую блокировку . в 
случае wait(int) с аргументом состояние будет TIMED_WAITING.</span></span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Как работает метод Thread.join()?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Метод join() 
вызывается для того, чтобы привязать текущий поток в конец потока для 
которого вызывается метод. То есть второй поток будет в режиме 
блокировки пока первый поток не выполнится.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что такое dead lock?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Это когда один 
поток А получил блокировку на объект А1, а поток В получил блокировку на
 объект В1. В то время как поток А пытается получит блокировку на объект
 В1, а поток В на А1.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<div>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">На каком объекте происходит синхронизация при вызове static synchronized метода?</span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"></span></div>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Представьте 
себе ситуацию что два потока одновременно изменяют состояние какого-то 
объекта, это недопустимо. Для этого необходимо синхронизировать потоки. 
Как это сделать? Ключевое слово synchronized позволяет это сделать 
установив в сигнатуре метода. Или же в методе можно описать блок 
synchronized, только в качестве параметра необходимо передать объект, 
который будет блокироватся.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Представьте 
себе ситуацию когда один поток ждет пока разблокируется объект… а если 
это ждут несколько потоков? Нет гарантии что тот объект что больше всех 
ждал снятия блокировки будет выполнятся первым.&nbsp;</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Статические 
синхронизированные методы и нестатические &nbsp;синхронизированные 
методы не будет &nbsp;блокировать друг друга, никогда. Статические 
&nbsp;методы блокируются на экземпляре класса Class в то время как 
нестатические методы блокируются на текущем экземпляре (this). Эти 
действия не мешают друг другу.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">wait() - отказывается от блокировки остальные методы сохраняют блокировку.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Для чего используется ключевое слово volatile, synchronized, transient, native?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Краткое описание ключевых слов:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">volatile - указывает на то, что поле синхронизировано для нескольких потоков</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">transient - указывает на то, что переменная не подлежит сериализации</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">native - говорит о том, что реализация метода написана на другой программной платформе</span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<ul>
</ul>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что значит приоритет потока?&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Приоритет 
потока - это число от 1 до 10, в &nbsp;зависимости от которого, 
планировщик потоков выбирает какой поток &nbsp;запускать. Однако 
полагаться на приоритеты для предсказуемого выполнения многопоточной 
&nbsp;программы нельзя!</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что такое потоки - демоны в джава?&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Это потоки, 
которое работают в фоновом &nbsp;режиме и не гарантируют что они 
завершатся. Тоеть если все потоки завершились, то поток демон просто 
обрывается вместе с закрытием приложения.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что значит усыпить поток?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Перевести поток в спящее состояние можно &nbsp;с помощью метода sleep(long ms) ms - время в миллисекундах.&nbsp;</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">При вызове 
этого метода, поток переходит &nbsp;в спящее состояние, после сна, поток
 переходит в пул потоков и &nbsp;находится в состоянии 
"работоспособный", т.е. не гарантируется что после пробуждения он будет 
сразу выполняться. Также поток не может усыпить другой поток, так как 
метод sleep - это статический метод! Вы просто усыпите текущий поток и 
не более того! Также метод sleep() может возбуждать 
InterruptedException().</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">В каких состояниях может быть &nbsp;поток в джава? Как вообще работает поток?&nbsp;</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">У нас есть 
текущий поток, в котором &nbsp;выполняется метод main. Этот поток имеет 
свой стек и этот стек начинается с вызова метода main.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Далее в методе 
main мы создаем новый поток, что происходит… создается новый поток и для
 него выделяется свой стек с первоначальным методом run().</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Когда мы 
запускаем несколько потоков, то мы не можем гарантировать определенный 
порядок их вызовов. Планированием &nbsp;потоков занимается планировщик 
&nbsp;потоков JVM, выбирая из пулов потоков &nbsp;поток. Мы даже не 
можем гарантировать &nbsp;что если первый поток начался &nbsp;выполнятся
 первым, то он и закончит выполнятся первым, он может закончить 
выполнятся последним.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Еще такой 
ньюанс, что поток, который закончил свое выполнение, не может быть 
повторно запущен! Он находится в состоянии "мертвый", а для запуска 
потока нового потока, объект должен находится в состоянии "новый".</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;">Потоки &nbsp;имеют такие состояния:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">новый(это когда только создали экземпляр класса Thread)</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">живой 
&nbsp;или работоспособный(переходит в это состояние после запуска метода
 start(), но это не означает что поток уже работает! Или же он может 
перейти в это состояние из состояние работающий или блокированный)</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">работающий(это когда метод run() начал выполнятся)</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">ожидающий
 (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния 
характеризуют поток как не готовый к работе. Я объединил эти состояния 
т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее 
время не может быть выполнен.</span><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Другими словами поток уже не работает, но он может вернутся в рабочее состояние.&nbsp;</span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Поток
 может быть заблокирован, это может &nbsp;означать что он ждет 
освобождение каких-то ресурсов. Поток может спать, если встретился метод
 sleep(long s) , или же он может ожидать, если встретился метод wait(), 
он будет ждать пока не вызовится метод notify() или notifyall().</span></span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">мертвый(состояние когда метод run() завершил свою работу)</span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<ul>
</ul>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Чем отличаются два интерфейса для реализации задач Runnable и Callable?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Основные различия:</span><br>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Классы, 
реализующие &nbsp;интерфейс Runnable должны реализовывать метод run() 
для выполнения задачи. Классы, реализующие интерфейс Callable должны 
реализовывать метод call() для выполнения задачи.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Метод 
Runnable.run() не возвращает никакого значения, его тип void, а метод 
Callable.call() может возвращать значение типа T. Интерфейс Callable 
является параметризированным &nbsp;Callable&lt;T&gt; и тип значения, 
которое будет возвращаться в методе call() задается этим параметром 
T.&nbsp;</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.</span></li>
</ul>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span>
</span><br>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Различия между CyclicBarrier и CountDownLatch?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Хоть оба эти 
синхронизаторы позволяют нитям дожидаться друг друга, главное различие 
между ними в том, что вы не можете заново использовать CountDownLatch 
после того, как его счётчик достигнет нуля, но вы можете использовать 
CyclicBarrier снова, даже после того, как барьер сломается.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что такое состояние гонки (race condition)?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Состояние гонки
 - причина трудноуловимых багов. Как сказано в самом названии, состояние
 гонки возникает из-за гонки между несколькими нитями, если нить, 
которая должна исполнятся первой, проиграла гонку и исполняется вторая, 
поведение кода изменяется, из-за чего возникают недетерменированные 
баги. Это одни из сложнейших к отлавливанию и воспроизведению багов, 
из-за беспорядочной природы гонок между нитями. Пример состояния гонки -
 беспорядочное исполнение.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Как остановить нить?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Java 
предоставляет богатые API для всего, но, по иронии судьбы, не 
предоставляет удобных способов остановки нити. В JDK 1.0 было несколько 
управляющих методов, например stop(), suspend() и resume(), которые были
 помечены как deprecated в будущих релизах из-за потенциальных угроз 
взаимной блокировки, с тех пор разработчики Java API не предприняли 
попыток представить стойкий, ните-безопасный и элегантный способ 
остановки нитей. Программисты в основном полагаются на факт того, что 
нить останавливается сама, как только заканчивает выполнять методы run()
 или call(). Для остановки вручную, программисты пользуются 
преимуществом volatile boolean переменной и проверяют её значение в 
каждой итерации, если в методе run() есть циклы, или прерывают нити 
методом interrupt() для внезапной отмены заданий.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><br></span>
<h3>
<ul>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Что происходит, когда в нити появляется исключение?</span></li>
</ul>
</h3>
<span style="font-family: Arial, Helvetica, sans-serif;">Это один из 
хороших вопросов с подвохом. Простыми словами, если исключение не 
поймано - нить мерта, если установлен обработчик непойманных исключений,
 он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, 
определённый как вложенный интерфейс для обработчиков, вызываемых, когда
 нить внезапно останавливается из-за непойманного исключения. Когда нить
 собирается остановится из-за непойманного исключения, JVM проверит её 
на наличие UncaughtExceptionHandler, используя 
Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод 
uncaughtException(), передав нить и исключение в виде аргументов.</span><br>
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"></span><br></span>
<h3>
<span style="font-family: Arial, Helvetica, sans-serif;"><a href="https://jsehelper.blogspot.nl/2016/01/multithreading-2.html">Multithreading (часть 2).</a></span></h3>


</body></html>