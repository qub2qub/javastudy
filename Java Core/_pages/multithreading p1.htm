<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Multithreading p1</title>
<link rel="stylesheet" href="../../Guides/grey.css">
</head>
<body>
<h3>
<ul>
<li>Чем отличается процесс от &nbsp;потока?</li>
</ul>
</h3>
Процесс это 
некоторая единица операционной системы, которой выделена память и другие
 ресурсы. Поток это единица исполнения кода. Поток имеет стэк - 
некоторую свою память для исполнения. Остальная память процесса - общая 
для всех его потоков. Потоки исполняются на ядрах процессора.&nbsp;<br>
В некоторых OS разница между процессами и потоками сведена к минимуму.<br>
<br>
<h3>
<ul>
<li>Каким образом можно создать поток?</li>
</ul>
</h3>
Есть несколько способов создания и запуска потоков:<br>
<ul>
<li>С помощью класса, реализующего Runnable:</li>
<ul>
<li>Создать объект класса Thread.</li>
<li>Создать объект класса, реализующего интерфейс Runnable.</li>
<li>Вызвать у 
созданного объекта Thread метод start() (после этого запустится метод 
run() у переданного объекта, реализующего Runnable).</li>
</ul>
<li>С помощью класса, расширяющего Thread:</li>
<ul>
<li>Создать объект класса ClassName extends Thread.</li>
<li>Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').<a name="more"></a></li>
</ul>
<li>С помощью класса, реализующего java.util.concurrent.Callable:</li>
<ul>
<li>Создать объект класса, реализующего интерфейс Callable.</li>
<li>Создать объект ExecutorService с указанием пула потоков.</li>
<li>Создать 
объект Future. Запуск происходит через метод submit(); Сигнатура: 
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task).</li>
</ul>
</ul>
<br>
<ul>
</ul>
<h3>
<ul>
<li>Что такое монитор?</li>
</ul>
</h3>
Контроль за 
доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор 
экземпляра может иметь только одного владельца. При попытке 
конкурирующего доступа к объекту, чей монитор имеет владельца, желающий 
заблокировать объект-ресурс поток должен подождать освобождения монитора
 этого объекта и только после этого завладеть им и начать использование 
объекта-ресурса.<br>
<br>
<h3>
<ul>
<li>Какие способы синхронизации в Java?</li>
</ul>
</h3>
Ниже приведены некоторые способы синхронизации в Java:<br>
<ul>
<li>Системная синхронизация с использованием wait/notify.&nbsp;Поток,
 который ждет выполнения каких-либо условий, вызывает у этого объекта 
метод wait, предварительно захватив его монитор. На этом его работа 
приостанавливается. Другой поток может вызвать на этом же самом объекте 
метод notify (опять же, предварительно захватив монитор объекта), в 
результате чего, ждущий на объекте поток "просыпается" и продолжает свое
 выполнение.&nbsp;</li>
<li>Системная синхронизация с использованием join.&nbsp;Метод
 join, вызванный у экземпляра класса Thread, позволяет текущему потоку 
остановиться до того момента, как поток, связаный с этим экземпляром, 
закончит работу.&nbsp;</li>
<li>Использование классов из пакета java.util.concurrent,&nbsp;который
 предоставляет набор классов для организации межпоточного 
взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. 
Концепция данного подхода заключается в использовании атомарных операций
 и переменных.</li>
</ul>
<br>
<br>
<ul>
</ul>
<h3>
<ul>
<li>Как работают методы wait и notify/notifyAll?</li>
</ul>
</h3>
Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.<br>
Как работают 
эти методы. Во-первых они могут вызваны только потоком, который захватил
 монитор объекта, для которого эти методы вызываются. То есть они 
вызываются внутри блока synchronized и для объекта, монитор которого 
этим synchronized захвачен. Если внутри synchronized метода - то для 
класса, к которому относятся эти методы.<br>
Что делает 
метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что
 другие потоки теперь могут его (монитор) захватить, то есть войти в 
блок synchronized для этого объекта. Затем метод wait() переходит в 
состояние ожидания, до тех пор пока другой поток не вызывет метод 
notify() или notifyAll() для этого же объекта. После чего поток, в 
котором был вызван wait(), пытается снова захватить монитор объекта и 
когда монитор становится свободным, то есть когда другой поток 
освобождает его, захватывает монитор и продолжает выполнение со 
следующего после wait() оператора. Причем у потока вызвашего wait() нет 
никакого преимущества перед другими потоками, ожидающими захвата того же
 монитора.<br>
Что делают 
методы notify(), notifyAll(). Они "пробуждают" поток, ожидающий методом 
wait() (если такой есть), и переводят его в состояние ожидания 
освобождения монитора. Разница между notify() и notifyAll() в том, что 
notify() пробуждает только один поток , ожидающий методом wait(), какой 
именно будет пробужден - определить нельзя, а notifyAll() - все такие 
потоки.<br>
<br>
<h3>
<ul>
<li>Чем отличается работа метода wait с параметром и без параметра?</li>
</ul>
</h3>
Разница методов в следующем:<br>
<ul>
<li>final void 
wait() &nbsp;- метод используется в многопоточной среде, может 
вызываться только потоком, владеющим объектом синхронизации. При этом 
объект синхронизации освобождается, а текущий поток переходит в режим 
ожидания сигнала освобождения объекта синхронизации другим потоком путем
 вызова метода notify() либо notifyAll().</li>
<li>final void 
wait(long time) &nbsp;- аналогично wait() данный метод используется в 
многопоточной среде, переходит текущий поток в режим ожидания сигнала 
освобождения объекта синхронизации другим потоком путем вызова метода 
notify() либо notifyAll(), или ожидание происходит заданное время time, 
затем выполнение продолжается безусловно.</li>
</ul>
<br>
<h3>
<ul>
<li>Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?</li>
</ul>
</h3>
Основные отличия:<br>
<ul>
<li>метод&nbsp;yield()
 - пытается сказать планировщику потоков, что нужно выполнить другой 
поток, что ожидает в очереди на выполнение. Метод не пытается перевести 
текущий поток в состояние блокировки, сна или ожидания. Он просто 
пытается его перевести из состояние "работающий" в состояние 
"работоспособный". Однако выполнение метода может вообще не произвести 
никакого эффекта. состояние потока остатается RUNNABLE&nbsp;</li>
<li>метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE</li>
<li>метод&nbsp;wait() - меняет состояние потока на WAITING&nbsp;может
 быть вызвано только у объекта владеющего блокировкой, в противном 
случае выкинется исключение IllegalMonitorStateException. при 
срабатывании метода блокировка отпускается, что позволяет продолжить 
работу другим потокам ожидающим захватить ту же самую блокировку . в 
случае wait(int) с аргументом состояние будет TIMED_WAITING.</li>
</ul>
<br>
<br>
<h3>
<ul>
<li>Как работает метод Thread.join()?</li>
</ul>
</h3>
Метод join() 
вызывается для того, чтобы привязать текущий поток в конец потока для 
которого вызывается метод. То есть второй поток будет в режиме 
блокировки пока первый поток не выполнится.<br>
<br>
<h3>
<ul>
<li>Что такое dead lock?</li>
</ul>
</h3>
Это когда один 
поток А получил блокировку на объект А1, а поток В получил блокировку на
 объект В1. В то время как поток А пытается получит блокировку на объект
 В1, а поток В на А1.<br>
<br>
<h3>
<div>
<ul>
<li>На каком объекте происходит синхронизация при вызове static synchronized метода?</li>
</ul>
</div>
</h3>
Представьте 
себе ситуацию что два потока одновременно изменяют состояние какого-то 
объекта, это недопустимо. Для этого необходимо синхронизировать потоки. 
Как это сделать? Ключевое слово synchronized позволяет это сделать 
установив в сигнатуре метода. Или же в методе можно описать блок 
synchronized, только в качестве параметра необходимо передать объект, 
который будет блокироватся.<br>
Представьте 
себе ситуацию когда один поток ждет пока разблокируется объект… а если 
это ждут несколько потоков? Нет гарантии что тот объект что больше всех 
ждал снятия блокировки будет выполнятся первым.&nbsp;<br>
Статические 
синхронизированные методы и нестатические &nbsp;синхронизированные 
методы не будет &nbsp;блокировать друг друга, никогда. Статические 
&nbsp;методы блокируются на экземпляре класса Class в то время как 
нестатические методы блокируются на текущем экземпляре (this). Эти 
действия не мешают друг другу.<br>
wait() - отказывается от блокировки остальные методы сохраняют блокировку.<br>
<br>
<h3>
<ul>
<li>Для чего используется ключевое слово volatile, synchronized, transient, native?</li>
</ul>
</h3>
Краткое описание ключевых слов:<br>
<ul>
<li>volatile - указывает на то, что поле синхронизировано для нескольких потоков</li>
<li>synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.</li>
<li>transient - указывает на то, что переменная не подлежит сериализации</li>
<li>native - говорит о том, что реализация метода написана на другой программной платформе</li>
</ul>
<br>
<br>
<ul>
</ul>
<h3>
<ul>
<li>Что значит приоритет потока?&nbsp;</li>
</ul>
</h3>
Приоритет 
потока - это число от 1 до 10, в &nbsp;зависимости от которого, 
планировщик потоков выбирает какой поток &nbsp;запускать. Однако 
полагаться на приоритеты для предсказуемого выполнения многопоточной 
&nbsp;программы нельзя!<br>
<br>
<h3>
<ul>
<li>Что такое потоки - демоны в джава?&nbsp;</li>
</ul>
</h3>
Это потоки, 
которое работают в фоновом &nbsp;режиме и не гарантируют что они 
завершатся. Тоеть если все потоки завершились, то поток демон просто 
обрывается вместе с закрытием приложения.<br>
<br>
<h3>
<ul>
<li>Что значит усыпить поток?</li>
</ul>
</h3>
Перевести поток в спящее состояние можно &nbsp;с помощью метода sleep(long ms) ms - время в миллисекундах.&nbsp;<br>
При вызове 
этого метода, поток переходит &nbsp;в спящее состояние, после сна, поток
 переходит в пул потоков и &nbsp;находится в состоянии 
"работоспособный", т.е. не гарантируется что после пробуждения он будет 
сразу выполняться. Также поток не может усыпить другой поток, так как 
метод sleep - это статический метод! Вы просто усыпите текущий поток и 
не более того! Также метод sleep() может возбуждать 
InterruptedException().<br>
<br>
<h3>
<ul>
<li>В каких состояниях может быть &nbsp;поток в джава? Как вообще работает поток?&nbsp;</li>
</ul>
</h3>
У нас есть 
текущий поток, в котором &nbsp;выполняется метод main. Этот поток имеет 
свой стек и этот стек начинается с вызова метода main.<br>
Далее в методе 
main мы создаем новый поток, что происходит… создается новый поток и для
 него выделяется свой стек с первоначальным методом run().<br>
Когда мы 
запускаем несколько потоков, то мы не можем гарантировать определенный 
порядок их вызовов. Планированием &nbsp;потоков занимается планировщик 
&nbsp;потоков JVM, выбирая из пулов потоков &nbsp;поток. Мы даже не 
можем гарантировать &nbsp;что если первый поток начался &nbsp;выполнятся
 первым, то он и закончит выполнятся первым, он может закончить 
выполнятся последним.<br>
Еще такой 
ньюанс, что поток, который закончил свое выполнение, не может быть 
повторно запущен! Он находится в состоянии "мертвый", а для запуска 
потока нового потока, объект должен находится в состоянии "новый".<br>
Потоки &nbsp;имеют такие состояния:<br>
<ul>
<li>новый(это когда только создали экземпляр класса Thread)</li>
<li>живой 
&nbsp;или работоспособный(переходит в это состояние после запуска метода
 start(), но это не означает что поток уже работает! Или же он может 
перейти в это состояние из состояние работающий или блокированный)</li>
<li>работающий(это когда метод run() начал выполнятся)</li>
<li>ожидающий
 (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния 
характеризуют поток как не готовый к работе. Я объединил эти состояния 
т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее 
время не может быть выполнен. Другими словами поток уже не работает, но он может вернутся в рабочее состояние.&nbsp;Поток
 может быть заблокирован, это может &nbsp;означать что он ждет 
освобождение каких-то ресурсов. Поток может спать, если встретился метод
 sleep(long s) , или же он может ожидать, если встретился метод wait(), 
он будет ждать пока не вызовится метод notify() или notifyall().</li>
<li>мертвый(состояние когда метод run() завершил свою работу)</li>
</ul>
<br>
<br>
<ul>
</ul>
<h3>
<ul>
<li>Чем отличаются два интерфейса для реализации задач Runnable и Callable?</li>
</ul>
</h3>
Основные различия:<br>
<ul>
<li>Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.</li>
<li>Классы, 
реализующие &nbsp;интерфейс Runnable должны реализовывать метод run() 
для выполнения задачи. Классы, реализующие интерфейс Callable должны 
реализовывать метод call() для выполнения задачи.</li>
<li>Метод 
Runnable.run() не возвращает никакого значения, его тип void, а метод 
Callable.call() может возвращать значение типа T. Интерфейс Callable 
является параметризированным &nbsp;Callable&lt;T&gt; и тип значения, 
которое будет возвращаться в методе call() задается этим параметром 
T.&nbsp;</li>
<li>Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.</li>
</ul>
<br>
<br>
<h3>
<ul>
<li>Различия между CyclicBarrier и CountDownLatch?</li>
</ul>
</h3>
Хоть оба эти 
синхронизаторы позволяют нитям дожидаться друг друга, главное различие 
между ними в том, что вы не можете заново использовать CountDownLatch 
после того, как его счётчик достигнет нуля, но вы можете использовать 
CyclicBarrier снова, даже после того, как барьер сломается.<br>
<br>
<h3>
<ul>
<li>Что такое состояние гонки (race condition)?</li>
</ul>
</h3>
Состояние гонки
 - причина трудноуловимых багов. Как сказано в самом названии, состояние
 гонки возникает из-за гонки между несколькими нитями, если нить, 
которая должна исполнятся первой, проиграла гонку и исполняется вторая, 
поведение кода изменяется, из-за чего возникают недетерменированные 
баги. Это одни из сложнейших к отлавливанию и воспроизведению багов, 
из-за беспорядочной природы гонок между нитями. Пример состояния гонки -
 беспорядочное исполнение.<br>
<br>
<h3>
<ul>
<li>Как остановить нить?</li>
</ul>
</h3>
Java 
предоставляет богатые API для всего, но, по иронии судьбы, не 
предоставляет удобных способов остановки нити. В JDK 1.0 было несколько 
управляющих методов, например stop(), suspend() и resume(), которые были
 помечены как deprecated в будущих релизах из-за потенциальных угроз 
взаимной блокировки, с тех пор разработчики Java API не предприняли 
попыток представить стойкий, ните-безопасный и элегантный способ 
остановки нитей. Программисты в основном полагаются на факт того, что 
нить останавливается сама, как только заканчивает выполнять методы run()
 или call(). Для остановки вручную, программисты пользуются 
преимуществом volatile boolean переменной и проверяют её значение в 
каждой итерации, если в методе run() есть циклы, или прерывают нити 
методом interrupt() для внезапной отмены заданий.<br>
<br>
<h3>
<ul>
<li>Что происходит, когда в нити появляется исключение?</li>
</ul>
</h3>
Это один из 
хороших вопросов с подвохом. Простыми словами, если исключение не 
поймано - нить мерта, если установлен обработчик непойманных исключений,
 он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, 
определённый как вложенный интерфейс для обработчиков, вызываемых, когда
 нить внезапно останавливается из-за непойманного исключения. Когда нить
 собирается остановится из-за непойманного исключения, JVM проверит её 
на наличие UncaughtExceptionHandler, используя 
Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод 
uncaughtException(), передав нить и исключение в виде аргументов.<br>
<br>
<h3>
<a href="https://jsehelper.blogspot.nl/2016/01/multithreading-2.html">Multithreading (часть 2).</a></h3>


</body></html>