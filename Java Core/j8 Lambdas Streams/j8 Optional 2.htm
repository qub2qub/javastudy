<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>j8 Optional 2</title>
    <link rel="stylesheet" href="../../Guides/grey.css">
    <style type="text/css">

    </style>
</head>
<body>
<a href="http://dolszewski.com/java/java-8-optional-use-cases/">src</a>
<h2>JAVA 8 OPTIONAL USE CASES</h2>
<div class="entry-content cye-lm-tag">
		<p class="cye-lm-tag">It’s been almost two years since Java 8 was officially released and many excellent articles about new enhancements and related best practices have been written through that time. <strong>Surprisingly, one of the more controversial topics amongst all the added features is the Optional class.</strong> The type is a container, which can be either empty or contain a non-null value. Such construction reminds the user of an Optional object that the situation when there’s nothing inside must be handled appropriately. Although <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">the definition of the type on Javadoc </a>is quite descriptive, when it comes to identifying valid use cases it’s getting more problematic.</p>
<h2>Method result</h2>
<p class="cye-lm-tag">The first possible use case is actually a no-brainer. Brian Goetz, who is working on the Java language at Oracle, stated this purpose <a href="http://stackoverflow.com/a/26328555/1487809">in his answer on Stack Overflow</a> as <strong>the main motivator to add the type to the standard library</strong>.</p>
<blockquote class="cye-lm-tag">
<p style="padding-left: 30px;" class="cye-lm-tag">Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result”, and using null for such was overwhelmingly likely to cause errors.</p>
</blockquote>
<p class="cye-lm-tag">Before Java 8, receiving a null value from a method was ambiguous. It could mean there’s nothing to return or that an error occurred during execution. Besides, developers tended to forget verifying if the result was null, which led to nasty NullPointerException at runtime. Optional solves both problems by providing a convenient way to force the user of the method to check its self-explanatory output.</p>
<h2>Collection wrapper</h2>
<p class="cye-lm-tag">While putting a nullable method result inside Optional is advisable, the rule doesn’t apply when the output is a collection or an array. In case when there’s no element to return, <strong>an empty instance is superior to empty Optional and null</strong> as it conveys all necessary information. Optional doesn’t provide any additional value and only complicates client code, hence it should be avoided. Here’s a bad practice sample:</p>
<div><div id="highlighter_248334" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">Optional&lt;List&lt;Item&gt;&gt; itemsOptional = getItems();</code></div><div class="line number2 index1 alt1"><code class="java keyword">if</code> <code class="java plain">(itemsOptional.isPresent()) { </code><code class="java comments">// do we really need this?</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">itemsOptional.get().forEach(item -&gt; {</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">// process item</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">});</code></div><div class="line number6 index5 alt1"><code class="java plain">} </code><code class="java keyword">else</code> <code class="java plain">{</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">// the result is empty</code></div><div class="line number8 index7 alt1"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">As long as the <em>getItems()</em> method returned the unwrapped list instance, client code could get rid of one condition check and simply iterate over the collection. If we want to verify the absence of the result, each collection has the <em>isEmpty()</em> method and in case of arrays, the length property can be used. On the whole, Optional adds unnecessary complexity.</p>
<h2>Constructor and method parameters</h2>
<p class="cye-lm-tag">Although it might be tempting to consider Optional for not mandatory method parameters, such a solution pale in comparison with other possible alternatives. To illustrate the problem, examine the following constructor declaration:</p>
<div><div id="highlighter_648143" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java plain">SystemMessage(String title, String content, Optional&lt;Attachment&gt; attachment) {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">// assigning field values</code></div><div class="line number3 index2 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">At first glance it may look as a right design decision. After all, we explicitly marked the attachment parameter as optional. However, as for calling the constructor, client code can become a little bit clumsy.</p>
<div><div id="highlighter_223158" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">SystemMessage withoutAttachment = </code><code class="java keyword">new</code> <code class="java plain">SystemMessage(</code><code class="java string">"title"</code><code class="java plain">, </code><code class="java string">"content"</code><code class="java plain">, Optional.empty());</code></div><div class="line number2 index1 alt1"><code class="java plain">Attachment attachment = </code><code class="java keyword">new</code> <code class="java plain">Attachment();</code></div><div class="line number3 index2 alt2"><code class="java plain">SystemMessage withAttachment = </code><code class="java keyword">new</code> <code class="java plain">SystemMessage(</code><code class="java string">"title"</code><code class="java plain">, </code><code class="java string">"content"</code><code class="java plain">, Optional.ofNullable(attachment));</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">Instead of providing clarity, the factory methods of the Optional class only distract the reader. Note there’s only one optional parameter, but imagine having two or three. Uncle Bob definitely wouldn’t be proud of such code </p>
<p class="cye-lm-tag"><strong>When a method can accept optional parameters, it’s preferable to adopt the well-proven approach and design such case using method overloading.</strong> In the example of the <em>SystemMessage</em> class, declaring two separate constructors are superior to using Optional.</p>
<div><div id="highlighter_952694" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java plain">SystemMessage(String title, String content) {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">this</code><code class="java plain">(title, content, </code><code class="java keyword">null</code><code class="java plain">);</code></div><div class="line number3 index2 alt2"><code class="java plain">}</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="java keyword">public</code> <code class="java plain">SystemMessage(String title, String content, Attachment attachment) {</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">// assigning field values</code></div><div class="line number7 index6 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">That change makes client code much simpler and easier to read.</p>
<div><div id="highlighter_949584" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">SystemMessage withoutAttachment = </code><code class="java keyword">new</code> <code class="java plain">SystemMessage(</code><code class="java string">"title"</code><code class="java plain">, </code><code class="java string">"content"</code><code class="java plain">);</code></div><div class="line number2 index1 alt1"><code class="java plain">Attachment attachment = </code><code class="java keyword">new</code> <code class="java plain">Attachment();</code></div><div class="line number3 index2 alt2"><code class="java plain">SystemMessage withAttachment = </code><code class="java keyword">new</code> <code class="java plain">SystemMessage(</code><code class="java string">"title"</code><code class="java plain">, </code><code class="java string">"content"</code><code class="java plain">, attachment);</code></div></div></td></tr></tbody></table></div></div>
<h2>POJOs</h2>
<p class="cye-lm-tag">POJO fields or getters are probably the most controversial candidates for Optional usage and judging by different blog posts, articles, and comments we all can agree only on one thing: another holy war has already been started. On the one hand, in the aforementioned Stack Overflow post, <strong>Brian Goetz left no doubt the type isn’t suitable for accessors</strong>.</p>
<blockquote class="cye-lm-tag">
<p style="padding-left: 30px;" class="cye-lm-tag">I think routinely using it as a return value for getters would definitely be over-use.</p>
</blockquote>
<p class="cye-lm-tag">What is more, <a href="http://mail.openjdk.java.net/pipermail/jdk8-dev/2013-September/003274.html">Optional deliberately doesn’t implement the Serializable interface</a>, which essentially disqualifies the type as a member of any class that relies on the mechanism. For a number of developers these two justifications are sufficient to reject the idea of Optional POJO fields.</p>
<p class="cye-lm-tag">On the other side of the coin, others started to question the previously mentioned arguments. As a matter of fact, a nullable model field isn’t a rare case and considering Optional is reasonable. Stephen Colebourne, mostly known as a principal contributor of Joda-Time and the JSR-310 specification, proposed <a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html">on his blog post </a>to <strong>keep nullable fields inside of a class, but wrap them up with Optional when they leave the private scope through public getters</strong>. Just like in the case of the method result, we want to aware other developers of possible lack of value.</p>
<p class="cye-lm-tag">Besides memory overhead, <strong>the main obstacle which prevents using Optional as a POJO field is support of libraries and frameworks</strong>. Reflection is widely used to read and manipulate objects and Optional requires special treatment. For instance, the Jackson development team has already provided <a href="https://github.com/FasterXML/jackson-datatype-jdk8">an additional module that handles Optional fields</a> while converting a POJO into JSON format. Hibernate validator also works with <a href="http://docs.jboss.org/hibernate/validator/5.2/reference/en-US/html_single/#section-optional-unwrapper">Optional entity fields</a>, but in many cases you don’t get support out of the box and some additional work might be inevitable.</p>
<p class="cye-lm-tag">If you choose the dark side and ignore the advice from Brian Goetz, you have to <strong>make sure all libraries and frameworks that you use can fully deal with the Optional class</strong>. No matter what your team decides when starting a new application, the best advice is to keep it consistent across the whole project.</p>
<h2>Optional class dependency</h2>
<p class="cye-lm-tag">Sometimes features or some part of business logic can be toggled on and off based on an application configuration. When such code is externalized into a separate class, it becomes an optional runtime dependency. Stateless classes don’t implement the Serializable interface, so there are no technical obstacles to use Optional as a class field. Consider the following example:</p>
<div><div id="highlighter_579541" class="syntaxhighlighter  java"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java keyword">class</code> <code class="java plain">OrderProcessor {</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">private</code> <code class="java plain">Optional&lt;SmsNotifier&gt; smsNotifier = Optional.empty();</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">public</code> <code class="java keyword">void</code> <code class="java plain">process(</code><code class="java keyword">final</code> <code class="java plain">Order order) {</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">// some processing logic here</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">smsNotifier.ifPresent(n -&gt; n.sendConfirmation(order));</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">public</code> <code class="java keyword">void</code> <code class="java plain">setSmsNotifier(SmsNotifier smsNotifier) {</code></div><div class="line number11 index10 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">this</code><code class="java plain">.smsNotifier = Optional.ofNullable(smsNotifier);</code></div><div class="line number12 index11 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number13 index12 alt2">&nbsp;</div><div class="line number14 index13 alt1"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>
<p class="cye-lm-tag">If a nullable field were used, we’d risk someone, while extending the class, would unknowingly use the field without verifying its presence. <strong>In the world dominated by dependency injection frameworks, a multitude of developers automatically assume if there’s a field in a business logic class then it must be set by a container</strong>. The Optional type is highly expressive in this situation and prevents automatic behavior from occurring.</p>
<p class="cye-lm-tag">As usual in programming, there’s no one best way to tackle the problem. Another possible solution for optional dependencies is <a href="https://en.wikipedia.org/wiki/Null_Object_pattern">the Null Object pattern</a>, which in some cases may be preferable.</p>
<h2>Not a silver bullet</h2>
<p class="cye-lm-tag">Although in many situations the temptation to use Optional may be strong, the original idea behind the type wasn’t to create an all-purpose replacement for every nullable value. Before applying the type, all possible alternatives should be considered as <strong class="cye-lm-tag">overusing of Optional may lead to introducing new burdensome code smells</strong>. If you have practical experience with Optional, especially as POJO fields or getter outputs, I’d be glad to read about what you’ve learned. Every comment is highly appreciated, so don’t hesitate to share your observations.</p>
	</div>
<br><hr>
</body>
</html>