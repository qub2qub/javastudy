**************************

What Is an Object?

Программные объекты концептуально похожи на объекты реального мира: они также состоят из СОСТОЯНИЯ и связанного с ним ПОВЕДЕНИЯ. 
Объект сохраняет свое состояние в полях (FIELDS) (переменные в некоторых языках программирования) и предоставляет/показывают своё поведение через методы (METHODS) (функции в некоторых языках программирования).

 Методы оперируют внутренним состоянием объекта и служат основным механизмом межобъектного взаимодействия. 

ИНКАПСУЛЯЦИЯ:
Сокрытие внутреннего состояние и требование о том, чтобы любое взаимодействие происходило через методы объекта -- есть инкапсуляция данных -- фундаментальный принцип объектно-ориентированного программирования.
----
Параметризируя своё состояние и предоставляя методы для изменения этого состояния, объект контролирует то, как внешний мир может его использовать. Например, если велосипед имеет только 6 передач, то метод переключения передач может отклонить любое значение, которое меньше, чем 1 или больше 6.

Пакетирование кода на отдельные объекты программного обеспечения предоставляет целый ряд преимуществ, в том числе:
1) Модульность: 
	- Исходный код для объекта может быть записан и поддерживаться независимо от исходного кода для других объектов. 
	- После создания объект можно легко передавать внутри системы.
2) Сокрытие информации: 
	- Взаимодействуя только через методы объекта, детали его внутренней реализации остаются скрытыми от внешнего мира.
3) Повторного использования кода: 
	- Если объект уже существует (возможно написанный другим разработчиком), вы можете использовать этот объект в вашей программе. Это позволяет специалистам реализовывать / тестировать / дебажить сложные объекты под конкретные задачи, которые потом вы можете с уверенностью применять в собственном коде.
4) Pluggability(переподключаемость) и легкость дебага: 
	- Если какой-то объект оказывается проблематичным, вы можете просто удалить его из вашего приложения и подключить другой объект в качестве его замены. Это аналогично фиксации механических проблем в реальном мире. Если болт сломается, заменить его, а не всю машину.
**************

What Is a Class?

В реальном мире, вы будете часто находить много отдельных объектов одного и того же рода. 
	- Там могут быть тысячи других велосипедов в наличии, все той же марки и той же модели. Каждый велосипед был построен из того же набора чертежей и, следовательно, содержит те же компоненты. В объектно-ориентированных терминах, мы говорим, что ваш велосипед является экземпляром класса объектов, известных как велосипеды. 
Класс является проектом, из которого создаются отдельные объекты.

Вы заметили, что класс велосипедов не содержит MAIN метод. Это потому, что это не полное приложение; это просто план для велосипедов, которые могут быть использованы в приложении. Ответственность за создание и использование новых объектов велосипедов принадлежит некоторому другому классу в вашем приложении.
*****************************

What Is Inheritance?
НАСЛЕДОВАНИЕ: 
Различные виды объектов часто имеют определенное количество общего друг с другом. Горные велосипеды, дорожные велосипеды, и тандемные велосипеды, например, все разделяют характеристики велосипедов (текущая скорость, текущая каденция педали, текущая передача). Тем не менее, каждый из них также определяет дополнительные функции, которые делают их различными: тандемы имеют два места и два набора рулей; дорожные велосипеды имеют рулями снижения; некоторые горные велосипеды имеют дополнительное кольцо цепи, придавая им более низкое передаточное отношение.

Объектно-ориентированное программирование позволяет классам наследовать общее состояние и поведение от других классов. В этом примере, велосипед теперь становится суперклассом для горный велосипед, дорожный велосипед, и сдвоенный велосипед. В языке программирования Java, каждому классу разрешено иметь только один прямой суперкласс, и каждый суперкласс может иметь неограниченное число подклассов.

Синтаксис создания подкласса прост. В начале Вашего объявления класса, используйте ключевое слово extends, за которым следует имя класса от которого будет происходить наследование.

Это дает MountainBike все те же поля и методы, как и в классе Bicycle, но позволяет его коду сосредоточиться исключительно на особенности, которые делают его уникальным.
Это делает код подклассов легко читаемым. 

Тем не менее, вы должны позаботиться, чтобы должным образом задокументировать состояние и поведение, которое определяет каждый суперкласс, так как этот код не будет отображаться в исходном файле каждого подкласса.
***************

What Is an Interface?
(interface = interact with)
(Интерфейс = взаимодействовать с)

Как вы уже знаете, объекты определяют своё взаимодействие с внешним миром с помощью методов, которые они предоставляют. Методы объекта формируют его интерфейс=взаимодействие с внешним миром; 

кнопки на передней панели телевизора, например, являются связующим звеном между вами и электропроводкой на другой стороне корпуса. Вы нажимаете кнопку "Power", чтобы включить/выключить телевизор.
В своей наиболее распространенной форме:
 - интерфейс -- это группа взаимосвязанных методов с пустыми телами.
(interface is a group of related methods with empty bodies)
----------
Реализация интерфейса позволяет классу стать более формальным касательно своего поведения (т.е. то что класс собирается предоставлять). Интерфейсы создаёт контракт между классом и внешним миром, и этот контракт усиливается компилятором во время сборки. Если ваш класс хочет реализовать интерфейс, то он долежн описать/реализовать все методы, определенные этим интерфейсом, в своём исходном коде до того, как класс будет успешно  скомпилирован.
*************************

What Is a Package?

Пакет представляет собой пространство имен, которое организует набор связанных классов и интерфейсов. Концептуально вы можете думать о пакетах как о папках на компьютере. Вы можете сохранить HTML-страницы в одну папку, изображения в другом, и сценарии или приложения в еще одном. Поскольку программное обеспечение, написанное на языке программирования Java может состоять из сотен или тысяч отдельных классов, то имеет смысл держать вещи организовано путем размещения связанных классов и интерфейсов в пакеты.

Платформа Java обеспечивает огромную библиотеку классов (набор пакетов), пригодного для использования в ваших собственных приложениях. Эта библиотека известна как "интерфейс прикладного программирования" или "API" для краткости (application programming interface). ЕГО(интерфейса) пакеты представляют собой задачи, наиболее часто связанные с программированием общего назначения. 
Например, 
объект Строка содержит состояние и поведение для символьных строк; 
объект File позволяет программисту легко создавать, удалять, проверять, сравнивать или изменять файл в файловой системе; 
объект Socket  позволяет созданть и использовать сетевые Socket ; 
различные объекты GUI: кнопки управления и флажков и все остальное, связанные с графическим интерфейсом пользователя. 
Есть буквально тысячи классов на выбор. Это позволяет программисту сосредоточиться на разработке конкретного приложения, а не инфраструктуры, необходимой, чтобы сделать его работу.

Платформа Java API Спецификация содержит полный список всех пакетов, интерфейсов, классов, полей и методов, предоставляемых платформой Java SE. 
*************************

Lesson: Language Basics

Variables. ПЕРЕМЕННЫЕ.
Язык программирования Java определяет следующие виды переменных:

1) Instance Variables Переменные экземпляра(сущности) (Non-Static Fields)
 С технической точки зрения, объекты хранят свои индивидуальные состояния в "нестатических полей", то есть поля, объявленные без ключевого слова static. Нестатические поля также известны как переменные экземпляра (instance variables ), поскольку их значения являются уникальными для каждого экземпляра класса (к каждому объекту); currentSpeed у одного велосипеда не зависит от currentSpeed другого.

2) Class Variables (Static Fields)  Переменные класса (статические поля)
 Переменной класса является любое поле, объявленное с модификатором static; 
 это говорит компилятору, что существует только один экземпляр (одна копия) этой переменной, независимо от того, сколько раз этот класс был создан (instantiated). Поле указывающее количество передач для определенного вида велосипедов может быть помечено как статическое, так как у всех таких велосипедов будет одинаковое количество передач. 
Также можно добавить ключевое слово final, чтобы указать, что число передач никогда не изменится.

3) Локальные переменные (Local Variables)
 Подобно тому, как объект сохраняет свое состояние в полях, метод будет сохранять свое временное состояние в локальных переменных. Синтаксис объявления локальной переменной похож на объявление поля (например, Int Count = 0;). Там нет специального ключевого слова, обозначающего переменную как локальную; понятие что переменная является локальной происходит из того, где (в каком месте) объявлена переменная - в данном случае находится между фигурными скобками открытия и закрытия метода. Таким образом, локальные переменные видны только методам, в которых они объявлены; они не доступны для остальной части класса.

4) Параметры (Parameters )
Сигнатура main method is public static void main(String[] args). Здесь args переменная -- является параметром для этого метода. Важно помнить, что параметры всегда классифицируются как "переменные", а не "поля" (parameters are always classified as "variables" not "fields"). 
Это относится и к другим конструкциям параметров(например, конструкторы и обработчики исключений).
 
 Если мы говорим о "полях в общем" (исключая локальные переменные и параметры), то можно просто сказать, "поля". 
Если обсуждение относится к "все вышеперечисленное", мы можем просто сказать "переменные". Если контекст требует различения, мы будем использовать специальные термины (статическое поле, локальные переменные и т.д.) в зависимости от обстоятельств. Вы также можете иногда встретить термин "член" ("member"). 
У кокого-то типа все его поля, методы, и вложенные типы вместе можно назвать членами этого типа.
--------------------
Naming - Именование

Каждый язык программирования имеет свой собственный набор правил и соглашений для видов имен, которые вам разрешено использовать, и язык программирования Java не отличается. 
Правила и соглашения для именования переменных можно суммировать следующим образом:

1) Имена переменных чувствительны к регистру. Именем переменной может быть любой допустимый идентификатор - последовательность неограниченной длины Unicode символов и цифр.
Переменная может начинаться либо с буквы, либо знака доллара "$", или символа подчеркивания "_". По Конвенции всегда надо начинать имена переменных с буквы, а не "$" или "_". Также символ знака доллара, по соглашению, вообще никогда не используется. 
Вы можете найти некоторые ситуации, когда автоматически генерируемые имена будут содержать знак доллара, но ваши имена переменных должны всегда избегать его использования. Аналогичное соглашение существует для символа подчеркивания; в то время как это технически законно начать имя вашей переменной с "_", эта практика не рекомендуется. 
White space не допускается.

2) Последующие символы могут быть буквы, цифры, знаки доллара, или символы подчеркивания. Конвенция (и здравый смысл) также применяются к этому правилу. При выборе имён для ваших переменных используйте полные слова вместо загадочных сокращений. Это позволит легче читать и понимать ваш код. Во многих случаях это также сделает ваш код самодокументируемым;
 Также имейте в виду, что имя, которое вы выбираете не должно быть ключевым или зарезервированным словом.

3) Если имя, которое вы выбираете состоит только из одного слова, пишется это слово со всех строчных букв. Если он состоит из более чем одного слова, пишите заглавной первую букву каждого последующего слова. Названия gearRatio и currentGear являются яркими примерами этой конвенции. Если ваша переменная хранит значение константы, такие как сstatic final int NUM_GEARS = 6, Пишите большую каждую букву и отделяйте последующие слова символом подчеркивания. По соглашению, символ подчеркивания никогда не используется в других местах.
*******************************

Primitive Data Types
ПРИМИТИВЫ

Язык программирования Java статически типизированный, это значит, что все переменные должны сначала быть объявлены, прежде чем они могут быть использованы. Т.е. надо задать тип и имя переменной:

int gear = 1;
Это означает, что существует поле под названием "gear", оно хранит числовые данные, и имеет начальное значение "1". Тип данных переменной определяет значения, которые она может содержать, плюс операции, которые могут быть выполнены над ней. В дополнение к Int, язык программирования Java поддерживает семь других примитивных типов данных. Примитивный тип предопределен языком и назван зарезервированными ключевыми словами. Примитивные значения не разделяют состояние с другими примитивными значениями. 
языком Java поддерживается Восемь примитивных типов данных:

1) byte: 8-бит (от -2^7 до +2^7-1)
Тип байт данных представляет собой 8-битное знаковое дополненное до двух число. Он имеет минимальное значение -128 и максимальное значение, равное 127 (включительно). Тип данных байт может быть полезным для сохранения памяти в больших массивах, где экономия памяти на самом деле имеет значение. Они также могут быть использованы вместо Int, где их пределы помогают уточнить код; тот факт, что диапазон действия переменной ограничивается может служить формой документации.

2) short: 16-бит (от -2^15 до +2^15-1)
тип short данных представляет собой 16-разрядное знаковое дополненое до двух число. Он имеет минимальное значение -32768 и максимальное значение 32767 (включительно). Как с байтом, одни и те же принципы применимы: вы можете использовать short, чтобы сохранить память в больших массивах, в ситуациях, когда экономия памяти на самом деле имеет значение.

3) int: 32-бита (от -2^31 до +2^31-1)
тип int представляет собой 32-разрядное знаковое дополненное до двух целое число, которое имеет минимальное значение -2 в 31й степени и максимальное значение 2 в 31й степени минус -1. В Java SE 8 и более поздних версиях можно использовать тип данных INT для представления без знака 32-разрядное целое число, которое имеет минимальное значение 0 и максимальное значение 2 в 32 - 1. ДЛя этого надо использоватьвать класс Integer (целое число без знака). Статические методы, такие как compareUnsigned, divideUnsigned и т.д. были добавлены к классу Integer для поддержки арифметических операций для целых чисел без знака.

4) long: 64-бита
Тип long представляет собой 64-разрядное дополненное до 2 целое число. Long со знаком имеет минимальное значение -2 в 63 и максимальное значение 2 в 63 - 1. В Java SE 8 и более поздних версиях можно использовать тип Long для представления беззнакового 64-разрядного числа, который имеет минимальное значение 0 и максимальное значение 2 в 64 - 1. Используйте этот тип данных, когда требуется диапазон значений шире, чем предусмотреный Int. класс Long также содержит методы, такие как compareUnsigned, divideUnsigned и т.д. для поддержки арифметических операций для беззнаковых Long.

5) float: 32-бита с плавающей точкой.
Тип float является 32-битным типом одинарной точности IEEE 754 с плавающей точкой. Его диапазон значений выходит за рамки этой дискуссии, но указывается в Floating-Point Types, Formats, and Values section of the Java Language Specification. Как и с рекомендациями по byte и short, используйте float  (вместо double), если вам нужно сохранить память в больших массивах чисел с плавающей запятой. 
Этот тип данных никогда не должен использоваться для точных значений, таких как валюта. Для этого вам нужно будет использовать класс java.math.BigDecimal.

6) double: 64-бита с плавающей точкой.
Тип double это  64-битный тип двойной точности IEEE 754 с плавающей точкой. Для десятичных значений, этот тип данных, как правило, выбрается по умолчанию. Как упоминалось выше, этот тип данных никогда не должен использоваться для точных значений, таких как валюта.

7) boolean - логическое значение: размер точно не определён
Тип данных Boolean имеет только два возможных значения: истина и ложь (true and false). Используйте этот тип данных для простых флагов, которые позволяют отслеживать условия истина / ложь . Этот тип данных представляет один бит информации, но его "размер" точно не определён.

8) char - символ: 16-бит (2^16-1)
Тип char представляет собой один 16-битный Unicode символ. Он имеет минимальное значение '\ u0000' (или 0) и максимальное значение '\ uffff' (или 65535 включительно).

В дополнение к восьми примитивным типам данных, перечисленных выше, язык программирования Java также предоставляет специальную поддержку для строк символов через java.lang.String класс. Обрамляя строку в двойные кавычки, вы автоматически создадите новый объект String; объекты Строка неизменны, а это значит, что после создания, их значения не могут быть изменены. Класс Строка не является технически примитивным типом данных, но, учитывая особую поддержку, оказываемую ему языком, вы должны думать о string примерно как о примитиве.
-----------************************------------
Default Values
Значения по умолчанию

Не всегда необходимо  присваивать значение сразу после объявления поля(FIELD).
Полям, которые были объявлены, но не были инициализированы, компилятор сам присвоит разумное значение. 
По умолчанию это будет или ноль или null, в зависимости от типа данных. 

В следующей таблице приведены значения по умолчанию 
Data Type | Default Value (for fields)
1 byte 			0
2 short 		0
3 int 			0
4 long 			0L
5 float 		0.0f
6 double 		0.0d
7 char 			'\u0000'
8 boolean 		false
9 String 		null
* any object   	null


Локальные переменные немного отличаются; 
!! компилятор никогда не назначает значение по умолчанию для неинициализированной локальной переменной !! 
Если вы не можете инициализировать локальную переменную, где она объявлена, убедитесь, чтобы присвоить ему значение, прежде чем пытаетесь использовать её. Доступ к неинициализированной локальной переменной приведет к ошибке времени компиляции.
------------******************************--------------
Literals - Литералы

Вы можете заметить, что ключевое слово new не используется при инициализации переменной примитивного типа. Примитивные типы - это  специальные типы данных, встроенные в язык; они не являются объектами, создаваемыми из класса. 
literal - это представление в исходным коде  фиксированного значения; литералы представлены непосредственно в коде без необходимости их вычисления. 

Как показано ниже, можно присвоить литерал переменной примитивного типа:
boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;

Integer Literals - 
Целочисленный литерал имеет тип long, если он заканчивается буквой L или l; в противном случае он имеет тип Int. Рекомендуется использовать верхний буквы L, так как строчную букву l трудно отличить от цифры 1.

Значения целочисленных типов byte, short, int, и long могут быть создан из INT литералов. Значения типа long, которые превышают допустимый диапазон Int, поэтому могут быть создан из long литералов. 

Integer литералы можно выразить этими системами счисления:
1) Decimal Десятичный: Основание 10, чьи цифры состоит из чисел от 0 до 9; это система счисления вы используете каждый день
2) Hexadecimal шестнадцатеричная: Основание 16, чьи цифры состоят из чисел от 0 до 9 и буквы от А до F
3) Двоичная Binary: Base 2 (Основание 2), чьи цифры состоит из чисел 0 и 1 (вы можете создавать бинарные литералы в Java SE 7 и более поздних версий)

Для программирования общего назначения, десятичная система, вероятно, будет единственной системой, который вы будете когда-либо использовать. Тем не менее, если вам необходимо использовать другую систему счисления, следующий пример показывает правильный синтаксис. 

Префикс 0x указывает на шестнадцатеричный и 0b указывает на двоичный:
// Число 26, в десятичной системе счисления
INT decVal = 26;
// Число 26, в шестнадцатеричном
INT hexVal = 0x1a;
// Число 26, в двоичной системе
INT binVal = 0b11010;

----------------
Floating-Point Literals
Литералы С плавающей точкой 

A floating-point literal is of type float, если он заканчивается буквой F или f; в противном случае это будет тип double (он необязательно может заканчиваться буквой D или d).

Типы с плавающей точкой (float and double) также могут быть выражены с помощью Е или Е (для научной нотации), F или f (32-bit float literal) и D или d (64-bit double literal, это по умолчанию и по конвенция пропускается).

double d1 = 123.4;
// Такое же значение, как d1, но и в научной нотации
double d2 = 1.234e2;
float f1  = 123.4f;
--------------------*****************--------------
Character and String Literals

Литералы типов char and String могут содержать любой Unicode (UTF-16) символ. Если ваш редактор и файловая система позволяет, вы можете использовать такие символы непосредственно в коде. 
Если нет, то вы можете использовать "Unicode escape", такие как '\ u0108' (capital C with circumflex) или "S\u00ED Se\u00F1or" (Si Senor in Spanish). 
Всегда используйте 'одиночные кавычки' для char литералов и "двойные кавычки" для String литералов. 
Unicode escape  последовательности могут быть использованы в других местах в программе (например, в именах полей, например), а не только в char  или String  литералах.

Язык программирования Java также поддерживает несколько специальных escape последовательностей для символьных и строковых литералов: \b (backspace), \t (tab), \n (line feed), \f (form feed), \r (carriage return), \" (double quote), \' (single quote), and \\ (backslash).

Есть специальный null literal, который может быть использован в качестве значения для любого ссылочного типа. NULL может быть назначен любой переменной, кроме переменных примитивных типов. С null вы можете только протестировать его присутствие. Таким образом, значение NULL часто используется в программах как маркер, чтобы указать, что некоторый объект недоступен.

Наконец, есть также специальный вид литерала называется литерал класса (class literal), образованный именем типа и добавления к нему ".class"; например, String.class. Это относится к объекту (типа Class), который представляет сам тип.

---------------------*********************************----------------
Using Underscore Characters in Numeric Literals
Использование символа подчеркивания в числовых литералах

В Java SE 7 и позднийх,можно добавлять любое количество символа подчеркивания (_) в любое место между цифрами в числовом литерале. например, для отдельных групп цифр в числовых литералов, которые могут улучшить читаемость кода.

Например, если ваш код содержит цифры с большим количеством цифр, вы можете использовать символ подчеркивания для разделения цифр в группах по три, подобно тому, как вы будете использовать знак препинания, запятую или пробел, в качестве разделителя.

Следующий пример показывает другие способы использования подчеркивание в числовых литералах:

long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;

Вы можете поместить знак подчеркивания только между цифрами;

Вы не можете поместить знак подчеркивания в следующих местах:
1-В начале или в конце числа
2-Рядом с десятичной точкой в литерале с плавающей точкой
3-Перед суффиксом F или L
4-В местах, где ожидается строка из цифр.

Следующие примеры показываютvalid and invalid размещения подчеркивания (которые выделены) в числовых литералов:
// Invalid: cannot put underscores adjacent to a decimal point
float pi1 = 3_.1415F;
// Invalid: cannot put underscores adjacent to a decimal point
float pi2 = 3._1415F;
// Invalid: cannot put underscores prior to an L suffix
long socialSecurityNumber1 = 999_99_9999_L;

// OK (decimal literal)
int x1 = 5_2;
// Invalid: cannot put underscores At the end of a literal
int x2 = 52_;
// OK (decimal literal)
int x3 = 5_______2;

// Invalid: cannot put underscores in the 0x radix prefix
int x4 = 0_x52;
// Invalid: cannot put underscores at the beginning of a number
int x5 = 0x_52;
// OK (hexadecimal literal)
int x6 = 0x5_2; 
// Invalid: cannot put underscores at the end of a number
int x7 = 0x52_;
******************************************************************

МАССИВЫ Arrays

 Массив представляет собой объект-контейнер, который содержит определенное/ФИКСИРОВАННОЕ количество значений одного типа. Длина массива задаётся во время создания массива. После создания, его длина фиксирована.
Каждый элемент в массиве называется элементом, а каждый элемент доступен по его цифровому индексу.
нумерация начинается с 0.
 9-й элемент, поэтому, может быть доступен по индексу 8.

Как и объявлений для переменных других типов, объявление массива состоит из двух компонентов: типа массива и имени массива. Тип массива записывается как type[], где type  является типом данных содержащихся элементов; скобки - это специальные символы, к-е указывают, что эта переменная содержит массив.
 Размер массива не является частью его типа (поэтому скобки пусты). Как и с переменными других типов, декларация массива на самом деле не создаёт массив; она просто сообщает компилятору, что эта переменная будет содержать массив указанного типа.
 !! ДЕКЛАРАЦИЯ ТИПА НЕ СОЗДАЁТ ЭТОТ ТИП, А ЛИШЬ СООБЩАЕТ КОМПИЛЯТОРУ, ЧТО ЭТА ПЕРЕМЕННАЯ БУДЕТ СОДЕРЖАТЬ ЭЛЕМЕНТ/МАССИВ УКАЗАННОГО ТИПА. !!

Можно писать скобки после имени массива:
// this form is discouraged
float anArrayOfFloats[];
Но Конвенция отбивает эту форму; т.к. скобки определяют тип массива и должны появиться в обозначении типа.
-----------

Creating, Initializing, and Accessing an Array

Один из способов создать массив -- это оператором new. // create an array of integers
int[] anArray = new int[10];
Alternatively, you can use the shortcut syntax to create and initialize an array:
int[] anArray = { 
    100, 200, 300,
    400, 500, 600, 
    700, 800, 900, 1000
};
При этом длина массива определяется числом значений в фигурных скобках и разделенных запятыми.

Можно также объявить массив массивов (также известный как многомерный массив) с помощью двух или более наборов скобок, таких как String[][]. Каждый элемент, следовательно, должен быть доступен по соответствующему количеству значений индексов.

В языке программирования Java, многомерный массив является массивом, компонентами которого являются сами массивы.This is unlike arrays in C or Fortran. Следствием этого является то, что количество rows может изменяться.
--------------------------------------

Copying Arrays

Класс System имеет метод ArrayCopy , который можно использовать для эффективного копирования данных из одного массива в другой:

public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

Два аргумента Object указывают на два массива: 1 массив, откуда скопировать, и 2 массив, куда копировать. Три int аргумента задают начальную позицию в исходном массиве, начальную позицию в массиве назначения, и количество элементов массива, чтобы скопировать.
----------------------------

Array Manipulations

Для вашего удобства, Java SE предоставляет несколько методов для выполнения манипуляций с массивами (общие задачи, такие как копирование, сортировка и поиск массивов) в классе java.util.Arrays. 
Например, предыдущий пример может быть изменен, чтобы использовать метод copyOfRange класса java.util.Arrays. Разница заключается в том, что с помощью метода copyOfRange не нужно заранее создать массив назначения перед вызовом метода, так как целевой массив возвращается методом.

Обратите внимание, что второй параметр метода copyOfRange является начальным индексом диапазона для копирования, включительно, в то время как третий параметр является окончательным индексом диапазона для копирования, исключительно. В этом примере, копируемый диапазон не включает в себя элемент массива с индексом 9 (который содержит символ а).

Некоторые другие полезные операции, предусмотренные методами в классе java.util.Arrays, являются: 
1- Поиск индекса конкретного значения в массиве (метод BinarySearch).
2- Сравнение двух массивов, чтобы определить, равны ли они или нет (метод equals).
3- Заполнение массива определенным значением в каждом индексе (метод fill ). 
4- Сортировка массива в порядке возрастания. Это может быть сделано либо последовательно, с использованием метода sort , или одновременно, используя метод parallelSort, введенную в Java SE 8. Параллельная сортировка больших массивов данных на многопроцессорных системах работает быстрее последовательной сортировки массива.
***********************************

Summary of Variables

Язык программирования Java использует как "поля" так и "переменные" в рамках своей терминологии. 
Переменные сущности [ instance variable ](нестатические поля) являются уникальными для каждого экземпляра класса.

Переменные класса [ class variable ] (статические поля) являются поля, объявленные со статическим модификатором(static modifier); есть ровно один экземпляр переменной класса, независимо от того, сколько раз класс был создан. 

Локальные переменные [ local variable ] хранят временное состояние внутри метода. 

Параметры [parameters] - это переменные, которые предоставляют дополнительную информацию в метод; как локальные переменные так и параметры всегда классифицируются как "переменные" (но не "поля"). При выборе названия для полей или переменных, существуют правила и соглашения, которым вы должны следовать.

Восемь примитивных типов данных: byte, short, int, long, float, double, boolean, and char. 
Класс java.lang.String представляет собой строки символов. Компилятор будет назначать разумное значение по умолчанию для полей указанных выше типов; для локальных переменных, значение по умолчанию никогда не назначается. 
literal  является представление в исходным коде фиксированного значения. 
Массив представляет собой объект-контейнер, который содержит определенное количество значений одного типа. Длина массива устанавливается, когда создается массив. После создания, его длина фиксирована.
*************************
надо добавить остальные темы после этой
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variablesummary.html
начать с этой:
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html
*************************
СИГНАТУРА МЕТОДА -- ЭТО ИМЯ МЕТОДА И ТИВЫ ЕГО ПАРАМЕТРОВ. 
- method signature  —- the method's name and the parameter types.

-  Parameters refers to the list of variables in a method declaration. Arguments are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration's parameters in type and order. 
++ ПАРАМЕТРЫ ссылются на список переменых в декларации метода. 
АРГУМЕНТЫ -- это реальные значения, которые передаются внутрь метода, когда он вызывается.
Аргументы должны совпадать с декларированными параметрами по типу и порядку следования.

- Primitive arguments, such as an int or a double, are passed into methods by value. 
This means that any changes to the values of the parameters exist only within the scope of the method. 
When the method returns, the parameters are gone and any changes to them are lost.
++ Т.е. при ПЕРЕДАЧЕ ПРИМИТИВОВ в метод передаётся значение примитива. Т.е. из исходного примитива берётся его значение и передаётся (происходит как бы невидимое создание второй копии значения, которое и уйдёт внутрь метода. исходно значение примитива останется как и было, нетронутым, и присвоиным исходной переменной.)
Любые изменения значений параметров существуют только внутри области видимости метода.
После выхода из метода параметры пропадают, как и любые изменения с ними.

-Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object's fields can be changed in the method, if they have the proper access level
++ когда ПЕРЕДАЁТСЯ ССЫЛОЧНЫЙ ТИП, т.е. ссылка на объект, она тоже передаётся по значению. 
А значение в этом случае - это ссылка на адрес в памяти. Т.е. занчение этой ссылки. ССылка остаётся той же, что и у исходного объекта. ПОЭтому когда в методе с этим объектом просиходят какие-то действия, то они фактически просиходят не со ссылкой, а с той памятью куда она ссылается. по выходу из метода - исходная переменная также осталась ссылаться на эту же область памяти. но по факту в этой памяти метод уже что-то изменил.
И после выхода из метода, переданная ссылка всё ещё указывает на тот же объект, что и раньше. При этом значение полей объекта могло быть изменено внутри метода, если к ним есть должный доступ.
НО НО НО если к локальной переменной в методе присвоится новый объект - то есть ссылка на новый оббъект -- ссылка будет ссылаться на новую область памяти для этого вновь созданного объекта, и только внутри области видимости метода. И будет изменять память там. по выходу из метода - эта ссылка потеряется, объект будет удалён gc, поэтому грубо говоря изменения в новом объекте не имеют смысла.

-  как происходит создание объекта:
1-DECLARATION: The code set in bold are all variable declarations that associate a variable name with an object type.
2-INSTANTIATION: The new keyword is a Java operator that creates the object.
3-INITIALIZATION: The new operator is followed by a call to a constructor, which initializes the new object.

you write: "type name;"
This notifies the compiler that you will use name to refer to data whose type is type.
Simply declaring a reference variable does not create an object. For that, you need to use the new operator.
The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory.
The new operator also invokes the object constructor.
The new operator returns a reference to the object it created. This reference is usually assigned to a variable of the appropriate type.
Т.Е.:
1) ДЕКЛАРАЦИЯ "VarType varName;" -- это инструкция для компилятора, что имя varName будет ссылаться на данные с типом VarType.
Только декларация ссылки на переменную -- не создаёт объект. Для создания надо использовать ключевое слово new.
2) Оператор new СОЗДАЁТ СУЩНОСТЬ КЛАССА ПУТЁМ ВЫДЕЛЕНИЯ ПАМЯТИ под этот новый объект, и возвращает ссылку на этот участок памяти.
3) Оператор new также сразу после размещения объекта в памяти ВЫЗЫВАЕТ ЕГО КОНСТРУКТОР, чтобы проинициализировать созданный объект.

-- All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, called the default constructor. This default constructor calls the class parent's no-argument constructor, or the Object constructor if the class has no other parent. If the parent has no constructor (Object does have one), the compiler will reject the program.
++Все классы имеют как минимум 1 конструктор; если у класса нет конструктора, то java компилятор автоматически добавляет конструктор без аргументов, к-й называется конструктор по умолчанию.
Он (конструктор по умолчанию) вызывает родительский конструктор без аргументов. Если у класса нет родителя, то будет вызван конструктор у Object. Если у родителя нет конструктора -- компилятор откажется от программы.

-- An object is eligible for garbage collection when there are no more references to that object. References that are held in a variable are usually dropped when the variable goes out of scope. Or, you can explicitly drop an object reference by setting the variable to the special value null.
++ Объект будет подвергнут сбору мусора (garbage collection) кога на него больше нет ссылок:
1) когда переменная выходит за область видимости
2) можно явно задать null для переменной.

-- A method returns to the code that invoked it when it (whichever occurs first)
1    completes all the statements in the method,
 2   reaches a return statement, or
  3  throws an exception (covered later),
whichever occurs first.

ВОЗВРАЩЕНИЕ из метода в вызвавший его код происходит когда (что наступит раньше):
1) выполнены все выражения в методе
2) достигнут оператор return
3) выброшено исключение

-- можно написать return в void методе, в этом случае метод выйдет в этой точке. надо для логического ветвления и выхода.
-- You can override a method and define it to return a subclass of the original method.
This technique, called covariant return type, means that the return type is allowed to vary in the same direction as the subclass.
-- Within an instance method or a constructor, "this" is a reference to the current object — the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using this.
-- From within a constructor, you can also use the "this" keyword to call another constructor in the same class. Doing so is called an explicit constructor invocation.
If present, the invocation of another constructor must be the first line in the constructor.
-- A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package.
-- At the member level, you can also use the public modifier or no modifier (package-private) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: private and protected. The private modifier specifies that the member can only be accessed in its own class. The protected modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.
---------------------------------------
Access Levels Modifier;	Class; 	Package; 	Subclass; 	World;
public 					Y 	Y 	Y 	Y
protected 				Y 	Y 	Y 	N
no modifier 			Y 	Y 	N 	N (package-private, no subclass)
private 				Y 	N 	N 	N

The first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members. The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member. The third column indicates whether subclasses of the class declared outside this package have access to the member. The fourth column indicates whether all classes have access to the member.

-- Not all combinations of instance and class variables and methods are allowed:
    Instance methods can access instance variables and instance methods directly.
    Instance methods can access class variables and class methods directly.
    Class methods can access class variables and class methods directly.
    Class methods cannot access instance variables or instance methods directly—they must use an object reference. Also, class methods cannot use the "this" keyword as there is no instance for this to refer to.
-- The static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.
но для final указан для объекта (ссылочного типа) - значением этой переменной является ссылка, то в этом случае, ссылка на объект является неизменной. а сам объект можно изменять.
-- Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.
++ Если тип константы равен примитиву или строке, то компилятор на этапе компиляции подставляет этто значение в код, и если значение изменилось -- надо перекомпилировать весь код, где использовалась эта константа.

-- A static initialization block is a normal block of code enclosed in braces, { }, and preceded by the static keyword:
static {
	// some code in static initialization block
}
A class can have any number of static initialization blocks, and they can appear anywhere in the class body. The runtime system guarantees that static initialization blocks are called in the order that they appear in the source code.
Статические блоки инициализации вызываются в том порядке, в котором они записаны.
*********************************************
-- Initializing Instance Members

Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: 
1) initializer blocks and 2) final methods.

Проинициализировать [ instance variables ] сущностные переменные можно 3 способами:
1) в конструкторе
2) и инициализационных блоках // { int a=1; }
3) в final методах
..
2) INITIALIZER BLOCKS for instance variables look just like static initializer blocks, but without the static keyword:
{
    // whatever code is needed for initialization goes here
}
The Java compiler copies initializer blocks into every constructor. Therefore, this approach can be used to share a block of code between multiple constructors.
++ Инициализационный блок для переменных сущности, записываются просто в фигурных скобках, БЕЗ слова static. 
Java compiler копирует эти initializer blocks в каждый конструктор.

3) A final method cannot be overridden in a subclass.
The method is final because calling non-final methods during instance initialization can cause problems.
*******************************
-- Summary of Creating and Using Classes and Objects

Объявление класса даёт имя классу и между фигурными скобками содержит тело класса. Имени класса могут предшествовать модификаторы. Тело класса содержит поля, методы и конструкторы для класса.
 Класс использует поля для хранения информации о своём состоянии, а методы использует для реализации поведения. Конструкторы, которые инициализируют новый экземпляр класса, называются по имени класса и выглядят как методы, но без возвращаемого типа.

Вы контролируете доступ к классам и членам одинаковым образом: с помощью модификатора доступа, например public в их объявлении.

Вы определяете переменную  для всего класса или метод класса (class variable or a class method) с помощью ключевого слова static в объявлении члена. 
Член, который не объявлен как static неявно считается членом экземпляра этого класса (т.е. принадлежит конкретной сущности, а не всему классу). Переменные класса являются общими для всех экземпляров класса и могут быть доступны через имя класса, но также и через ссылку экземпляра класса. 
Экземпляры класса получают свою собственную копию каждой (instance variable) переменной экземпляра, к неё надо обращаться через ссылку экземпляра класса.

Вы создаете объект из класса с помощью оператора new и конструктора. Оператор new возвращает ссылку на объект, который был создан. Вы можете присвоить ссылку какой-то переменной или использовать эту ссылку напрямую (сразу у неё можно вызвать какие-то методы).

Сборщик мусора автоматически очищает неиспользуемые объекты. Объект не используется, если программа не имеет больше ссылок на него. Вы можете явно удалить ссылку, установив в переменную, содержащую ссылку, значение NULL.

************************************
Nested Classes - ВЛОЖЕННЫЕ КЛАССЫ

The Java programming language allows you to define a class within another class. Such a class is called a nested class and is illustrated here:
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}

Terminology: Nested classes are divided into two categories: 
1) static nested classes (that are declared static) 
2) non-static nested classes --  are called inner classes 
Есть 2 вида ВЛОЖЕННЫХ КЛАССов:
1) (СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС)
2) (ВНУТРЕННИЙ КЛАСС) - НЕ СТАТИЧЕСКИЙ

class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
A nested class is a member of its enclosing class. 
Вложенный класс - является членом своего объемлющего класса.

Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class. 
не-статические вложенные классы (т.е. обычные внутренние классы) -- имеют доступ ко всем (в т.ч. и private) остальным членам объемлющего класса (т.е. класса в котором они определены).

As a member of the OuterClass, a nested class can be declared private, public, protected, or package private. (Recall that outer classes can only be declared public or package private.)
Как и любой другой член объемлющего/внешнего класса (OuterClass-а) вложенный класс может быть объявлен private, public, protected, or package private.
--------------------------------
Why Use Nested Classes? -- ЗАЧЕМ НУЖНЫ ВЛОЖЕННЫЕ КЛАССЫ.

1) Это способ логически сгруппировать классы, которые используются только в одном месте: Если класс полезен только для одного другого класса, то вполне логично, чтобы встроить его в этот класс и держать их вместе. Вложение таких "вспомогательных классов (helper classes)" делает их пакет более прямолинейным/гладким.

2) Это увеличивает инкапсуляцию: Рассмотрим два класса верхнего уровня, A и B, где B необходим доступ к членам класса А (тогда эти члены/поля/методы будут объявлены public), но могли и должны были быть объявлены как private. Скрывая класс B внутри класса А, ВСЕ члены класса А (поля и методы) могут быть объявлены private, а класс B всё равно может получить к ним доступ. Кроме того, сам B может быть скрыт от внешнего мира.

3) Это может привести к более читаемому и легче-поддерживаемому коду: Вкладывая небольшие классы внуть классов верхнего уровня - мы помещает код ближе к тому месту, где он используется.
------------------------------------------------------
Static Nested Classes -- СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС

Статический вложенный класс (static nested class) связан с его внешним классом, аналогично с тем как и статические методы и статические переменные. 
Также как и статические методы, статический вложенный класс не может обращаться непосредственно к (instance variables or instance methods) переменным экземпляра или методам экземпляра, определенным в объемлющем классе.
 static nested class может использовать instance variables or instance methods только через ссылку на созданный объект/экземпляр класса.
Примечание: Статический вложенный класс (static nested class) взаимодействует с членами экземпляра своего внешнего класса (и других классов) так же, как и любой другой класс верхнего уровня. В действительности, статический вложенный класс на самом деле считается как обычный класс верхнего уровня, который был вложен в другой класс верхнего  уровня только/исключительно для удобства упаковки.
Т.Е. СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС -- ЭТО КАК ОБЫЧНЫЙ КЛАСС ВЕРХНЕГО УРОВНЯ. Вложенность в этом случае никак не влияет.

Static nested classes are accessed using the enclosing class name:
OuterClass.StaticNestedClass

Например, чтобы создать объект для статического вложенного класса, используйте следующий синтаксис:
OuterClass.StaticNestedClass nestedObject =
     new OuterClass.StaticNestedClass();
Имя статического вложенного класса будет состоять из имени родительского класса и имени самого вложенного класса. И больше никаких отличий.
-------------------------------------------------------------
Inner Classes -- ВНУТРЕННИЕ КЛАССЫ

Также Как с (instance methods and instance variables) методами экземпляра и переменными экземпляра, внутренний класс (inner class) связан с экземпляром включающего его класса и имеет прямой доступ к методам и полям этого объекта. Кроме того, потому что внутренний класс связан с экземпляром класса, он НЕ МОЖЕТ объявить в себе любые статические элементы(поля/методы).

Экземпляры внутреннего класса живут внутри экземпляра внешнего класса. Рассмотрим следующие классы:
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}

Экземпляр InnerClass может существовать только внутри экземпляра OuterClass и имеет прямой доступ к методам и полям его экземпляра, в кот-м он содержится.

Чтобы создать экземпляр внутреннего класса, вы должны сначала создать экземпляр внешнего класса. Затем создайте внутренний объект в рамках внешнего объекта:

OuterClass.InnerClass innerObject = outerObject.new InnerClass();

Есть два специальных вида внутренних классов: 
1) местные классы и 2) анонимные классы (local classes and anonymous classes).
---------------------------------------------------
Есть 2 вида ВЛОЖЕННЫХ КЛАССов [nested class]:
1) (СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС) [static nested class]
2) (ВНУТРЕННИЙ КЛАСС) - класс экземпляра [inner class]
	2.1 ОБЫЧНЫЙ ВНУТРЕННИЙ КЛАСС [inner class] (внутри внешнего класса, как объявление переменной)
	2.2 ЛОКАЛЬНЫЙ КЛАСС [local class]
	2.3 АНОНИМНЫЙ КЛАСС [anonymous class]
---------------------------------------------------
ЗАТЕНЕНИЕ - Shadowing

Если ОБЪЯВЛЕНИЕ типа (например, переменная или имя параметра) в определенной области (например, ВО внутреннем классе или в определении метода) имеет такое же имя, как и у другого 2объвления в обрамляющей области видимости, то это 1ОБЪЯВЛЕНИЕ затеняет/закрывает 2декларацию во внешней/обрамляющей области. И уже нельзя сослаться на затенённое объявление только по его имени.
If a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration shadows the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone.
Вы не можете обратиться к затененной декларации по его имени (только по имени). В следующем примере, ShadowTest, демонстрирует это:
 
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23); 
    }
}

The following is the output of this example:
x = 23 			// значение из аргумента метода
this.x = 1 		// из внутреннего класса
ShadowTest.this.x = 0 // из внешнего класса
-----------------------------------------------------------------------
Serialization -- СЕРИАЛИЗАЦИЯ ВНУТРЕННИХ КЛАССОВ

Сериализация внутренних классов, в том числе локальных и анонимных классов, настоятельно не рекомендуется. Когда компилятор Java компилирует некоторые конструкции, такие как внутренние классы, он создает синтетические конструкции (synthetic constructs); это классы, методы, поля и другие конструкции, которые не имеют соответствующей конструкции в исходном коде. Синтетические конструкции позволяют Java-компилятору реализовывать новые возможности языка Java без изменений в JVM. Тем не менее, синтетические конструкции могут меняться в зависимости от различных реализаций Java компилятора. Это означает, что файлы .class могут меняться в зависимости от различных реализаций jvm. Следовательно, могут быть проблемы совместимости при сериализации внутренних классов, а затем их десериализации с другой реализацией JRE. 
----------------------------------------
Local and Anonymous Classes
Local Class -- an inner class declared within the body of a method.
Anonymous Class -- an inner class declared within the body of a method without naming the class.
ЛОКАЛЬНЫЙ КЛАСС -- это внутрениий класс, определённый внутри тела метода.
АНОНИМНЫЙ КЛАСС -- это внутрениий класс, определённый внутри тела метода и без имени.


Modifiers
You can use the same modifiers for inner classes that you use for other members of the outer class. For example, you can use the access specifiers private, public, and protected to restrict access to inner classes, just as you use them to restrict access do to other class members.
МОДИФИКАТОРЫ -- такие как и для любых других членов класса, чтобы ограничить видимость внутреннего класса.
-------------------------------------------------
Local Classes -- ЛОКАЛЬНЫЙ КЛАСС

Local classes are classes that are defined in a block, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.
You can define a local class inside any block.
For example, you can define a local class in a method body, a for loop, or an if clause.

Локальный класс можно определить в любом блоке. Блок -- это ноль или больше выражений внутри пары фигурных скобок.
Т.е. можно определить локальные классы в методе, в цикле, в if и т.п.

---
Accessing Members of an Enclosing Class

ЛОКАЛЬНЫЙ КЛАСС имеет доступ к:
1) членам (полям и методам) его внешнего класса
2) к final локальным переменным:
	2.1 только тем локальным переменным, которые объявлены final
	2.2 а с java_8 -- к final or effectively final
3) с java_8 -- к параметрам метода

A local class has access to the members of its enclosing class. In the previous example, the PhoneNumber constructor accesses the member LocalClassExample.regularExpression.

In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it captures that variable or parameter. For example, the PhoneNumber constructor can access the local variable numberLength because it is declared final; numberLength is a captured variable.

However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. 
A variable or parameter whose value is never changed after it is initialized is EFFECTIVELY FINAL.
Starting in Java SE 8, if you declare the local class in a method, it can access the method's parameters.
---------------------------------------
Shadowing and Local Classes

1) объявление типа (н-р, переменной) затеняет другое объявление с таким же именем в скоупе выше.
2) Локальные классы не могут объявлять статических членов
3) Локальные классы в статических методах могут ссылаться только на статические члены внешнего класса.
4) Локальные классы -- НЕ статические, т.к. имеют доступ к членам экземпляра блока, в котором они определены. Поэтому, они не могут содержать большинство статических объявлений.
5) Нельзя объявить интерфейс внутри блока, т.к. он по существу и есть статический.
6) Внутри локального класса нельзя объявить static initializers or member interfaces
7) Внутри локального класса статическими могут быть только константы

1-Declarations of a type (such as a variable) in a local class shadow declarations in the enclosing scope that have the same name. 
2-Local classes are similar to inner classes because they cannot define or declare any static members. 
3-Local classes in static methods can only refer to static members of the enclosing class.
4-Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.
5-You cannot declare an interface inside a block; interfaces are inherently static.
6-You cannot declare static initializers or member interfaces in a local class. 
7-A local class can have static members provided that they are constant variables. 
***(A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time.)

**********************************************************
https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html
Anonymous Classes --- АНОНИМНЫЙ КЛАСС
Анонимные классы позволяют одновременно объявить и создать экземпляр класса, т.е. сделать код более кратким. 
Они похожи на местные классы (local classes), за исключением того, что они не имеют названия. Используйте их, если вам нужно использовать локальный класс только один раз.
В то время как местные классы являются объявлением классов, анонимные классы представляют собой выражения, а это значит, что вы определяете класс в другом выражении.
анонимный класс является выражением. Синтаксис выражения анонимного класса похож на вызов конструктора, за исключением того, что определение класса содержится в блоке кода.

Выражение анонимного класса состоит из следующих частей: 
1) оператор  new 
2) имя интерфейса для реализации или класс для расширения. В этом примере анонимный класс реализует интерфейс HelloWorld.
3) Скобки, которые содержат аргументы конструктора, так же, как обычное выражение при создании экземпляра класса.
 Примечание: При реализации интерфейса, там нет конструктора, так что вы оставляете пустую пару скобок, как в этом примере.
4) Тело, которое является объявлением тела класса. Более конкретно, в теле объявления допускается методы, но выражения(statement) - нет.

  interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }

HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };
---------------------
ПОСКОЛЬКУ ОПРЕДЕЛЕНИЕ(DEFINITION) АНОНИМНОГО КЛАССА ЯВЛЯЕТСЯ ВЫРАЖЕНИЕМ(EXPRESSION), ОНО ДОЛЖНО БЫТЬ ЧАСТЬЮ ОБЪЯВЛЕНИЯ (STATEMENT).
 В этом примере выражение анонимный класс является частью оператора, который создает frenchGreeting объект. (Это объясняет, почему в конце ставится точка с запятой после закрывающей скобки анонимного класса.)
---------------------
Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class
Доступ к локальным переменным объемющей области видимости, декларирование и доступ к Членам анонимного класса.

Как и локальные классы, анонимные классы могут захватывать переменные (capture variables); они имеют одинаковый доступ к локальным переменным объемлющей области (they have the same access to local variables of the enclosing scope):
1) анонимный класс имеет доступ к членам его заключающего класса. 
2) Анонимный класс не может получить доступ к локальным переменным в (its enclosing scope) объемлющей его области, которые не объявлены как final or effectively final. 
3) Как и у вложенного класса, декларация типа (новой переменной) в анонимном классе затеняет любые другие похожие объявления в enclosing scope, которые имеют такое же имя. 

Анонимные классы также имеют те же ограничения, как и местные классы (local classes) по отношению к своим членам:
1) Вы не можете объявлять статические инициализаторы или интерфейсы членов в анонимном классе. 
2) Анонимный класс может иметь статические члены при условии, что они являются константами.

В анонимных классах можно объявить следующее:
1) Поля 
2) Дополнительные методы (даже если они не реализуют любые методы супертипе) [Extra methods, even if they do not implement any methods of the supertype]
3) Instance initializers
4) Локальные классы (Local classes)

Тем не менее, вы не можете объявить конструкторы в анонимном классе.

Примеры  Anonymous классов
Анонимные классы часто используются в графическом интерфейсе пользователя (GUI) приложений.

********************************
Lambda Expressions
Одна из проблем анонимных классов является то, что если реализация вашего анонимного класса является очень простой, такой как интерфейс, который содержит только один метод, то синтаксис анонимных классов может показаться громоздким и неясным. В этих случаях, вы пытаетесь передать функционал как аргумент в другой метод.
Например, что нужно сделать, когда кто-то нажимает на кнопку. Лямбда-выражения позволяют сделать это: т.е. передать функциональность как аргумент в метод, или принимать код за сами данные.

Анонимные классы показывают, как реализовать базовый класс, не давая ему имя. Несмотря на то, что это часто более кратко, чем создавть новый класс с именем. НО для классов с только одним методом, даже это кажется чрезмерным и громоздким. Лямбда-выражения позволяют выразить экземпляры классов из одного метода более компактно.
---------
https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html
ЛУЧШЕ ЧИТАТЬ АНГЛ ВЕРСИЮ С ПРИМЕРАМИ НА САЙТЕ.
Ideal Use Case for Lambda Expressions

Approach 1: Create Methods That Search for Members That Match One Characteristic

Note: A List is an ordered Collection. A collection is an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. 

Одним упрощенным подходом является создание нескольких методов; каждый метод ищет пользователей, которые соответствуют одной характеристики, например, пола или возраста.
Такой подход может потенциально сделать ваше приложение хрупким, оно может перестать работать из-за введения обновлений (например, новые типы данных). Предположим, что вы решили обновить приложение и изменить структуру класса Person таким образом, что он содержит различные переменные-члены; например, сам класс сохраняет и измеряет возраст с новым типом (данных) или по новому алгоритму. Вам придется переписать много вашего API, чтобы приспособить это изменение. Кроме того, этот подход имеет излишне ограничительный характер; что, если вы хотите распечатать членов моложе определенного возраста, например?

Approach 2: Create More Generalized Search Methods

Что делать, если вы хотите напечатать членов определенного пола, или сочетание определенного пола и возрастной диапазон? Что делать, если вы решите изменить класс Person и добавить другие атрибуты, такие как статус отношений или географического положения? Хотя этот метод является более общим, чем printPersonsOlder, Но попытка создать отдельный метод для каждого возможного поискового запроса по-прежнему может привести к хрупкому кода. Вместо этого вы можете отделить код, который определяет критерий criteria , по которым вы хотите искать, в другом классе.

Approach 3: Specify Search Criteria Code in a Local Class

Although this approach is less brittle—you don't have to rewrite methods if you change the structure of the Person—you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because CheckPersonEligibleForSelectiveService implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.

    public static void printPersons(
        List<Person> roster, CheckPerson tester) {
        for (Person p : roster) {
            if (tester.test(p)) {
                p.printPerson();
            }
        }
    }

Approach 4: Specify Search Criteria Code in an Anonymous Class

This approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.

Approach 5: Specify Search Criteria Code with a Lambda Expression

The CheckPerson interface is a functional interface. 
!!! A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.) !!!

Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it. To do this, instead of using an anonymous class expression, you use a lambda expression, which is highlighted in the following method invocation:

printPersons(
    roster,
    (Person p) -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);

You can use a standard functional interface in place of the interface CheckPerson, which reduces even further the amount of code required.

You can use a standard functional interface in place of the interface CheckPerson, which reduces even further the amount of code required.
----------
Approach 6: Use Standard Functional Interfaces with Lambda Expressions

Reconsider the CheckPerson interface:

interface CheckPerson {
    boolean test(Person p);
}
As a result, the following method invocation is the same as when you invoked printPersons in Approach 3
--------
Approach 7: Use Lambda Expressions Throughout Your Application

Instead of invoking the method printPerson, you can specify a different action to perform on those Person instances that satisfy the criteria specified by tester. You can specify this action with a lambda expression. Suppose you want a lambda expression similar to printPerson, one that takes one argument (an object of type Person) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type Person and returns void. The Consumer<T> interface contains the method void accept(T t), which has these characteristics. The following method replaces the invocation p.printPerson() with an instance of Consumer<Person> that invokes the method accept:

public static void processPersons(
    List<Person> roster,
    Predicate<Person> tester,
    Consumer<Person> block) {
        for (Person p : roster) {
            if (tester.test(p)) {
                block.accept(p);
            }
        }
}

The lambda expression used to print members is highlighted:

processPersons(
     roster,
     p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25,
     p -> p.printPerson()
);
---------
Approach 8: Use Generics More Extensively

Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters
***************************
https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html
Когда что использовать?
When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions 

Как уже упоминалось в разделе про Вложенные классы, вложенные классы позволяют вам логически группипрвать классы, которые используются только в одном месте, это увеличивает инкапсуляцию, а также делает код более читаемым и легче сопровождаемым. 
---------------------------------------------------
Есть 2 вида ВЛОЖЕННЫХ КЛАССов [nested class]:
1) (СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС) [static nested class]
2) (ВНУТРЕННИЙ КЛАСС) - класс экземпляра [inner class]
	2.1 ОБЫЧНЫЙ ВНУТРЕННИЙ КЛАСС [inner class] (внутри внешнего класса, как объявление переменной)
	2.2 ЛОКАЛЬНЫЙ КЛАСС [local class]
	2.3 АНОНИМНЫЙ КЛАСС [anonymous class]
---------------------------------------------------
Локальные классы, анонимные классы и лямбда-выражения также придают эти преимущества; Тем не менее, они предназначены для использования для более конкретных ситуаций:

1) Локальный класс: Используйте его, если вам нужно создать более одного экземпляра класса, иметь доступ к его конструктору, или задать новый именованый тип (потому что, например, вам нужно вызвать дополнительные методы позже).
2) Анонимный класс: Используйте его, если вам нужно объявить поля или дополнительные методы.
3) лямбда-выражения:
3.1) Используйте его, если вы инкапсулируете одну единицу поведения, которую вы хотите передать в другой код. Например, можно использовать лямбда-выражения, если вы хотите выполнить определенное действие над каждом элементе коллекции, когда процесс будет завершен, или когда процесс сталкивается с ошибкой.
3.2) Используйте его, если вам нужен простой экземпляр функционального интерфейса и ни один из этих критериев не применяются (например, вам не нужен конструктор, с именем типа, полей или дополнительные методы).
4) Вложенный класс: Используйте его, если ваши требования аналогичны требованиям локального класса; или вы хотите сделать тип доступным более широко, и вам не требуется доступ к локальным переменным или параметрам метода.
4.1) Внутренний класс: [нестатический вложенный класс (или внутренний класс) (non-static nested class (or inner class))] если вам необходим доступ к непубличным полям и методам объемлющего экземпляра. 
4.2) Используйте статический вложенный класс, если вам не нужен такой доступ.
--------------------
**********************
Enum Types

ПЕРЕЧИСЛЕНИЕ представляет собой особый тип данных, который ПОЗВОЛЯЕТ ПЕРЕМЕННОЙ ИМЕТЬ ЗНАЧЕНИЕ ИЗ НАБОРА ПРЕДОПРЕДЕЛЕННЫХ КОНСТАНТ. Переменная должна быть равна одному из значений, которые были предопределены для неё. 
Общие примеры включают направления компаса (значения север, юг, восток и запад) и дни недели.
Поскольку enumы являются константами, имена полей типа enum пишутся заглавными буквами.
В языке программирования Java, вы определяете тип перечисления, используя ключевое слово enum. Например, вы указываете дни-недели перечислияемого типа, как:
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY 
}
Вы должны использовать Enum когда вам нужно представить фиксированный набор констант. Это включает в себя природные типы перечислений, такие как планеты в нашей Солнечной системе и наборов данных, КОГДА ВЫ ЗНАЕТЕ ВСЕ ВОЗМОЖНЫЕ ЗНАЧЕНИЯ ВО ВРЕМЯ КОМПИЛЯЦИИ, например, выбор по меню, флаги командной строки..

Декларация enum объявляет\определяет новый класс (called an enum type). 
Тело enum класса может включать в себя перечисление методов и другие поля. 
Компилятор автоматически добавляет некоторые специальные методы, когда он создает ENUM. Например, у них есть static метод "values()", который возвращает массив, содержащий все значения перечисления в порядке их объявления. Этот метод обычно используется в сочетании с for-each construct чтобы перебрать значения типа ENUM. Например, этот код из примера класса Planet ниже перебирает всех планет в Солнечной системе.

for (Planet p : Planet.values()) {
    System.out.printf("Your weight on %s is %f%n",
                      p, p.surfaceWeight(mass));
}

Примечание: Все перечислений неявно расширяют java.lang.Enum (All enums implicitly extend java.lang.Enum). Поскольку класс может расширять только один родительский класс, и язык Java не поддерживает множественное наследование состояния, следовательно, перечисление не может расширить ничего другого.

В следующем примере, планета представляет собой тип перечисления, представляющий планеты в Солнечной системе. Они определяются свойствами для постоянной массы и радиуса.

Каждая константа перечисления объявляется со значениями параметров массы и радиуса. Эти значения передаются в конструктор, когда создается эта константа (для каждой планеты). Java требует, чтобы сначала были определены константы (т.е. в самомом начала enum, до объявления каких-либо полей или методов). Кроме того, если в enum есть/определены также поля и методы, то список констант перечисления должны заканчиваться точкой с запятой.
----
Примечание: Конструктор для перечислимого типа должен иметь package-private or private доступ. Он автоматически создает константы, которые определены в начале тела перечисления. Вы не можете вызывать конструктор перечисления самостоятельно.
----

В дополнение к своим свойствам и конструктор, Planet есть методы, которые позволяют получить поверхностную силу тяжести и вес объекта на каждой планете:
*******************
Lesson: Annotations
Annotations, a form of metadata, provide data about a program that is not part of the program itself.
Аннотации -- это форма метаданных, которые предоставляют данные о программе, но не являются частью самой программы. Аннотации не имеют прямого влияния на работу кода, который  они аннотируют.
Аннотации имеют ряд применений, среди них: 
1) Информация для компилятора - Аннотации могут быть использованы компилятором для обнаружения ошибок или подавления предупреждений. 
2) Дополнительная обработка во Время компиляции и во время развертывания программы - Программные средства могут обрабатывать информацию для генерации кода, XML-файлы и так далее. 
3) Доп. Обработка во выполнения 
---------------
 As of the Java SE 8 release, annotations can also be applied to the use of types. Here are some examples:

    Class instance creation expression:

        new @Interned MyObject();

    Type cast:

        myString = (@NonNull String) str;

    implements clause:

        class UnmodifiableList<T> implements
            @Readonly List<@Readonly T> { ... }

    Thrown exception declaration:

        void monitorTemperature() throws
            @Critical TemperatureException { ... }

This form of annotation is called a type annotation.
-------------------
The predefined annotation types defined in java.lang are @Deprecated, @Override, and @SuppressWarnings.

@Deprecated @Deprecated (резко осуждается, протестуется, возражается) annotation indicates that the marked element is deprecated and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field with the @Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc @deprecated tag, as shown in the following example. The use of the at sign (@) in both Javadoc comments and in annotations is not coincidental: they are related conceptually. Also, note that the Javadoc tag starts with a lowercase d and the annotation starts with an uppercase D.

   // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated
     */
    @Deprecated
    static void deprecatedMethod() { }
}

@Override @Override annotation informs the compiler that the element is meant to override an element declared in a superclass. Overriding methods will be discussed in Interfaces and Inheritance.

   // mark method as a superclass method
   // that has been overridden
   @Override 
   int overriddenMethod() { }

While it is not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with @Override fails to correctly override a method in one of its superclasses, the compiler generates an error.

@SuppressWarnings @SuppressWarnings annotation tells the compiler to suppress specific warnings that it would otherwise generate (подавляет конкретные предупреждения, которые в противном случае были бы сгенерированы). In the following example, a deprecated method is used, and the compiler usually generates a warning. In this case, however, the annotation causes the warning to be suppressed.

   // use a deprecated method and tell 
   // compiler not to generate a warning
   @SuppressWarnings("deprecation")
    void useDeprecatedMethod() {
        // deprecation warning
        // - suppressed
        objectOne.deprecatedMethod();
    }

Every compiler warning belongs to a category. The Java Language Specification lists two categories: deprecation and unchecked. The unchecked warning can occur when interfacing with legacy code written before the advent of generics (взаимодействие с унаследованным кодом, написанным еще до появления дженериков). To suppress multiple categories of warnings, use the following syntax:

@SuppressWarnings({"unchecked", "deprecation"})

@SafeVarargs @SafeVarargs annotation, when applied to a method or constructor, asserts that the code does not perform potentially unsafe operations on its varargs parameter. When this annotation type is used, unchecked warnings relating to varargs usage are suppressed.

@FunctionalInterface @FunctionalInterface annotation, introduced in Java SE 8, indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Specification.

---------------
As of the Java SE 8 release, annotations can also be applied to any type use. This means that annotations can be used anywhere you use a type. A few examples of where types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses. This form of annotation is called a type annotation.

