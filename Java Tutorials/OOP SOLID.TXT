---OOP---
АБСТРАКЦИЯ -- это набор всех значимых характеристик объекта.
Абстракция -- это придание объекту характеристик, которые отличают его от всех других объектов и чётко определяют его концептуальные границы.
Абстракция может быть выражена через интерфейс. (способ отделить реализацию от спецификации)

ИНКАПСУЛЯЦИЯ -- [это свойство системы, которое] позволяет объединить данные и работающие с ними методы в класс, и позволяет скрыть детали реализации от пользователя.
Тем самым пользователь не знает и не задумывается о сложности реализации компонента, а взаимодействует с ним посредством предоставляемого интерфейса.
Инкапсуляция -- объединяет, скрывает и защищает жизненно важные для компонента данные и методы.

НАСЛЕДОВАНИЕ -- [это свойство системы, которое] позволяет описать\создать новый класс на основе уже существующего, при этом функциональность и свойства родительского класса заимствуются новым классом.
Класс-наследник реализует спецификацию базового\родительского класса.
Это позволяет обращаться с объектом класса-наследника так же как и с объектом базового класса.

ПОЛИМОРФИЗМ -- [это свойство системы, которое] позволяет использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре каждого объекта.
Полиморфизм -- это возможность объектов с одинаковой спецификацией иметь различную реализацию.
(кратко: один интерфейс -- много реализаций)
***********************
---SOLID---
[ S ] - SRP - Single Responsibility - на каждый класс должны быть возложена только 1 функциональная обязанность.Класс должен иметь одну и только одну причину для изменений.
Т.е. должны быть только 1 причина для изменения [данного класса].
И при изменении надо будет менять только 1 класс.
Например, собрать данные и напечатать отчёт должны делать 2 разных класса.
--- http://x-twig.ru/blog/single-responsibility-principle/
один из способов поиска причин изменения - анализ аудитории класса.
ответственность - это определенный набор функций, которые выполняет один взятый актёр.
Актер для ответственности - единственный источник изменений этой ответственности.
http://x-twig.ru/user_files/HighLevelDesign.png
Создание нового объекта обозначено с правой стороны схемы с помощью «Фабрик» (Factories) и единой точки входа нашего приложения (Main). Один актёр - одна ответственность. О сохраняемости (Persistence) также позаботились, расположив ее внизу. Отдельный модуль предназначается для отдельной ответственности. И наконец, с левой стороны мы разместили представление, или механизм доставки, в виде MVC или каком-либо другом типе пользовательского интерфейса. И вновь соблюден принцип единой ответственности. Все, что нам остается выяснить, - это что делать с самой бизнес-логикой
---

[ O ] - OCP - Open-Closed - программные сущности должны быть открыты для расширения и закрыты для изменения.
Сущность программного обеспечения (классы, модули и функции) должна быть открыта для усовершенствования, но закрыта для различных изменений.
Речь идет о разработке модулей, классов и функций таким образом, чтобы в ситуации, когда понадобится новый функционал, не пришлось менять уже существующий код. Решение – в написании нового кода, который будет использовать существующий.
Т.е. должна существовать возможность расширить поведение, не меняя исходный код.
Иначе надо повторно делать юнит тесты всего кода, code review и другие сопутствующие процедуры.
Например, Collections.sort + comparator.
--- http://x-twig.ru/blog/the-open-closed-principle/
Каждый новый принцип SOLID можно рассматривать в контексте уже рассмотренных ранее. Так, принцип единственной обязанности (SRP) гласит, что на одном объекте может лежать только одна обязанность. Сравнивая OCP и SRP, можно отметить их комплементарность, взаимодополняемость. Код, разработанный с учетом SRP, визуально будет близок к такому же коду, но учитывающему OCP. Когда у нас есть код, каждый объект которого имеет одну обязанность, введение новой функции создаст вторую обязанность, второй повод для изменения. Это может нарушить оба принципа.
Точно также, если у нас есть код, который должен меняться только тогда, когда его основные функции меняются или, наоборот, должны оставаться неизменными при добавлении новой функции, то в этом коде будут соблюдены оба принципа. Но это не значит, что SRP-принцип всегда приводит к OCP, или, наоборот, но в преобладающем большинстве случаев, если соблюден один принцип, привести код к соблюдению второго не составит большого труда
--- http://x-twig.ru/user_files/violate1.png
если любой один класс напрямую использует другой класс, то принцип открытости-закрытости будет нарушаться. Строго говоря, это – верно. Очень интересно найти тот самый предел, ту черту, за которой приходит понимание: соответствовать принципу OCP гораздо сложнее, чем изменить уже существующий код, или же затраты на изменение кода будут слишком большими.
--- http://x-twig.ru/user_files/strategy.png
Шаблон Стратегия отлично показывает используемый интерфейс.
-1-В интерфейсе мы можем определить только поведение, поэтому вместо прямого использования общедоступных переменных следует подумать о сеттерах и геттерах.
-2-Интерфейсы принадлежат их клиентам и поэтому, когда мы ходим дать имя интерфейсу, нам нужно полностью забыть о реализации и думать только о клиенте.
-3-Интерфейсы должны отражать потребности клиентов. Интерфейсы относятся к клиентам и называются таким образом, чтобы отражать типы и объекты, которые необходимы клиентам. Интерфейсы должны содержать методы, которые клиенты хотят использовать.

Шаблонный метод очень смахивает на стратегию, но с одним отличием: вместо интерфейса он использует абстрактные классы. Шаблонный метод рекомендуется использовать в том случае, если клиент для нашего приложения очень специфический, с небольшой возможностью повторного использования и в том случае, если у серверных классов общее поведение
---
В большинстве систем невозможно не повлиять на код при вводе новых классов. Но соответствие принципу открытости-закрытости может значительно сократить классы и модули, требующие постоянного изменения.
--- мнение:
[По большому счету принцип открытости закрытости - это правильное применение полиморфизма и инкапсуляции??, то что может измениться мы инкапсулируем ( прячем в объектах ), а к тому что работает с тем что меняется мы применяем полиморфизм и его формы могут быть разными??]
---

[ L ] - LSP - Leskov Substitution - принцип подстановки Барбары Лесков:
Функции, которые используют базовый тип, должны иметь возможность использовать подтип базового типа, не зная об этом.
Если S - это подтип от Т, то должна быть возможность заменить Т на S без изменения основных свойств программы.
=> ВХОДные параметры не могут быть сужены, но могут быть расширены.
=> ВЫХОДные параметры не могут быть ослаблены\расширены, но могут быть сужены.
Подтипы должны дополнять базовые типы [а не заменять существующее поведение базового типа].
Дочерний\Наследующий класс должен дополнять, а не замещать поведение родительского\базового класса.
Если у нас есть класс A и унаследованный от него класс B, то если мы заменим все использования класса A на B, ничего не должно измениться в работе программы.
(подклассы должны\могут переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента).
--- x-twig.ru/blog/liskov-substitution-principle/
Шаблонный метод проектирования – классический пример соблюдения и реализации принципа подстановки, который, в свою очередь, является одним из способов соблюдения OCP
нарушение принципа LSP – это скрытое нарушение принципа OCP.
Например, нельзя наследовать квадрат от прямоугольника. http://x-twig.ru/blog/liskov-substitution-principle/
объектно-ориентированное программирование не может применить правила реальной жизни к объектам. Каждый объект здесь должен быть абстракцией над концепцией.
---

[ I ] - ISP - interface segregation - принципа разделения интерфейса: много специализированных интерфейсов лучше, чем 1 универсальный.
Клиент не должен зависеть от методов, которые он не использует.
Также много интерфейсов делают систему менее связанной (low coupling) и тогда её легче изменять, рефакторить и устанавливать (deploy).
--- http://x-twig.ru/blog/Interface-segregation-principle/
http://x-twig.ru/user_files/carUsingInterface.png
Вместо реализации Car становится клиентом. А мы хотим дать возможность клиенту использовать весь модуль.
Интерфейсы относятся к клиентам, а не к реализациям, поэтому и создавать их нужно в лучших отношениях с клиентом. Мы должны разбить интерфейсы на кусочки так, чтобы они лучше работали с клиентами.
Конечно, могут появиться дубляжи, но помните, что интерфейсы – это простые определения имен функций и логика в них не реализуется, а значит, и проблем с дублированием не будет.
Еще один приятный момент заключается в том, что в нашей бизнес-логике один класс может реализовать несколько интерфейсов, если ему это понадобится. Так что мы можем обеспечить единую реализацию для всех общих методов между интерфейсами. Интерфейсы также заставляют нас думать о нашем коде больше с точки зрения клиента, что, в свою очередь, приводит нас к уже более легкому тестированию.
---

[ D ] - DI - dependency inversion - инверсия зависимостей: 
Зависимости внутри системы строятся на основе абстракций (интерфейсов):
-1- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Все они должны зависеть от абстракций.
-2- Абстракции не должны зависеть от деталей.
-3- Детали должны зависеть от абстракций.
Выполнение верхнеуровневых модулей должно быть независимо от выполнения низкоуровневых, чтобы увеличить возможность их переиспользования.
Минусы прямых зависимостей:
-1- Жёсткость -- трудно изменить модули, т.к. каждое изменение влияет на вного других частей.
-2- Хрупкость -- при изменении могут сломаться неожиданный части системы.
-3- Неподвижность -- трудно повторно использовать модуль в другом приложении, т.е. его нельзя отделить от других модулей текущего приложения.
Можно\нужно разделить модули по степени изменяемости:
сделать так, чтобы более часто изменяемые модули зависели от менее часто изменяемых, а не наоборот.
--- http://x-twig.ru/blog/the-dependency-Inversion-principle/
Принципы SOLID - это исключительно архитектурные принципы Роберта С. Мартина, которые полностью меняют правила игры, весь ход программирования.
http://x-twig.ru/user_files/HighLevelDesign.png
В этой архитектуре есть несколько интересных моментов:
  -1- пользовательский интерфейс (в большинстве случаев, веб-фреймворк MVC) или любой другой механизм доставки в нашем проекте будет зависеть от бизнес-логики. Бизнес-логика сама по себе довольно абстрактна, а пользовательский интерфейс – само воплощение конкретики. Он представляет собой одну из деталей проекта, и к тому же, очень нестабильную. Ничто не должно зависеть от пользовательского интерфейса, ничто не должно зависеть от веб-фреймворка MVC;

  -2- еще одно интересное наблюдение, сделанное нами, говорит, что долговременное сохранение, база данных, наш MySQL или PostgreSQL базируются на бизнес-логике. Это позволяет менять сохраняемость так, как это нужно нам. Если завтра нам понадобится изменить MySQL вместе с PostgreSQL или просто текстовые файлы, мы легко сможем это сделать. Нам, конечно, придется реализовать определенный уровень сохраняемости для новых методов сохранения состояния, но для этого не придется менять отдельные строки кода в нашей бизнес-логике;

  -3- в конце концов, в правой части нашей бизнес-логики, вне ее, у нас есть все классы, которые создают классы бизнес-логики. Эти классы созданы как точки входа в наши приложения. Многие люди склонны думать, что они принадлежат к бизнес-логике, но делают они это только для того, чтобы создать бизнес-объекты. Они – просто классы, которые помогают нам создавать другие классы. Бизнес-объекты и логика, которую они обеспечивают, не зависят от них. Мы могли бы использовать различные модели или создать простой объект, чтобы обеспечить бизнес-логику. Это не имеет значения. После того, как бизнес-объекты созданы, они начинают выполнять свою работу.
---
Наиболее популярным и часто используемым решением для того, чтобы инвертировать зависимость, является введение более абстрактного модуля в наш проект. Наиболее абстрактным элементом в ООП является интерфейс. Таким образом, любой другой класс может зависеть от интерфейса, и все еще соблюдать DIP.
Принцип инверсии зависимостей помогает нам соблюдать все остальные принципы из пятерки SOLID. Соблюдая принцип DIP, мы практически начинаем соблюдать OCP, можем разделять обязанности, правильно используем подтипы и можем разделять интерфейсы
---
https://code.tutsplus.com/
---