Процесс имеет самодостаточную среду исполнения. Процесс обычно имеет полный, частный набор базовых ресурсов времени выполнения; в частности, каждый процесс имеет свое собственное пространство памяти.
Процессы часто рассматриваются как синонимы с программ или приложений. Тем не менее, то, что пользователь видит в качестве одного приложения на самом деле может быть множество взаимодействующих процессов. Для облегчения взаимодействия между процессами, большинство операционных систем поддерживают Inter Process Communication (IPC) ресурсы, такие как трубы и розетки (pipes and sockets). IPC используется не только для связи между процессами на той же системе, но процессы в различных системах.
Большинство реализаций виртуальной машины Java работать как единый процесс. Приложение Java может создать дополнительные процессы, используя объект ProcessBuilder. 
****************************
Потоки
Потоки иногда называют легкими процессами. Оба процессы и потоки обеспечивают среду выполнения, но создание нового потока требует меньше ресурсов, чем создание нового процесса.
Потоки существуют в рамках процесса - каждый процесс имеет по крайней мере один поток. Потоки совместно используюи ресурсы процесса, в том числе память и открытые файлы. Это эффективная, но часто потенциально проблемная практика коммуникации.
Многопоточное исполнение является существенной особенностью платформы Java. Каждое приложение имеет, по меньшей мере, один поток - или несколько, если считать "system" threads, которые управляют памятью и обработкой сигналов. Но с точки зрения прикладного программиста , вы начинаете только одним потоком, называемый основной поток (main thread). Этот поток имеет возможность создавать дополнительные потоки.
-----------
Thread Objects

Каждый поток связан с экземпляром класса Thread. Существуют две основные стратегии  использования потоков:
1) Для того, чтобы непосредственно контролировать создание и управление потоками, просто инстанцируйте/создайте Thread каждый раз, когда приложение должно инициировать/выполпоток асинхронную задачу.
2) Для абстрактного управления потоками от остальной части приложения, передать задачи приложения к исполнителю. ( tasks to an executor)
-------------
Defining and Starting a Thread

Приложение , которое создает экземпляр Thread должен предоставить код , который будет работать в этом потоке. Есть два способа сделать это:

1) Предоставить Runnable объект. Runnable интерфейс определяет единственный метод запуска , RUN , который содержит код, к-й будет выполняется в потоке. Runnable объект передается в Thread конструктор.
HelloRunnable примере:
public class HelloRunnable implements Runnable {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }

}
2) Созадть Подкласс потока Thread. Класс Thread сам реализует Runnable , но его метод RUN ничего не делает. Приложение может создать подкласс потока, предоставляя свою собственную реализацию RUN:
public class HelloThread extends Thread {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new HelloThread()).start();
    }

}
Обратите внимание на то, что оба примера вызовают Thread.start для того , чтобы начать новый поток.

Какую из этих идиом вы должны использовать? Первая идиома, которая использует Runnable объект, является более общим подходом, так как Runnable объект может создать подкласс класса, кроме Thread . Вторую идиому легче использовать в простых приложениях, но она ограничивается тем фактом , что ваш класс-задача (task class) должен быть потомком Thread . Этот урок посвящен первому подходу, который отделяет Runnable задачу из Thread объекта , который выполняет задачу. Мало того, что этот подход более гибким, но он применим к API для управления потоками высокого уровня.

Thread класс определяет ряд методов , используемых для управления потоками. К ним относятся статические методы, которые предоставляют информацию о том.. , или влияют на состояние.. потока, который вызвал этот метод. Другие методы вызываются из других потоков, участвующих в управлении текущего/другого потока.
------------
Pausing Execution with Sleep

 Thread.sleep заставляет текущий поток приостановить выполнение в течение определенного периода времени. Это является эффективным средством для предоставления процессорного времени другим потокам приложения или другим приложеним, которые могут выполняться на компьютерной системе. Метод sleep также может быть использован для стимуляции, как показано в примере ниже, и ожидания другого потока которому нужно опред. время на выполнение своих вычислений.

Предусмотрены два перегруженные версии sleep: 1) тот, который определяет время ожидания в миллисекундах
2) и тот, который определяет время сна в наносекундах.

Но это время сна не гарантируется из-за ограничений базовой ОС. Кроме того, период сна может быть прекращено путем прерывания. you cannot assume that invoking sleep will suspend the thread for precisely the time period specified

Обратите внимание на то, что поток при вызове метода sleep может выбросить InterruptedException. Это происходит когда другой поток прерывает текущий поток во время его сна.
------------------------
Прерывания

Прерывание является указанием потоку остановить то , что он делает и делать что - то другое. Это программист решает, как именно поток реагирует на прерывание, но обычно в этом случае поток прекращается (terminate).

A thread sends an interrupt by invoking interrupt() on the Thread object for the thread to be interrupted. For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption.

Supporting Interruption

Как поток поддерживает свой ??собственный перерыв? Это зависит от того, что он в данный момент делает. Если поток часто вызывает методы , которые бросают InterruptedException , он просто возвращается из RUN метода после того, как он ловит это исключение. Например, 
for (int i = 0; i < importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We've been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}

Многие методы , которые бросают InterruptedException , такие как sleep , предназначены , чтобы отменить их текущую операцию и вернуться/return немедленно, как только получено прерывание.

Что делать , если поток долго работает без вызова метода , который бросает InterruptedException ? 
Т.е. как поток может понять, что он был прерван, если он не вызывает метод, из которого можно получить InterruptedException ? 
Поэтомум поток должен периодически вызывать Thread.interrupted , который возвращает true , если прерывание было получено. Например:
for (int i = 0; i < inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We've been interrupted: no more crunching.
        return;
    }
}
В этом простом примере, код просто проверяет на interrupt и выходит из потока , если прерывание было получено. В более сложных приложениях больше смысла было бы бросить InterruptedException :

if (Thread.interrupted()) {
    throw new InterruptedException();
}
This allows interrupt handling code to be centralized in a catch clause

The Interrupt Status Flag / Флаг статуса прерывания

Механизм прерываний реализован с использованием внутреннего флага , известного как состояние прерывания (interrupt status). Вызов Thread.interrupt устанавливает этот флаг. Когда поток проверяет прерывания путем вызова статического метода Thread.interrupted , статус прерывания очищается. Нестатический isInterrupted метод, который используется одним потоком , чтобы запросить информацию о состоянии прерывания другого, не меняет флаг статуса прерывания у другого.

По соглашению, любой метод , that exits by throwing an InterruptedException clears interrupt status when it does so. НО всегда возможно , что статус прерывания сразу же будет установлен снова, другим потоком (by another thread invoking interrupt) .
**********
Joins Соединения

Метод позволяет одному потоку присоединиться к другому и ждать его завершения. Если t - это поток, который выполняется в данный момент, то вызов вдругом потоке

t.join();

заставляет текущий поток (из которого было вызвано t.join) приостановить своё выполнение, и ждать пока поток t, не завершит свою работу.

Overloads of join позволяют программисту указать период ожидания. Однако, как и со  sleep, join зависит от таймингов операционной системы, так что вы не должны предполагать, что join will wait exactly as long as you specify.

Как sleep, join реагирует на прерывание путем выхода с InterruptedException.
--------------------
The SimpleThreads Example

The following example brings together some of the concepts of this section. SimpleThreads consists of two threads. The first is the main thread that every Java application has. The main thread creates a new thread from the Runnable object, MessageLoop, and waits for it to finish. If the MessageLoop thread takes too long to finish, the main thread interrupts it.

The MessageLoop thread prints out a series of messages. If interrupted before it has printed all its messages, the MessageLoop thread prints a message and exits.


public class SimpleThreads {

    // Display a message, preceded by
    // the name of the current thread
    static void threadMessage(String message) {
        String threadName =
            Thread.currentThread().getName();
        System.out.format("%s: %s%n",
                          threadName,
                          message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                "Mares eat oats",
                "Does eat oats",
                "Little lambs eat ivy",
                "A kid will eat ivy too"
            };
            try {
                for (int i = 0;
                     i < importantInfo.length;
                     i++) {
                    // Pause for 4 seconds
                    Thread.sleep(4000);
                    // Print a message
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage("I wasn't done!");
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        // Delay, in milliseconds before
        // we interrupt MessageLoop
        // thread (default one hour).
        long patience = 1000 * 60 * 60;

        // If command line argument
        // present, gives patience
        // in seconds.
        if (args.length > 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println("Argument must be an integer.");
                System.exit(1);
            }
        }

        threadMessage("Starting MessageLoop thread");
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage("Waiting for MessageLoop thread to finish");
        // loop until MessageLoop
        // thread exits
        while (t.isAlive()) {
            threadMessage("Still waiting...");
            // Wait maximum of 1 second
            // for MessageLoop thread
            // to finish.
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) > patience)
                  && t.isAlive()) {
                threadMessage("Tired of waiting!");
                t.interrupt();
                // Shouldn't be long now
                // -- wait indefinitely
                t.join();
            }
        }
        threadMessage("Finally!");
    }
}

*****************
Synchronization синхронизация

Потоки общаются в первую очередь, предоставляя совместный доступ к полям и к объектам на которые ссылаются эти поля. Эта форма общения является чрезвычайно эффективной, но позволяет два вида возможных ошибок: 
1) thread interference (пересечение потоков/вмешательство одного потоко в работу другого)
2) memory consistency errors (ошибки согласованности памяти).
Для предотвращения этих ошибок используется синхронизация.

Тем не менее, синхронизация может приввести потоки к соревнованию/раздору/соперничеству, это возникает, когда два или более потоков пытаются получить доступ к одному ресурсу одновременно. Это влечёт к тому, что Java начинает выполнять один или несколько потоков более медленно, или даже может приостановить их исполнение. 

Голодание и активная блокировка (Starvation and livelock) являются формами  соперничествА ПОТОКОВ. 
-------
Thread Interference - соперничество ПОТОКОВ
например класс счётчик
class Counter {
    private int c = 0;
    public void increment() {
        c++;
    }
    public void decrement() {
        c--;
    }
    public int value() {
        return c;
    }
}
Счетчик разработан таким образом, что каждый вызов приращения добавит 1 к C, и каждый вызов декремента будет вычитать 1 из с. Тем не менее, если на объект счетчика ссылаются из нескольких потоков, интерференция/Вмешательство между потоками может нарушить алгоритм выполнения (prevent this from happening as expected.).

Вмешательство происходит, когда две операции, работают в разных потоках, но действуя на одних и тех же данных, ПЕРЕКРЫВАЮТСЯ. Это означает, что две операции состоят из нескольких шагов, и последовательность этих шагов перекрывается.

It might not seem possible for operations on instances of Counter to interleave, так как обе операции на C одиночные, простые выражения. Тем не менее, даже простые выражения могут выполняться виртуальной машиной  в несколько шагов. 
одно выражение C ++ можно разбить на три этапа:

1)Получить текущее значение с.
2)Увеличить извлеченное значение на 1.
3)сохранить измененное значение обратно в с.

Выражение c-- можно разложить таким же образом, за исключением того, что второй этап декрементирует вместо приращений.

Пусть Поток А вызывает приращение примерно в то же время Поток B вызывает декремент. Если начальное значение с равно 0, их перемежающиеся действия могут выполнить следующую последовательность:


1 Thread A: Retrieve c.
2    Thread B: Retrieve c.
3    Thread A: Increment retrieved value; result is 1.
4    Thread B: Decrement retrieved value; result is -1.
5    Thread A: Store result in c; c is now 1.
6    Thread B: Store result in c; c is now -1.


Результат Thread A теряется, он  затирается результатом Thread B. Это только одно возможных перекрытий. При других обстоятельствах это могло быть иначе...
******************
Memory Consistency Errors

Ошибки согласованности памяти возникают , когда разные потоки имеют противоречивые представления о том , какими должны быть одни и те же данные. 

Ключ к избежанию ошибок согласованности памяти - это понимание happens-before relationship. Это соотношение  гарантирует, что memory writes by one specific statement are visible to another specific statement. 

Suppose a simple int field is defined and initialized:
int counter = 0;

Поле Счетчика совместно используется двумя потоками, А и Б. 
Suppose thread A increments counter: counter++;

Then, shortly afterwards, thread B prints out counter:
System.out.println(counter);

Если эти два выражения были выполнены в одном и том же потоке, можно было бы с уверенностью сказать, что выведется "1". Но если два утверждения выполняются в отдельных потоках, значение  вполне может быть "0", потому что нет никакой гарантии , что  thread A's change to counter will be visible to thread B - unless the programmer has established a happens-before relationship between these two statements.

Есть несколько действий, которые создают happens-before relationship. Одним из них является синхронизация.

Мы уже видели два действия, которые создают happens-before relationship:

1) Когда инструкция вызывает Thread.start , каждое утверждение , которое имеет happens-before relationship с этим утверждением также имеет happens-before relationship с каждым утверждением , выполняемым новым потоком. The effects of the code that led up to the creation of the new thread are visible to the new thread

2) Когда поток завершается и заставлят выйти другой поток из Thread.join (который ждал этот первый поток), то все выражения, который были выполнены в завершённом потоке имеют happens-before relationship со всеми выражениями, которые  идут во втором потоке после Thread.join. The effects of the code in the thread are now visible to the thread that performed the join.

********************
Synchronized Methods

Язык программирования Java предоставляет два основных идиомы синхронизации: синхронизированные методы и синхронные заявления/выражения. 

Для того, чтобы метод синхронизированный, добавьте ключевое слово synchronized к его declaration/объявлению.

making these methods synchronized has two effects:
  1) два одновременных вызова синхронизованного метода не могут пересечься.
 Когда один поток выполняет синхронизированный метод для объекта, все остальные потоки, которые вызывают синхронизированные методы для того же объекта блокируются (приостановить исполнение) до тех пор пока первый поток не закончит свою работу с объектом.
2) Когда синхронизированный метод завершается, он автоматически устанавливает happens-before relationship с любым последующим вызовом синхронизированного метода того же объекта. Это гарантирует, что изменения в состоянии объекта видимы для всех потоков.

Обратите внимание, что конструкторы не могут быть синхронизированы. Синхронизация конструкторов не имеет смысла, потому что только поток, который создает объект должен иметь доступ к нему, пока он строится.

Внимание: При создании объекта, который будет shared между потоками, надо следать, чтобы ссылка на объект не "утекла" преждевременно. Например, предположим, что вы хотите создать список List  под названием экземпляры (instances), содержащий каждый экземпляр класса. Можно было бы попытаться добавить следующую строку в конструктор:

instances.add (это);

Но тогда другие потоки могут использовать instances  для доступа к объекту до завершения строительства объекта (его инициализации).

Синхронные методы позволяют простую стратегию для предотвращения помех/соперничества потоков и ошибок согласованности памяти: если объект виден более чем одному потоку, все операции чтения/записи в переменные этого объекта выполняются с помощью синхронизированных методов. (Важное исключение: final поля, которые не могут быть изменены после того, как объект построен, можгут безопасно считываться через несинхронизированные методы, соразу после того как объект построен) Эта стратегия эффективна, но может вызвать проблемы с живостью (liveness).

******************
Intrinsic Locks and Synchronization
https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html
Внутренние Замки и синхронизация

Синхронизация строится вокруг внутренней сущности , известной как внутренняя блокировка/внутренний замок, или блокировка монитора . (Спецификация API часто обращается к этой сущности просто как "монитор" . ) Внутренния блокировка играет определенную роль в обоих аспектах синхронизации: 
1) обеспечивает исключительный доступа к объекту 
2) установливает happens-before relationships , которые имеют важное значение для видимости.

Каждый объект имеет внутреннюю блокировку/замок , связанный с ним самим. По соглашению, поток , которому нужен эксклюзивный и последовательный доступ к полям объекта должен получить (acquire) внутреннюю блокировку (intrinsic lock) объекта, перед началом доступа к ним, а затем освободить внутреннюю блокировку , когда поток закончить свою работу с полями объекта. В этом случае говорят, что поток владеет внутренним замком/блокировкой в период между тем как он получил блокировку и отпустил блокировку. До тех пор пока поток владеет внутренней блокировкой, никакой другой поток не может получить ту же самую блокировку. Другой поток будет заблокирован в тот момент как попытается получить блокировку.

Когда поток освобождает естественную/внутреннюю блокировку (intrinsic=belonging naturally=essential),  устанавливается happens-before связь между этим действием и любым последующим захватом того же замка/блокировки.

Locks In Synchronized Methods

Когда поток вызывает синхронизированный метод, он автоматически получает блокировку для объекта, в кот-м опредлён этот метода, и освобождает её, когда метод заканчивает/происходит выход из метода. Снятия блокировки происходит даже в том случае, если возврат был вызван by uncaught exception (неперехваченным исключением).

Вы можете спросить , что происходит , когда вызывается статический синхронизированный метод?
так как статический метод связан с классом, а не с объект, то В этом случае поток получает блокировку для класса объекта ( Class object ), связанного с этим классом. Таким образом , доступ к статическим полям класса контролируется замком, отличающимся от замка для экземпляра класса.

Synchronized Statements / Синхронные заявления

Другой способ создать синхронизированные коды - это с помощью синхронизированных утверждений (synchronized statements). В отличие от синх методов, в синх заявлениях необходимо указать объект , который предоставить свой внутренний замок/внутреннюю блокировку:

public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
В этом примере addName метод необходимо синхронизировать изменения в Lastname и nameCount , но также надо избегать синхронизованных вызовых других методов объекта. (Вызов других методов объекта из синхронизированного кода может создать проблемы, описанные в разделе живучести Liveness) Без синхронизации должен быть вызван только метод с единственной целью: nameList.add .

Синхронные утверждения также полезны для улучшения параллелизма с мелкозернистой синхронизацией. 
Т.е. с помощью Synchronized statements можно сделать более точеную синхронизацию.

Предположим, например, класс MsLunch имеет два поля c1 и c2, которые никогда не используются вместе. Все обновления этих полей должны быть синхронизированы, но можно разрешить чтобы обновление c1 пересекалось/перекрывалось с обновлением c2.
Если этого не позволить, то этим мы снизим параллелизм и создадим ненужную блокироку. 
Вместо того чтобы использовать синхронизированные методы или  замок связанный с this (lock associated with 'this') , мы создаем два объекта исключительно для предоставления замков.

public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
 Используйте эту идиому с крайней осторожностью. Вы должны быть абсолютно уверены в безопасности такого перекрытия/пересечения изменения двух полей.

Reentrant Synchronization

Напомним , что поток не может получить блокировку , принадлежащую другому потоку. Но поток может получить блокировку , которой он уже владеет.

 Такое поведение, когда поток может получить блокировку ещё раз (ещё много раз) задействет механизм, называемый reentrant synchronization (Повторный вход в синхронизацию). Это описывает ситуацию , когда синхронизированный код, прямо или косвенно, вызывает метод , который также содержит синхроннизированный код, и оба набора кода используют один и тот же замок/тот же объект для блокировки. Без reentrant synchronization  синхронизированному коду придется принимать много дополнительных мер предосторожности, чтобы избежать блокировки себя же самим собой.
-------------------
Atomic Access - атомарный доступ

В программировании, атомарное действие значит, что оно происходит всё и сразу. Atomic действие не может остановиться в середине: оно либо полностью происходит, или не происходит вообще. Никаких побочных эффектов атомарного действия не видны, пока действие не будет завершено.

Мы уже видели, что выражение приращения (increment expression), например, C++, не описывает элементарное действие. Даже очень простые выражения могут определять сложные действия, которые можно разложит на более простые действия. Но есть действительно атомарны действия, это:

1)-Чтение и запись - атомарны для ссылочных переменных (reference variables) и для большинства примитивных переменных primitive variables (всех типов, за исключением long and double) 

2)-Чтение и запись атомарны для всех переменных объявленых volatile (в том числе long and double).

атомарные действия не могут перекрываться, поэтому их можно использовать, не опасаясь столкновений потоков (предотвратить многочисленные потоки от столкновений друг с другом во время обновления общего состояния). Но это не устраняет полностью неоходимость синхронизировать атомарные действия, поскольку  всё ещё возможны ошибки согласованности памяти (memory consistency errors are still possible). Использование volatile  переменных снижает риск ошибок согласованности памяти, так как любая запись в volatile переменную устанавливает happens-before  связь с последующим чтением той же самой переменной. Это означает, что изменения в volatile переменной всегда видны другим потокам. Более того, это также означает, что, когда поток считывает volatile переменную, она видит не только последнее изменение это volatile переменной, но и побочные эффекты кода, которые привели к этому изменению.

Использование simple atomic variable access является более эффективным, чем доступ к этим переменным через синхронизированый кода, но требует больше заботы от программиста, чтобы избежать ошибок согласованности памяти. Будет ли дополнительное усилие стоить того, зависит от размера и сложности приложения.

Некоторые из классов в пакете java.util.concurrent обеспечивают атомарные методы, которые не полагаются на синхронизацию.
----------------------
Liveness живувесть = это
Возможность приложения выполняться бесконечно долго.
Deadlock - Тупик -  описывает ситуацию, когда два и более потоков оказываеются заблокированными навсегда, ожидая друг друга. Вот пример.

Альфонс и Гастон друзья. Строгое правило вежливости в том, что, когда вы кланяятесь к другу, вы должны оставаться склонёнными, чтобы дать время другу поклониться в ответ.
 К сожалению, это правило не учитывает возможность того, что два друга могли поклониться друг другу одновременно. 
public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format("%s: %s"
                + "  has bowed to me!%n", 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format("%s: %s"
                + " has bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}
Deadlock наступит когда оба потока будут пытаться вызвать bowBack.
 Ни одна блокировки никогда не закончится, потому что каждый поток ждет другой, чтобы выйти из bow.

---------------------
Starvation and Livelock
Голодание и динамический тупик

 Starvation and Livelock встречаются гораздо реже, чем deadlock

Starvation
Голодание описывает ситуацию, когда поток не в состоянии получить регулярный доступ к совместно используемым ресурсам и не в состоянии добиться прогресса (хоть как-то продвинуться в своём выполнении). Это происходит, когда общие ресурсы становятся недоступными на долгий перид времени с помощью "жадных" потоков.

 Например, предположим, что объект имеет синхронизированный метод, выполнение которго занимает много времени. Если один поток часто вызывает этот метод, то другие потоки, которые также хотят получить частый синхронизированный доступ к тому же объекту, часто будут заблокированы.

Livelock - динамический тупик
Поток часто действует в ответ на действие другого потока. Если действие другого потока является также ответом на действия другого потока, то это может привести динамический тупик (livelock). Как и в случае deadlock, livelocked потоки не в состоянии добиться дальнейшего прогресса. Но потоки на самом деле не заблокированы - они просто слишком заняты, отвечая на друг другу, поэтому у них нет времени чтобы возобновить свою непосредственную работу.

 Например, два человека пытающихся разойтись в коридоре: Альфонс шагает влева, чтобы Гастон прошёл от него справа, в то же время как Гастон шагает отсебя направо, чтобы позволить Альфонс пройти слева от себя. 
т.е. сдвигаются в одну и ту же сторону коридора, пропуская друга с противоположной.
 Видя, что они по-прежнему блокируют друг друга, Alphone перемещается вправо, в то время как Гастон движется слева от него. Они по-прежнему блокируют друг друга, так что ...

Guarded Blocks
Потокам часто приходится согласовывать свои действия. Наиболее распространенной является координационной идиомой явл-ся охраняемый блоки. 
Блок(кода) начинается с выяснения условия, которое должно быть истинным для того, чтобы блок продолжил своё выполнение.
 Есть алгоритм, которому надо следовать, чтобы сделать это правильно.

Предположим, например, guardedJoy  это метод, который не должен продолжаться до тех пор, пока  общая переменная joy не будет установлена другим потоком. 
Такой метод теоретически мог бы зациклиться, пока условие=истина, но такой цикл расточителен, так он постоянно выполняется пока ждёт.
public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don't do this!
    while(!joy) {}
    System.out.println("Joy has been achieved!");
}
Более эффективный охранник вызывает Object.wait, чтобы приостановить выполнение текущего потока. Вызов wait не возвратится (does not return until), пока другой поток не выдаст уведомление , что , возможно, произошло какое - то особое событие(хотя и не обязательно что это будет именно то событие, которого ждёт первый поток):

public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we're waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println("Joy and efficiency have been achieved!");
}
!!!
 Примечание:  Всегда вызывайте wait  внутри цикла, который проверяет вырежения/[значение переменной состояния](т.к. цикл завершится как-то только значение выражения/переменной станет true). Не думайте, что прерывание было вызванно изменением того состояния, которое вы жидали.
 Не думайте, что условие по - прежнему верно.
!!!
Как и многие другие методы , которые приостанавливают выполнение, wait  может бросить InterruptedException . В этом примере, мы можем просто игнорировать это исключение.

Почему этот метод guardedJoy описан как синхр-ый? Предположим , что d является объектом, который мы используем для вызова wait. Когда поток вызывает d.wait , он должен владеть блокировкой над d - в противном случае возникает ошибка. Вызывая wait внутри синхронизированного метода, мы по простому получаем эту блокировку/замок.

Когда поток вызывает wait, он снимает блокировку и приостанавливает своё выполнение. В какой - то момент в будущем, другой поток получит ту же блокировку и вызвет Object.notifyAll , информируя все ожидающие (желающие получить блокировку) потоки , что произошло что - то важное:

public synchronized notifyJoy() {
    joy = true;
    notifyAll();
}
Через некоторое время после того, как второй поток освободил блокировку, её получает первый поток, и он возобновляется путем возврата от вызова wait .

!!!
Примечание:  Существует второй способ уведомления, notify , который будит только один поток. Поскольку notify не позволяет указать поток , который надо разбудить, он полезен только в  широко(много)-распараллеленых приложениях - то есть программы с большим количеством потоков, все делают похожие дела. В таком приложении вам всё равно , какой поток получает проснулся.
!!!
Let's use guarded blocks to create a Producer-Consumer application (производитель-потребитель). 
 Этот вид приложения делит данные между двумя потоками: производитель , который создает данные, и потребитель , который делает что - то с ним. Два потока взаимодействуют , используя общий объект. Координация имеет важное значение: поток-потребитель  не должен пытаться извлечь данные до того , как поток-производитель добавил их, а поток-производитель  не должен пытаться доставить новые данные , если потребитель не извлёк старые данные.

In this example, the data is a series of text messages, which are shared through an object of type Drop:


public class Drop {
    // Message sent from producer
    // to consumer.
    private String message;
    // True if consumer should wait
    // for producer to send message,
    // false if producer should wait for
    // consumer to retrieve message.
    private boolean empty = true;

    public synchronized String take() {
        // Wait until message is
        // available.
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = true;
        // Notify producer that
        // status has changed.
        notifyAll();
        return message;
    }

    public synchronized void put(String message) {
        // Wait until message has
        // been retrieved.
        while (!empty) {
            try { 
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = false;
        // Store message.
        this.message = message;
        // Notify consumer that status
        // has changed.
        notifyAll();
    }
}
поток-Производитель, определенный в Producer, посылает серию похожих сообщений. Строка "DONE" указывает на то, что все сообщения были отправлены. Для того, чтобы смоделировать непредсказуемый характер реальных приложений, поток-производитель делает паузу в случайных интервалах между сообщениями.
import java.util.Random;

public class Producer implements Runnable {
    private Drop drop;

    public Producer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        String importantInfo[] = {
            "Mares eat oats",
            "Does eat oats",
            "Little lambs eat ivy",
            "A kid will eat ivy too"
        };
        Random random = new Random();

        for (int i = 0;
             i < importantInfo.length;
             i++) {
            drop.put(importantInfo[i]);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
        drop.put("DONE");
    }
}
The consumer thread, defined in Consumer, simply retrieves the messages and prints them out, until it retrieves the "DONE" string. This thread also pauses for random intervals.


import java.util.Random;

public class Consumer implements Runnable {
    private Drop drop;

    public Consumer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        Random random = new Random();
        for (String message = drop.take();
             ! message.equals("DONE");
             message = drop.take()) {
            System.out.format("MESSAGE RECEIVED: %s%n", message);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
    }
}

Finally, here is the main thread, defined in ProducerConsumerExample, that launches the producer and consumer threads.


public class ProducerConsumerExample {
    public static void main(String[] args) {
        Drop drop = new Drop();
        (new Thread(new Producer(drop))).start();
        (new Thread(new Consumer(drop))).start();
    }
}
*****************
Immutable Objects
неизменные объекты

Объект считается НЕИЗМЕННЫМ, если ее состояние не может измениться после его создания.
 Максимальная опора на неизменные объекты общепринятая практика в качестве стратегии для создания простого, надежного кода.

Неизменные объекты особенно полезны в параллельных приложениях. Поскольку они не могут изменить свое состояние, они не могут быть повреждены из-за столкновения/пересечения потоков, также они не могут находиться в противоречивом/несогласованном (inconsistent) состоянии.

Программисты часто не хотят использовать неизменные объекты, потому что они беспокоятся о стоимости создания нового объекта, в отличие от обновления объекта на месте. 

Влияние создания объекта часто переоценено/преувеличено.
В противовес этому можно взглянуть на эффективность неизменяемых объектов.
 К ним относятся меньшие расходы по сборке мусора, а также отсутствие необходимости защать изменяемые объекты от повреждений.
-----------
A Synchronized Class Example
Класс,  SynchronizedRGB, определяет объекты, представляющие цвета. Каждый объект представляет собой цвет, как три целых числа, которые обозначают  основные значения цветов; и 1 строка, с названием цвета.
public class SynchronizedRGB {

    // Values must be between 0 and 255.
    private int red;
    private int green;
    private int blue;
    private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red < 0 || red > 255
            || green < 0 || green > 255
            || blue < 0 || blue > 255) {
            throw new IllegalArgumentException();
        }
    }

    public SynchronizedRGB(int red,
                           int green,
                           int blue,
                           String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }

    public void set(int red,
                    int green,
                    int blue,
                    String name) {
        check(red, green, blue);
        synchronized (this) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.name = name;
        }
    }

    public synchronized int getRGB() {
        return ((red << 16) | (green << 8) | blue);
    }

    public synchronized String getName() {
        return name;
    }

    public synchronized void invert() {
        red = 255 - red;
        green = 255 - green;
        blue = 255 - blue;
        name = "Inverse of " + name;
    }
}
SynchronizedRGB  следует использовать осторожно, чтобы не привести его в противоречивое состояние. Пусть, например, поток выполняет следующий код:
SynchronizedRGB color =
    new SynchronizedRGB(0, 0, 0, "Pitch Black");
...
int myColorInt = color.getRGB();      //Statement 1
String myColorName = color.getName(); //Statement 2

Если другой поток вызывает color.set после утверждения 1, но до утверждения 2, значение myColorInt не будет соответствовать значению myColorName. Чтобы избежать этого результата, два утверждения должны быть связаны друг с другом:

synchronized (color) {
    int myColorInt = color.getRGB();
    String myColorName = color.getName();
} 
Такого рода несоответствия возможно только для изменяемых объектов - это не будет проблемой it will not be an issue for the immutable version of SynchronizedRGB.
----------------------------------
A Strategy for Defining Immutable Objects
Следующие правила определяют простую стратегию для создания неизменяемых объектов. Не все классы документированые как "неизменные" следуют этим правилам. Это не обязательно означает, что создатели этих классов были неаккуратны - они могут иметь веские основания полагать, что экземпляры их классов никогда не меняются после создания. Однако такие стратегии требуют сложного анализа и не для начинающих.

1)-Не предоставляйте «setter» методов - т.е. тех, которые изменяют поля или объекты, на которые ссылаются эти полями.
2)-Сделайте все поля final and private.
3)-Не позволяйте подклассам переопределять методы. Самый простой способ сделать это -- объявить класс как final. Более сложный подход -- это сделать private-конструктор частные и создавать экземпляры из factory methods..
4)-Если поля экземпляра класса включают ссылки на изменяемые объекты, то не допукайте, чтобы эти объекты изменялись:
4а) Не предоставляйте методы, которые изменяют изменяемые объекты.
4б) Не сообщайте/не раскрывайте/не расшаревайте ссылки на изменяемые объекты.
 - Никогда не храните ссылки на  внешние, изменяемые объекты, переданные в конструктор;
 - в случае необходимости, создавайте копии, и сохраните ссылки в эти копии.
 - Аналогичным образом, создайте копии ваших внутренних изменяемых объектов, чтобы избежать возвращения их оригиналов в своих методах (avoid returning the originals in your methods).

Применим эту стратегию к  SynchronizedRGB:

1) Есть два setter метода в этом классе. 
Первый из них, set, произвольно преобразовывает объект, и не имеет места в неизменяемой версии класса. 
Второй, invert, может быть адаптирован, чтобы создавать новый объект вместо модификации существующего.
2) Все поля уже являются  private; но дополнительно сделаем их final.
3) Сам класс объявим final.
4) Только одно поле ссылается на объект, и этот объект сам является неизменный. Поэтому здесь никакие изменения не нужны.

final public class ImmutableRGB {

    // Values must be between 0 and 255.
    final private int red;
    final private int green;
    final private int blue;
    final private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red < 0 || red > 255
            || green < 0 || green > 255
            || blue < 0 || blue > 255) {
            throw new IllegalArgumentException();
        }
    }

    public ImmutableRGB(int red,
                        int green,
                        int blue,
                        String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }


    public int getRGB() {
        return ((red << 16) | (green << 8) | blue);
    }

    public String getName() {
        return name;
    }

    public ImmutableRGB invert() {
        return new ImmutableRGB(255 - red,
                       255 - green,
                       255 - blue,
                       "Inverse of " + name);
    }
}
***************************
High Level Concurrency Objects
-----------
Lock Objects
Synchronized код опирается на простой вид reentrant lock. Этот вид блокировки прост в использовании, но имеет много ограничений. Более сложные  идиомы блокировки поддерживаются пакетом java.util.concurrent.locks.

Объекты Блокировки работают очень схоже с неявными блокировками, используемыми в синхронизированном коде. Как и в случае неявных блокировок, только один поток может владеть объектом блокировки (Lock object ) одновременно. Lock objects  также поддерживают механизм wait/notify, через связанные с ними объекты Condition.

Самым большим преимуществом объектов блокировки (Lock objects) над неявной блокировкой является их способность отступать от попытки получить блокировку (т.е. прекращать пробовать захватить замок/блокировку.). Метод tryLock отступает, если блокировка не доступна немедленно или в течение какого-то промежутка времени (если он указан). Метод lockInterruptibly отступает, если другой (2й) поток посылает прерывание до получения блокировки 1м потоком.

Давайте использоем объекты блокировки, чтобы решить deadlock проблемы. Альфонс и Гастон тренировали себя замечать, чтобы заметить когда друг собирается поклониться. Мы смоделируем это с помощью другого объекта Friend.
Он должен получить блокировку для обоих участников, прежде чем приступать кланяться. 
Вот исходный код для усовершенствованной модели, SafeLock. Чтобы продемонстрировать универсальность этой идиомы, мы предполагаем, что Альфонс и Гастон настолько увлечены своей новообретенной способностью безопасно кланяться, что они не могут остановиться, кланяясь друг к другу
package concur;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

public class Safelock {
    static class Friend {
        private final String name;
        private final Lock lock = new ReentrantLock();

        public Friend(String name) {
            this.name = name;
        }

        public String getName() {
            return this.name;
        }

        public boolean impendingBow(Friend bower) {
            Boolean myLock = false;
            Boolean yourLock = false;
            try {
                myLock = lock.tryLock();
                yourLock = bower.lock.tryLock();
            } finally {
                if (!(myLock && yourLock)) {
                    if (myLock) {
                        lock.unlock();
                    }
                    if (yourLock) {
                        bower.lock.unlock();
                    }
                }
            }
            return myLock && yourLock;
        }

        public void bow(Friend bower) {
            if (impendingBow(bower)) {
                try {
                    System.out.format("%s: %s has"
                                    + " bowed to me!%n",
                            this.name, bower.getName());
                    bower.bowBack(this);
                } finally {
                    lock.unlock();
                    bower.lock.unlock();
                }
            } else {
                System.out.format("%s: %s started"
                                + " to bow to me, but saw that"
                                + " I was already bowing to"
                                + " him.%n",
                        this.name, bower.getName());
            }
        }

        public void bowBack(Friend bower) {
            System.out.format("%s: %s has" +
                            " bowed back to me!%n",
                    this.name, bower.getName());
        }
    }

    static class BowLoop implements Runnable {
        private Friend bower;
        private Friend bowee;

        public BowLoop(Friend bower, Friend bowee) {
            this.bower = bower;
            this.bowee = bowee;
        }

        public void run() {
            Random random = new Random();
            for (; ; ) {
                try {
                    Thread.sleep(random.nextInt(10));
                } catch (InterruptedException e) {
                }
                bowee.bow(bower);
            }
        }
    }

    public static void main(String[] args) {
        final Friend alphonse = new Friend("Alphonse");
        final Friend gaston = new Friend("Gaston");
        new Thread(new BowLoop(alphonse, gaston)).start();
        new Thread(new BowLoop(gaston, alphonse)).start();
    }
}
*********************
Executors
Во всех предыдущих примерах, есть тесная связь между задачей выполняется с помощью нового потока, как это определено его Runnable объектом, а самим потоком, как определено объектом Thread. Это хорошо работает для небольших приложений, но в крупномасштабных приложениях имеет смысл отделить управление потоками и их создание от остальной части приложения. Объекты, которые инкапсулируют/выполняют и скрывают/- эти функции известны как исполнители (executors).
---------
Executor Interfaces
Пакет java.util.concurrent определяет три интерфейса исполнителей:
1) Executor, простой интерфейс, который поддерживает запуск новых задач.
2) ExecutorService, подинтерфейс Executor, который добавляет функции, которые помогают управлять жизненным циклом, как индивидуальных задач, так и самого исполнителя.
3) ScheduledExecutorService, подинтерфейс ExecutorService, поддерживает будущее и / или периодическое выполнение задач.

Как правило, переменные, которые ссылаются на объект-исполнителя,  объявлены с типом одного из этих трех этих интерфейсов.
Т.е. тип!=классу исполнителя, а тип=интерфейсу исполнителя.

The Executor Interface
Интерфейс Исполнитель предоставляет единственный метод выполнения, execute, чтобы быть подходящей заменой для общей идиомы создания новых потоков. Если r is a Runnable object, and e is an Executor object, то вы можете заменить:
(new Thread(r)).start();
with
e.execute(r);
Определение execute менее специфично. Идиома низкого уровня создает новый поток и запускает его немедленно.

 В зависимости от реализации Executor, execute может сделать то же самое, но более вероятно, что execute надо использовать чтобы  запустить r в существующем рабочем потоке,
 или чтобы поместить r в очередь, и ждать когда рабочий поток станет доступным.

Реализации executor  в java.util.concurrent спроектированы так, чтобы в полной мере использовать более продвинутые ExecutorService и ScheduledExecutorService интерфейсы, хотя они также работают с базовым интерфейсом Executor.
-------------------------
The ExecutorService Interface
Он дополняет метод execute  подобным, но более универсальным submit методом. Как и execute, submit принимает Runnable объекты, но также принимает и  Callable объекты, которые позволяют задаче возвращать значение. Метод submit возвращает объект будущего ( Future object), который используется для получения возвращаемого значения из Callable, и он (Future object) также управляет состоянием обоих Callable and Runnable tasks.

ExecutorService также предоставляет методы для  запуска (submitting) больших коллекций of Callable objects.
Наконец, ExecutorService предоставляет ряд методов для управления отключением исполнителя (shutdown of the executor). Чтобы поддержать немедленное отключение, задачи (tasks) должны правильно обрабатывать прерывания (interrupts).
--------------------
The ScheduledExecutorService Interface

Интерфейс ScheduledExecutorService добавляет к методам родительского ExecutorService ещё один - schedule , который выполняет Runnable или Callable  задачи с заданной задержкой. Кроме того, интерфейс определяет scheduleAtFixedRate и scheduleWithFixedDelay, который повторяет выполнение задачи указанные через определенные промежутки времени.
****************************
Thread Pools
Пулы потоков

Большинство реализаций исполнителя в java.util.concurrent используют пулы потоков, которые состоят из рабочих потоков (worker threads). Такого рода потоки существует отдельно от Runnable и Callable задач, которые он выполняет, и часто используется для выполнения нескольких задач.

Использование рабочих потоков сводит к минимуму затраты на создание потока. Объекты потоков используют значительный объём памяти.
А в крупномасштабном приложении  выделения и освобождения многих объектов потоков создает значительные затраты при управлении памятью.

Один общий тип пула потоков  - это фиксированной пул потоков (fixed thread pool). Этот тип бассейна всегда имеет определенное/заданное количество выполняющихся потоков;
 если поток каким-то образом прекращается, пока он все еще в работе, то он автоматически заменяется новым потоком. 
Задачи добавляются в пул через внутреннюю очередь, которая хранит дополнительные задачи, когда задач больше, чем потоков.

Важным преимуществом фиксированного пула потоков (fixed thread pool) является то, что приложения, использующие его, деградирует изящно (degrade gracefully). Чтобы понять это, рассмотрим веб-сервер, на котором каждый запрос HTTP обрабатывается отдельным потоком.
1) Если приложение просто создает новый поток для каждого нового запроса HTTP
---- и в какой-то моетн система получает больше запросов, чем она может тут же сразу же  работать, то....
 когда затраты на работу всех этих потоков превышает пропускную способность системы -->> приложение внезапно перестанет отвечать на ВСЕ запросы.
ПОЭТОМУ С ограничением по числу потоков, которые могут быть созданы, приложение не будет обслуживать HTTP-запросы так быстро, как они приходят, НО оно будет обслуживать их так быстро, как сможет выдержать система.

Простой способ создать исполнитель, который использует  фиксированный пул потоков --- это вызвать фабричный метод newFixedThreadPool в java.util.concurrent.Executors Этот класс также предоставляет следующие фабричные методы:

1)Метод newCachedThreadPool создает исполнителя с возможностью расширения пула потоков (with an expandable thread pool). Этот исполнитель подходит для приложений, которые запускают множество короткоживущих задач.
2) Метод newSingleThreadExecutor создает исполнитель, который выполняет только одну задачу за один раз (в единицу времени).
3) Существует несколько методов завода из ScheduledExecutorService версии вышеперечисленных исполнителей.

Если ни один из исполнителей предоставленных выше не отвечает вашим требованиям, конструируя экземпляры -- то можете попробовать создвать сущности из
java.util.concurrent.ThreadPoolExecutor или java.util.concurrent.ScheduledThreadPoolExecutor.
****************************
Fork/Join
The fork/join framework является реализация интерфейса ExecutorService, который поможет вам использовать преимущество нескольких процессоров. 
Он (fork/join framework) предназначен для работ, которые могут быть рекурсивно разбиты на более мелкие куски . 
Цель состоит в том, чтобы использовать всю доступную вычислительную мощность для повышения производительности вашего приложения.

Как и при любой реализации ExecutorService, fork/join framework распределяет задачи для рабочих потоков в пуле потоков. 
fork/join структура при этом отличается тем, что использует алгоритм кражи-работы  (work-stealing algorithm). Рабочие потоки, которые закончили все свои вычисления и болтаются без работы, могут украсть задачи от других потоков, которые все еще заняты.

Центр fork/join framework - 
это класс ForkJoinPool - это расширение класса AbstractExecutorService. ForkJoinPool реализует основной алгоритм кражи-работы и может выполнять ForkJoinTask задачи.

Основные функции в fork/join framework

Первым шагом для использования fork/join framework - это надо  написать код, который выполняет сегмент работы. Ваш код должен выглядеть примерно следующий образом:

если (моя часть работы достаточно мала)
  сделать работу напрямую
или
  разделить свою работу на две части
  вызвать/запустит эти две части и ждать результатов
-------
if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results

Заверните этот код в подкласс ForkJoinTask, как правило,используя однин его (ForkJoinTask) более специализированных подтипов:
1) либо RecursiveTask (который может возвращать результат)
2) или RecursiveAction.

После того, как ваш подкласс ForkJoinTask готов, создайте объект, который представляет всю работу, которую предстоит сделать, и передайте его в метод invoke() экземпляра ForkJoinPool.
------------------------
Blurring for Clarity - Размытие для ясности

Чтобы помочь вам понять, как fork/join framework работает, рассмотрим следующий пример. Предположим, что вы хотите, чтобы размылить (blur) изображение. Оригинальный источник изображения (source image) представлен в виде массива целых чисел, где каждое целое число содержит цветовые значения для одного пикселя. Размытое результирующее изображение (blurred destination image) также представлен массивои целых числом  с тем же размером, что и источник.

Выполнение размытия осуществляется работой по одному/каждому пикселю, проходя  через весь исходный массив. Каждый пиксель усредняется по значению окружающих его пикселей (красный, зеленый и синий компоненты усредняются), и результат помещается в результирующий массив. Так как изображение -- это большой массив, этот процесс может занять много времени. Вы можете воспользоваться преимуществом параллельной обработки данных на многопроцессорных системах реализовав этот алгоритм с помощью fork/join framework. Вот одна из возможных реализаций:
public class ForkBlur extends RecursiveAction {
    private int[] mSource;
    private int mStart;
    private int mLength;
    private int[] mDestination;
  
    // Processing window size; should be odd.
    private int mBlurWidth = 15;
  
    public ForkBlur(int[] src, int start, int length, int[] dst) {
        mSource = src;
        mStart = start;
        mLength = length;
        mDestination = dst;
    }

    protected void computeDirectly() {
        int sidePixels = (mBlurWidth - 1) / 2;
        for (int index = mStart; index < mStart + mLength; index++) {
            // Calculate average.
            float rt = 0, gt = 0, bt = 0;
            for (int mi = -sidePixels; mi <= sidePixels; mi++) {
                int mindex = Math.min(Math.max(mi + index, 0),
                                    mSource.length - 1);
                int pixel = mSource[mindex];
                rt += (float)((pixel & 0x00ff0000) >> 16)
                      / mBlurWidth;
                gt += (float)((pixel & 0x0000ff00) >>  8)
                      / mBlurWidth;
                bt += (float)((pixel & 0x000000ff) >>  0)
                      / mBlurWidth;
            }
          
            // Reassemble destination pixel.
            int dpixel = (0xff000000     ) |
                   (((int)rt) << 16) |
                   (((int)gt) <<  8) |
                   (((int)bt) <<  0);
            mDestination[index] = dpixel;
        }
    }
}
Теперь вы реализовываете abstract compute() метод, который либо выполняет размытие сам или разбивает его на две более мелкие задачи. Простой порог длина массива помогает определить, выполняется работа или разбиение. (A simple array length threshold helps determine whether the work is performed or split)
Т.О. мы описали предыдущие методы в подклассе класса RecursiveAction.
А настройки запуска задачи в ForkJoinPool довольно просты, и включает в себя следующие шаги

1) Создать задачу, которая представляет всю работу, которую предстоит сделать.

     // source image pixels are in src
// destination image pixels are in dst
ForkBlur fb = new ForkBlur(src, 0, src.length, dst);

2) Создание ForkJoinPool, который будет запускать задачу.

     ForkJoinPool pool = new ForkJoinPool();
3) Выполнить задачу.
pool.invoke(fb);

Для получения полного исходного кода, в том числе дополнительным кодом, который создает файл назначения изображения, смотрите пример ForkBlur.
--------------
Standard Implementations

В Java уже есть некоторые полезные функции,которые уже реализованы с использованием fork/join framework. Одна такая штука используется классом java.util.Arrays для своих parallelSort() методов. Эти методы аналогичны обычной сортировке,но Параллельность выполнения делает их быстрее на  больших массивах при запуске на многопроцессорных системах.

Другая реализация  fork/join framework используется методами в пакете java.util.streams, который является частью проекта Lambda.
*****************
Concurrent Collections

Пакет java.util.concurrent предоставляет ряд новых интерфейсов коллекций:

1) BlockingQueue определяет "первый вошёл - первый вышел" структуру данных, которая блокируется или ждёт истечения времени ожидания при попытке добавить в полную очередь, или извлечь из пустой очереди.
2) ConcurrentMap является подинтерфейсом java.util.Map, который определяет полезные атомарные операции. Эти операции удаляють или заменяють пару ключ-значение, только если ключ существует, или добавляет пару ключ-значение, только если ключ отсутствует. Выполнение этих операций атомарными помогает избежать синхронизации. ConcurrentHashMap является Стандартной реализацией общего назначения от ConcurrentMap, ConcurrentHashMap является одновременно аналогом HashMap.
3) ConcurrentNavigableMap является подинтерфейсом ConcurrentMap, который поддерживает приблизительные совпадения. Стандартной реализацией общего назначения ConcurrentNavigableMap является ConcurrentSkipListMap, она одновременно является  аналогом TreeMap.

Все эти коллекции помогают избежать ошибок согласованности памяти, определяя happens-before связь между операцией, которая добавляет объект в коллекцию с последующими операциями, которые получают доступ или удаляют этот объект.
***************************
Atomic Variables
 Java.util.concurrent.atomic пакет определяет классы, которые поддерживают атомарные операции на отдельных переменных. Все классы имеют get and set методы, которые работают, как чтение и запись на volatile переменных.
То есть, set имеет happens-before связь с любым последующим get на этой же переменной. Атомарный Метод compareAndSet обеспечивает согласованность памяти, как это делают простые атомарные арифметические методы, которые применяются к целому атомарному числу.

Чтобы увидеть, как можно использовать этот пакет, давайте вернемся к классу счетчика ( Counter), который мы первоначально использовали для демонстрации интерференции/столкновения потоков:
Для этого простого класса, синхронизация является приемлемым решением. Но для более сложного класса, мы могли бы избежать влияния ненужной синхронизации на живучесть (liveness) . Замена поля INT на AtomicInteger позволяет предотвратить интерференцию потоков, не прибегая к синхронизации, как в атомной счетчик:
class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);
    public void increment() {
        c.incrementAndGet();
    }
    public void decrement() {
        c.decrementAndGet();
    }
    public int value() {
        return c.get();
    }
}
*************
Concurrent Random Numbers
В JDK 7, java.util.concurrent включает в себя удобный класс, ThreadLocalRandom, который нужен для получения случайные чисел из нескольких потоков или ForkJoinTasks.
Для одновременного/параллельного доступа, используя ThreadLocalRandom вместо Math.random (), можно добиться  снижения конкуренции и, в конечном счете, более высокой производительности.
Для этого надо вызвать ThreadLocalRandom.current(), а затем вызвать один из его методов, чтобы получить случайное число. Вот один из примеров:
int r = ThreadLocalRandom.current() .nextInt(4, 77);
******************
For Further Reading

    Concurrent Programming in Java: Design Principles and Pattern (2nd Edition) by Doug Lea. A comprehensive work by a leading expert, who's also the architect of the Java platform's concurrency framework.
    Java Concurrency in Practice by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. A practical guide designed to be accessible to the novice.
    Effective Java Programming Language Guide (2nd Edition) by Joshua Bloch. Though this is a general programming guide, its chapter on threads contains essential "best practices" for concurrent programming.
    Concurrency: State Models & Java Programs (2nd Edition), by Jeff Magee and Jeff Kramer. An introduction to concurrent programming through a combination of modeling and practical examples.
    Java Concurrent Animated: Animations that show usage of concurrency features.

