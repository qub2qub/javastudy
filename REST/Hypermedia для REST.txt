https://habrahabr.ru/company/aligntechnology/blog/281206/
Hypermedia — то без чего ваше API не совсем REST

Всем привет! Меня зовут Дмитрий Павлов, в компании Align Technology мы с коллегами занимаемся разработкой Web API для взаимодействия внутренних систем и интеграции нашей компании со сторонними вендорами. Об идеях создания API для веба, а точнее RESTful API я хотел бы рассказать в этой статье.

В последние годы тема Web API стала очень популярна, многие компании занимаются созданием подобных интерфейсов, как открытых, так и для внутреннего пользования. В описании Web API практически всегда можно встретить акроним REST, но что же это обозначает этот термин и правильно ли его используют?

REST или не REST?

Большинство разработчиков, особенно в России, понимает под REST программный интерфейс, работающий с использованием протокола HTTP[S] при условии соблюдения следующих свойств:

    Сервер не хранит состояние клиента: никаких сессий, все что требуется для выполнения запроса клиент передаёт с самим запросом.

    Человекочитаемые URL, в которых ресурсы идентифицируются отдельно. Никаких больше /index.php?productId=1, вместо этого используем /products/1

    Более широкое использование HTTP методов: не ограничиваемся GET и POST, добавляем PUT и DELETE. В некоторых API можно встретить еще и PATCH.

    В качестве формата передачи данных используется JSON.


Алгоритм по которому такой API используется обычно стандартен. Для начала нужно пойти на сайт с документацией, найти страничку со списком URL-шаблонов для доступа к ресурсам. Обычно она выглядит так:

Список ресурсов для API "Рецепты печенек"

--- /recipes/cookies - список рецептов печенек, 
GET на данный URL возвращает список доступных рецептов
  [
      {
         "name" : "Овсяное печенье с шоколадом",
         "rating" : 5,
         "shortDescription" : "...."
      }
  ]

POST на данный URL возволит вам создать новый рецепт. В качестве тела запроса ожидается json вида как
  {
     "name" : "Малиновое печенье",
     "shortDescription" : "...."
     ......
  }

--- /recipes/cookies/:name - рецепт печеньки с именем ${name}
{
  "name" : "Овсяное печенье с шоколадом",
  "rating" : 5,
  "shortDescription" : "....",
  "description" : "...."
  "ingredients" : [
      {
        "name" : "Овсянка",
        .....
      },
      {
        "name" : "Масло",
        .....
      },
      {
        "name" : "Шоколад",
        .....
      }
  ],
  "cookingSteps" : [
   ....
  ]
}
// остальные ресурсы гипотетического API с перечсилением HTTP методов и URL шаблонов


и изучив её выполнять запросы к ресурсам (что обычно выражается в написании клиента, который по заданным форматам URL'ов подставляет параметры и обрабатывает ответы).

Примеров таких API на просторах сети предостаточно, до недавнего времени у Яндекса многие API (раз, два) заявленные как REST работали по этой схеме.

Если мы обратимся к первоисточникам, т.е. к диссертации Роя Филдинга (на которую очень часто ссылаются, но гораздо реже читают), мы увидим, что API, созданные таким способом, не могут называться REST, поскольку они нарушают некоторые из принципов, описанных в диссертации, самый главный из которых — использование hypermedia как средства управления состоянием (Hypermedia As The Engine Of Application State ,HATEOAS), косвенно затрагивая вопросы само описываемых сообщений (self-descriptive messages).

Hypermedia в сообщениях

Суть HATEOAS состоит в подходе к описанию ресурсов нашего API. Вместо простого перечисления набора ресурсов, со списком всех возможных операций, которые клиент может вызвать, руководствуясь некоторой внутренней логикой, мы проводим инверсию контроля — теперь за состояние ресурса отвечает сервер и он диктует клиенту, какие операции над ресурсом можно совершить в текущий момент. Эта информация должна присутствовать в самом представлении ресурса, который получает клиент. Таким образом, представление ресурса само себя описывает в достаточной степени, чтобы клиент понял, что с ним можно делать.

Применение такого подхода обычно означает, что клиент знает некоторый конечный набор "точек входа" (можете считать их аналогами стартовых страниц на сайтах), с которых он начинает свое взаимодействие с API, используя предоставленную в представлении ресурса информацию для навигации к другим ресурсам и совершения действий.

Для достижения этой задачи как раз и используются гиперссылки (hypermedia):
1) Все ресурсы адресуемы при помощи ссылок, причем ссылки на другие ресурсы присутствуют внутри самих сообщений для их связи между собой. 
--Клиент вместо ориентации на формат URI руководствуется идентификаторами, по которым он выбирает ссылки, располагающиеся прямо в ПРЕДСТАВЛЕНИИ РЕСУРСА. Если ранее мы указывали в документации что нужно взять некоторый ID и на его основе построить специальный URL, тем самым делая наборы URL частью нашего API, то теперь детали формирования URL являются просто особенностями реализации сервера и клиента не волнуют. В конце концов, клиенту важно получить доступ к ресурсу, а не генерировать URL по шаблонам из документации.

2) Доступные операции над ресурсом тоже представимы в виде ссылок.

3*)Отсутствие ссылки как на связанные ресурсы, так и на доступные действия означает, что данная операция недоступна в текущем состоянии ресурса.

Пример переработки API "Рецепты печенек" в Hypermedia представление

Возвращаясь к примеру с нашим API о каталоге рецептов печенек, преобразуем его в Hypermedia-вид.

Как вы помните, у нас был список рецептов и ресурс, подробно описывающий конкретный рецепт с перечислением ингредиентов и шагов по приготовлению. Вот как они будут выглядеть с использованием hypermedia подхода:

//список рецептов
{
 "links": {
  "self" : "/recipes/cookies"
 }
 "items": [
      {
         "name": "Овсяное печенье с шоколадом",
         "rating": 5,
         "shortDescription": "...."
         "links": {
           "self": "/recipes/cookies/Овсяное печенье с шоколадом"
         }
      }
 ]
}

//конкретный рецепт
{
  "links": {
    "self": "/recipes/cookies/Овсяное печенье с шоколадом"
  }
  "name": "Овсяное печенье с шоколадом",
  "rating": 5,
  "shortDescription": "....",
  "description": "...."
  "ingredients": [
      {        
        "name": "Овсянка",
        .....
      },
      {
        "name": "Масло",
        .....
      },
      {
        "name": "Шоколад",
        .....
      }
  ],
  "cookingSteps": [
   ....
  ]
}


Значительное отличие от оригинальной версии заключается в появлении объекта links внутри каждого ресурса. Ключи этого объекта представляют собой relation'ы (те самые идентификаторы), а значения — ссылки. В результате наши ресурсы не требуют дополнительной информации (вне самого ресурса) о том как же перейти из каталога рецептов к детальному описанию, ссылка встроена в представление ресурса.

Данные подход позволяет легко расширять функциональность нашего API. Предположим, что мы для каждого рецепта хотим предоставить клиенту набор рекомендаций, представимый в виде списка рецептов. Сделать это очень легко, достаточно добавить в наш объект links новый ключ:

"links" : {
  "self" : "/recipes/cookies/Овсяное печенье с шоколадом",
  "http://acme.com/recipes/rels/you-can-also-like" : "/recipes/cookies?related_to=Овсяное+печенье+с+шоколадом"
}


Аналогично, совершенно не составит труда добавить идентификацию ингредиентов как отдельных ресурсов, если в этом возникнет необходимость.

Содержание URI не играет никакой роли, ведь теперь элементом API является relation, и мы без каких либо изменений на клиенте можем поменять ссылку на /recipes/related-to/Овсяное печенье с шоколадом или на /recipes/234892skfj45sdlkfjdsa12

Hypermedia на службе перемен

Hypermedia используется не только для навигации, но и для совершения действий, достаточно лишь определить, что некоторые relation отвечают за совершение определенных операций над ресурсами, а также обозначить семантику и детали этих операций.

Для наглядности рассмотрим пример с нашим API, добавив hypermedia-контрол для создания нового рецепта.

//список рецептов
{
 "links" : {
  "self" : "/recipes/cookies",
  "http://acme.com/recipes/rels/add-recipe" : "/recipes/cookies"
 }
 "items" : [
      .....
 ]
}


Мы лишь добавили ссылку со специальным relation'ом. Основное правило заключается в том, что клиент игнорирует неизвестные ему отношения: "старые" клиенты, не знающие как добавлять новый рецепт, будут работать как раньше, а для тех кто поддерживает создание, это будет сигналом, что есть возможность добавления нового рецепта путем отправки запроса на URI, который указан в отношении http://acme.com/recipes/rels/add-recipe.

Данный подход позволяет нам не описывать статический набор операций и условия их выполнения в документации, а непосредственно серверу контролировать какие операции клиент может совершать над ресурсом в данный момент времени, а какие — нет. Добавление новых действий тоже не представляет сложности: мы просто объявляем новый relation, и начинаем включать его в представление ресурса, которое формирует сервер.

Разумеется, предоставление ссылок не снимает с сервера ответсвенности за корректное оперирование HTTP методами и соблюдения их семантики :).

А как же relation?

У вас к данному моменту наверняка возник вопрос: какой смысл затевать все это, если для эффективной работы клиент все равно должен понимать смысл relation'ов? По ним-то документация должна иметься.

В самом деле, для эффективной работы клиент действительно должен понимать, что значит каждое отношение. Основная идея, стоящая за заменой интерпретации URI на работу с relation'ами, состоит в большей долговечности последних. URI является деталью реализации и может меняться со временем или от сервера к серверу. Relation же представляет собой семантическое описание связи и не завязан на детали хранения.

Предположим, я хочу сделать совместимый API для хранения рецептов, но из-за особенностей хранения хочу идентифицировать каждый рецепт по UUID, а не по названию. В случае с оригинальным API сделать это невозможно, а для hypermedia API это совершенно незаметно для клиента.

В результате появляется возможность создания более универсальных клиентов менее подверженных изменениям в случае модификаций на сервере.

Hypermedia types или почему application/json нам не подходит

Решив воспользоваться преимуществами Hypermedia подхода, мы модифицировали наш API указанным выше способом, и теперь у нас ресурсы связаны друг с другом по ссылке. С первого взгляда может показаться, что с нашим API все в порядке, но перед тем как заявить, что у нас Hypermedia API, посмотрим на заголовок Content-Type, возвращаемый нами в ответах. Если там стоит application/json или даже text/plain, то нам еще предстоит потрудиться.

Ресурсы глазами машины

Глядя на получившиеся у нас ресурсы, человек сразу выделяют ссылки, что создает впечатление о корректном формате нашего сообщения. Мы делаем вывод об этом, анализируя содержимое сообщения, тогда так стандарт предписывает смотреть на Content-Type заголовок ответа.

Рассмотрим следующий ответ сервера:

200 OK
Content-Type: text/plain

<?xml version="1.0"?>
<hello>world</hello>


Нам очевидно, что в ответе содержится xml-документ, но Content-Type предписывает воспринимать содержимое как простой текст, поэтому то, что он похож на xml-документ может быть просто совпадением или частным случаем. Именно поэтому верный Content-Type так важен.

Давайте разбираться, чем же для нашей задачи не подойдет application/json? Дело в том, что стандарт, описывающий этот тип, не предусматривает никакого места или механизма для определения ссылок в нем. И даже если сформированное нами сообщения содержит ссылки, то машина не может отличить их от строки, в которой содержится текст по формату напоминающий ссылку. Нам же нужно однозначно определить, где в сообщении ссылка, а где нет, поэтому нам нужен другой тип.

Vendor specific типы

Одним из способов решить проблему корректности Content-Type'а — использовать свой собственный. В документации мы явно укажем, где у нас в сообщении расположены ссылки. Если клиент получил от сервера ответ с нашем личным Content-Type'ом, ему не нужно будет динамически угадывать, что ссылка а что нет, если конечно он понимает наш Content-Type. 

Стоит отметить, что зачастую документация с описанием типа содержит не только подробности самого формата (т.е. где расположены ссылки, а где свойства), но и другую информацию:
1) семантическое описание свойств, т.е. что они обозначают с точки зрения бизнес логики;
2) детали взаимодействия клиента с сервером, такие как HTTP методы необходимые для отправки запроса.

Такие типы называются vendor specific, поскольку часто создаются под конкретную задачу и конкретной организацией. Их нет необходимости регистрировать в IANA. Рекомендуется давать им название вида application/vnd.${vendor}+${base_format}, где ${vendor} — это перевернутый домен компании, ${base_format} — тип который мы взяли за основу. Если компания имеет домен acme.com и для представления наших ресурсов мы используем json, то для нашего API рецептов название типа будет выглядеть как application/vnd.com.acme.recipes+json.

Hypermedia типы общего назначения

На первый взгляд, vendor specific типы решают возникшую проблему со ссылками, но у них есть и свои проблемы:
1) типы не совместимы между собой, поэтому клиентам приходится поддерживать много разных реализаций, в случае если они взаимодействуют не с одним API, т.е. требуется поддержка отдельной библиотеки для разбора формата каждого типа, выделения в нем свойств, ссылок и прочего;
2) создание vendor specific типа под каждую задачу ведет к очень заметному росту их общего числа.

В качестве альтернативы не заставил себя ждать новый подход, который принесли типы общего назначения. Если подумать, то все что нам нужно от формата сообщений — это спецификация, отвечающая на вопросы:
1) как найти свойства наших ресурсов,
2) как найти hypermedia контролы внутри ресурса.

Именно эта задача и решается: тип общего назначения не пытается подстроиться под конкретную доменную область, ими можно описать большинство ресурсов, с которыми мы имеем дело.

Важной особенностью всех типов общего назначения является то, что они не ставят задачу семантического описания документа, т.е. они не говорят, что же это за ресурс — описание рецепта или комментарий в блоге, это не их задача. Они отвечают больше за детали формата, оставляя семантическую спецификацию за рамками. Предполагается, что семантика будет заключена в так называемом профиле — отдельном документе, описывающим семантику свойств и отношений (relations).

На данный момент существует уже достаточно большое количество подобных форматов, поэтому перечислим лишь некоторые из них:
1) application/hal+json — один из первых появившихся и наиболее популярный формат в наши дни;
2) application/vnd.siren+json;
3) application/mason+json.

В описании всех таких форматов вы найдете, как и куда помещать свойства ресурса, в каком виде оформлять ссылки на другие ресурсы.
Различаются они форматом и возможностями, которые содержатся в самом типе.

*** Разница в форматах или принципиальность создателей ***

Большинство типов общего назначения отличается незначительными деталями, например, как форматировать ссылки. Так, в HAL ссылки выглядят следующим образом:

"_links" : {
  "self" : ....
  "relToResource": .....
}


Тогда как Siren представляет их так:

"links" : [
  {"rel" : ["self"], "href" : "...."},
  {"rel" : ["relToResource"], "href" : "...."}
]


Основное отличие здесь в представлении relation значений. Создатель HAL стремился сделать формат более лаконичным, в то время как создатель Siren — более полным: relation у ссылки действительно может быть сложным (поэтому в Siren это массив значений), но это не всегда используется (поэтому в HAL это скаляр, да еще и ключ в объекте).

Такие вот разные взгляды и привели к созданию разных форматов, об одном формате договориться не смогли.

*** Различие в возможностях ***

Не будем здесь перечислять все различия в форматах, обозначим только основные, на примере уже упомянутых типов:

1) В HAL не существует понятия действий как отдельной сущности, только ссылки и метод, который нужно использовать для отправки запроса тоже не включен в сообщение. В Siren и Mason в наличии инструменты по описанию форм: сообщение содержит параметры, которые требуется для ввода клиентом, метод, которым нужно все это отправить и Content-Type.
2) HAL имеет отдельное понятие формы поиска — безопасного, идемпотентного действия для получения информации с сервера. Siren и Mason, как уже говорилось выше, обладает возможностью описать любое действие.
3) HAL и Siren не содержат в спецификации деталей по описанию ошибок, это остаётся на усмотрение пользователя формата (можно использовать application/vnd.error+json), тогда как в Mason этот аспект включен в формат.


Generic vs vendor specific

Какой же вариант предпочтительнее: специально созданный тип или один из существующих вариантов? Как обычно бывает с подобными вопросами, однозначного ответа на него нет, все зависит от обстоятельств использования, поэтому попробуем выделить преимущества и недостатки каждого из них.

Одно из главных преимуществ hypermedia-типа общего назначения — экономия времени вам и клиентам вашего API. 
Вот за счет чего она достигается:
1) Формат сообщений уже придуман за вас. Вы можете сосредоточиться на решении вашей проблемы создавая API в уже установленных ограничениях выбранного формата.
2) Для создания и разбора сообщений уже написаны библиотеки под разные языки программирования. Согласитесь, удобно подключить готовую библиотеку и работать с высокоуровневыми понятиями вида ссылка, действие, свойства объекта, а не с деталями путей в JSON.
3) Для многих generic-типов существуют так называемые браузеры. Это простые клиенты, которые понимают элементы определенного типа, и динамически формируют веб интерфейс, позволяя вам сразу демонстрировать созданный API, не потратив и минуты на создание клиента.
4) Вашим клиентам потребуется только изучать документацию по вашему API, т.е. они смогут сосредоточиться только на бизнес-смысле, не тратя время на чтение деталей формата.


В то же время часть преимуществ такого подхода могут для кого-то выглядеть недостатками. В силу того, что тип не завязан под какую-либо доменную область и задачу, представление ресурсов получается более "раздутым", по сравнению со специальным типом, который мы могли бы создать.

В итоге для большинства задач можно рекомендовать использовать один из имеющихся Hypermedia-форматов общего назначения по умолчанию и делать выбор в пользу vendor-форматов в сложных или специфических случаях (если вы, конечно, не ставите целью vendor lock-in).

Насколько мне нужно все это?

Описанный подход не является очередной серебряной пулей, призванной решить все проблемы при разработке API.

Можно отметить, что концепция точек входа способна привести к росту числа запросов, чтобы "добраться" до нужного ресурса и что включая ссылки мы делаем сообщение более объемным по сравнению с голыми данными.

На эти недостатки можно возразить, что эти проблемы решаются продуманной структурой ресурсов (кто мешает сделать операции поиска ресурса в точке входа для быстрой навигации?), кэшированием, которое тоже отмечено Филдингом как важная компонента этого архитектурного подхода, и банальным включением компрессии на веб серверах.

Основной плюс REST-подхода (здесь я имею ввиду полноценный REST) в гибкости и расширяемости, который он предоставляет, позволяя нам добавлять новые возможности или просто менять организацию ресурсов у себя на сервере без нарушения работы существующих клиентов.

Даже если вы решите не использовать hypermedia в вашем API, теперь вы знаете, что без нее REST — это не REST, а просто Web API. Это не делает API плохим или хорошим, я просто констатирую факт. Главное не забывать, что API мы делаем не ради самого API, а для решения задач, стоящих перед нами :).

Примеры на просторах сети

1) https://tech.yandex.ru/disk/ API Яндекс Диска — пример hypermedia API, использующий HAL.
2) https://developer.github.com/v3/ Github — использует свой формат (на основе JSON), который тем не менее является hypermedia.
3) https://developer.paypal.com/docs/api/ Paypal тоже использует свой формат сообщений.
4) http://api.foxycart.com/docs  Foxycart — пример API имеющего представление в нескольких форматах — HAL и Siren. Также имеет замечательное
    представление документации (к сожалению, технология генерирования таких документов не opensource) https://api.foxycart.com/hal-browser/index.html

************************
https://tech.yandex.ru/oauth/doc/dg/concepts/ya-oauth-intro-docpage/
Реализация OAuth в Яндексе
**********************
Коменты к статье:
>> Три вопроса:

1) Клиенту все еще нужно догадываться, что запрос на add-recipe нужно делать постом а не путом или патчем? Почему бы не указывать метод явно? Например:

    "links": {
    "add-recipe": {
      "href": "http://example.com/recipes",
      "method": "POST"
    },
    "recent-recipe": {
      "href": "http://example.com/recipes/my-recipe",
      "method": "GET"
    }
    }


2) Почему бы значение 'href' не указывать абсолютной ссылкой? Таким образом можно абстрагироваться от синглтон-домена и мы легко можем заменить домен в случае разнесения функциональности по разным доменам-субдоменам.
    А можем и не заменить.

    "add-recipe": {
      "href": "http://example.com/recipes",
      "method": "POST"
    }


    "add-recipe": {
      "href": "http://mycompany.example.com/recipes",
      "method": "POST"
    }


3) Совершенно не понял почему ключом выступает ссылка? (в ваших примерах это "http://acme.com/recipes/rels/you-can-also-like"). Невнимательно прочитал?
Спасибо.

<< 
1) Тут вопрос дизайна и предпочтений. Этот пример показывал как можно было бы сделать свой, ни на что не похожий hypermedia тип (application/vnd.com.acme.recipes+json). У авторов такого типа, в его документации было бы описано как создавать рецепты, какой метод нужен. Дизайн странный, но используя свой Content-Type они вполне это могут сделать, хотя ваш вариант мне нравится больше :).
Даже у авторов generic-типов нет консенсуса на этот счет. В HAL методов нет, в Siren есть. Альтернативой документирования методов, или указания их в ресурсе может являться ссылка на профиль, такой ресурс с мета-информацией.

2) Вполне допустимы оба варианта, дело вкуса. У нас в проектах для "локальных" ресурсов мы опускаем домен, а для связи нескольких микросервисов уже указываем полный линк. Клиенты поддерживают оба формата, так что для них все прозрачно. Все как со ссылками на веб страницах.

3) Скорее я не раскрыл этот момент. Если надеть шляпу формалиста и бюрократа, то все "простые" link relation'ы нужно регистрировать в IANA. Эта организация ведет список общеупотребимых идентификаторов, таких как self, prev, next. Поэтому используя url, мы вводим namespace чтобы точно не пересечься семантически с другими доменами на просторах сети. 
Следовать этому подходу или нет — зависит от обстоятельств. 
Есть варианты когда создатели забивают на это, и используют короткие имена, еще один подход использование префиксов, например acme:add-recipe. Тот же HAL подерживает curies раздел, где задается описания этих сокращений, и ресолв до полного url'a. 
Вот например прим с сайта HAL:

"_links": {
"curies": [
{
  "name": "doc",
  "href": "http://haltalk.herokuapp.com/docs/{rel}",
  "templated": true
}
],

"doc:latest-posts": {
"href": "/posts/latest"
}
}

-----------------------
спорно
>> REST — это ресурсы и отношения вместо объектов и методов на RPC. 
Мы получим стандартизованный протокол, поддерживающий стаднартизованную архитектуру (т.е., нужно будет просто понять REST, и принимать решений и делиться ими в команде при проектировании/реализации придётся гораздо меньше). Выбор между XML и JSON в REST вообще никак не принципиален. 
-----------------
>> Как уже отметили, для всяких сложностей, например последовательных запросов по доморощенному протоколу, дуплекс, дозвон — callback и т.п. — есть SOAP. 
<< 

Я не думаю, что вопрос выбора инструмента SOAP или REST определяется сложностью задачи. Кстати, сравнивать конкретную технологию с архитектурным принципом не вполне корректно.

Кстати в отличной книге Майка Амундсена Restful Web APIs упоминается CoAP — протокол для простых электронных устройств, использующий REST принципы. Я не буду развивать эту тему, так как не специалист в этой области, но стоит отметить. что не все упирается в http.
-----------------
>> HATEOAS — один из принципов REST, предписывающий ресурсу нести в себе информацию об отношениях с другими ресурсами. 
HAL — язык для описания таких отношений. 
Помимо этого принципа REST ограничивает архитектуру в количестве действий, которые в принципе возможны над любым ресурсом — у GET, POST, PUT, PATCH, DELETE строго определена семантика и способ их обработки сервером (и стратегия кеширования результатов).
Именно потому в HAL не указываются методы запроса, этот не перечень RPC-действий, которые можно совершить с ресурсом, а перечень REST-ресурсов, имеющих отношение к данному. А действия над всеми ресурсами всегда одинаковые.

Отличие RPC/SOAP от REST не в сложности/простоте реализации, а в семантике. 
RPC — это когда прикладная задача моделируется объектами и методами, 
а REST — это когда задача моделируется ресурсами и отношениями между ними. 
Эти способы взаимовыразимы друг через друга (REST можно построить на базе RPC и наоборот), но не одно и то же. 

<< Посмотрите RFC 7231, в частности метод POST. Там четко написано, что семантику определяет сам ресурс, который обрабатывает запрос. В связи с чем если у ресурса сложное поведение, через POST можно сделать разные действия. Понимаю что можно разное поведение можно реализовать и через PUT, но у него более четкая семантика с точки зрения HTTP.

Вы еще забыли важный момент в отличии RPC от REST — в RPC все методы определны заранее, это действительно похоже на сигнатуру класса. В REST при помощи гипермедиа контролов (их наличия и отсутсвия) сервер как владелец ресурса определяет что может делать клиент в текущий момент.

>> Семантику определяет сам ресурс, верно. Определяет семантику в рамках ограничений, накладываемых парадигмой REST, в которых POST — это именно конкретный глагол, создающий ресурс.
Не забыл. Этот момент непринципиален в том различии REST и RPC, о котором я говорил. Но можно его считать целью этих различий (некой практической выгодой архитектуры).

<< Почитайте пожалуйста первый параграф по ссылке выше. Там простым английским языком написано, что в общем случае семантика POST'а не определена и ресурс может такой запрос обрабатывать как хочет не нарушая спецификацию.

Вы правы что в большинстве своём он применяется для создания чего-либо, но не нужно воспринимать частый, но все же конкретный пример использования за семантику определенную в стандарте.

<< REST — это архитектурный принцип, 
HTTP — протокол. 
Почитайте внимательно диссертацию Филдинга.

<< Я согласен что REST это про ресурсы, а не про набор заранее определенных вызовов, как в случае с RPC.

Но я не совсем согласен со следующими моментами:
    >>Семантика методов. В первом комментарии вы сказали что "GET, POST, PUT, PATCH, DELETE строго определена семантика".
        <<Это так для всего кроме POST. Как я указывал ранее, в актуальной спецификации HTTP у post'а семантику определяет сам ресурс и REST тут ничего не меняет, потому что REST не меняет ограничений протокола.

    Я не спорю что много задач можно решить чисто CRUD подходом, вводя самоограничение, что POST мы используем только для создания ресурса, но не стоит обобщать это на все API и на протокол HTTP как таковой. REST, как принцип, нас совсем не ограничивает — он предписывает серверу сообщать клиенту состояние ресурса (и что с ним можно делать) и не нарушать семантику протокола который используется между ними используя его возможности по назначению. Указывать явно или не указывать метод для выполнения действия уже вопрос реализации.

    >>"HAL — язык описания отношений".
        << 1 Вообще это формат представления ресурса у которого в спеке четко прописано где находятся ссылки. И форматов подобных ему достаточно много. Отношения описывают линки, семантика которых задаётся relation'ом. Тут эти форматы ничего не изобретают, используя уже известные конструкции из html'я и atom фидов.
        2 То что там нет методов не истина в последней инстанции, а просто виденье его создателя — об этом Майк Келли лично говорил на конфе API Craft в 2014 году.
---
>>1. Нет, REST нас ограничивает, вы просто не поняли этих ограничений, похоже. 
Если мы хотим в духе RPC ввести новую операцию над объектом, мы её реализовываем новым ресурсом со стандартными операциями над ним. Например, мы хотим реализовать у объекта «Ракета» метод «Запустить», тогда в концепции REST мы, например, создадим у ресурса «Ракета» вложенный ресурс «Запуск». Т.е., методом POST создавая экземпляр ресурса «Ракета/:id/Запуск» мы и производим запуск ракеты.
2. Не могу оспорить вашего мнения. Оно отвалится самостоятельно, когда (если) примите то, что я описал в первом пункте. 

>> Да, возможно, слово «например» в моих словах недостаточно чётко указывало, что я привожу лишь один из вариантов реализации. 
Т.е., если пришла мысль добавить новое действие к ресурсу, то это в REST будет ПЕРЕДАЧЕЙ НОВОГО СОСТОЯНИЯ — либо «виртуальный» вложенный ресурс, либо «виртуальное» дополнительное поле в ресурсе, но никак не «виртуальная» семантика глагола. 
Да, ему нужно думать состояниями, а не действиями. Может, такая формулировка кому-то действительно будет удобнее, чтобы испытать просветление. Но, мне казалось, что эту сторону вопроса уже обсудили выше, и затруднения вызывает именно проблема отсутствия глаголов в HAL, отчего и начал развиваться диалог. Безусловно, всегда можно найти, чем мои слова можно дополнить. Не обязательно это делать в форме возражения. 

>> Представьте, что ракета в прикладной задаче многоразовая, запуски логируются, и к этим логам разграничивается доступ по ролям. Теперь мой пример стал красивее вашего? Ваше «заблуждение» я тоже показал, утрировав ваш пример.
Не нужно вообще переносить глаголы куда-то, нужно сразу проектировать в духе REST. Декомпозиция на ресурсы зависит от прикладной области и ограничений реализации (что, как и где будет обрабатываться, как контролироваться).

<< Какое отношение внутренняя реализация (логирование, проверка прав) имеет ко внешнему api? Каким образом ваш клиент должен догадаться, что для изменения состояния ресурса "ракета", необходимо создать ресурс "запустить"? И чем это знание принципиально отличается от знания глагола "запустить"?
<< Не опирайтесь на мой пример — в нём не было никаких исходных данных о прикладной задаче, его можно понимать очень по-разному, он был приведён не для полного объяснения принципа REST, а лишь для пояснения частного, конкретного аспекта, всплывшего в диалоге — почему в HAL указываются связанные ресурсы, а не связанные дейсвтия. Т.е., отсюда у меня и появился связанный ресурс, мне нужно было придумать именно связанный ресурс, а не дополнительный стейт, чтобы показать, что указывается в HAL.

Клиент догадываться ни о чём не должен, он должен знать, как работать с конкретным API. REST не избавляет от необходимости понимать прикладную область и ресурсы, на которые её декомпозировали в API. Он лишь избавляется от головной боли, связанной с распределением, кешированием, разграничением доступов, интерпретацией ошибок и статусов — ограничения REST этому способствуют (как раз потому, что не позволяют как попало обращаться с глаголами, и потому, что заставляют думать ресурсами, а не действиями). 
...
>> Я ещё раз подчеркну, что REST — он о состояниях, а не действиях выраженных в форме существительных. И если у вашей ракеты есть состояние state, то и изменять его надо редактируя ракету. А если по бизнесу у вас есть отдельный процесс "launch", то и состояния state у ракеты быть не должно. Зато у "launch будет состояние "stage", которое опять же можно изменять редактированием "launch".

-------------------------------
>>Есть ли в HATEOAS каноничный способ сообщить о _доступности_ этих стандартных действий, передавая некую авторизационную информацию вместе с отношениями? Конечно, сервер всегда может дать отлуп на неавторизованную операцию, но что если хочется уберечь пользователя и заранее скрыть в UI запрещённые контролы (кнопку «Удалить», например)? 

<< Стандарта нет, все зависит от дизайна API и задач стоящих перед API. С точки зрения стандартных операций, есть OPTIONS метод, ответ на который должен содержать список доступных HTTP методов которые можно выполнить над ресурсом. В некоторых случаях это может помочь, но если у вас логика сложная то это может быть слишком "грубо" — например вы хотите позволить клиенту делать PUT запрос с определенными данными, но запрещать передавать другие данные. Как вы понимаете, через OPTIONS этого будет сложно достичь.

Могу сказать о своем опыте: если речь идет о "единичных" ресурсах, то отсутсвие ресурса выражается в отсутсвии ссылки на него. С коллекциями мы считаем что они всегда есть, но в случае чего пустые.

Action'ы мы выставляем в основном в тех ресурсах, к которым они относятся, но бывают и исключения. Из последних примеров — есть ресурс asset — содержащий мета-информацию и у него есть action для загрузки бинарных данных для него, естественно указывающий на другой URI. Так же и с созданием элементов для коллекций — action всегда присутсвует в самом ресурсе-коллекции, но в некоторых случаях мы выставляем его в другом ресурсе, если это лучше соотносится с задачами (производительность, логичность с точки зрения семантики ресурса и т.д.).
********************
<< HATEOAS/HAL добавляет в ресурс знания не о действиях над этим ресурсом (действия для любого REST-ресурса всегда CRUD), а знания о связанных ресурсах. 
Изначальный список корневых ресурсов получается из entry-point (пример: https://morethancoding.com/2011/09/07/uri-construction-give-it-a-rest/ ). 
Не пытайтесь сделать RPC из REST, это не просто способ связи клиента с сервером, это именно архитектура приложения (парадигма декомпозиции прикладной задачи на ресурсы и отношения между ними). 

>> предположим страница профайла, есть ресурс Account, мне в любом случае нужно будет сходить за списком линок для данного ресурса, а затем уже по нужному релейшну сходить и получить то что мне нужно?
Или это какое-то начальное знание с сервера при отрисовке темплейта? И как быть, если «типа микросервисы», т.е. темплейт рисует FE, а за данными ходим в сервисы BE?

--"возможно, категорично про темплейты":
<< Композиция ресурсов — на совести клиента. 
Т.е., в общем случае REST-приложение — это набор RESTfull API и отдельно хостящиеся клиенты (SPA, мобильное приложение, т.д.), каждый из которых сам реализует композицию данных по-своему. 
Микросерверность в REST — это возможность клиента работать сразу с кучей разнородных API на разных урлах. Темплейты на сервере не рендерятся, это задача клиента, сервисы предоставляют только данные (ресурсы). Т.е., да, теймплейтами рулит FE, а API рулит BE. 