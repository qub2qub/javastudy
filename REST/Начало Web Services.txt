Веб-сервисы -- 
1) это программная система, спроектированная для общения между машинами через сеть.
2) это технология, позволяющая приложениям общаться между собой через протоколы и веб-интерфейсы, вне зависимости от окружения.

т.е. Веб-сервисы обеспечивают общение приложений между собой. Человек тут отсутствует. И вызовы их должны быть понятны машинам.

Взаимодействие происходит через интерфейсы и через сеть.
Гибкость менять реализацию.
WS не зависят от окружения -- могут быть написаны на любом языке и запускаться на любом окружении.

Вызывать ВС могут не только клиентские приложения, а и сами вс могут вызывать другие вс.

Чем отличаются веб-сайты и веб-сервисы:
сайты -- ориентированы на людей и имеюг ГУИ,
сервисы -- ориентированы на машин/другое ПО, и поэтому не имеют ГУИ, и возвращают данные.

*************************
Что дают Веб-сервисы, плюсы их использования:
1) Common API
ВС платформо-независимы, и разные (часто несовместимые) платформы могут общаться друг с другом через ВС.
Обычно ВС пишутся одновременно с клиентами, это накладывает отпечаток. Но в идеале -- они сами по себе как конечный продукт, который можно продавать клиентам.

2) High compatibility -- высокая совместимость
ВС часто ис-ют простые проверенные технологии XML и HTTP.
Из коробки или сторонними библиотеками
80-й порт для HTTP как правило открыт в высоко-секьюрных системах и firewalls.

3) Black box -- 
WS скрывают от конечного пользователя свою внутреннюю реализацию.
Клиент не знает, с чем именно работает ВС.
Также внутренние системы (internal systems) могу РАЗДЕЛЬНО разрабатываться, тестироваться, обновляться, деплоиться.

4) Security
Вытекает из п.3 -- из-за сокрытия реализации.
АПИ веб-сервиса определяет разрешённые действия, тем самым предоставляется ограниченный доступ к внутренним системам.
Также и протоколы, через которые идёт общение с вс, дают некоторые инструменты для обеспечения безопасности.
И также есть сторонние бибилиотеки и firewalls, которые могут обеспечить доп. безопасность.

5) Надёжная открытая инфраструктура
6) независимость платформы и языка
7) Модульный дизайн -- каждый сервис - это закрытый модуль.

****************************

Service Oriented Architecture -- SOA --
это модульный подход к разработке ПО, основанный на использовании распределённых слабосвязанных заменяемых компонентов, оснащённых стандартизированными интерфейсами для взаимодействия по стандартизированным протоколам.

Не толко ВС могут реализовать такую архитектуру.

*********************************

История сервисов:
1990е -- DCE/RCP -- 
Distributed Computing Environment / Remote Procedure Calls

система удаленного вызова процедур, разработанная для Distributed Computing Environment (DCE). Эта система позволяет программистам заниматься разработкой распределённого программного обеспечения, как будто это все работает на том же компьютере, без необходимости волноваться за код, отвечающий за работу с сетью.

Арихтектура включает в себя утилиты для генерации клиентского кода, и библиотеки, скрывающие транспортный уровень.
Для описания стандартов удалённого сервиса был включён язык описания интерфейсов. IDL -- это язык спецификация, для описания интерфейсов, синтаксически похожий на описание классов на С++.
Это клиент-серверная платфома и независимая от языка.

--- 1990е -- MSRPC
инфраструктурая для межпроцессорного взаимодейския винды

--- 1991 --- CORBA
механизм для интеграции изолированных систем
корба -- могла работа с разными языками программирования

--- 1993 --- COM/OLE
КОМ-проги не самостоятельные, искользуются в компонентах, взаимодействует с другими компонентами. не по сети.

--- 1993 --- DCOM --
скрещены и расширены для работы по сети: MSRPC + COM/OLE.
добавили маршалинг и унмаршалинг данных.
конкурент корбе. но они оба работали по локальной сети, а не по интернету, тк в нём много firewalls и секьюрити сложностей.

--- 1998 --- XML-RPC
предназначен для вызова удалённых процедур, для передачи вопроса-ответа ис-ся XML, транспортом здесь явл-ся HTTP.
вопросы-ответы -- это валидный xml с опред структурой.
Одним запросом можно вызвать только 1 метод на сервере.

Плюсы:
1) старый, большая истрия, поддержка разными языками.
2) ему не нужен какой-то доп. контракт wsdl, wadl и тп.
3) поддерживает все базовые типы из коробки.

Минусы
1) очень многословен (too verbose) большая нагрузка на сеть
2) использования любых не базовых типов довольно сложно.

--- 13.09.1999 --- SOAP 1.0 -- 
Simple Object Access Protocol

--- 2000 --- описание REST 
ничего нового не изобрёл, всё и так существовало(в http или других сервисах)
(архитектурный стиль, а не стандарт, и не реализация RPC)
Взаимодействие с рест осущ-ся по стандартам http запроса.
ПЛЮСЫ:
1) может использовать любые представления данных (xml. json. др.)
2) простая и относительно быстрая реализаци
3) не нужно описывать контракт (wsdl др)
4) переиспользуют приемущества/фичи протокола http, вместо изобретения своих.

МИНУСЫ:
1) это не стандарт, поэтому ограниченная поддержка в языках программирования.
2) не имеет схем или формального контракта. поэтому есть различные реализации с различным качеством. и плохо документирован.

--- 08.05.2000 --- SOAP 1.1 -- 
переход от xml-data k xml-schema, перестала зависеть от протокола http.
всё это в теории.

--- 24.06.2003 --- SOAP 1.2
стал протоколом, и аббревиатура не расшифровывается.

ПЛЮСЫ СОАП:
1) Стандарт с долгой историей, у него хорошая поддрежка во всех ЯП
2) механизм wsdl описывает контракт, позволяет автоматически генерить и клиента и сервер, и сам по себе служит документацией
3) даёт гораздо больше функциональности чем xml-rpc (+безопасность)
4) из коробки поддерживает все основные типы
5) позволяет использовать custom-data (XSD-defined)

МИНУСЫ СОАП:
1) многословность и объемность передаваемых данных
2) надо много времени и опыта/навыков для написания WSDL, XSD
3) очень обширный формат, универсальный. большинство сервисов никогда не используют все его возможности, а только маленькую часть его.

***********************************
SOAP vs REST

SOAP
1) Стандарт
2) Данные доступны как сервис (getUser, addToCart)
3) Может использовать любой транспортный протокол
4) XML-сообщение
5) Ис-ет WSDL как описание сервиса(интерфейсы, биндинги, типы, формат собщений,..) Для WSDL есть много утилит для генерации клиент и сервер кода.

REST
1) Архитектурный стиль
2) Данные доступны как ресуре (user, cart)
3) Только HTTP
4) Разные форматы сообщения (XML, JSON, etc.)
5) есть разные сторонних стандартов (WADL, WSDL, ..)

*****************************
SOAP -- легковесный протокол для обмена структурированной информацией в децентрализированной и распределённой системе.

ограничения на SOAP:
1) должно ис-ть xml
2) должно в себе иметь soap envelope namespace
3) не должно содержать никаких dtd схем
4) не должно содержать никаких инструкций по обработке xml

SOAP Header может содержать след. мета-инфу, касательно:
1) Authentication
2) Security digest
3) Routing
4) Transactions
5) Payment 
6) Encoding
7) ...

___ soap:Header ___
В заголовке Блоки/тэги могут быть аннотированы глобальным SOAP атрибутом mustUnderstand, 
чтобы обозначить необходимость понимания заголовка получателем до обработки сообщения.

Если блок заголовка аннотирован mustUnderstand="1", и получатель не поддерживает данный заголовок, сообщение не будет обработано и отправителю будет возвращен Fault (с кодом состояния soap:MustUnderstand). 

Когда mustUnderstand="0" или этого атрибута нет, получатель может игнорировать эти заголовки и продолжать обработку. 

Атрибут mustUnderstand играет центральную роль во всей модели обработки SOAP.

___ env:body ___
SOAP сообщение обязано иметь один элемент Body. Внутри тела содержится само сообщение. Нет ограничений на то как это тело может быть закодировано или представлено. Это может быть просто строка, или зашифрованный массив байт или просто XML. Единственное ограничение в том, чтобы внутренний контент тега боди не превратил результирующий XML в невалидный.

___ soap:Fault ___
Элемент Fault ДОЛЖЕН содержать элемент <soap:faultcode> [использует имя определенного пространства имен, классифицирует ошибку], 
за которым следует элемент <soap:faultstring> [описание ошибки для человека ]. 

Элемент Fault МОЖЕТ содержать элемент <soap:detail> для предоставления деталей ошибки, которые могут помочь клиентам диагностировать проблему, особенно в случае кодов ошибки Client и Server.

***************************
REST - Representational state transfer
Передача состояния представления/ресурса:
1) происходит обмен информацией о состоянии ресурса 
2) и переведение ресурса в какое-то другое состояние. 
3) Между манипуляциями ресурс находится в состоянии "покоя".

Пример урлов и их значение:
Noun (URI)	|	Verb	|	Meaning
-----------------------------------------
/user			GET			Get	all users
/user			POST		Add a new user from information in the POST body
/user/new		GET			Get	the form to create a new user
/user/:name		GET			Get	a single user by name
/user/:name/edit	GET		Get the form to edit an existing user
/user/:name		PUT			Update a user with information in the POST body
/user/:name		DELETE		Delete the specified user

**************************
Ограничения REST:
1) приведение архитектуры к модели клиент-сервер

2) Stateless -- в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится. И он никак не может повлиять на дальнейшие запросы от клиента.
Каждый запрос от клиента должен содержать в себе всю необходимую информацию для выполнения этого запроса. 
В таком случае любое состояние сессии сохраняется на стороне клиента. 

3) Cacheable -- Клиенты и/или промежуточные узлы могут выполнять кэширование ответов сервера. 
Ответы сервера поэтому должны иметь явное или неявное обозначение кэшируемые они или некэшируемые, с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы. 
Правильное использование кэширования способно полностью или частично устранить некоторые клиент-серверные взаимодействия, еще более повышая производительность и расширяемость системы.

4) Uniform interface -- Реализации отделены от сервисов которые их предоставляют. Для обеспечения единства интерфейсов Рой Филдинг выделил четыре ограничения: 
  
  __ 4.1 __ Идентификация ресурсов: 
   «ресурс» это ключевое понятие в REST.
   «Любая информация которую можно именовать – есть ресурс: документ, изображение, сервис, коллекция других ресурсов, не виртуальный объект (человек например) – все это может быть ресурсом». 
   При попытки доступа к ресурсу он должен быть однозначно идентифицирован в запросе, в HTTP для этого используется URI. 
   При этом РЕСУРСЫ КОНЦЕПТУАЛЬНО ОТДЕЛЕНЫ ОТ ПРЕДСТАВЛЕНИЯ. Т.е. сервис может возвращать одни и те же данные в разных представлениях (разных форматах: xml, json, etc). 
  
  __ 4.2 __ Манипуляция ресурсами через представление: 
    Если клиент хранит представление ресурса, включая метаданные -- он обладает достаточной информацией для модификации или удаления ресурса.
  
  __ 4.3 __ Каждое сообщение содержит достаточно информации, чтобы понять каким образом его обрабатывать. 
  
  __ 4.4 __ Гипермедиа, как средство изменения состояния приложения. 
  Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте).
  HATEOS
  Исключая простые точки входа в приложение, клиент не может предположить что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. 

5) Layered system -- 
 Клиент не способен точно определить взаимодействует ли он напрямую с сервером, или же с промежуточным узлом и не может видеть дальше узла с которым взаимодействует.
   Это позволяет повысить масштабируемость за счет балансировки нагрузки и распределенного кэширования и т.д.

6) Code on demand --
Сервис может позволить расширять функциональность клиента за счёт загрузки кода с сервера в виде апплетов или скриптов.

*****************************************
Перед тем как вызвать сервис мы должны знать что и как нам вызывать. 
Для соупа есть UDDI, WSDL, XSD.
UDDI - каталог, зайти в него и найти нужный сервис и его описание.
WSDL содержит описание всех операций которые могут быть вызваны в этом веб-сервисе, и описание того как их вызвать. 
Для описания формата сообщений запроса и ответа используются XSD схемы.

Для реста -- чтобы узнать про ресурс – надо изначально получить ссылку на него. и на полученной представлении можно найти другие ссылки и т.д.

(WSDL, 'wiz-del')  Web Services Description Language --- Это язык основанный на XML и используемый для описания функционала предоставляемого веб-сервисом.
Спецом для машин, описывает как метод может быть вызван, входные параметры и данные которые он может вернуть, включая описание формата этих данных.

Отличия xsd и wsdl:
XSD-схема описывает ТОЛЬКО структуру входящего или исходящего сообщения. 
WSDL -- к этому добавляет ещё описание операций: какой протокол ис-ть, какие типы данных и т.п.

СОУП-веб-сервис <-- это ресурс и совокупность операций которые над ним можно произвести.
Операции группируются в интерфейсы. 
Операции можно вызывать по любому протоколу (TCP, HTTP, SMTP и т.д.), от него адрес URI (адрес по которому данный интерфейс находится). 
Каждый URI связан с интерфейсом через “биндинг”.

WADL (! НЕ является стандартом! )-- машинно-читабельное XML описание веб-сервисов базированных на протоколе HTTP. 
WADL документирует ресурсы предоставляемые сервисом и связи между ними.

*********************************
REST и SOAP -- несколько уровней безопасности.
1) транспортный уровень -- на уровне протокола передачи данных.
2) аутентификация и авторизация пользователя -- На основе логина и пароля сервис может давать или запрещать доступ пользователя к сервису.
3) ТОЛЬКО у соап есть -- расширение WS-Security -- на уровне самой SOAP инфраструктуры независимо от транспортного уровня -- может определять какие цифровые подписи должны быть у сообщения, какая информация должна быть в заголовке сообщении и т.д.

