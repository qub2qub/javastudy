<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>мысли про рест</title>
    <link rel="stylesheet" href="../Git Guide/grey.css">
    <style type="text/css">
    	div.comment-container {
    		border: 1px solid #920000;
    	}
    </style>
</head>
<body>
<a href="http://eax.me/rest/">src1</a>
<a href="http://eax.me/distributed-erlang/">src2</a>
<a href="http://eax.me/effective-optimization/">src3</a>
<a href="http://eao197.blogspot.com.by/2010/02/work-prog.html">src4</a>
<div class="post cye-lm-tag" id="post-24832">
                <div class="post-top cye-lm-tag">
                    <div class="post-title cye-lm-tag">
                        <div class="left cye-lm-tag">
                          <h2 class="cye-lm-tag">Зачем нужен этот ваш REST, а также о некоторых тонкостях реализации RESTful приложений</h2>
                          <div style="float: left;">
                          <p class="cye-lm-tag">25 ноября 2013</p>
                          </div>
                          <div style="float: right;"></div>
                          <div style="clear: both;"></div>
                        </div>
                    </div>
                </div>
				<div class="entry">
					<p class="cye-lm-tag">На днях кое-кто спросил меня, дескать, на кой черт вообще <a href="http://eax.me/scotty/">нужен этот REST</a>. Зачем, например, заморачиваться с методом DELETE или там заголовком Accept? Не проще ли использовать метод GET и передавать все в параметрах, например, <code class="codecolorer text default"><span class="text cye-lm-tag">delete=true</span></code> или <code class="codecolorer text default"><span class="text cye-lm-tag">format=json</span></code>? Вбил в браузере, и работает! А вот этот ваш DELETE так просто через браузер не пошлешь. На что я ответил примерно так. <span id="more-24832" class="cye-lm-tag"></span></p>
<p class="cye-lm-tag">Вот, допустим, у вас есть некоторые ресурсы. Для определенности, пусть это будут книги и пользователи. Что, собственно, означает иметь REST API для работы с этими ресурсами? В первом приближении, следующее. Если мы хотим получить какую-то книгу, то говорим <code class="codecolorer text default"><span class="text cye-lm-tag">GET /books/123</span></code>. Аналогично информация о пользователе получается запросом <code class="codecolorer text default"><span class="text cye-lm-tag">GET /users/456</span></code>. Вообще-то, в начале URL неплохо бы иметь что-то вроде <code class="codecolorer text default"><span class="text cye-lm-tag">/api/v1.0/</span></code>, но для краткости мы это опустим. По&nbsp;умолчанию данные отдаются, например, в <a href="http://eax.me/scala-json/">JSON’е</a>, но при желании мы можем передать Accept-заголовок с другим форматом. Для создания или обновления существующей книги следует использовать метод PUT, передав данные в теле запроса и указав формат этих данных в заголовке Content-type. Для удаления данных используется метод DELETE.</p>
<p class="cye-lm-tag">Внимательный читатель спросит, а для чего тогда нужен POST? Вообще, если делать все по науке, он должен использоваться для добавления элементов в сущность, словно она является неким контейнером, например, словарем. Однако на практике так обычно не делают, ведь при использовании API несколькими клиентами один клиент может изменить название книги, а второй — ее цену, в&nbsp;результате чего получится ерунда. Поэтому POST либо вообще не используют, либо используют в качестве замены методов PUT и DELETE. То есть, POST с&nbsp;каким-то телом запроса работает, как PUT, а без тела запроса — как DELETE. Это&nbsp;позволяет работать с клиентами, которые почему-то не умеют посылать PUT и DELETE.</p>
<p class="cye-lm-tag">Можно работать и сразу с целыми коллекциями. Для получения списка всех пользователей говорим <code class="codecolorer text default"><span class="text cye-lm-tag">GET /users</span></code>, а для создания нового пользователя с автоматически сгенерированным id — <code class="codecolorer text default"><span class="text cye-lm-tag">POST /users</span></code>. Как и ранее, в последнем случае данные передаются в теле запроса. Также можно перезаписать всю коллекцию, сказав <code class="codecolorer text default"><span class="text cye-lm-tag">PUT /users</span></code>, и удалить сразу всех пользователей, сказав <code class="codecolorer text default"><span class="text cye-lm-tag">DELETE /users</span></code>. Еще иногда требуется фильтрация по полям или пагинация, в&nbsp;этих случаях делают так:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">GET /api/v1.0/users?fields=id,email,url&amp;offset=100&amp;limit=10&amp;order_by=id</div></div>
<p class="cye-lm-tag">… или как-то так:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">GET /api/v1.0/logs?from=2013-01-01+00:00:00&amp;to=2013-12-31+23:59:59</div></div>
<p class="cye-lm-tag">Как бы, это все. Довольно однообразно и даже логично, не так ли? Так чем такой подход лучше описанного в начале поста?</p>
<p class="cye-lm-tag">В свое время я имел удовольствие работать над проектом, где API был устроен «простым и понятным» образом, на методах GET и POST, со всякими <code class="codecolorer text default"><span class="text cye-lm-tag">delete=1</span></code> и так далее. Смею вас заверить, что на самом деле вы этого не хотите. Потому что на практике работа с этим API превращается в какой-то кошмар.</p>
<p class="cye-lm-tag">Допустим, один программист занимается книгами, а второй пользователями. Первый решает, что для получения списка всех сущностей будет использоваться запрос <code class="codecolorer text default"><span class="text cye-lm-tag">GET /all_books</span></code>, а второй решает перечислять только id и использовать URL <code class="codecolorer text default"><span class="text cye-lm-tag">GET /select_user_ids</span></code>. Для удаления сущности первый программист решает использовать параметр <code class="codecolorer text default"><span class="text cye-lm-tag">del=true</span></code>, а второй — <code class="codecolorer text default"><span class="text cye-lm-tag">delete=1</span></code>. Для экспорта данных в&nbsp;CSV первый программист делает поддержку <code class="codecolorer text default"><span class="text cye-lm-tag">export=text/csv</span></code>, а второй — <code class="codecolorer text default"><span class="text cye-lm-tag">format=CSV</span></code>. Потом выясняется, что некоторые библиотеки не умеют посылать GET-запросы со слишком длинными query string и ходить за данными на чтение начинают методом POST. А затем кто-то случайно удаляет через браузер всех пользователей в боевом окружении… И так далее, и тому подобное, полный бардак в общем.</p>
<p class="cye-lm-tag">Вы спросите, что же мешает привести все это безобразие в одному стандарту, например, использовать только <code class="codecolorer text default"><span class="text cye-lm-tag">del=1</span></code> и <code class="codecolorer text default"><span class="text cye-lm-tag">export=csv</span></code>? Так вот, <em>REST — это и есть то самое приведение к одному стандарту</em>, с учетом всяческих граблей типа случайного удаления данных через браузер и так далее. Притом у разных компаний этот стандарт одинаковый. Когда в команду разработчиков приходит новичок, вы просто говорите ему, что у вас всюду REST, а основные ресурсы — это пользователи и книги. Все, после этого одного предложения ваш новый коллега знает 90% API, безо всякого там чтения Wiki. Если вы хотите говорить с&nbsp;иностранцами, вы же просто <a href="http://eax.me/english/">используете общепринятый английский язык</a>, а&nbsp;не&nbsp;изобретаете новый? Вот так же и здесь. Нельзя также не напомнить о пользе повторного использования протоколов и кода. А ведь для работы с REST, и HTTP вообще, написана куча библиотек и фреймворков. </p>
<p class="cye-lm-tag">Вы скажите «я, конечно, согласен, что REST такой весь из себя интуитивно понятный и общепринятый, но что, если я просто хочу загрузить через браузер список книг в формате CSV»? Тут важно понимать, что <em>REST — это не о том, как сделать все через браузер</em>. Предполагается, что должен быть клиент, который умеет работать с вашим API, вот через него и экспортируете. Но если по каким-то причинам это затруднительно, вы можете, например, использовать curl. Если у вас нелады с консолью, вы без труда найдете множество GUI-клиентов или, скажем, какой-нибудь плагин для Chrome, с аналогичным функционалом. Однако я все же советую попробовать curl. Пользоваться им совсем не так сложно, как вам может казаться. Всего-то нужно запомнить десяток параметров.</p>
<p class="cye-lm-tag">Так задаются дополнительные HTTP-заголовки:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-H 'Accept: text/csv' -H 'Content-type: application/json'</div></div>
<p class="cye-lm-tag">Выбираем используемый метод:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-X{GET|PUT|POST|DELETE}</div></div>
<p class="cye-lm-tag">Указываем тело запроса:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-d '{"name":"Alex","url":"http://eax.me/"}'</div></div>
<p class="cye-lm-tag">Если тело запроса большое, можно сохранить его в файл и сказать:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-d @filename.json</div></div>
<p class="cye-lm-tag">Выводим заголовки из ответа сервера в stdout:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-D -</div></div>
<p class="cye-lm-tag">Говорим передавать данные в gzip’е:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">--compressed</div></div>
<p class="cye-lm-tag">Сохраняем тело ответа в указанный файл вместо stdout:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">-o output.json</div></div>
<p class="cye-lm-tag">Наконец, для отключения буферизации используйте флаг <code class="codecolorer text default"><span class="text cye-lm-tag">-N</span></code>. Может пригодится, если вы работаете с большими объемами данных или бесконечными потоками.</p>
<p class="cye-lm-tag">Теперь рассмотрим пару примеров.</p>
<p class="cye-lm-tag">Экспорт книг в формате CSV:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl -H 'Accept: text/csv' http://localhost/api/v1.0/books -o books.csv</div></div>
<p class="cye-lm-tag">Создание пользователя c выводом заголовков из ответа сервера в stdout:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl -XPOST -H 'Content-type: application/json' -d '{"name":"Alex"}' \<br>
&nbsp; http://localhost/api/v1.0/users -D -</div></div>
<p class="cye-lm-tag">Удаление пользователя с заданным id:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl -XDELETE http://localhost/api/v1.0/users/123</div></div>
<p class="cye-lm-tag">Несложно, правда ведь?</p>
<p class="cye-lm-tag">Несколько финальных замечаний, относящихся не совсем к REST. Во-первых, иногда от приложения требуется не только предоставлять доступ к некоторым ресурсам, но и выполнять какие-то команды. Таким командам имеет смысл выделять URL-адреса, начинающиеся с <code class="codecolorer text default"><span class="text cye-lm-tag">/commands/</span></code>. Например, запуск почтовой рассылки по всем пользователям будет выглядеть как-то так:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl -XPOST -H 'Content-type: application/json' \<br>
&nbsp; -d '{"subject":"Good news, everyone!","body":"..."}' \<br>
&nbsp; http://localhost/api/v1.0/commands/notify_all_users_via_email</div></div>
<p class="cye-lm-tag"><em>Дополнение:</em> Некоторые команды должны быть доступны только в тестовом окружении, для них можно выделить URL-адреса, начинающиеся с <code class="codecolorer text default"><span class="text cye-lm-tag">/debug/</span></code>.</p>
<p class="cye-lm-tag">Во-вторых, иногда требуется <a href="http://eax.me/haskell-conduits/">реализовать бесконечные потоки событий</a>, или отправку текущего состояния, а затем обновлений к нему. Таким концам разумно выделить URL, начинающиеся, например, со <code class="codecolorer text default"><span class="text cye-lm-tag">/streams/</span></code>. Вот как примерно это должно работать:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl -H 'Accept: application/x-json-stream' \<br>
&nbsp; http://localhost/api/v1.0/streams/users -N<br>
<br>
{"type":"user","data":{"id":123,"name":"Alex","url":"http://eax.me/"}}<br>
{"type":"user","data":{"id":456,"name":"Bob","url":"http://ya.ru/"}}<br>
...<br>
{"type":"sync"}<br>
{"type":"heartbeat"}<br>
{"type":"heartbeat"}<br>
{"type":"user_deleted","data":{"id":123}}<br>
...</div></div>
<p class="cye-lm-tag">Нужно обратить внимание на несколько моментов. Здесь используется формат <span style="white-space: nowrap;" class="cye-lm-tag"><code class="codecolorer text default"><span class="text cye-lm-tag">x-json-stream</span></code>,</span> то есть, поток JSON-объектов, разделенных символом \n. Если этот символ встречается в самом JSON-объекте, его, соответственно, следует кодировать. Некоторым клиентам может быть удобнее работать с честным JSON’ом, то есть, списком JSON-объектов. Предусмотреть поддержку сразу нескольких форматов довольно просто. Во втором случае список объектов должен начинаться с открывающейся квадратной скобки, а объекты должны разделяться запятыми. Для удобства работы со стримом нужно либо ставить после запятых символ \n, либо делать это на стороне клиента с помощью sed:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">curl ... | sed 's/},/}\n/g'</div></div>
<p class="cye-lm-tag">Каждый объект имеет поле type и опциональное поле data. Объекты с типом heartbeat посылаются несмотря ни на что один раз в пять секунд. Если клиент не видит такого объекта в течение десяти секунд, он считает, что либо что-то сломалось на стороне сервера, либо что-то не так с сетью, и закрывает соединение. Объект с типом sync используется в стримах, посылающих некое состояние, а затем обновления к нему, для разделения первого от второго. Наконец, все остальные типы представляют собой полезную нагрузку. Поле data нужно по той причине, что вложенные данные также могут иметь поле type, что приводило бы к неразберихе.</p>
<p class="cye-lm-tag">В-третьих, когда вы пишите RESTful приложение, старайтесь с самого начала придерживаться некоторых соглашений. Например, с самого начала договоритесь, что имена полей в JSON-объектах должны всегда писаться в camelCase. Раз и навсегда запретите использовать в идентификаторах такие спецсимволы, как знак плюс и пробелы. Договоритесь, что в случае получения кода 301 клиент должен посылать точно такой же запрос на URL, указанный в заголовке Location. Примите соглашение о том, как будет передаваться автоматически сгенерированные id. Например, в Riak для этого <a href="http://eax.me/riak-install/">используется заголовок Location</a>. Подумайте о том, как&nbsp;вы будете сообщать о различных типах ошибок, в том числе временной недоступности БД, ошибках валидации полей и так далее. Пользователи почти наверняка  предпочтут увидеть:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;"><div class="text codecolorer">{"message":"validation_error","description":"..."}</div></div>
<p class="cye-lm-tag">… вместо кода 500 без каких-либо дополнительных пояснений. Если для вашего приложения важна точность представления чисел, договоритесь передавать все числа в виде строк, чтобы json-декодер не терял точность из-за преобразования строк во float’ы.</p>
<p class="cye-lm-tag">Но помните, хотя все написанное выше — это идеал, к которому стоит стремиться, <a href="http://eax.me/standards/">на практике всем наплевать на стандарты</a>. А значит, вас ждет много подпорок, слепленных на скорую руку, нежелание коллег переходить на более правильные версии API (зачем, если все работает?), и многие другие увлекательные вещи.</p>
<p class="cye-lm-tag"><em>Дополнение:</em> <a href="http://eax.me/python-flask/">Пишем REST-сервис на Python с использованием Flask</a></p>


				</div>
			</div>
<br><hr>
<div class="post" id="post-18113">
                <div class="post-top">
                    <div class="post-title">
                        <div class="left">
                          <h2>Распределенный Erlang? Вероятно, вам это не нужно!</h2>
                          <div style="float: left;">
                          <p>26 августа 2013</p>
                          </div>
                          <div style="float: right;"></div>
                          <div style="clear: both;"></div>
                        </div>
                    </div>
                </div>
				<div class="entry">
					<p>Возможность <a href="http://eax.me/erlang/">Erlang</a>‘а производить <a href="http://eax.me/erlang-gen-server/">прозрачный обмен сообщениями</a> между процессами, работающими на разных физических машинах, бесспорно, является интересной и порой весьма практичной. Но не факт, что эту возможность следует использовать именно в вашем проекте. Хотя далее по тексту речь будет идти <span style="white-space: nowrap;">об Erlang,</span> многое из написанного также относится и&nbsp;к&nbsp;<a href="http://eax.me/akka-cluster-basics/">распределенным акторам в&nbsp;Akka</a> или Cloud Haskell. <span id="more-18113"></span> </p>
<p><em>Дополнение:</em> При использовании <a href="http://eax.me/akka-cluster-basics/">Akka Cluster</a>, как выяснилось, возникают очень похожие проблемы. Также приходится дополнительно помнить о том, как ведет себя система в разных граничных случаях (какие гарантии на доставку сообщений по сети? что происходит при смерти синглтона?); постоянно думать об обратной совместимости сообщений, передаваемых между акторами; намного сложнее становятся тестирование и бесшовная раскладка, приходится дополнительно следить, чтобы кластер не разваливался, что особенно часто случается в сети AWS; если одному актору стало плохо, например, выросла большая очередь сообщений, страдает не одна машина, а весь кластер; ну и так далее.</p>
<p>Для определенности скажем, что вы разрабатываете на языке Erlang высоконагруженное веб-приложение, которое должно взаимодействовать с другими приложениями, также написанными вами на Erlang. Нужно выбрать, использовать обмен сообщениями, или же осуществлять взаимодействие между приложениями с&nbsp;помощью <a href="http://eax.me/rest/">REST API</a> (так называемая <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B8%D1%81-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0">сервис-ориентированная архитектура</a> или&nbsp;SOA).</p>
<p>Вот некоторые причины, почему стоит сделать выбор в пользу REST:</p>
<ul>
<li>Помимо команды матерых Erlang-программистов, занимающейся непосредственно разработкой приложения, есть и другие заинтересованные лица. Это админы, тестировщики, недавно прибывшие в команду джуниоры и программисты из соседних отделов, использующие другие языки. Все эти люди не понимают, как работать с&nbsp;распределенным Erlang’ом и для чего нужны эти дуратские куки;</li>
<li>Вашему приложению рано или поздно придется взаимодействовать с&nbsp;программами, написанными на языках, отличных от Erlang, для чего, видимо, все равно придется предусмотреть REST API. Зачем поддерживать два интерфейса, если можно сразу сосредоточить свои усилия на одном? HTTP — наиболее универсальное решение, с ним можно работать на&nbsp;любом нормальном языке;</li>
<li>Распределенный Erlang — это зияющая дыра в безопасности. Когда в&nbsp;вашу систему попадет злобный хакер и украдет Erlang’овую куку, он автоматически получит доступ ко всем машинам, на котором работают ноды, использующие эту куку;</li>
<li>Практически все программисты прекрасно понимают, как работать с&nbsp;REST API. Однако использование в проекте распределенных процессов потребует от программистов изучения целого нового фреймворка со всеми его особенностями и подводными граблями. Если процесс умер, будут ли доставлены все отправленные им сообщения? Каковы гарантии на доставку сообщений в случае временного падения сети? (Правильные ответы содержатся, например, <a href="http://eax.me/books-issue-4/">в книге Erlang and OTP in Action</a>);</li>
<li>При использовании распределенных процессов вас ждут целые классы новых увлекательных ошибок. Например, возникающих в результате использования разных версий некой библиотеки или виртуальной машины Erlang’а на разных нодах, netsplit’ов, <em>залипания epmd</em> или конфликтов глобальных имен. Хуже всего то, что эти ошибки часто возникают не по вине программистов. Например, админы могут перенести приложение на новый сервер, а спустя какое-то время ребутнуть старый сервер, на&nbsp;котором автоматически запуститься старая версия приложения, что&nbsp;приведет к массе занятных эффектов;</li>
<li>При использовании распределенных процессов ваш код становится более запутанным. Уже нельзя с уверенностью сказать, кто, куда и&nbsp;зачем ходит. В случае использования HTTP все намного проще, потому что адреса сервисов должны указываться в конфиге приложения, а хождение в них осуществляться через библиотеки для&nbsp;работы с HTTP;</li>
<li>Использование распределенных процессов может лишний раз препятствовать горизонтальному масштабированию. В общем случае вы&nbsp;уже не можете просто взять и запустить еще один экземпляр приложения, хотя бы, потому что это может привести к конфликту глобальных имен;</li>
<li>Для работы с HTTP имеется куча готовых библиотек, а также проксей, позволяющих <a href="http://eax.me/mod-gzip-config/">настроить gzip’ование</a> и шифрование трафика, всевозможных сниферов и так далее. При использовании HTTP в ваше приложение можно будет ходить из кода на JavaScript, что позволит без труда писать всякие там веб-админки и прочее. Любой грамотный админ с легкостью настроит вам балансировку нагрузки хотя бы с помощью того же DNS. Отладка и тестирование станут существенно проще;</li>
</ul>
<p>Понятно, что все зависит от конкретной ситуации. Если вам нужно, например, обрабатывать сто тысяч котировок в секунду, то передавать их&nbsp;по HTTP в JSON’е может оказаться не самой лучшей идеей. Однако если вы пишите приложение, которое обменивается с другими приложениями сравнительно небольшими объемами данных, желание поиграться с распределенными процессами в Erlang, <a href="http://eax.me/cloud-haskell/">Cloud Haskell</a> или <a href="http://eax.me/akka-basics/">Akka</a>, скорее всего, не принесет вам ничего, кроме боли и&nbsp;глубокого разочарования.</p>
<p>Вспомним, чему нас учит народная мудрость. В первую очередь <a href="http://eax.me/avoid-new-toys/">мы используем обкатанные, проверенные временем решения</a>, и только когда они не справляются, начинаем пробовать новые игрушки за чужие деньги. Сначала мы пишем рабочий код, затем делаем его красивым и только потом, если это действительно необходимо, пытаемся его оптимизировать. Притом ускоряем мы только самые тормозные места и используя для этого <a href="http://eax.me/effective-optimization/">самые простые и эффективные методы</a>.</p>
<p>В общем, что касается распределенных процессов в Erlang — скорее всего, вы не должны этого хотеть.</p>


				</div>
			</div>
<br><hr>
<div class="post cye-lm-tag" id="post-2653">
                <div class="post-top cye-lm-tag">
                    <div class="post-title cye-lm-tag">
                        <div class="left cye-lm-tag">
                          <h2 class="cye-lm-tag">Двенадцать эффективных методов оптимизации программ</h2>
                          <div style="float: left;">
                          <p class="cye-lm-tag">6 мая 2013</p>
                          </div>
                          <div style="float: right;"></div>
                          <div style="clear: both;"></div>
                        </div>
                    </div>
                </div>
				<div class="entry cye-lm-tag">
					<p class="cye-lm-tag">Программисты постоянно занимаются оптимизацией программ. Это такая же неотъемлемая часть работы, как исправление багов или рефакторинг. Обычно, говоря «оптимизация», мы имеем в виду ускорение программы. Несмотря на то, что под оптимизацией также может пониматься уменьшение объема используемой оперативной памяти или иных ресурсов (скажем, сетевого трафика или заряда батареи), в данной заметке речь пойдет именно об ускорении. <span id="more-2653" class="cye-lm-tag"></span></p>
<p class="cye-lm-tag">Для начала, немного прописных истин. Никто не занимается оптимизацией до тех пор, пока не придет заказчик (или коллега из отдела QA — не суть важно) и не скажет, что в таком-то месте программа работает слишком медленно. То есть, в первую очередь мы пишем программу с простым и понятным кодом, как следует тестируем ее и только потом, <em>если понадобится</em>, оптимизируем. Нет смысла оптимизировать программу, если (1) все работает и все довольны, (2) через полгода требования к программе поменяются и код придется переписать.</p>
<p class="cye-lm-tag"><em>Примечание:</em> Пожалуй, если вы пишите библиотеку, то позаботиться об ее оптимизации можно и заранее.</p>
<p class="cye-lm-tag">Также никто не бросается оптимизировать программу до тех пор, пока не станет понятно, насколько быстро она должна работать. Формулировка «таблица должна отрисовываться не дольше, чем за одну секунду» является правильной, а «таблица должна отрисовываться быстро» — нет. То есть, вы должны знать, <span style="white-space: nowrap;" class="cye-lm-tag">в каком</span> случае считать работу выполненной. Нельзя достичь цели, которая постоянно меняется. (Но если бизнес не хочет этого понимать, что ж… любой каприз за ваши деньги.)</p>
<p class="cye-lm-tag">Взявшись за оптимизацию, мы находим самое-самое тормозное место и ускоряем его. Если теперь программа работает достаточно быстро и ничего не сломалось, цель достигнута. Иначе переходим к первому шагу. Искать медленные места можно, к примеру, с помощью профилировщика, <a href="http://eax.me/graphite/">записи метрик в Graphite</a>, отладочного вывода с временными метками или логирования медленных <span style="white-space: nowrap;" class="cye-lm-tag">SQL-запросов.</span> Можно, конечно, и наугад, если в вашем распоряжении много времени.</p>
<p class="cye-lm-tag">Теперь перейдем непосредственно к методам. Я подозреваю, что некоторые из них вызовут у вас удивление, тем не менее…</p>
<p class="cye-lm-tag"><strong>Обновление ПО</strong>. Это может показаться невероятным, однако переход на последнюю версию какой-нибудь используемой в проекте библиотеки, СУБД, виртуальной машины <a href="http://eax.me/erlang/">Erlang</a>‘а или ядра Linux может <em>очень существенно</em> увеличить скорость работы вашего приложения. Простое и, как правило, быстрое решение.</p>
<p class="cye-lm-tag"><strong>Настройка окружения</strong>. Используемая СУБД или операционная система могут быть настроены неправильно. Настройки по умолчанию <a href="http://eax.me/postgresql-vs-mysql/">MySQL и PostgreSQL</a> предполагают, что вы пытаетесь запустить СУБД на первопне. <a href="http://kpy3.wordpress.com/">Один мой коллега</a> рассказывал, как однажды в его практике приложение удалось существенно ускорить, просто попробовав различные параметры JVM. Этот метод даже проще, чем обновление ПО. Однако применять его, по понятным причинам, нужно после обновления. Или в случае, если обновление по каким-то причинам в обозримом будущем невозможно.</p>
<p class="cye-lm-tag"><strong>Удаление ненужного функционала</strong>. Вы можете увеличить быстродействие вашего приложения, выкинув ненужный код. Иногда оказывается, что программа делает что-то ненужное или не очень нужное. Возможно, одна из решаемых проблем потеряла свою актуальность. Иногда заказчик вместо настоящей проблемы описывает программисту свое видение ее решения, а программист в силу своей неопытности просто кодирует это решение. Тем временем решение настоящей проблемы может быть намного проще. Иногда некий функционал обрастает костылями и подпорками. В этом случае имеет смысл реализовать функционал с чистого листа, а старое решение выкинуть.</p>
<p class="cye-lm-tag"><strong>Покупка нового железа</strong>. Чем не метод? Часто намного быстрее и дешевле купить новое железо, чем оптимизировать код программы. В ряде случаев удвоение числа ядер процессора может привести к удвоению скорости работы программы. Можно докупить оперативной памяти и хранить данные в ней, вместо того, чтобы брать их с диска или передавать по сети. Можно перенести базу данных на SSD. Если программа масштабируется горизонтально, можно докупить десяток серверов.</p>
<p class="cye-lm-tag"><strong>Мемоизация и кэширование</strong>. Теперь перейдем к «настоящим» оптимизациям. <a href="http://eax.me/erlang-memoization/">Мемоизация</a> — это сохранение значения, возвращаемого функцией для заданных аргументов. Кэширование — это сохранение результатов чего угодно. Например, кэшироваться могут веб-страницы или отчеты за месяц. Кэширование может быть неприменимо, если кэшируемые данные быстро обновляются. Также в контексте кэширования часто встает проблема инвалидации кэша. В контексте мемоизации такая проблема не возникает, так как мемоизации обычно подвергаются <em>чистые функции</em>, то есть, функции без побочных эффектов, возвращаемое значение которых зависит только от аргументов. Мемоизация и кэширование эффективны <span style="white-space: nowrap;" class="cye-lm-tag">и легко</span> реализуются, однако неправильное кэширование может препятствовать горизонтальному масштабированию программы. При добавлении в ваше приложение очередного кэша, подумайте о том, как вы будете им управлять, когда программа будет работать в двух и более экземплярах.</p>
<p class="cye-lm-tag"><strong>Распараллеливание</strong>. Распараллеливание может быть простой или сложной операцией, в зависимости от. Например, <a href="http://eax.me/erlang-task-queue/">в Erlang очень многие задачи могут быть с легкостью распараллелены</a> путем написания буквально десятка строк кода. <span style="white-space: nowrap;" class="cye-lm-tag">А в Scala</span> вы можете без особого труда воспользоваться параллельными коллекциями вместо обычных. Однако некоторые задачи не могут быть решены параллельно по своей природе. И если программа работает на одноядерном процессоре, распараллеливание ничего не даст. Недетерминированные функции и функции с побочными эффектами усложняют применение этой оптимизации, что есть еще один повод для написания чистых функций. При написании веба или каких-то бэкендов распараллеливание не всегда возможно, так как нельзя занять все ядра обработкой запроса одного пользователя, заблокировав тем самым обработку остальных запросов.</p>
<p class="cye-lm-tag"><strong>Распределение нагрузки</strong>. Если нагрузка на СУБД мала, можно воспользоваться триггерами или хранимками, разгрузив тем самым само приложение и уменьшив трафик. Или, наоборот, можно перенести всю логику в приложение, разгрузив СУБД. Для построения отчетов, создания резервных копий и выполнения других тяжелых операций над СУБД имеет смысл завести специальную реплику. СУБД можно настроить так, чтобы разные таблицы хранились на разных физических дисках. Можно отдать пользователю статическую страницу с JavaScript <span style="white-space: nowrap;" class="cye-lm-tag">и общаться</span> с ним исключительно при помощи <a href="http://eax.me/rest/">REST API</a>. Пусть сам генерирует себе HTML. Статический контент можно держать на отдельном домене. Этим вы уменьшите трафик, так как на этот домен не будут отправляться кукисы. Незачем <a href="http://eax.me/erlang-ibrowse-gzip/">gzip’овать</a>/шифровать данные в Apache или даже в самом приложении, если <a href="http://eax.me/wordpress-extra-optimization/">с&nbsp;этой&nbsp;задачей намного лучше справится nginx</a>. При помощи шардинга можно распределить нагрузку между несколькими репликами базы данных, процессами Erlang’а или экземплярами <a href="http://eax.me/memcached/">Memcached</a>.  </p>
<p class="cye-lm-tag"><strong>Ленивые вычисления</strong>. Грубо говоря, <a href="http://eax.me/lazy-evaluation/">ленивые вычисления</a> — это когда вместо конкретного значения возвращается анонимная функция, которая при вызове вычисляет это значение. В ряде языков программирования ленивые вычисления поддерживаются на уровне синтаксиса. Фокус в том, чтобы значение было вычислено непосредственно перед его использованием. Представьте себе ситуацию, когда мы отдаем данные в формате CSV и пользователь может задать фильтр, определяющий, какие столбцы должны быть переданы. В этом случае ленивые вычисления оказываются как нельзя кстати. Если окажется, что значение на самом деле не нужно, мы сэкономим время, которое было бы потрачено на его вычисление. Однако следует отметить, что ленивые вычисления приводят к увеличению объема используемой памяти и могут плохо работать с грязными функциями.</p>
<p class="cye-lm-tag"><strong>Отложенные расчеты</strong>. Зачем считать что-то прямо сейчас, если это можно сделать потом? При обработке HTTP-запроса мы можем моментально вернуть пользователю OK, а непосредственную работу выполнить в фоновом процессе. Если запрос очень важен, мы можем положить его в персистентную очередь задач, обрабатываемую по cron’у. Или группой непрерывно работающих процессов. <span style="white-space: nowrap;" class="cye-lm-tag">В последнем</span> случае мы даже имеем хорошие шансы получить горизонтальное масштабирование и, соответственно, реальное увеличение скорости, а не только видимое. Кроме того, отложенные задачи могут быть похожи. Например, им нужны одни и те же данные из БД. В этом случае при отложенной обработке N задач одной пачкой можно сходить в базу в N раз меньше.</p>
<p class="cye-lm-tag"><strong>Более подходящие алгоритмы</strong> и структуры данных. Quicksort быстрее сортировки пузырьком, а <a href="http://eax.me/elliptic-curves-crypto/">эллиптические кривые быстрее RSA</a>. Если нужно проверить принадлежность элемента множеству, <a href="http://eax.me/hash-tables/">следует использовать <span style="white-space: nowrap;" class="cye-lm-tag">хэш-таблицы</span></a>, а не односвязные списки. Правильные индексы и денормализация схемы базы данных могут существенно сократить время выполнения <span style="white-space: nowrap;" class="cye-lm-tag">SQL-запросов.</span> Если требуется синхронизировать некие данные, вместо полной их пересылки при каждом изменении лучше использовать схему снапшот + апдейты.</p>
<p class="cye-lm-tag"><strong>Аппроксимация</strong>. Это почти что случай более подходящего алгоритма, только с потерей точности. Вместо длинной арифметики часто можно обойтись обычными float’ами. При сборе статистики данные можно слать по UDP вместо TCP. Пусть небольшая часть пакетов не дойдет, а часть — придет дважды. При сборе статистики намного важнее изменение цифр, а не конкретные значения. Также, например, незачем <a href="http://eax.me/scala-chart/">строить график</a> по всем точкам, если можно взять их подмножество и <a href="http://eax.me/bezier-spline/">построить кривую Безье</a>. Вместо дорогостоящего вычисления медианы часто можно посчитать среднее.</p>
<p class="cye-lm-tag"><strong>Переписывание на другой язык</strong>. Вполне может оказаться, что программу в существенной степени тормозит сборка мусора или, скажем, проверка типов на этапе выполнения. Переписывание <em>небольших частей</em> программы с Ruby на <a href="http://eax.me/scala/">Scala</a> или с Erlang на <a href="http://eax.me/ocaml/">OCaml</a> <em>может</em> привести к ускорению этой программы. Если переписываемый кусок кода достаточно прост, можно с небольшим риском переписать его на Си или C++. Этот метод нужно использовать крайне осторожно. Он приводит к появлению зоопарка языков программирования, что усложняет поддержку проекта. Метод может не сработать, например, из-за накладных расходов на преобразование данных из одного представления в другое. Также он может быть опасен. Например, <a href="http://eax.me/erlang-nif-library/">ошибка в NIF может привести к падению всей виртуальной машины Erlang’а</a>, а не одного процесса.</p>
<p class="cye-lm-tag">В заключение хочу отметить, что приведенная классификация весьма и весьма условна. Совершенно очевидно, что граница между распараллеливанием и распределением нагрузки или отложенными расчетами и ленивыми вычислениями весьма размыта.</p>
<p class="cye-lm-tag">А что бы вы добавили к названным методам?</p>
<p class="cye-lm-tag"><em>Дополнение:</em> <a href="http://eax.me/benchmarks/">Почему на самом деле ваш бенчмарк — говно</a></p>


				</div>
			</div>
<br><hr>
<div class="post hentry uncustomized-post-template cye-lm-tag" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
<meta content="654279083390275842" itemprop="blogId">
<meta content="8206408881482160191" itemprop="postId">
<a name="8206408881482160191"></a>
<h3 class="post-title entry-title cye-lm-tag" itemprop="name">
[work; prog] Нравоучение: делайте свои имитаторы чужих компонентов
</h3>
<div class="post-header">
<div class="post-header-line-1"></div>
</div>
<div class="post-body entry-content" id="post-body-8206408881482160191" itemprop="description articleBody">
<p class="cye-lm-tag">Сегодня войду в роль старого бывалого программиста-гуру и дам совет начинающим разработчикам: если вы пишите систему, в которой необходимо взаимодействие с чужими компонентами, то всегда старайтесь делать собственные имитаторы этих компонентов.</p>  <p class="cye-lm-tag">Например, вам нужно обращаться к чужому Web-сервису – напишите его имитатор. Вам нужно обслуживать запросы чужих клиентов – напишите их имитаторы. Вам нужно запрашивать данные у чужой системы – напишите ее имитатор. Просто возьмите и напишите. Хотя бы самый простой и ограниченный в функциональности. Но чтобы вы могли докручивать его в любую нужную вам сторону. В любой момент. Никого не упрашивая и даже не ставя в известность.</p>  <p class="cye-lm-tag">Зачем это нужно делать? Затем, что если вы этого не сделаете, то рано или поздно вам придется обратиться к вашему партнеру с просьбой сымитировать ту или иную ситуацию. Мол, нужно проверить, что будет, если мы от вас получим три положительных ответа, затем через 0.25 секунды один ответ с кодом 0x543f, а еще через 0.155 секунды – еще 150 положительных ответов.</p>  <p class="cye-lm-tag">Так вот, когда у вас возникнет такая необходимость и вы обратитесь с подобной просьбой к своему партнеру, знаете что произойдет? Ваша просьба будет передана разработчику вроде меня (и это еще не самый плохой случай, я уверяю) и первая мысль у этого разработчика будет: “А нахер мне это надо?!!!”</p>  <p class="cye-lm-tag">И в лучшем случае, если вам повезет и у партнера будет серьезный стимул помогать вам, то со временем вашу просьбу удовлетворят, частично. Но ведь могут и вежливо послать, мол, “имитация не является штатным режимом работы нашего ПО и повторить предложенный сценарий не представляется возможным”.</p>  <p class="cye-lm-tag">А теперь представьте, что написанная вами система запущена в коммерческую эксплуатацию, работает под нагрузкой и вдруг случается большой трындец и наступает полный обертюр. Все на ушах, в чем дело не понятно, а разбираться нужно. Причем параллельно с вами разбираться в проблеме будут и партнеры. И не исключено, что они докопаются до причин раньше вас. Вот раскопают они, что если события происходят в последовательности X, Y, Z за временной интервал t, то вашей системе наступает кабздец. И на каком-нибудь совместном совещании в присутствии большого начальства поделятся своими подозрениями. И что вам останется? Вы-то сами не сможете работу своей системы проверить – нужно идти на поклон к партнеру, т.е. публично расписываться в собственной беспомощности. Даже если вы сами первыми вычислите эту злосчастную последовательность X, Y, Z – это все равно будут лишь ваши предположения. Проверить их самостоятельно вы будете не в состоянии.</p>  <p class="cye-lm-tag">А будь у вас имитатор компонента партнера вы бы оказались в более выигрышном положении. Вы смогли бы сами воспроизвести условия возникновения проблемы и проверить работу своей системы. И сделать это все оперативно, без публичного шума. Нашли бы проблему, залатали ее и при разборе полетов бы доложили: “Да, был у нас злобный баг. Он проявлялся при таких-то условиях. Мы его уже исправили. Сейчас все работает.” И пусть партнер проверяет сколько хочет (если сможет, ведь имитация не является штатным режимом работы его ПО).</p>  <p class="cye-lm-tag">Если при чтении последних двух абзацев у вас возникла мысль о том, что с вашей-то системой такая жопа не случится, то выбросьте ее из головы – баги есть всегда и везде. Так что лучше напишите пару-тройку имитаторов, это окупится.</p>  
<div style="clear: both;"></div>
</div>

</body>
</html>