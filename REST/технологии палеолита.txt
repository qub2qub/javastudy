https://habrahabr.ru/post/204958/
Назад, к технологиям верхнего палеолита, от любимых всеми REST, STATEless, CRUD, CGI, FastСGI и MVC
***
Тогда и в этой статье стоит строго прописать, что и под чем подразумевается. А то вот так читаешь, думаешь об одном. А потом в комментариях оказывается, что говорят тут совсем о другом.
Мы говорим о безграмотности начинающих разработчиков, но при этом забываем, что матерые дядьки порой тоже договориться не могут. 
*****

«Только со смертью догмы начинается наука.»
// Галилео Галилей

«Я начал завидовать рабам. Они всё знают заранее. У них твёрдые убеждения.»
// х/ф Марка Захарова «Убить дракона» по мотивам пьесы Евгения Шварца

Уже пару лет и дня не проходит, чтобы я не услышал (или не прочитал) от людей, начинающих новые проекты, фразу типа «Возьмем серверный движок для REST API и MVC, и погнали». Сначала я думал, что у этих слов есть один источник, может книжку какую завезли во все магазины или где-то в топе поисковиков лежит статья, зомбирующая разработчиков. Если же выяснять у них, что они понимают под REST и MVC, то можно повредиться умом. Ну с MVC уже все ясно, об этом я уже давно писал, ничего не изменилось, только усугубилось, стоит набрать в Google Images «mvc» и мы увидим страшное, стрелочки в любые стороны. Ну а про REST отвечают следующее: ну как же, нам нужно из браузерного GUI и мобильного приложения вызывать серверные методы, например: setUserCity(userId, cityId) или calculateMatrix(data) или startVideoConverter(options, source, destination) а потом мы столкнемся с большой нагрузкой и архитектура REST все решит. Дальше я задаю вопросы, от которых глаза округляются уже у тех, кто недавно еще горел праведной верой, рвался в бой и точно знал, что к чему в этом мире. Теперь можно перейти к рассмотрению терминологической катастрофы, в эпицентре которой мы с вами пребываем.

Вопросы по MVC

Первый вопрос: нарисуйте мне схему «что такое MVC?». Что я получаю:

Для MVP таких пониманий и схем тоже достаточно, даже не сомневайтесь.

Второй вопрос: а как это паттерн, предназначенный для пользовательских интерфейсов может быть применен на сервере?
Я не могу перечислить тут все возможные варианты ответов. Но правильный встречается очень редко и он такой: на сервере MVC может быть только если у нас пользовательский интерфейс полностью реализован на сервере, т.е. нет браузерного кода, интерфейс генерируется на сервере, а браузер просто показывает его.

Третий вопрос: как вам удалось совместить MVC с REST?
Не удержусь, опубликую распространенные варианты:

    Ну как же, у нас MVC реализован при помощи REST
    Ну как же, у нас REST реализован при помощи MVC


Не могу это комментировать, тут совершенно ясно, что мы имеем дело с терминологической катастрофой, но об этом дальше.

Вопросы по REST

Первый вопрос: ну, дорогие мои, а как эти ваши setUserCity, calculateMatrix и startVideoConverter могут быть реализованы на REST?
Мой вариант ответа: весь смысл REST в том, что он оперирует файлами, каждый из которых имеет свой уникальный URL и над этим файлом можно производить только HTTP методы: GET, PUT, POST, DELETE. Поэтому, все эти свои setUserCity будьте любезны заменить на HTTP POST /user/id и отправлять туда нужно целиком сериализованного пользователя. Или другой вариант, нужно для каждого параметра пользователя иметь отдельный URL. Очевидно, что CRUD методов (create, read, update, delete), вызванных через HTTP методы, хватит для манипуляции файлами или объектами в БД. Например, для ввода форм и бланков, сохранения их в таблицы с дальнейшим удалением и редактированием. Но любое современное приложение не может же быть сведено к таким примитивным вызовам. И разработчики, чаще всего, понимают под REST именно его противоположность — RPC (вызов удаленных процедур), когда мы можем сделать сколько угодно методов, а не только CRUD, и когда один URL может отдавать совершенно разные ответы, в зависимости от того, какой пользователь его вызвал, с какими параметрами и в какой последовательности. А это уже совсем не REST, например, Хабр выдает по адресу http://habrahabr.ru/tracker/ разный список для каждого из нас и такое повсеместно, в Google, Facebook, Github и т.д. Так что, уберите слово REST, вводящее в заблуждение, делайте API и все.

Второй вопрос: ладно, а что такое REST именно для вас?
Разброс мнений тут не так широк, как для MVC, но терминологическая катастрофа вот в чем: как я показал выше, под REST понимают совсем не REST, а чтобы сделать все по науке идут и изучают догматическую литературу по REST, подыскивают фреймворки с поддержкой REST, а в результате, выходит гибрид RPC и REST. И хуже всего, что все это происходит неосознанно.

Третий вопрос: вы можете объяснить, как именно REST спасет вас от больших нагрузок?
Мой вариант ответа: он STATEless, но что это значит и зачем нам отказываться от состояния на сервере — обсудим ниже.

В чем же смысл STATEless

При масштабировании современные веб-сервера порождают отдельные процессы для каждого запроса. Если эти процессы будут STATEless, то нет ни какой разницы, на одном сервере работает система или на сотне серверов. Каждый процесс получает данные запроса по протоколу CGI и должен выделить память, развернуть в ней свои структуры данных, если нужно, то создать соединения с БД, прочитать файлы или сделать вызовы к внешним модулям. Потом процесс выполнит свою логику и все это хозяйство погибает. Такие процедуры задерживают выполнение HTTP запросов, поэтому есть FastСGI, который предусматривает несколько всегда запущенных процессов и экономит время на их порождении, первичном выделении памяти, ее освобождении и завершении процессов. Еще FastСGI позволяет повторно использовать подключения к БД и другие дескрипторы. Но структуры памяти, необходимые для обработки каждого HTTP запроса, все равно живут не долго, они погибают и создаются, а при этом повторно выполняются запросы в БД, обращения к файлам и к внешним модулям. Но и в этом случае необходимо придерживаться принципа STATEless, потому, что неизвестно, в какой процесс попадает следующий HTTP запрос. А разные запросы могут относиться к разным сайтам приложениям, и даже в одном приложении могут относиться к разным сессиям или предусматривать развертывание в памяти очень отличающихся структур данных.

Настало счастье программисту из верхнего палеолита

В то время, когда складывалось мое программистское мировоззрение (1997-2002 годы), мэинстримом была трехзвенная архитектура приложений (оконный клиент, сервер приложений, СУБД). И клиенты взаимодействовали с серверами приложений по RPC. Все было STATEful, но тогда и задач то таких не было, которые бы требовали масштабирования сервера приложений на много машин. И вот, долгие годы, с 2002 по 2012 я терпел REST и STATEless, мечтая в душе про полноценное STATEful программирование и RPC для высоконагруженных систем. Теперь же, когда большинство языков и платформ имеют свои Event-Loop решения, как Node.js, Python's Twisted и Ruby Event Machine, я чувствую себя совершенно счастливым человеком и больше не знаю, зачем нужен STATEless и откуда берутся в наше время фразы типа «Возьмем серверный движок для REST API и MVC, и погнали».

С тех пор, как появилась возможность делать высоконагруженные сервера приложений с состоянием, процессы опять стали жить долго, все структуры данных можно оставлять в памяти, остаются и соединения с БД, кеши, таймеры, можно развернуть сложную модель в памяти и она будет там сидеть месяц. И с этой моделью может взаимодействовать клиентская часть через API. А теперь немного арифметики, представьте, что состояние пользователя 32Кб, а у нас есть 16Гб памяти, этого хватит на 524288 (более полумиллиона) пользователей.

Единственное, что осталось решить, это как направлять в один и тот же процесс все запросы, относящиеся к одной сессии. То есть, нужно «приклеивать» сессию к серверу и к процессу (процесс может быть на одном из множества серверов). Для этого у нас есть аппаратные и программные балансировщики, реализующие прилипание по IP (ip-sticky) и по кукизу (cookie-sticky). Конечно, каждый процесс должен маркировать кукизом со своим идентификатором все запросы, которые не имеют такого идентификатора. Если идентификатор есть, то работает прилипание, а если нет, то round robin или более сложный алгоритм балансировки.

А с MVC мы еще не закончили

MVC научил всех разделять модель, представление и контроллер, причем бездумно, где нужно и где не нужно. Но общего понимания о каждом компоненте так и не выработалось. Кто-то оставляет в модели только параметры, а методы выносит в контроллер, а у кого-то модели умеют себя сами сохранять и восстанавливать из БД, другие же — яростные противники такого подхода и выделяют еще data access layer для доступа к БД. В любом случае, с терминологической катастрофой нужно что-то делать.

Предлагаю использовать слово «модель», как его принято использовать в науке и технике, а именно — это упрощенное представление реальной системы и/или процесса. Из этого следует, что модель может содержать параметры и методы. Но методы эти должны подходить под определение. Например, методы CRUD не могут быть частью модели объекта реального мира, потому, что ни один реальный объект не умеет себя создавать или удалять. CRUD — это не есть часть модели, а часть API слоя хранения данных, как методы отрисовки — часть API графического слоя. Модель же не должна знать ничего о своем хранении, протоколах передачи по сети, особенностях отрисовки в браузере и т.д. Хороший пример метода для модели: SteppingMotor.setSpeed(х), когда модель является драйвером физического устройства или используется для моделирования физического устройства. Другой хороший пример, это математические модели, например, Equation.calculateRoots(). И третий пример, это информационные модели, например: Patient.assignBed(bedId).

Слова же «view» и «controller» по возможности избегаю, лишь потому, что в сознании отдельных разработчиков у них могут быть совершенно непредсказуемые и странные смыслы. Вместо них лучше использовать более конкретные понятия «template», «control» (или «user interface control»), «request router» и т.д.

Советы по разработке приложений на технологиях верхнего палеолита

Из событийно-ориентированных решений я лично использую Node.js, но думаю, что они могут носить универсальный характер:
1. Разделяйте клиент и сервер (браузерное приложение и сетевое API) по принципам RPC и STATEful с приклеиванием сессий к процессам.
2. Используйте оперативную память, не лазьте в базу данных постоянно. STATEful — это великолепная возможность писать быстрые приложения, и даже не из-за того, что Event Loop фреймворки предполагают неблокирующий ввод/вывод, а из-за правильного использования памяти. Большинство операций ввода-вывода не нужно даже делать в во время обработки запросов, чтение можно делать упреждающими и параллельным, а запись ленивой (lazy). Разворачивайте данные в память приложения, стройте хеши, объекты, массивы, которые проживут долгую и счастливую жизнь в STATEful процессе.
3. Между разными процессами взаимодействуйте через ZeroMQ (и другие MQ), TCP, HTTP, IPC и еще что-угодно. Таким образом, данные разных процессов, в зависимости от того, что это за данные, могут или дублироваться в памяти (кешироваться, если это общие данные) или быть разделены на «прилепленные» сессии или синхронизироваться между собой через межпроцессовое взаимодействие.

Заключение

Каждый раз переосмысливайте шаблоны проектирования. не берите чужие решения только из-за их авторитета, они могут быть не плохими, но не для вашего случая. Брать решения можно и нужно, но только при полном их переваривании и понимании.
Всегда сверяйте терминологию со своими коллегами еще перед началом проекта и уточняйте ее вплоть до создания словарика в общем доступе. С той путаницей понятий, которая накопилась в наше время, невозможно быть уверенными, что говорите об одном и том же, даже если используете одни и те же слова.

UPD: Комментарии ниже — лучшее доказательство терминологической катастрофы. Оказывается нет общего понимания, не только в том, что такое REST и MVC, но даже в том, что такое stateless и statefull. И еще интереснее, нет общего понимания, что такое «состояние» вообще. Кто-то понимает под этим состояние процесса (его память), кто-то состояние всех серверов (тогда состояние может быть в другом процессе), а кто-то состояние системы в целом (тогда состоянием можно считать и хранимые файлы и данные в БД). В такой ситуации лучше выбрасывать старые термины, испорченные и испачканные, о смысле которых уже нет ни какой надежды договориться и вводить новые, но делая уже строгие словарные определения. Иначе, вообще не о чем говорить, нельзя построить диалога, говоря одними словами, но о совершенно разных понятиях.

***************

Если кеш в отдельном процессе (например, memcached), а процесс обработки HTTP запроса создает и уничтожает структуры данных каждый раз при получении нового HTTP запроса, то это stateless. А если модель развертывается в нативных структурах языка и сохраняется между запросами в серверном процессе, то у вас stateful, мои искренние поздравления.

>когда нужно разделять сервер и клиент
<Разделение простое, если сайт — генерируйте все на сервере, если веб-приложение — разделяйте
>Не имеет значения, по-моему, в каком процессе разворачиваются данные. Главное являются ли они кэшем, сохраненных в хранилище данных, либо основной структурой, которая лишь дублируется в хранилище на случай рестарта. 
<Являются ли данные кешем адресуемых по URL ресурсов (файлов) или развернутой в структурах данных (моделью) — это важно, но в родном ли это процессе приложения или нужно каждый раз за состоянием обращаться в другой процесс и вынимать оттуда сериализованные объекты, а потом их туда сохранять — это важно не менее. 
--------------
Когда уже мы перестанем говорить, что А лучше Б, доказывать, что это серебряная пуля, махать флагом и зазывать всех применять только это решение? В программировании нет универсального подхода. Паттерны, методики, фреймворки — это лишь сборники советов. Но как и где их применять — зависит от задачи. Имею опыт применения STATEful подхода. И были проекты, где такой подход был выбран неоправданно и доставил кучу проблем. Были и уместные случаи использования. Аналогичный опыт использования STATEless. Давайте все же более глубоко и широко анализировать задачу и на основании этого анализа принимать решение об используемом подходе.
Согласен с автором по поводу разночтений терминологии. Это касается не только REST'а и MVC, но и вообще многих определений и подходов. Это общая проблема.
Так же согласен насчет модели. Вообще, у меня при проектировании общий подход такой: при создании каждого слоя надо задавать вопросы — какая цель существования этого слоя? что он знает? что он умеет? кого он использует? кто его использует? И между этими вопросами не должно быть противоречий.
В целом, понимаю, что скорее всего, статья была призвана «поднять» авторитет STATEful подхода, но в итоге получилась слишком холиварной
-----------
<Stateful не значит, что нет базы, и все хранится только в памяти, просто модель в памяти память не разрушается между запросами, а сохранение ее в базу ленивое. Ни какого дампа иметь не нужно. Отладка Stateful такая же, как и Stateless, нужно вывести определенную часть данных в лог. 
Для критических операций можно делать транзакционный лог, но большинство данных, в памяти может быть утеряна и восстановлена из базы. 
>А какие плюсы дает ленивое сохранение в БД?
<Как упреждающее чтение, так и ленивое сохранение позволяют исключить из времени исполнения запроса все операции ввода/вывода. 
>Непонятно что именно читать с упреждением, как при ленивом сохранении сказать пользователю что что-то не сохранилось из-за ошибки, и зачем сокращать время запроса. 
<1. Читать с упреждением: например, мы знаем, что нужно 5 раз в сутки перестроить статистический отчет, вот мы его по времени и перестраиваем, кладем в кеш, а при запросе не происходит расчетов, сразу отдается кеш из памяти.
2. Если что-то не сохранилось в ленивом режиме, то пользователь может получить об этом уведомление без рефреша страницы, для этого есть Server-Sent Event и WebSockets, на худой конец Long Pooling, которые подключились прямо в тот же процесс.
3. Время запроса сокращать нужно, чтобы пользователь не ждал. 
>>1. Ну, раз в сутки перестроить отчет — это вполне себе классическая штука. В большинстве случаев параллельно веб-серверу крутится процесс, который всякое такое делает. Положить его сразу в кэш — тоже можно, и в каких-то специфических случаях может быть даже и нужно.

2. А если пользователь успеет закрыть приложение? И оправдана ли настолько более сложная инфраструктура — ведь мало того что нужно тащить server-side events, так надо еще как-то уметь открыть ту же форму чтобы что-то поправить, нужно как-то думать в какую вкладку посылать событие, нужно придумывать как сделать чтобы пользователю было понятно. А потом какая разница пользователю — через веб-сокет придет «ваш заказ принят», по ajax-у, или это будет ответ на обычный post-запрос?

3. Это оправдано если нет последствий для пользователя. Если от оптимизаций пользователь не видит что его заказ не сохранился, или получает не актуальные данные — я бы, как пользователь, лучше бы подождал. 
<<На закрытие окна браузера можно повесить предупреждение, но вообще, пользователь может и комп выключит, тут мы ему уже ни чем не поможем. А вот Server-Sent Events и WebSocket отличаются от AJAX тем, что по ним можно прислать событие с сервера на клиент по инициативе сервера, а не по запросу клиента. 
-------------------

>>Соглашусь, что хорошего программиста отличает ясность в понимании той терминологии, которую он использует, потому что за каждым словом скрывается множество нюансов.
Но Stateless подход гораздо более приемлем для нагруженных приложений, требующих масштабирования. Возможно его дольше воплощать (хотя это спорно), и отдельный компонент системы может работать немного медленнее за счет необходимости получения данных из внешнего источника (кэш, БД, другой компонент), но зато количество таких компонентов может расти линейно без потери производительности и, самое главное, надежности всей системы.
Опять же автоматизация тестирования Stateless системы гораздо тривиальнее. 
<<А в чем преграда масштабирования Statefull системы? 
>> Проблема привязки клиента к процессу/серверу, как минимум. Прилипание по куки или айпи это лишь часть решения. Пускай ситуация: есть 4 сервера, на каждом по сотне клиентов, работают, объём данных растёт, клиенты начинают жаловаться на тормоза. Ставим ещё один сервер, но клиенты прилипли к первым четверым — они загружены, а пятый стоит. Нужно или рвать сессию клиента (возможно с потерей данных), или предусматривать механизм миграции состояния с сервер на сервера хотя бы ручками. 
<<  Мигрировать клиентов очень просто, их сессии рвать не нужно, их можно просто перестикать к другому процессу, а их состояние на старом сервере просто убить, перемещать их на другой сервер дольше, чем восстановить состояние сессии из БД. Кстати, кроме состояний сессий, есть еще глобальное состояние и состояние хранимых объектов, доступ к которым есть у многих сессий, эти состояния синхронизируются через подписку на события (например, паттерн pub/sub из ZMQ). 
>> Фигассе «просто» :-)
Это в случае Stateless просто, а здесь, пи#$$ц, извините.

Это надо писать балансер, который бы раскидывал нагрузку, ну или использовать готовый — по мне так это нифига не просто + куча подводных граблей. 
<<  Есть несколько готовых технологических стеков, просто нужно изучить событийно-ориентированные фреймворки, они по своей организации даже проще, чем обычные. 
>>  Т.е. есть у меня 3-х этапная огромная веб-форма. Я заполнил первый этап, второй этап, начал заполнять третий — последний, и тут… Админ решил, что неплохо бы нам отмасштабироваться, включил новый сервер и прибил мою сессию на сервере. И что мне теперь — заново форму заполнять? (В случае stateless промежуточные состояния сохраняются в hidden поле или в БД).
Если же промежуточные состояния формы не держатся в памяти а скидываются в БД то какой-же это statefull? 
<< Можно передвигать сессии для неактивных пользователей, их всегда больше и этого админу хватит для удовлетворения. 
>>Если у вас есть 3ех этапная форма, при заполнении которой нужно вызывать процедуры на сервере и при этом вы не закрепляете выполнение этих процедур за пользователем, а за сессией, у ваш протокол логически stateful. Естественно, если вы захотите его реализовать через stateless то у вас будут костыли.

Проверка на stateless/stateful очень проста. Если пользователь зашёл с другого компьютера, то ему надо будет форму всю заново заполнять? Если да — stateful, если нет — stateless. Ещё раз нельзя путать state протокола и state сервера, это существенные вещи.

Ещё стоит заметить, что сохранение состояния клиента это необязательно сохранение в базу данных, состояние можно хранится и памяти, например в memcached, процессе erlang'а и проч. К состоянию протокола это не имеет отношения. 
<< hidden поля в случае get формы вполне себе попадают в URL. Если в первой форме будет пункт «Вам есть 18 лет», то у второй формы будет URL
/form/2?is_18=true
Так что тут тоже как подойти… 
<<.. В случаях, при открытии сессии на новом компьютере, на старый сваливается по SSE событие, закрывающее все недоделанное и выводящее сообщение о том, что сессия перешла к другому клиенту. Вот именно такой случай был при многостраничных опросах (голосованиях). 
<< Server-Sent Events это протокол, позволяющий передавать события с сервера на клиент по инициативе сервера, без AJAX опрашивания (пулинга), можно применять вебсокеты или лонг-пулинг. Но суть у них одна, события попадают с сервера на клиент за миллисекунды. Как только на новом компьютере пользователь вошел, то на старом он автоматически вышел (пришло событие), но даже если предположить, что за эти миллисекунды кто-то нажал сабмит, то сервер уже не признает сессию со старого компьютера, на сервере то она уже получила новый идентификатор и посты со старого будут 403 Forbidden.
>> Вот видите вам уже нужен двусторонний обмен данными, вместо одностороннего. Зачем усложнять, когда всё уже придумано? В REST предусмотрен ответ на такой случай 409-ый.

С оптимизацией без цифр не очень понятно, потому что вы несколько выиграли в нагрузке сервера, зато проиграли в нагрузке на сеть. Процессор то всегда можно ещё один поставить, а вот канал не всегда можно расширить. 
-----------------------
>> Думаю, следует различать внутреннее состояние приложения (не оказывающее влияния на результаты запросов — кэши, дескрипторы ресурсов, какие-то глобальные данные и т. п.) и внешнее (оказывающее влияние на результаты запросов, например, данные и/или результаты предыдущих запросов, но недоступное клиенту). 
<<  Это точно, я в статью апдейт сделал, потому, что уже три состояния насчитали: состояние процесса обработки HTTP-запросов, состояние всех серверных процессов (включая процессы специализированных серверов состояний, редис, мемкеш), состояние всей системы в целом (включая БД, а многие БД имеют кеш в памяти, не хуже, чем мемкеш). А состояние еще можно делить на состояние сессий, состояние объектов данных, глобальное состояние системы. 
*****************************
stateLESS, statFUL… Полностью согласен с автором.

Уберите куки, сессии, хранилища, уберите из базы профили пользователей (чего ещё забыл?) — вот тогда у вас stateLESS. Во всех остальных случаях, если есть хоть один способ хранения состояния пользователя — у вас stateFUL. Жуткий, урезанный, ограниченный, эдакий stateHALF, но с хранением состояния. Так что не врите себе и другим, поддёргивая профиль пользователя из базы и читая его куку, что у вас stateLESS-подход. Просто используемая технология не поддерживает состояния и вам приходится хоть как-то (куки, хранилища, etc) этот недостаток восполнить. А если вы его пытаетесь восполнить — значит, вам нужен stateFUL-подход.

И не нужно говорить, что речь не о проекте в целом, а о его серверной (клиентской, БД, etc, да хоть M / V / C и иже с ымями) части. Разницы нет абсолютно. Вы храните состояние пользователя, так или иначе. Так просто делайте это полноценно, только и делов. И не врите. В первую очередь себе. 

 Я говорю не о том, что это должно быть stateFUL. Я говорю о том, что любой stateLESS с хранением состояния не есть stateLESS. Следовательно, зачем городить себе палки в колёса и стоически преодолевать проблемы технологии? А если там кроме логина/пароля и нет ничего, и оно не сильно-то и надо, то зачем оно нам вообще? Уберите и не парьтесь. 

>Состояние чего?
<Пользователя. Аутентификация, история посещения/покупок, etc… 

Веб за двадцать пять лет сильно изменился. Если тогда были тупо текстовые файлики, то сейчас у нас сплошь и рядом идентификация и интеграция. Если тогда было пофик, кто читает, то сейчас мы хотим знать точно, тот же это, который запросил, или уже сфальсифицированный, как минимум с позиции безопасности, не говоря уж об увеличении продаж методом «с этим обычно покупают...». И если на ненагруженных проектах состояние пользователя порою рациональнее хранить в каких-либо сессиях, либо не хранить вообще, то на высоких нагрузках имеет смысл как-то себе жизнь всё-таки упростить. Я за разумный подход.

А с этими терминологиями столько копий переломано впустую, какая нафик разница, как это называется? Важно лишь, что именно оно делает и как помогает. И помогает ли вообще. Ниже хорошо написали. 

>>Ежу понятно, что в самом общем, любая система, где есть возможность изменения состояния — stateful-система, ведь состояние надо же где-то держать.

Но давайте не будем передергивать и ограничим контекст процессом веб-сервера, принимающего запросы пользователей (ну и сам протокол в придачу, который stateless by design). Вот тут речь о том и идет — хранить все в памяти или нет. Это напрямую влияет на то, к какому серверу наш пользователь должен обращаться «при последующем запросе». 
>>Неважно где хранить — в памяти, в файлах или в удаленном хранилище типа Амазон. Важно, содержит ли единичный запрос всю необходимую информацию, чтобы дать предсказуемый ответ. 
*************
катастрофа в том, что вы не можете отличиать состояние протокола от состояния сервера. Если вы работаете через HTTP то у вас уже stateless протокол, какие бы вы костыли туда не вставили типа sessionid и прочие, от этого stateful он никогда не станет. Хотите stateful протокол? Возьмите любой ssh, telnet, вот там будет state-ов куча. Только не надо мучать HTTP.

Или даже свой протокол сделайте и через websocket его прокиньте. То что HTTP будет выступать транспортным уровнем вашего протокола не превратит его в statful. 
>> о, наконец-то словами выразили мысль, которая постоянно вертелась в виде туманных ощущений «что-то тут не так»

Верно, ведь и ip — протокол без состояния, а вот tcp — уже с состоянием — но этот факт сам по себе не делает ip протоколом с состоянием. Просто ip лежит уровнем ниже, а tcp использует его и добавляет свои фокусы. Есть и собрат tcp по уровню поверх ip — udp — который не имеет состояния. То есть, всё возможно. Можно и наоборот поверх протокола с состоянием построить протокол без состояния, если возможность протокола держать состояние не использовать.

Сделать через HTTP что-то с состоянием можно, если передавать в каждом запросе контекст. В этом случае протокол сам по себе остаётся без состояния (ему же каждый раз приходится напоминать!) а вот приложение поверх него получается с состоянием. Если бы сам протокол был с состоянием, не нужны были бы например куки. 

----------
К сожалению, веб развивается намного быстрее академической науки, точнее даже так, развивающие веб во многом не в курсе теоретических основ того, чем собственно они занимаются. «Быстро и на коленке» — вот фактически девиз веба конца 2000ых, так появился всякий ад типа <?php $a=get_from_sql(«SELECT a FROM $table_name»); ?><?$a+1?>. Только когда это стало совершенно нереально поддерживать и гонять под высокими нагрузками народ понял, что «что-то пошло не так». Пример конечно утрированный, но некоторые современные костыли ничем не лучше.

И тут выделелось два пути, интенсивный — ну что, php работает плохо, ну не переписывать же это дерьмо, давайте напишем транслятор в C или лучше сразу в машинный код и всё будет круто. Ну или сделаем всё на JS/C#/Java/%langname%, это же модно, значит будет быстро. И экстенсивный, где люди всё же вспомнили, что веб создавался как клиент-сервеное приложение, что можно вообще передать всю страницу клиенту статически и разущенная на клиенте JS программа будет общаться по REST протоколу с сервером и выводить уже нужную информацию пользователю.
--------------
Одно дело состояние протокола, а другое дело состояние сервера. Через протокол без состояния можно работать с сервером, имеющим состояние.
Серверный процесс, я имею в виду конечно. Статья и обсуждение не про протокол и не про всю серверную часть, а про процессы с состоянием. 
-----------
спорно:
<< Кука куке рознь в этом отношении. Если кука хранит ид временной сессии на сервере, где хранится ид пользователя, то это явно стэйтфулл. Если же она хранит зашифрованный ид пользователя, то это стэйтлесс. 
>>  Кука — просто механизм хранения и передачи состояния, сам процесс веб-приложения на сервере для работы с этой кукой не обязан хранить состояние в себе. Суть не в том, хранит ли кука какие-то данные или только ссылку на «состояние», а в том где это «состояние» находится фактически. 
<<  Суть как раз в том хранит кука (или ещё какой заголовок) данные, достаточные для полноценного запроса, или какие-то ссылки на какое-то объекты, хранящиеся на сервере, но явно клиенту недоступные. Одно дело, когда сервер даёт клиенту куку, о смысле которой он не знает ничего, кроме того, что должен каждый раз её серверу давать, а совсем другое, если клиент сам формирует куку с ид пользователя. 
>>  Также клиент сам формирует URL, по которому обращается. Но каким образом все это внезапно делает веб-приложение непременно завязаным на состоянии конкретного сервера? 
<<  Не непременно, а большей частью. Банальный пример — при первом запросе (аутентификации) получаешь куку сессии, в которой хранится, как минимум, признак аутентификации, и для нормальной работы клиентской части нужно посылать всегда эту куку, но даже тогда сервер может по каким-то причинам (истекло время сеанса, например) изменить своё состояние и потребовать аутентификации заново. 
---------------------------
Как всегда склоняюсь к старому доброму «Right Tool For The Right Job».

Никто не заставляет использовать только один подход, тем более ни один не является единственно верным или в корне неверным.

Ну зачем мне stateful-подход там, где он не нужен или неудобен. И точно так же, зачем пытаться сделать непременно stateless там, где это будет хаком?

Stateless вполне себе годится для доброй (обычно бОльшей) части любого веб-приложения, где царит CRUD и иже с ним, а также прочие сценарии, где мы этот самый «state» где-то храним. Ну зачем помнить залогиненного пользователя в запущенном процессе и реализовывать sticky-sessions и продвинутую балансировку (и не говорите, что это не проблема при масштабировании), когда все можно держать в базе/Redis (сессии)/etc, а само веб-приложение держать «stateless».

С другой стороны — какой там «REST» или stateless, если у нас real-time-система или просто система с pub/sub и сокетами — тут как раз нужен запущенный процесс, держащий состояние всех участников в памяти сервера и управляющий общим состоянием и обработчиками событий в реальном времени.

P.S. Насчет REST — согласен полностью — черт пойми что под ним имеют в виду. 
*******************************
