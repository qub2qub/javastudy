__Q1__
Если у метода будут 2 аннотации @Transactional и @PostConstruct, например для разогрева кэша -- то этот метод сработает без транзакции.
Почему?
Из-за конвенций спринга по созданию объекта:
1) сначала создаётся объект
2) потом он прогоняется по всем BPP - beforeInitialization
3) потом инит методы
4) потом он прогоняется по всем BPP - afterInitialization
5) и только после всего этого(или в п.4) на него наворачиваются все прокси.
Т.е. инит метод работает до того как есть прокси для транзакций.

Как решить?
1) Например, заинжектить transaction manager в этот бин и через него вызвать транзакции.
Но это идёт в разрез с декларативным способом работы с транзакцией.
2) Или юзать Application Refresh Listener, через доп. аннотацию и её обрабтку в листенере, чтобы метод вызывался когда Spring Application Context полностью построился и обновился (refresh), т.е. бин уже до конца проинициализирован и обёрнут во все прокси.

__Q2__
Если бин описать в джава конфиге, то чего не будет в BeanDefinition?
Не будет класса бина (BeanClass).
Почему нет инфы о классе?
Т.к. в джаве пока не запущен метод, никак нельзя узнать, что этот метод вернёт.
Т.е. в методе могут быть условия, в зависимости от которых может, например, вернуться базовый класс, а можен его наследник.
Но не во всех случаях эту проблему можно решить, например для BFPP на этапе когда бины ещё не созданы -- никак не узнаешь.

__Q3__
Разница между CGLIB и Dynamic Proxy?
минусы CGLIB:
1) cglib не сможет сделать прокси если класс явл-ся final
2) с точки зрение производительности не очень хорошо
3) объекты из классов cglib-а не очень хорошо ведут себя в памяти (занимают много места)

Поэтому спринг как решает:
если класс которому спринг должен сделать прокси имплементит хотя бы 1 интерфейс, в ктором есть хотя бы 1 метод -- то тогда спринг будет делать Dynamic Proxy через интерфейсы.
А Если вообще нету интерфейсов или они все пустые без методов -- то тогда выбора нет -- и он делает класс наследник(если класс не финал) через cglib.


__Q4__
Что будет если прописать один и тот же бин в разных конфигах?

1) В XML -- 
если прописать 2 бина с 1 и тем же id то всё грохнется

2) Аннотации --
2 бина с 1 и тем же id при сканировании - всё грохнется

Но можно переопределять бины, если 1 прописан через xml, второй через аннотации.
Победит XML -- чтобы люди могли в нём переопределить beanDefinition, ничего не перекомпилируя.
