
____________ 3 модели транзакций и 4 стратегии использования транзакций. (IBM)
Платформой Java поддерживаются следующие 3 модели транзакций:
1) локальная модель (Local Transaction model);
2) программная модель (Programmatic Transaction model);
3) декларативная модель (Declarative Transaction model).
Эти модели задают:
1) основные принципы поведения транзакций. 
2) как транзакции должны реализовываться.

 При этом модели описывают только правила и семантику обработки транзакций, оставляя вопросы применения модели на усмотрение разработчика. 

----1. Локальная модель транзакций
Локальная модель транзакций получила свое имя из-за того, что управление всеми транзакциями осуществляется менеджером ресурсов базы данных, а не контейнером или инфраструктурой, в которой выполняется ваше приложение. (transactions are managed by the underlying database resource manager, not the container or framework your application is running in)
В этой модели вы управляете только соединениями, а не транзакциями.
you can't use the Local Transaction model when you make database updates using an ORM frameworks such as Hibernate, TopLink, or the Java Persistence API (JPA). 
НО вы можете применять эту модель при использовании data-access objects (DAO) or JDBC-based frameworks and database stored procedures.
Local Transaction model можно ис-ть 2 двумя способами:
1) оставить управление соединением Базе Данных (let the database manage the connection) 
[Для этого необходимо установить свойство autoCommit JDBC-объекта Connection в true (это значение используется по умолчанию). Таким образом вы указываете системе управления базой данных (СУБД), что необходимо подтверждать транзакцию после выполнения каждой операции вставки, изменения или удаления записи, либо откатывать ее в случае ошибки.]
2) программно управленять соединением (manage the connection programmatically)
[свойство autoCommit объекта Connection должно равняться false, и вам придется самостоятельно подтверждать или откатывать транзакции.]

----2. Программная модель транзакций
ответственность за управление транзакциями возлагается на разработчика, он сам управляет транзакциями, и они оказываются изолированными от низкоуровневых соединений с базой данных.
При работе с этой моделью разработчик должен самостоятельно получить ссылку на транзакцию от менеджера транзакций, начать ее, затем подтвердить, а если возникло исключение – то откатить.
Spring Framework поддерживает два способа реализации программной модели транзакций. Можно использовать либо класс TransactionTemplate, либо напрямую работать с менеджером транзакций платформы (platform transaction manager) [таких менеджеров в спринге есть по крайней мере 9 штук: DataSourceTransactionManager, HibernateTransactionManager, JpaTransactionManager, JtaTransactionManager...].
Для конфигурирования менеджера JpaTransactionManager в Spring необходимо определить объект класса org.springframework.orm.jpa.JpaTransactionManager в XML-контексте приложения и добавить в него ссылку на JPA Entity Manager Factory bean.
И потом inject-ните этот transaction manager в ваш bean.

----3. Декларативная модель транзакций
The Declarative Transaction model, otherwise known as Container Managed Transactions (CMT), is the most common transaction model in the Java platform.
При работе с этой моделью контейнер самостоятельно начинает, подтверждает и откатывает транзакции. Задачей разработчика является только описание поведения транзакций. Большинство ошибок, рассмотренных в первой статье серии, связаны с использованием именно декларативной модели.
--Атрибуты транзакций:
Required
Mandatory
RequiresNew
Supports
NotSupported
Never
*NESTED
----------
--Required - если метод вызывается в области видимости ранее начатой транзакции, то именно она будет использоваться при выполнении метода. В противном случае метод methodA() начнет новую транзакцию. 
Если methodA запустил новую транзакцию, то именно он и должен её  завершить (закомитить или откатить).

--Mandatory - если метод вызывается в области видимости ранее начатой транзакции, то именно она будет использоваться при выполнении метода. Иначе, если метод вызывается вне контекста транзакции (if methodA() is invoked without a transaction context), то будет выброшено исключение типа TransactionRequiredException, сигнализирующее о том, что транзакция должна быть начата до вызова метода methodA().

--RequiresNew - метод всегда начинает новую транзакцию (и, соответственно, эта транзакция должна быть закончена в этом же методе), вне зависимости от того, был ли вызван метод в контексте существующей транзакции или нет. Н-р, если methodA() был вызван в контексте некой транзакции (назовем ее Transaction1), то она будет приостановлена, и будет начата новая транзакция (Transaction2). При завершении метода methodA() транзакция Transaction2 либо подтверждается, либо откатывается, после чего возобновляется выполнение Transaction1. Такая схема работы очевидным образом нарушает принцип ACID (атомарность, согласованность, изолированность, стойкость) (atomicity, consistency, isolation, durability). Т.к. операции изменения данных в БД более не содержатся внутри одной единицы работы. Если транзакцию Transaction1 придется откатить, то результаты Transaction2 все равно останутся подтвержденными.

--Supports - если methodA() вызывается в области видимости существующей транзакции, то он будет выполнен внутри этой транзакции. Если же метод methodA() вызывается вне контекста транзакции, то транзакция и не будет начата вовсе.
Этот атрибут, как правило, используется для операций чтения данных из базы. почему бы в этом случае не использовать атрибут NotSupported? (Это будет означать, что метод будет выполняться вне контекста транзакции.) -> Потому что если выполнять запрос внутри транзакции, то данные будут читаться из лога транзакций базы данных, т.е. будут видны все только что сделанные изменения. Если же запрос выполняется вне транзакции, то ему будут доступны только неизменённые данные из самой таблицы. (Invoking the query operation in the context of an existing transaction will cause data to be read from the database transaction log (in other words, updated data), whereas running without a transaction scope will case the query to read unchanged data from the table) This is not necessarily a bad thing; it depends on your use case and business logic. 
Допустим, что вы добавляете новый торговый приказ в таблицу TRADE и сразу за этим, не заканчивая транзакцию, запрашиваете полный список всех приказов. В этом случае еще не подтвержденный приказ попадет в результаты запроса. Если бы использовался атрибут NotSupported, то в результаты попали бы только записи из таблицы, а не из лога транзакций, поэтому неподтвержденный заказ был бы не виден. 

--NotSupported - означает, что метод НЕ должен выполняться внутри транзакции (он не будет создавать новую транзакцию, или не будет исползовать уже существующую). Если этот атрибут указан для метода methodA(), вызванного в контексте транзакции, то она будет приостановлена до момента завершения метода. После выхода из метода выполнение транзакции будет возобновлено.
Данный атрибут имеет смысл использовать в ограниченном числе случаев, причем, как правило, они связаны с вызовом хранимых процедур (stored procedures). Если хранимая процедура вызывается в контексте существующей транзакции, но при этом содержит строку BEGIN TRANS, то будет сгенерировано исключение, говорящее о том, что новая транзакция не может быть начата. 
Если у вас нет возможности изменить код хранимой процедуры, то можно использовать атрибут NotSupported для приостановки текущей транзакции, чтобы избежать исключения. При этом теряется свойство атомарности изменений, поскольку операции с базой данных более не являются частью одной логической единицей работы (LUW).

--Never - ведет себя практически так же, как и NotSupported, за одним важным исключением: если метод, отмеченный данным атрибутом, вызывается в контексте транзакции, то выбрасывается исключение, сигнализирующее о том, что в момент вызова этого метода транзакция недопустима (a transaction is not allowed when you invoke that method).
смысл использовать: тестирование. Он позволяет легко и быстро проверить факт существования транзакции в момент вызова некоторого метода. 
*********************************
Стратегии использования транзакций (Transaction strategies):
1) стратегия клиентского дирижирования (client orchestration transaction strategy);
2) стратегия на основе интерфейсного слоя (API layer transaction strategy);
3) стратегия с высокой степенью параллелизма (High Concurrency transaction strategy);
4) высокопроизводительная стратегия (High-Speed Processing transaction strategy).

---1. Client Orchestration
is used when multiple server-based or model-based calls from the client layer fulfill a single unit of work (когда несколько клиентских обращений к серверу или к модели составляют одну единицу работы).
По сути, именно клиент определяет последовательность действий, необходимых для каждого конкретного запроса. Например, для отправки торгового приказа может быть необходимо сохранить его в базе данных, а затем обновить состояние счета клиента, отразив в нем сумму сделки. Если приложение предоставляет слишком "мелкозернистый" интерфейс, то приходится вызывать оба метода (по отдельности) на стороне клиента. В этом случае и транзакция должна определяться на клиентской стороне, чтобы гарантировать атомарность обработки запроса.

---2. API Layer
применяется, когда приложение предоставляет меньшее количество методов, которые выступают в качестве основных точек доступа к серверной функциональности (при желании такие точки можно называть сервисами).
При этом все клиенты выполняют вызов только одного серверного метода для обработки запроса. Если применить эту стратегию к предыдущему примеру с отправкой торгового приказа, то следует создать один метод (processTrade()), который будет вызываться клиентами. Он должен содержать всю логику сохранения приказа и обновления состояния счета.

---3. High Concurrency
a variation of the API Layer transaction strategy, is used for applications that cannot support long-running transactions from the API layer (usually because of performance or scalability needs).
ис-ся в тех приложениях, к-е не могут поддерживать долгие транзакции от API слоя (в основном из-за нужд производительности и масштабируемости).
High Concurrency is used primarily in applications that support a high degree of concurrency from a user perspective. Transactions are fairly expensive in the Java platform. Depending on the database you are using, they can cause locks in the database, hold up resources, slow down an application from a throughput standpoint, and in some cases even cause deadlocks in the database. The main idea behind this transaction strategy is to shorten the transaction scope so that you minimize the locks in the database while still maintaining an atomic unit of work for any given client request. In some cases, you may need to refactor your application logic to support this transaction strategy.
Т.е. приложение должно параллельно обслуживать большое число запросов от клиентов. На платформе Java транзакции обходятся достаточно дорого. В зависимости от используемой базы данных, они могут приводить к блокировкам (в некоторых случаях даже взаимным блокировкам), захвату ресурсов и ухудшению пропускной способности приложения. Главной идеей High Concurrency стратегии является сокращение контекста транзакций (transaction scope) с целью минимизации блокировок, но при этом по-прежнему сохраняя свойство атомарности при обработке любого клиентского запроса.

---4. High-Speed Processing
Высокопроизводительная стратегия является, вероятно, наиболее экстремальной из всех возможных стратегий. Она применяется в случаях, когда необходимо добиться максимальной скорости обработки запросов (и, как следствие, пропускной способности), но при этом в какой-то мере сохранить атомарность выполнения транзакций. Данная стратегия подразумевает некоторый риск для целостности и согласованности данных, однако при правильной реализации она является наиболее быстрой из всех стратегий, возможных на платформе Java. В то же время она оказывается наиболее сложной и неудобной в реализации из всех четырех стратегий