____________ Ошибки, связанные с локальными транзакциями ____________
Начать лучше всего с рассмотрения самого простого случая, а именно – локальных транзакций, также часто называемых транзакциями баз данных. В былые времена при работе с хранилищами данных (например, через JDBC) было принято оставлять обработку транзакций базе данных. В конце концов, это ее прямая обязанность, не так ли? 
Локальные транзакции идеально подходят для обработки логических единиц работы (logical units of work – LUW), выполняющих единичные операторы вставки, изменения или удаления данных.
В этом примере методы insertTrade() и updateAcct() используют JDBC, не включая их в одну транзакцию. После выполнения метода insertTrade() торговый приказ был сохранен в базе данных, и соответствующая транзакция была подтверждена. 
Если вызов метода updateAcct(), то приказ останется в таблице TRADE что будет означать несогласованность базы данных. Если бы метод placeTrade() использовал транзакции, то обе операции являлись бы частью единой LUW, и заказ на торги был бы отменен в случае сбоя при обновлении счета.

(ORM-based frameworks require a transaction in order to trigger the synchronization between the object cache and the database.
It is through a transaction commit that the SQL code is generated and the database affected by the desired action (that is, insert, update, delete). 
Without a transaction there is no trigger for the ORM to generate SQL code and persist the changes, so the method simply ends — no exceptions, no updates. If you are using an ORM-based framework, you must use transactions. You can no longer rely on the database to manage the connections and commit the work. ) 

(ORM framework-ам требуются транзакции для синхронизации содержимого их кэша объектов и базы данных. Генерация SQL-кода и изменение базы данных вследствие выполнения нужного оператора (insert, update или delete) выполняется только при подтверждении транзакции. В отсутствие транзакции некому дать сигнал ORM о том, что надо сгенерировать код SQL и выполнить изменения в базе данных, поэтому метод просто завершается, ничего не сделав, даже не выбросив исключения. При работе с ORM вы обязаны использовать транзакции. Больше нельзя полагаться на базу данных в вопросах управления соединения и подтверждения изменений.
----------------
Ошибки, связанные с аннотацией @Transactional в Spring Framework

Итак, выполнив код, приведенный в листинге 3, мы убедились, что в отсутствие транзакций метод persist() работает не так, как предполагалось.
при работе с Spring Framework следует использовать аннотацию @Transactional. Добавьте ее в код, как показано в листинге 4.

При использовании аннотации @Transactional в Spring следует добавить следующую строку в конфигурационный файл Spring:

<tx:annotation-driven transaction-manager="transactionManager"/>

В свойстве transaction-manager хранится ссылка на менеджер транзакций (transaction manager bean), определенный в конфигурационном файле Spring. 
Эта строка указывает Spring, что при применении перехватчика транзакций следует использовать аннотацию @Transactional. Без нее данная аннотация игнорируется, в результате чего транзакции в коде не используются вовсе.

при использовании аннотации @Transactional без параметров 
1) режимом распространения является REQUIRED, 
2) значением атрибута "только чтение" – false, 
3) уровень изоляции соответствует уровню изоляции по умолчанию для базы данных (как правило, это READ_COMMITTED), 
4) и транзакция не будет откатываться в случае контролируемых исключений (checked exception).
--------------------------------
____________ Ошибки для read-only flag у аннотации @Transactional 
The read-only flag is applied only if a transaction is started. 
If no transaction was started -- the read-only flag is ignored.
из-за режима распространения SUPPORTS новая транзакция не начинается, поэтому в методе используется локальная транзакция (т.е. транзакция базы данных) local (database) transaction. Флаг "только чтение" применяется только в случае начала новой транзакции, иначе - он просто игнорируется.

Если у транзакции поставить атрибут Propagation.REQUIRED, то Метод выбросит исключение, говорящее о том, что производится попытка изменения данных через соединение, разрешающее только операции чтения. 
Because a transaction is started (REQUIRED), the connection is set to read-only.

Странной особенностью флага "только чтение" является то, что он вступает в силу только с началом новой транзакции. Зачем надо начинать транзакцию, если речь идет только о чтении данных? Разумеется, этого делать не нужно. Начало транзакции при выполнении операции чтения всего лишь добавит лишних накладных расходов в обрабатывающий поток, а также может привести к появлению разделяемых блокировок чтения в базе данных (это зависит от типа используемой базы данных и уровня изоляции). Таким образом, флаг "только чтение" оказывается несколько бессмысленным при работе через JDBC и приводит к увеличению накладных расходов из-за выполнения необязательной транзакции.
-------------------------------
При ис-ии ORM-based framework  и аннотации 
@Transactional(readOnly = true, propagation=Propagation.REQUIRED)
public long insertTrade(TradeData trade) throws Exception {
   em.persist(trade);
   return trade.getTradeId();
}
возможны след. варианты:
A Throw a read-only connection exception
B Correctly insert the trade order and commit the data
C Do nothing because the readOnly flag is set to true
In some cases the answer is C, but in most cases (particularly when using JPA) the answer is B: The trade order is correctly inserted into the database without error.

!! Потому что это только при ис-ии JDBC и режима Propagation.REQUIRED будет выброшено исключение, а в случае с ORM framework-ами read-only flag работает иначе:
When you are generating a key on an insert, the ORM framework will go to the database to obtain the key and subsequently perform the insert. For some vendors, such as Hibernate, the flush mode will be set to MANUAL, and no insert will occur for inserts with non-generated keys. The same holds true for updates.
начало и завершение транзакции приводят к увеличению продолжительности обработки и повышенному расходованию ресурсов. Итак, можно сделать следующий вывод: при использовании ORM флаг "только чтение", как правило, бесполезен, и в большинстве случаев игнорируется. 

!! Однако если вы все же хотите его использовать, то обязательно установите режим распространения SUPPORTS, чтобы избежать запуска транзакций.

Еще лучше вообще не использовать аннотацию @Transactional при чтении данных из БД.
----------------------------
Ошибки, связанные с атрибутом транзакций REQUIRES_NEW

При работе со Spring Framework или EJB использование атрибута транзакций REQUIRES_NEW может привести к негативным результатам, в частности, к искажению данных или потере согласованности. Этот атрибут всегда запускает новую транзакцию при начале выполнения метода вне зависимости от того, существует ли ранее начатая транзакция. Многие разработчики некорректно используют атрибут REQUIRES_NEW, предполагая, что это правильный способ гарантии запуска транзакции.

Проблемы, связанные с атрибутом REQUIRES_NEW, возникают в случае, если методы (каждый из которых имеет аннотацию с REQUIRES_NEW) вызываются внутри одной логической единицы работы (LUW) путем межсервисного или программного взаимодействия. И если первый отработает нормально, а второй выбросит исключение - то первый останется закоимичен в БД, а второй откатится. Если нужно было чтобы они оба (или ни один из них) закомитился - то тут будет ошибка.

Использование атрибута транзакции REQUIRES_NEW означает, что выполнение существующей транзакции (если таковая есть) прерывается, и начинается новая транзакция. После завершения метода новая транзакция подтверждается, а старая – возобновляется. 
Вследствие такого поведения атрибут REQUIRES_NEW должен использоваться только в случае, если операция с базой данных должна быть подтверждена вне зависимости от результатов внешней транзакции.
---------------- *****************

____________Ошибки, связанные с откатом транзакций
upon a checked exception (и the Spring Framework и EJB) -- the transaction commits any work that has not yet been committed.
при выбросе контролируемого исключения в Spring Framework или EJB транзакция всё равно подтвердит все неподтвержденные к этому моменту изменения.
Т.е. если транзакция в методе состоит из нескольких операций, и возникнет checked exception, то транзакция потом всё равно успешно завершится, и все изменения, к-е были сделаны до возникновения exception, будут закомичены в БД.
---
Run-time exceptions (that is, unchecked exceptions) automatically force the entire logical unit of work to roll back
Исключения времени выполнения (неконтролируемые исключения) автоматически приводят к откату всей логической единицы работы (т.е. транзакции), а контролируемые исключения – нет.

Пэтому если метод сам выбросил и сам же словил в своём же try-catch блоке обычное checked exception -- то использование @Transactional у этого метода бессмысленно с точки зрения транзакций (т.к. она всё равно не соблюдается, и statement-ы выполняются частично и несогласованно).

Подобное поведение может показаться странным, однако для такого поведения у транзакций есть свои обоснования:
1)не все контролируемые исключения (checked exceptions) плохие, т.к.  они могут использоваться для отправки уведомлений или передачи управления на основе заданного условия.
2) код сам может обработать некоторые типы контролируемых исключений (checked exceptions), т.е. исправить проблемную ситуацию, и тем самым в конце он сможет завершить транзакцию успешно (т.е. закомитить её). 

(Например, приложение для книжного Интернет-магазина. Для завершения заказа приложение должно отправить клиенту подтверждение по электронной почте. Если сервер e-mail неработоспособен, то будет выброшено контролируемое исключение SMTP, сигнализирующее о невозможности отправки сообщения. Если бы контролируемые исключения автоматически приводили к откату транзакций, то весь заказ на покупку книг был бы отменен только потому, что сервер не смог отправить почту. 
By not automatically rolling back on checked exceptions, you can catch that exception and perform some sort of corrective action (such as sending the message to a pending queue) and commit the rest of the order.)
--------------
Если вы используете декларативную модель транзакций (она более подробно описывается во второй статье этой серии), то необходимо указать, как именно контейнер или инфраструктура (framework) должны обрабатывать контролируемые исключения. В Spring Framework это делается при помощи параметра rollbackFor в аннотации @Transactional.
Значением этого параметра может быть:
1) класс исключения, 
2) массив подобных классов. 
Или можно использовать параметр rollbackForClassName для задания имен исключений в строковом виде. 
Существует также обратный параметр noRollbackFor для указания того, что любое исключение, кроме заданных, должно приводить к откату транзакции. Как правило, большинство разработчиков указывают в качестве значения Exception.class, что означает, что все исключения, выбрасываемые данным методом, должны приводить к откату транзакции.
