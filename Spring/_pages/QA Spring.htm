<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>QA Spring</title>
    <link rel="stylesheet" href="../Git Guide/grey.css">
</head>
<body>
<a href="http://javastudy.ru/interview/jee-spring-questions-answers/">src1</a>
<a href="http://javastudy.ru/interview/jee-spring-questions-answers-2/">src2</a>
<h2>Spring Framework</h2>

<div class="entry-body">
<h3>Вопросы</h3>
<p>1. Расскажите о Spring Framework.<br>
2. Каковы некоторые из важных особенностей и преимуществ Spring Framework?<br>
3. Что вы понимаете под Dependency Injection (DI)?<br>
4. Как реализуется DI в Spring Framework?<br>
5. Каковы преимущества использования Spring Tool Suite?<br>
6. Приведите названия некоторых важных Spring модулей.<br>
7. Что вы понимаете под аспектно-ориентированным программированием (Aspect Oriented Programming &mdash; AOP)?<br>
8. Что такое Aspect, Advice, Pointcut, JointPoint и Advice Arguments в АОП?<br>
9. В чем разница между Spring AOP и AspectJ АОП?<br>
10. Что такое IoC контейнер Spring?<br>
11. Что такое Spring бин?<br>
12. Какое значение имеет конфигурационный файл Spring Bean?<br>
13. Каковы различные способы настроить класс как Spring Bean?<br>
14. Какие вы знаете различные scope у Spring Bean?<br>
15. Что такое жизненный цикл Spring Bean?<br>
16. Как получить объекты ServletContext и ServletConfig внутри Spring Bean?<br>
17. Что такое связывание в Spring и расскажите об аннотации @Autowired?<br>
18. Каковы различные типы автоматического связывания в Spring?<br>
19. Является ли Spring бин потокобезопасным?<br>
20. Что такое контроллер в Spring MVC?<br>
21. Какая разница между аннотациями @Component, @Repository и @Service в Spring?<br>
22. Расскажите, что вы знаете о DispatcherServlet и ContextLoaderListener.<br>
23. Что такое ViewResolver в Spring?<br>
24. Что такое MultipartResolver и когда его использовать?<br>
25. Как обрабатывать исключения в Spring MVC Framework?<br>
26. Как создать ApplicationContext в программе Java?<br>
27. Можем ли мы иметь несколько файлов конфигурации Spring?<br>
28. Каковы минимальные настройки, чтобы создать приложение Spring MVC?<br>
29. Как бы вы связали Spring MVC Framework и архитектуру MVC?<br>
30. Как добиться локализации в приложениях Spring MVC?</p>

<p>31. Как мы можем использовать Spring для создания веб-службы RESTful, возвращающей JSON?<br>
32. Приведите пример часто используемых аннотаций Spring.<br>
33. Можем ли мы послать объект как ответ метода обработчика контроллера?<br>
34. Как загрузить файл в Spring MVC?<br>
35. Как проверить (валидировать) данные формы в Spring Web MVC Framework?<br>
36. Что вы знаете Spring MVC Interceptor и как он используется?<br>
37. Spring JdbcTemplate класс и его применение.<br>
38. Как использовать Tomcat JNDI DataSource в веб-приложении Spring?<br>
39. Каким образом можно управлять транзакциями в Spring?<br>
40. Расскажите о Spring DAO.<br>
41. Как интегрировать Spring и Hibernate?<br>
42. Расскажите о Spring Security.<br>
43. Как внедрить java.util.Properties в Spring Bean?<br>
44. Назовите некоторые из шаблонов проектирования, используемых в Spring Framework?<br>
45. Best Practices в Spring Framework.</p>
<h3>Ответы</h3>
<h4>1. Расскажите о Spring Framework.</h4>
<p>Spring Framework (или коротко Spring) &mdash; универсальный фреймворк с открытым исходным кодом для Java-платформы.&nbsp;Несмотря на то, что Spring Framework не обеспечивает&nbsp;какую-либо конкретную модель программирования, он стал широко распространённым в Java-сообществе главным образом как альтернатива и замена модели Enterprise JavaBeans. Spring Framework предоставляет бо́льшую свободу Java-разработчикам в проектировании; кроме того, он предоставляет хорошо документированные и лёгкие в использовании средства решения проблем, возникающих при создании приложений корпоративного масштаба.&nbsp;Обычно Spring описывают как&nbsp;облегченную платформу для построения Java-приложений, но с этим утверждением&nbsp;связаны два интересных момента. Во-первых, Spring можно использовать для построения любого приложения на языке Java (т.е. автономных, веб приложений, приложений&nbsp;JEE и т.д.), что отличает Spring от многих других платформ, таких как Apache Struts,&nbsp;которая ограничена только веб-приложениями. Во-вторых, характеристика “облегченная” в действительности не имеет никакого отношения к количеству классов или размеру дистрибутива; напротив, она определяет принцип всей философии Spring &mdash; минимальное воздействие. Платформа Spring является облегченной в том смысле, что для&nbsp;использования ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения, а если в какой-то момент вы решите больше не пользоваться Spring, то и это сделать очень просто. Обратите внимание, что речь идет&nbsp;только о ядре Spring &mdash; многие дополнительные компоненты Spring, такие как доступ к<br>
данным, требуют более тесной привязки к Spring Framework.</p>
<h4>2. Каковы некоторые из важных особенностей и преимуществ Spring Framework?</h4>
<p>Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности.</p>
<p>Spring Framework, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java.&nbsp;Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring Framework реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java. Таким образом к достоинствам Spring можно отнести:</p>
<ul>
<li>Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.</li>
<li>Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д..</li>
<li>Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI lookup (поиска).</li>
<li>Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.</li>
</ul>
<h4>3. Что вы понимаете под Dependency Injection (DI)?</h4>
<p>Внедрение зависимости (Dependency injection, DI) &mdash; процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» ( Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму. К достоинствам применения DI можно отнести:</p>
<ul>
<li>Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть&nbsp;написан для связывания вместе различных компонентов приложения. Зачастую&nbsp;этот код очень прост &mdash; при создании зависимости должен создаваться новый экземпляр соответствующего объекта.</li>
<li>Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.</li>
<li>Возможность управления общими зависимостями в единственном репозитории.&nbsp;При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны &mdash; внутри зависимого&nbsp;класса. Это приводит к распространению зависимостей по множеству классов в&nbsp;приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории&nbsp;(в Spring есть возможность хранить эту информацию в XML-файлах или Java&nbsp;классах), что существенно упрощает управление зависимостями и снижает количество возможных ошибок.</li>
<li>Улучшенная возможность тестирования. Когда классы проектируются для DI,&nbsp;становится возможной простая замена зависимостей. Это особенно полезно при&nbsp;тестировании приложения.</li>
<li>Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд&nbsp;средств DI и можете сосредоточиться на построении логики приложения, а не на&nbsp;поддерживающей DI платформе.</li>
</ul>
<h4>4. Как реализуется DI в Spring Framework?</h4>
<p>Реализация DI в Spring основана на двух ключевых концепциях Java &mdash; компонентах&nbsp;JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java&nbsp;классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также&nbsp;называемые POJO (Plain Old Java Object &mdash; простой старый объект Java)) предоставляют&nbsp;стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов.&nbsp;За счет применения DI объем кода, который&nbsp;необходим при проектировании приложения на основе интерфейсов, снижается почти&nbsp;до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от&nbsp;DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.</p>
<p>К типам реализации внедрения зависимостей в Spring относят:</p>
<p><strong>Constructor Dependency Injection</strong> &mdash; это тип внедрения зависимостей, при котором&nbsp;зависимости компонента предоставляются ему в его конструкторе (или конструкторах).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1924737778428">
		
			<div class="crayon-plain-wrap"><pre>public class ConstructorInjection {

private Dependency dependency;
  
  public ConstructorInjection(Dependency dependency) {
         this.dependency = dependency;
  }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p><strong>Setter Dependency Injection</strong>&nbsp;&mdash; контейнер IoC внедряет зависимости компонента в компонент через методы установки в стиле JavaBean.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca192e983263359">
		
			<div class="crayon-plain-wrap"><pre>public class SetterInjection {
private Dependency dependency;
   public void setDependency(Dependency dependency) {
           this.dependency = dependency;
   }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p></p>
<h4>5. Каковы преимущества использования Spring Tool Suite?</h4>
<p>Для упрощения процесса разработки основанных на Spring приложений в Eclipse&nbsp;(наиболее часто используемая <span style="color: #999999;">бесплатная</span> IDE-среда для разработки Java-приложений), в рамках&nbsp;Spring создан проект Spring IDE. Проект бесплатный. Он интегрирован в Eclipse IDE, Spring IDE,&nbsp;Mylyn (среда разработки в Eclipse, основанная на задачах), Maven for Eclipse, AspectJ&nbsp;Development Tool.</p>
<h4>6. Приведите названия некоторых важных Spring модулей.</h4>
<ul>
<li>Inversion of Control-контейнер: конфигурирование компонентов приложений и управление жизненным циклом Java-объектов.</li>
<li>Фреймворк аспектно-ориентированного программирования: работает с функциональностью, которая не может быть реализована возможностями объектно-ориентированного программирования на Java без потерь.</li>
<li>Фреймворк доступа к данным: работает с системами управления реляционными базами данных на Java-платформе, используя JDBC- и ORM-средства и обеспечивая решения задач, которые повторяются в большом числе Java-based environments.</li>
<li>Фреймворк управления транзакциями: координация различных API управления транзакциями и инструментарий настраиваемого управления транзакциями для объектов Java.</li>
<li>Фреймворк MVC: каркас, основанный на HTTP и сервлетах, предоставляющий множество возможностей для расширения и настройки (customization).</li>
<li>Фреймворк удалённого доступа: конфигурируемая передача Java-объектов через сеть в стиле RPC, поддерживающая RMI, CORBA,HTTP-based протоколы, включая web-сервисы (SOAP).</li>
<li>Фреймворк аутентификации и авторизации: конфигурируемый инструментарий процессов аутентификации и авторизации, поддерживающий много популярных и ставших индустриальными стандартами протоколов, инструментов, практик через дочерний проект Spring Security (ранее известный как Acegi).</li>
<li>Фреймворк удалённого управления: конфигурируемое представление и управление Java-объектами для локальной или удалённой конфигурации с помощью JMX.</li>
<li>Фреймворк работы с сообщениями: конфигурируемая регистрация объектов-слушателей сообщений для прозрачной обработки сообщений из очереди сообщений с помощью JMS, улучшенная отправка сообщений по стандарту JMS API.</li>
<li>Тестирование: каркас, поддерживающий классы для написания модульных и интеграционных тестов.</li>
</ul>
<h4>7. Что вы понимаете под аспектно-ориентированным программированием (Aspect Oriented Programming &mdash; AOP)?</h4>
<p>Аспектно-ориентированное программирование (АОП) &mdash; это одна из “моделей программирования текущего момента” в мире Java. АОП предоставляет возможность реализации сквозной логики &mdash; т.е. логики, которая применяется к множеству частей приложения &mdash; в одном месте и обеспечения автоматического применения этой логики по&nbsp;всему приложению.&nbsp;Подход Spring к АОП заключается в создании “динамических прокси” для целевых&nbsp;объектов и “привязывании” объектов к конфигурированному совету для выполнения&nbsp;сквозной логики.</p>
<h4>8. Что такое Aspect, Advice, Pointcut, JointPoint и Advice Arguments в АОП?</h4>
<ul>
<li><strong>Точки соединения</strong>. Точка соединения (<strong>joinpoint</strong>) &mdash; это четко определенная точка&nbsp;во время выполнения приложения. Типовые примеры точек соединения включают обращение к методу, собственно Method Invocation, инициализацию класса и&nbsp;создание экземпляра объекта. Точки соединения являются ключевой концепцией&nbsp;АОП и определяют места в приложении, в которые можно вставлять дополнительную логику с использованием АОП.</li>
<li><strong>Советы (advice)</strong>. Фрагмент кода, который должен выполняться в отдельной точке соединения, представляет собой совет (advice). Существует несколько типов советов,&nbsp;среди которых перед, когда совет выполняется до точки соединения, и после, когда совет выполняется после точки соединения. В ООП совет принимает форму&nbsp;метода внутри класса.</li>
<li><strong>Срезы</strong>. Срез (<strong>pointcut</strong>) &mdash; это коллекция точек соединения, которая используется&nbsp;для определения ситуации, когда совет должен быть выполнен. Создавая срезы,&nbsp;вы получаете точный контроль над тем, как применять совет к компонентам приложения. Как упоминалось ранее, типичной точкой соединения является Method&nbsp;Invocation. А типичный срез представляет собой коллекцию всех точек соединения Method Invocation в отдельном классе. Часто между срезами можно установить сложные отношения, чтобы обеспечить дополнительные ограничения на то,&nbsp;когда будет выполнен совет.</li>
<li><strong>Аспекты</strong>. Аспект (<strong>aspect</strong>) &mdash; это комбинация совета и срезов. Такая комбинация&nbsp;дает в результате определение логики, которая должна быть включена в приложение, и указание мест, где она должна выполняться.</li>
<li><strong>Связывание</strong>. Связывание (<strong>weaving</strong>) представляет собой процесс действительной&nbsp;вставки аспектов в определенную точку кода приложения. Для решений АОП&nbsp;времени компиляции это делается на этапе компиляции, обычно в виде дополнительного шага процесса сборки. Аналогично, для решений АОП времени выполнения связывание происходит динамически во время выполнения. В AspectJ&nbsp;поддерживается еще один механизм связывания под названием связывание во&nbsp;время загрузки (load-time weaving &mdash; LTW), который перехватывает лежащий в основе загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он&nbsp;загружается загрузчиком классов.</li>
<li><strong>Цель</strong>. Цель (<strong>target</strong>) &mdash; это объект, поток выполнения которого изменяется каким-то&nbsp;процессом АОП. На целевой объект часто ссылаются как на объект, снабженный&nbsp;советом.</li>
<li><strong>Введение</strong>. Введение (<strong>introduction</strong>) представляет собой процесс, посредством которого можно изменить структуру объекта за счет введения в него дополнительных&nbsp;методов или полей. Введение можно использовать для обеспечения реализации&nbsp;любым объектом определенного интерфейса без необходимости в том, чтобы&nbsp;класс этого объекта реализовывал такой интерфейс явно.</li>
</ul>
<h4>9. В чем разница между Spring AOP и AspectJ АОП?</h4>
<p>AspectJ де-факто является стандартом реализации АОП. Реализация АОП от Spring имеет некоторые отличия:</p>
<ul>
<li>Spring AOP немного проще, т.к. нет необходимости следить за процессом связывания.</li>
<li>Spring AOP поддерживает аннотации AspectJ, таким образом мы можем работать в спринг проекте похожим образом с AspectJ проектом.</li>
<li>Spring AOP поддерживает только proxy-based АОП и может использовать только один тип точек соединения &mdash; Method Invocation. AspectJ поддерживает все виды точек соединения.</li>
<li>Недостатком Spring AOP является работа только со своими бинами, которые существуют в Spring Context.</li>
</ul>
<h4>10. Что такое IoC контейнер Spring?</h4>
<p>По своей сути IoC, а, следовательно, и DI, направлены на то, чтобы предложить простой механизм для предоставления зависимостей компонента (часто называемых коллабораторами объекта) и управления этими зависимостями на протяжении всего их&nbsp;жизненного цикла. Компонент, который требует определенных зависимостей, зачастую&nbsp;называют зависимым объектом или, в случае IoC, целевым объектом. Вполне уместно&nbsp;сейчас заявить, что IoC предоставляет службы, через которые компоненты могут получать доступ к своим зависимостям, и службы для взаимодействия с зависимостями в&nbsp;течение их времени жизни. В общем случае IoC может быть расщеплена на два подтипа: инверсия управления (<strong>Dependency Injection</strong>) и инверсия поиска (<strong>Dependency Lookup</strong>). Инверсия управления &mdash; это крупная часть того, делает&nbsp;Spring, и ядро реализации Spring основано на инверсии управления, хотя также предоставляются и средства Dependency Lookup. Когда платформа Spring предоставляет&nbsp;коллабораторы зависимому объекту автоматически, она делает это с использованием&nbsp;инверсии управления (Dependency Injection). В приложении, основанном на Spring, всегда предпочтительнее применять Dependency Injection для передачи коллабораторов&nbsp;зависимым объектам вместо того, чтобы заставлять зависимые объекты получать коллабораторы через поиск.</p>
<h4>11. Что такое Spring бин?</h4>
<p>Термин <strong>бин</strong> в Spring используется для ссылки на <strong>любой компонент, управляемый контейнером</strong>. Обычно бины на&nbsp;определенном уровне придерживаются спецификации JavaBean, но это не обязательно&nbsp;особенно если для связывания бинов друг с другом планируется применять Constructor&nbsp;Injection. Для получения экземпляра бина используется ApplicationContext. IoC контейнер управляет жизненным циклом спринг бина, областью видимости и внедрением.</p>
<h4>12. Какое значение имеет конфигурационный файл Spring Bean?</h4>
<p>Конфигурационный файл спринг определяет все бины, которые будут инициализированы в Spring Context. При создании экземпляра Spring ApplicationContext будет прочитан конфигурационный xml файл и выполнены указанные в нем необходимые инициализации. Отдельно от базовой конфигурации, в файле могут содержаться описание перехватчиков (interceptors), view resolvers, настройки локализации и др..</p>
<h4>13. Каковы различные способы настроить класс как Spring Bean?</h4>
<p>Существует несколько способов работы с классами в Spring:</p>
<p><strong>XML конфигурация</strong>:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca193a723340125">
		
			<div class="crayon-plain-wrap"><pre>&lt;bean name="myBean" class="ru.javastudy.spring.beans.MyBean"&gt;&lt;/bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p><strong>Java based конфигурация</strong>. Все настройки и указания бинов прописываются в java коде:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca193f452381039">
		
			<div class="crayon-plain-wrap"><pre>@Configuration
@ComponentScan(value="ru.javastudy.spring.main")
public class MyConfiguration {
 
    @Bean
    public MyService getService(){
        return new MyService();
    }
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Для извлечения бина из контекста используется следующий подход:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1941138256745">
		
			<div class="crayon-plain-wrap"><pre>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(
        MyConfiguration.class);
MyService service = ctx.getBean(MyService.class);</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p><strong>Annotation based конфигурация</strong>. Можно использовать внутри кода аннотации @Component, @Service, @Repository, @Controller для указания классов в качестве спринг бинов. Для их поиска и управления контейнером прописывается настройка в xml файле:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1944706918134">
		
			<div class="crayon-plain-wrap"><pre>&lt;context:component-scan base-package="ru.javastudy.spring" /&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>14. Какие вы знаете различные scope у Spring Bean?</h4>
<p>В Spring предусмотрены различные области времени действия бинов:</p>
<ol>
<li><strong>singleton</strong> &mdash; может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.</li>
<li><strong>prototype</strong> &mdash; создается новый экземпляр при каждом запросе<strong>.</strong></li>
<li><strong>request</strong> &mdash;&nbsp;&nbsp;аналогичен prototype, но название служит пояснением к использованию бина в веб приложении<strong>.&nbsp;</strong>Создается новый экземпляр при каждом HTTP request.</li>
<li><strong>session</strong>&nbsp;&mdash; новый бин создается в контейнере при каждой новой HTTP сессии.</li>
<li><strong>global-session</strong>: используется для создания глобальных бинов на уровне сессии для Portlet &nbsp;приложений.</li>
</ol>
<h4>15. Что такое жизненный цикл Spring Bean?</h4>
<p>Жизненный цикл Spring бина &mdash; время существования класса. Spring бины инициализируются при инициализации Spring контейнера и происходит внедрение всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё содержимое. Если нам необходимо задать какое-либо&nbsp;действие при инициализации и уничтожении бина, то нужно воспользоваться методами <span style="color: #920000;">init()</span> и <span style="color: #920000;">destroy()</span>. Для этого можно использовать аннотации <span style="color: #920000;">@PostConstruct</span> и <span style="color: #920000;">@PreDestroy()</span>.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1948485307809">
		
			<div class="crayon-plain-wrap"><pre> @PostConstruct
    public void init(){
        System.out.println("Bean init method called");
    }
     

    @PreDestroy
    public void destroy(){
        System.out.println("Bean destroy method called");
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p>Или через xml конфигурацию:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca194a845663339">
		
			<div class="crayon-plain-wrap"><pre>&lt;bean name="myBean" class="ru.javastudy.spring.MyBean"
        init-method="init" destroy-method="destroy"&gt;
    &lt;property name="someProp" ref="someProp"&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<h4>16. Как получить объекты ServletContext и ServletConfig внутри Spring Bean?</h4>
<p>Доступны два способа для получения основных объектов контейнера внутри бина:</p>
<ul>
<li>Реализовать один из Spring*Aware (<span style="color: #920000;">ApplicationContextAware</span>,&nbsp;<span style="color: #920000;">ServletContextAware</span>,&nbsp;<span style="color: #920000;">ServletConfigAware</span> и др.) интерфейсов.</li>
<li>Использовать автоматическое связывание <span style="color: #920000;">@Autowired</span> в спринг. Способ работает внутри контейнера спринг.</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca194d699525119">
		
			<div class="crayon-plain-wrap"><pre>@Autowired
ServletContext servletContext;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->
<p></p>
<h4>17. Что такое связывание в Spring и расскажите об аннотации @Autowired?</h4>
<p>Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания <span style="color: #920000;">@Autowired</span>. Аннотация может использоваться над полем или методом для связывания по типу. Чтобы аннотация заработала, необходимо указать небольшие настройки в конфигурационном файле спринг с помощью элемента <strong>context:annotation-config</strong>.</p>
<h4>18. Каковы различные типы автоматического связывания в Spring?</h4>
<p>Существует четыре вида связывания в спринг:</p>
<ul>
<li>autowire<strong> byName,</strong></li>
<li>autowire<strong> byType,</strong></li>
<li>autowire <strong>by constructor,</strong></li>
<li>autowiring by<strong> @Autowired and @Qualifier annotations</strong></li>
</ul>
<h4>19. Является ли Spring бин потокобезопасным?</h4>
<p>По умолчанию бин задается как синглтон в Spring. Таким образом все публичные &nbsp;переменные класса могут быть изменены одновременно из разных мест. Так что &mdash; нет, не является. Однако поменяв область действия бина на <span style="color: #920000;">request</span>, <span style="color: #920000;">prototype</span>, <span style="color: #920000;">session</span> он станет потокобезопасным, но это скажется на производительности.</p>
<h4>20. Что такое контроллер в Spring MVC?</h4>
<p>Ключевым интерфейсом в Spring MVC является Controller.&nbsp;Контроллер обрабатывает запросы к действиям, осуществляемые&nbsp;пользователями в пользовательском интерфейсе, взаимодействуя с уровнем обслуживания, обновляя модель и направляя пользователей на соответствующие&nbsp;представления в зависимости от результатов выполнения.&nbsp;Controller &mdash; управление, связь между моделью и видом.</p>
<p><img src="pics/Dispatcher-servlet-diagram.png"/></p>
<p>Основным контроллером в Spring MVC является<span style="color: #920000;">&nbsp;org.springframework.web.servlet.DispatcherServlet</span>. Задается аннотацией @Controller и часто используется с аннотацией @RequestMapping, которая указывает какие запросы будут обрабатываться этим контроллером.</p>
<p>Читайте так же &mdash;&nbsp;<a href="http://javastudy.ru/spring-mvc/spring-mvc-basic/">Spring MVC &mdash; основные понятия, архитектура.</a></p>
<h4>21. Какая разница между аннотациями @Component, @Repository и @Service в Spring?</h4>
<p><strong>@Component</strong>&nbsp;используется для указания класса в качестве компонента спринг. При использовании поиска аннотаций, такой класс будет сконфигурирован как spring bean.</p>
<p><strong>@Controller</strong>&nbsp;специальный тип класса, применяемый в MVC приложениях. Обрабатывает запросы и часто используется с аннотацией @RequestMapping.</p>
<p><strong>@Repository</strong>&nbsp;указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DAO.</p>
<p><strong>@Service</strong>&nbsp;указывает, что класс является сервисом для реализации бизнес логики (на самом деле не отличается от Component, но просто помогает разработчику указать смысловую нагрузку класса).</p>
<p>Для указания контейнеру на класс-бин можно использовать любую из этих аннотаций. Но различные имена позволяют различать назначение того или иного класса.</p>
<h4>22. Расскажите, что вы знаете о DispatcherServlet и ContextLoaderListener.</h4>
<p><strong>DispatcherServlet</strong> &mdash; сервлет диспетчера. Этот сервлет анализирует запросы и направляет их соответствующему контроллеру для обработки.&nbsp;В Spring MVC класс <span style="color: #920000;">DispatcherServlet</span> является центральным сервлетом, который получает запросы и направляет их соответствующим контроллерам. В приложении Spring MVC может существовать произвольное количество экземпляров&nbsp;<span style="color: #920000;">DispatcherServlet</span>, предназначенных для разных целей (например, для обработки запросов пользовательского интерфейса, запросов веб-служб REST и т.д.). Каждый экземпляр <span style="color: #920000;">DispatcherServlet</span> имеет собственную конфигурацию <span style="color: #920000;">WebApplicationContext</span>,&nbsp;которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов&nbsp;и форматирование и т.п.</p>
<p><strong>ContextLoaderListener</strong> &mdash; слушатель при старте и завершении корневого класса Spring <span style="color: #920000;">WebApplicationContext</span>. Основным назначением является связывание жизненного цикла <span style="color: #920000;">ApplicationContext</span> и <span style="color: #920000;">ServletContext</span>, а так же автоматического создания <span style="color: #920000;">ApplicationContext</span>. Можно использовать этот класс для доступа к бинам из различных контекстов спринг. Настраивается в <span style="color: #920000;">web.xml</span>:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1954441104766">
		
			<div class="crayon-plain-wrap"><pre>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;
&lt;/context-param&gt;
 
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0013 seconds] -->
<p></p>
<h4>23. Что такое ViewResolver в Spring?</h4>
<p><strong>ViewResolver</strong> &mdash;&nbsp;распознаватель представлений. Интерфейс <span style="color: #920000;">ViewResolver</span> в Spring MVC (из пакета <span style="color: #920000;">org.springframework.web.servlet</span>) поддерживает распознавание представлений на основе логического имени, возвращаемого контроллером. Для поддержки&nbsp;различных механизмов распознавания представлений предусмотрено множество&nbsp;классов реализации. Например, класс <span style="color: #920000;">UrlBasedViewResolver</span> поддерживает прямое&nbsp;преобразование логических имен в URL. Класс <span style="color: #920000;">ContentNegotiatingViewResolver&nbsp;</span>поддерживает динамическое распознавание представлений в зависимости от типа&nbsp;медиа, поддерживаемого клиентом (XML, PDF, JSON и т.д.). Существует также несколько реализаций для интеграции с различными технологиями представлений,&nbsp;такими как FreeMarker (<span style="color: #920000;">FreeMarkerViewResolver</span>), Velocity (<span style="color: #920000;">VelocityViewResolver</span>)&nbsp;и JasperReports (<span style="color: #920000;">JasperReportsViewResolver</span>).</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1958062210312">
		
			<div class="crayon-plain-wrap"><pre>&lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources
           in the /WEB-INF/views directory --&gt;
       &lt;bean
               class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
              &lt;property name="prefix" value="/WEB-INF/views/" /&gt;
              &lt;property name="suffix" value=".jsp" /&gt;
       &lt;/bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p><span style="color: #920000;">InternalResourceViewResolver</span> &mdash; реализация <span style="color: #920000;">ViewResolver</span>, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к нему. Ищет по заданному пути, префиксу, суффиксу и имени.</p>
<p>Дополнительная информация &mdash;&nbsp;<a href="http://javastudy.ru/spring-mvc/spring-mvc-viewresolver/">Spring MVC &mdash; описание интерфейса ViewResolver</a>.</p>
<h4>24. Что такое MultipartResolver и когда его использовать?</h4>
<p>Интерфейс&nbsp;MultipartResolver используется для загрузки файлов. Существуют две реализации:&nbsp;CommonsMultipartResolver и&nbsp;StandardServletMultipartResolver, которые позволяют фреймворку загружать файлы. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca195c353344477">
		
			<div class="crayon-plain-wrap"><pre> &lt;beans:bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;
 
         &lt;!-- setting maximum upload size --&gt;
        &lt;beans:property name="maxUploadSize" value="100000" /&gt;
 
  &lt;/beans:bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0016 seconds] -->
<p></p>
<p class="entry-title">Пример &mdash; <a href="http://javastudy.ru/spring-mvc/spring-mvc-load-files/">Spring MVC &mdash; загрузка файла</a></p>
<h4>25. Как обрабатывать исключения в Spring MVC Framework?</h4>
<p>В Spring MVC интерфейс <span style="color: #920000;">HandlerExceptionResolver</span> (из пакета <span style="color: #920000;">org.springframework.web.servlet</span>) предназначен для работы с непредвиденными исключениями, возникающими во время&nbsp;выполнения обработчиков. По умолчанию <span style="color: #920000;">DispatcherServlet</span> регистрирует&nbsp;класс <span style="color: #920000;">DefaultHandlerExceptionResolver</span> (из пакета <span style="color: #920000;">org.springframework.web.servlet.mvc.support</span>). Этот распознаватель обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации <span style="color: #920000;">@ExceptionHandler</span> и передав ей в&nbsp;качестве атрибута тип исключения. В общем случае обработку исключений можно описать&nbsp;таким образом:</p>
<p><strong>Controller Based</strong> &ndash; указать методы для обработки исключения в классе контроллера. Для этого нужно пометить&nbsp;такие методы аннотацией <span style="color: #920000;">@ExceptionHandler</span>.</p>
<p><strong>Global Exception Handler</strong> &ndash; для обработки глобальных исключений спринг предоставляет аннотацию <span style="color: #920000;">@ControllerAdvice</span>.</p>
<p><strong>HandlerExceptionResolver implementation</strong> &ndash; Spring Framework предоставляет интерфейс&nbsp;<span style="color: #920000;">HandlerExceptionResolver</span>, который позволяет задать глобального обработчика исключений. Реализацию этого интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.</p>
<h4>26. Как создать ApplicationContext в программе Java?</h4>
<p>В независимой Java программе&nbsp;ApplicationContext можно создать следующим образом:</p>
<ol>
<li><strong>AnnotationConfigApplicationContext</strong>: при использовании Spring в качестве автономного приложения можно создать, инициализировать контейнер с помощью аннотаций.</li>
<li><strong>ClassPathXmlApplicationContext</strong>: второй подход использует xml файл, в котором задаются необходимые настройки, а затем используем класс для загрузки файла и получения объекта контейнера.</li>
<li><strong>FileSystemXmlApplicationContext</strong>: аналогичен варианту с xml, но с возможностью загрузки файла конфигурации из любого места файловой системы.</li>
</ol>
<h4>27. Можем ли мы иметь несколько файлов конфигурации Spring?</h4>
<p>С помощью указания contextConfigLocation можно задать несколько файлов конфигурации Spring. Параметры указываются через запятую или пробел:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1961510362978">
		
			<div class="crayon-plain-wrap"><pre>&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml,/WEB-INF/spring/appServlet/servlet-jdbc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0026 seconds] -->
<p>Поддерживается возможность указания нескольких корневых файлов конфигурации Spring:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1964644802563">
		
			<div class="crayon-plain-wrap"><pre>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/spring/root-context.xml /WEB-INF/spring/root-security.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>Файл конфигурации можно импортировать:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca1966589783491">
		
			<div class="crayon-plain-wrap"><pre>&lt;beans:import resource="spring-jdbc.xml"/&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<h4>28. Каковы минимальные настройки, чтобы создать приложение Spring MVC?</h4>
<p>Для создания простого Spring MVC приложения необходимо пройти следующие шаги:</p>
<ul>
<li>Добавить зависимости&nbsp;spring-context и spring-webmvc в проект.</li>
<li>Указать DispatcherServlet в web.xml для обработки запросов внутри приложения.</li>
<li>Задать определение spring bean (аннотацией или в xml). Добавить определение view resolver для представлений.</li>
<li>Настроить класс контроллер для обработки клиентских запросов.</li>
</ul>
<p>Смотрите пример&nbsp;<a href="http://javastudy.ru/spring-mvc/hello-world-example/">Spring MVC &mdash; Hello World, пример приложения. </a></p>
<h4>29. Как бы вы связали Spring MVC Framework и архитектуру MVC?</h4>
<ul>
<li>Моделью (Model) выступает любой Java bean в Spring. Внутри класса могут быть заданы различные атрибуты и свойства для использования в представлении.</li>
<li>Преставление (View) &mdash; JSP страница, HTML файл и т.п. служат для отображения необходимой информации пользователю. Представление передает обработку запросов к диспетчеру сервлетов (контроллеру).</li>
<li>DispatcherServlet (Controller) &mdash; это главный контроллер в приложении Spring MVC, который обрабатывает все входящие запросы и передает их для обработки в различные методы в контроллеры.</li>
</ul>
<h4>30. Как добиться локализации в приложениях Spring MVC?</h4>
<p>Spring MVC предоставляет очень простую и удобную возможность локализации приложения. Для этого необходимо сделать следующее:</p>
<ul>
<li>Создать файл resource bundle, в котором будут заданы различные варианты локализированной информации.</li>
<li>Определить messageSource в конфигурации Spring используя классы&nbsp;ResourceBundleMessageSource или ReloadableResourceBundleMessag<wbr></wbr>eSource.</li>
<li>Определить localeResolver класса&nbsp;CookieLocaleResolver для включения возможности переключения локали.</li>
<li>С помощью элемента spring:message DispatcherServlet будет определять в каком месте необходимо подставлять локализированное сообщение в ответе.</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58ce417ca196b761712275">
		
			<div class="crayon-plain-wrap"><pre>&lt;beans:bean id="messageSource"
    class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
    &lt;beans:property name="basename" value="classpath:messages" /&gt;
    &lt;beans:property name="defaultEncoding" value="UTF-8" /&gt;
&lt;/beans:bean&gt;
 
&lt;beans:bean id="localeResolver"
    class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;
    &lt;beans:property name="defaultLocale" value="en" /&gt;
    &lt;beans:property name="cookieName" value="myAppLocaleCookie"&gt;&lt;/beans:property&gt;
    &lt;beans:property name="cookieMaxAge" value="3600"&gt;&lt;/beans:property&gt;
&lt;/beans:bean&gt;
 
&lt;interceptors&gt;
    &lt;beans:bean
        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
        &lt;beans:property name="paramName" value="locale" /&gt;
    &lt;/beans:bean&gt;
&lt;/interceptors&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0042 seconds] -->
<p>Читайте пример&nbsp;<a href="http://javastudy.ru/spring-mvc/localization/">Spring MVC &mdash; локализация (выбор языка)</a></p>
<p>&nbsp;</p>	</div>

<div class="entry-body">
<h4>31. Как мы можем использовать Spring для создания веб-службы RESTful, возвращающей JSON?</h4>
<p>Spring Framework позволяет создавать Restful веб сервисы и возвращать данные в формате JSON. Spring обеспечивает интеграцию с Jackson JSON API для возможности отправки JSON ответов в restful web сервисе. Для отправки ответа в формате JSON из Spring MVC приложения необходимо произвести следующие настройки:</p>
<ul>
<li>Добавить зависимости Jackson JSON. С помощью maven это делается так:</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f6c345489514">
		
			<div class="crayon-plain-wrap"><pre>&lt;!-- Jackson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;${jackson.databind-version}&lt;/version&gt;
&lt;/dependency&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<ul>
<li>Настроить бин&nbsp;<span style="color: #920000;">RequestMappingHandlerAdapter</span> в файле конфигурации Spring и задать свойство <span style="color: #920000;">messageConverters</span> на использование бина&nbsp;<span style="color: #920000;">MappingJackson2HttpMessageConverter</span>.</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f74347917051">
		
			<div class="crayon-plain-wrap"><pre>&lt;!-- Configure to plugin JSON as request and response in method handler --&gt;
&lt;beans:bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;
    &lt;beans:property name="messageConverters"&gt;
        &lt;beans:list&gt;
            &lt;beans:ref bean="jsonMessageConverter"/&gt;
        &lt;/beans:list&gt;
    &lt;/beans:property&gt;
&lt;/beans:bean&gt;
  
&lt;!-- Configure bean to convert JSON to POJO and vice versa --&gt;
&lt;beans:bean id="jsonMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt;
&lt;/beans:bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0017 seconds] -->
<p></p>
<ul>
<li>В контроллере указать с помощью аннотации <span style="color: #920000;">@ResponseBody</span> возвращение <span style="color: #920000;">Object</span>:</li>
</ul>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f78102322765">
		
			<div class="crayon-plain-wrap"><pre>@RequestMapping(value = EmpRestURIConstants.GET_EMP, method = RequestMethod.GET)
public @ResponseBody Employee getEmployee(@PathVariable("id") int empId) {
    logger.info("Start getEmployee. ID="+empId);
      
    return empData.get(empId);
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p></p>
<h4>32. Приведите пример часто используемых аннотаций Spring.</h4>
<ul>
<li><strong>@Controller</strong> &ndash; класс фронт контроллера в проекте&nbsp;Spring MVC.</li>
<li><strong>@RequestMapping</strong> &ndash; позволяет задать&nbsp;шаблон маппинга URI в методе обработчике контроллера.</li>
<li><strong>@ResponseBody</strong> &ndash; позволяет отправлять&nbsp;Object в ответе. Обычно используется для отправки данных формата XML или&nbsp;JSON.</li>
<li><strong>@PathVariable</strong> &ndash; задает динамический маппинг значений из URI внутри аргументов метода обработчика.</li>
<li><strong>@Autowired</strong> &ndash; используется для автоматического связывания зависимостей в spring beans.</li>
<li><strong>@Qualifier</strong> &ndash; используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов).</li>
<li><strong>@Service</strong> &ndash; указывает что класс осуществляет сервисные функции.</li>
<li><strong>@Scope</strong> &ndash;&nbsp;указывает&nbsp;scope у&nbsp;spring bean.</li>
<li><strong>@Configuration</strong>, <strong>@ComponentScan</strong> и&nbsp;<strong>@Bean</strong> &ndash; для&nbsp;java based configurations.</li>
<li>AspectJ аннотации для настройки&nbsp;aspects и&nbsp;advices, <strong>@Aspect</strong>, <strong>@Before</strong>, <strong>@After</strong>,<strong>@Around</strong>, <strong>@Pointcut</strong>&nbsp;и др.</li>
</ul>
<h4>33. Можем ли мы послать объект как ответ метода обработчика контроллера?</h4>
<p>Да, это возможно. Для этого используется аннотация <span style="color: #920000;">@ResponseBody</span>. Так можно отправлять ответы в виде JSON, XML в restful веб сервисах.</p>
<h4>34. Как загрузить файл в Spring MVC?</h4>
<p>Внутри спринг предусмотрен интерфейс&nbsp;<strong>MultipartResolver </strong>для обеспечения загрузки файлов.&nbsp;Фактически нужно настроить файл конфигурации для указания обработчика загрузки файлов, а затем задать необходимый метод в контроллере spring.</p>
<p>Смотрите пример &mdash;&nbsp;<a href="http://javastudy.ru/spring-mvc/spring-mvc-load-files/">Spring MVC &mdash; загрузка файла</a>&nbsp;или&nbsp;<a href="http://javastudy.ru/spring-mvc/spring-mvc-load-file-with-validation/">Spring MVC &mdash; загрузка файла с валидацией</a>.</p>
<h4>35. Как проверить (валидировать) данные формы в Spring Web MVC Framework?</h4>
<p>Spring поддерживает аннотации валидации из JSR-303, а так же возможность создания своих реализаций классов валидаторов. Пример использования аннотаций:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f7d008700993">
		
			<div class="crayon-plain-wrap"><pre>    @Size(min=2, max=30) 
    private String name;
      
    @NotEmpty @Email
    private String email;
      
    @NotNull @Min(18) @Max(100)
    private Integer age;
      
    @NotNull
    private Gender gender;
      
    @DateTimeFormat(pattern="MM/dd/yyyy")
    @NotNull @Past
    private Date birthday;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p></p>
<h4>36. Что вы знаете о Spring MVC Interceptor и как он используется?</h4>
<p>Перехватчики в Spring (Spring Interceptor) являются аналогом Servlet Filter и позволяют перехватывать запросы клиента и обрабатывать их. Перехватить запрос клиента можно в трех местах:&nbsp;preHandle, postHandle&nbsp;и&nbsp;afterCompletion.</p>
<ul>
<li><span style="color: #920000;">preHandle</span> &mdash; метод используется для обработки запросов, которые еще не были переданы в метода обработчик контроллера. Должен вернуть <span style="color: #920000;">true</span> для передачи следующему перехватчику или в handler method. <span style="color: #920000;">False</span> укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.</li>
<li><span style="color: #920000;">postHandle</span> &mdash; вызывается&nbsp;после handler method, но до обработки <span style="color: #920000;">DispatcherServlet</span> для передачи представлению. Может использоваться для добавления параметров в объект <span style="color: #920000;">ModelAndView</span>.</li>
<li><span style="color: #920000;">afterCompletion</span> &mdash; вызывается после отрисовки представления.</li>
</ul>
<p>Для создания обработчика необходимо расширить абстрактный класс&nbsp;<span style="color: #920000;">HandlerInterceptorAdapter</span> или реализовать интерфейс&nbsp;<span style="color: #920000;">HandlerInterceptor</span>. Так же нужно указать перехватчики в конфигурационном файле Spring.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f81038786933">
		
			<div class="crayon-plain-wrap"><pre>&lt;!-- Configuring interceptors based on URI --&gt;
    &lt;interceptors&gt;
        &lt;interceptor&gt;
            &lt;mapping path="/home" /&gt;
            &lt;beans:bean class="ru.javastudy.spring.RequestProcessingTimeInterceptor"&gt;&lt;/beans:bean&gt;
        &lt;/interceptor&gt;
    &lt;/interceptors&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<h4>37. Spring JdbcTemplate класс и его применение.</h4>
<p>Spring предоставляет отличную поддержку JDBC API и предлагает класс утилиту <span style="color: #920000;">JdbcTemplate</span>, с помощью которого можно избавиться от многократного повторения похожего кода в приложении (вроде операций <span style="color: #920000;">open</span> \ <span style="color: #920000;">closing</span> <span style="color: #920000;">connection</span>; <span style="color: #920000;">ResultSet</span>, <span style="color: #920000;">PreparedStatement</span> и др.). Для подключения необходимо настроить файл конфигурации spring и получить объект&nbsp;<span style="color: #920000;">JdbcTemplate</span>. Например.</p>
<p><span style="color: #920000;">spring.xml</span>:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f85185467481">
		
			<div class="crayon-plain-wrap"><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
 
    &lt;bean id="employeeDAO" class="com.journaldev.spring.jdbc.dao.EmployeeDAOImpl"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;
     
    &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
 
        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/TestDB" /&gt;
        &lt;property name="username" value="pankaj" /&gt;
        &lt;property name="password" value="pankaj123" /&gt;
    &lt;/bean&gt;
 
&lt;/beans&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0036 seconds] -->
<p>Пример использования&nbsp;<span style="color: #920000;">JdbcTemplate</span>:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f88741800792">
		
			<div class="crayon-plain-wrap"><pre> @Override
    public void save(Employee employee) {
        String query = "insert into Employee (id, name, role) values (?,?,?)";
         
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
         
        Object[] args = new Object[] {employee.getId(), employee.getName(), employee.getRole()};
         
        int out = jdbcTemplate.update(query, args);
         
        if(out !=0){
            System.out.println("Employee saved with id="+employee.getId());
        }else System.out.println("Employee save failed with id="+employee.getId());
    }</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p></p>
<h4>38. Как использовать Tomcat JNDI DataSource в веб-приложении Spring?</h4>
<p>Для использования контейнера сервлетов настроенного на использование JNDI DataSource, необходимо задать соответствующее свойство в файле конфигурации и затем внедрять его как зависимость. Далее мы можем использовать объект <span style="color: #920000;">JdbcTemplate</span> для выполнения операций с базами данных.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f8b388747838">
		
			<div class="crayon-plain-wrap"><pre>&lt;beans:bean id="dbDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;beans:property name="jndiName" value="java:comp/env/jdbc/MyLocalDB"/&gt;
&lt;/beans:bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<h4>39. Каким образом можно управлять транзакциями в Spring?</h4>
<p>Транзакциями в Spring управляют с помощью&nbsp;Declarative Transaction Management (программное управление). Используется аннотация <span style="color: #920000;">@Transactional</span> для описания необходимости управления транзакцией. В файле конфигурации нужно добавить настройку <span style="color: #920000;">transactionManager</span> для DataSource.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f8e576909091">
		
			<div class="crayon-plain-wrap"><pre>&lt;bean id="transactionManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<h4>40. Расскажите о Spring DAO.</h4>
<p>Spring DAO предоставляет возможность работы с доступом к данным с помощью технологий вроде JDBC, Hibernate в удобном виде. Существуют специальные классы:&nbsp;<span style="color: #920000;">JdbcDaoSupport</span>,&nbsp;<span style="color: #920000;">HibernateDaoSupport</span>,&nbsp;<span style="color: #920000;">JdoDaoSupport</span>,&nbsp;<span style="color: #920000;">JpaDaoSupport</span>.</p>
<p>В Spring DAO поддерживается иерархия исключений, что помогает не обрабатывать некоторые исключения.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f91637016302">
		
			<div class="crayon-plain-wrap"><pre>import java.util.List;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
 
public class PersonDao extends JdbcDaoSupport{
 
public void insert(Person person){
String insertSql ="INSERT INTO PERSON (NAME, EMAIL) VALUES(?,?);";
String name = person.getName();
String email = person.getEmail();
 
getJdbcTemplate().update(insertSql,new Object[]{name,email});
}
 
public List&lt;Person&gt; selectAll(){
String selectAllSql = "SELECT * FROM PERSON;";
 
return getJdbcTemplate().query(selectAllSql, new PersonRowMapper());
}
 
}</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0020 seconds] -->
<p></p>
<h4>41. Как интегрировать Spring и Hibernate?</h4>
<p>Для интеграции Hibernate в Spring необходимо подключить зависимости, а так же настроить файл конфигурации Spring. Т.к. настройки несколько отличаются между проектами и версиями, то смотрите официальную документацию Spring и Hibernate для уточнения настроек для конкретных технологий.</p>
<p>Читайте (spring 4, hibernate 5) &mdash; &nbsp;<a href="http://javastudy.ru/spring-data-jpa/spring-data-jpa-helloworld/">Spring Data JPA &mdash; пример приложения Hello World. Настройки Spring Data + JPA + Hibernate + MySQL.</a></p>
<h4>42. Расскажите о Spring Security.</h4>
<p>Проект Spring Security предоставляет широкие возможности для защиты приложения. Кроме стандартных настроек для аутентификации, авторизации и распределения ролей и маппинга доступных страниц, ссылок и т.п., предоставляет защиту от различных вариантов атак (например CSRF). Имеет множество различных настроек, но остается легким в использовании.</p>
<p>Смотрите различные статьи в разделе&nbsp;<a href="http://javastudy.ru/frameworks/spring/spring-security/">Spring Security</a>.</p>
<h4>43. Как внедрить java.util.Properties в Spring Bean?</h4>
<p>Для возможности использования Spring EL для внедрения свойств (properties) в различные бины необходимо определить propertyConfigure bean, который будет загружать файл свойств.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f95455552301">
		
			<div class="crayon-plain-wrap"><pre>&lt;bean id="propertyConfigurer"
  class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="location" value="/WEB-INF/application.properties" /&gt;
&lt;/bean&gt; 
 
&lt;bean class="com.journaldev.spring.EmployeeDaoImpl"&gt;
    &lt;property name="maxReadResults" value="${results.read.max}"/&gt;
&lt;/bean&gt;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>Или через аннотации:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div style="margin-top: 12px; margin-bottom: 12px; font-size: 14px ! important; line-height: 18px ! important; height: auto;" data-settings=" minimize scroll-mouseover wrap" class="crayon-syntax crayon-theme-familiar crayon-font-arial crayon-os-pc print-yes notranslate crayon-wrapped" id="crayon-58cdd54461f98746203428">
		
			<div class="crayon-plain-wrap"><pre>@Value("${maxReadResults}") 
private int maxReadResults;</pre></div>
			<div style="position: relative; z-index: 1; overflow: hidden;" class="crayon-main">
				
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->
<p></p>
<h4>44. Назовите некоторые из шаблонов проектирования, используемых в Spring Framework?</h4>
<p>Spring Framework использует множество шаблонов проектирования, например:</p>
<ol>
<li>Singleton Pattern: Creating beans with default scope.</li>
<li>Factory Pattern: Bean Factory classes</li>
<li>Prototype Pattern: Bean scopes</li>
<li>Adapter Pattern: Spring Web and Spring MVC</li>
<li>Proxy Pattern: Spring Aspect Oriented Programming support</li>
<li>Template Method Pattern: JdbcTemplate, HibernateTemplate etc</li>
<li>Front Controller: Spring MVC DispatcherServlet</li>
<li>Data Access Object: Spring DAO support</li>
<li>Dependency Injection and Aspect Oriented Programming</li>
</ol>
<h4>45. Best Practices в Spring Framework.</h4>
<ol>
<li>Избегайте указания версий в пространстве имен, чтобы быть уверенным в использовании последних версий.</li>
<li>Разделяйте конфигурации спринг согласно их деятельности, например: <span style="color: #920000;">spring-jdbc.xml</span>, <span style="color: #920000;">spring-security.xml</span>.</li>
<li>Spring бины, которые будут использованы в различных контекстах, необходимо указывать в root context и инициализировать с помощью listener.</li>
<li>Настраивайте зависимости бинов где это возможно и избегайте автоматического связывание там, где в этом нет строгой надобности.</li>
<li>Создавайте файл свойств и считывайте его в файле конфигурации Spring для использования application level properties.</li>
<li>Для больших приложений предпочтительнее использовать настройки с помощью xml файлов конфигурации, а не аннотаций.</li>
<li>Используйте подходящие по смыслу аннотации при указании бина, например: @Service для классов бизнес логики и <span style="color: #920000;">@Repository</span> для классов для работы с данными.</li>
<li>Spring framework имеет в проекте множество модулей. Удалите все лишние зависимости, которые могут быть загружены автоматически при указании корневой библиотеки.</li>
<li>Если вы используете аспекты, убедитесь, что используете точку присоединения как можно более близко, чтобы избежать случайных проблем с обработкой лишних методов. Пользовательские аннотации могут принести существенные преимущества при использовании AOP.</li>
<li>Используйте&nbsp;dependency injection там, где это принесет явную пользу.&nbsp;Внедрение зависимостей повсюду может добавить сложностей при поддержке проекта.</li>
</ol>
<p>&nbsp;</p>	</div>


</body>
</html>