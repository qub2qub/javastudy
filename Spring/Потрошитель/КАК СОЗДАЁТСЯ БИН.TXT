Спринг делает следуюие шаги:
1) BeanDefinitionReader распарсил xml, положил в мапу по id-ку все BeanDefinition-ы
2) BeanFactory вытащил из этих BeanDefinition-ов определения BeanPostProcessor-ов, создал их и отложил их в сторонку (потому что потом с их помощью он будет настраивать все остальные бины)
3) BeanFactory создаёт остальные бины (вызвав конструктор), при этом передавая их уже во все BPP.postProcessBeforeInitialization(), которые поднастраивают каждый бин
4) У бинов вызывается init() метод
5) Дёргаются все BPP.postProcessAfterInitialization()
6) Полностью настроенные объекты попадают в контекст (IoC Container)

ЗАЧЕМ ПЕРВЫЙ ПРОХОД У BPP.postProcessBeforeInitialization() ?
после создания бина вызовав конструктор, не все поля могут быть проинициализированы.
Их инициализация произойдёт на этой фазе, вызвав все ВРР.

А ЗАЧЕМ ТОГДА ВТОРОЙ ПРОХОД У BPP.postProcessAfterInitialization() ?
По коныенциям спринга, те ВРР которые что-то в классе меняют, должны это делать на этапе postProcessAfterInitialization, потому что на предыдущем "postProcessBeforeInitialization" нужно чтобы класс сохранил оригинальную метадату, которую ис-ют другие ВРР.

--------------------------------------------------
Транзакции на этапе init-МЕТОДА ещё не настроены, т.е. делать например WarmCache в @PostConstruct ещё нет смысла.
Т.к. транзакции настраиваются в "postProcessAfterInitialization".

!! Поэтому можно сделать ТРЕТЬЮ ФАЗУ ИНИЦИАЛИЗАЦИИ.
Создать класс, который implements ApplicationListener<ContextRefreshedEvent>
и в нём намутить логику для вызова метода с аннотацией например @AfterProxy, которая определена в методе интерфейса (т.к. уже будут прокси классы).

******************************************************
Спринг делает следующие шаги:
1) просканировал xml
2) создились bean definitions (спринг понял, какие бины ему создать и что в них проинжектить)
3) при помощи reflection спринг запустил его конструктор
4) конструктор отработал, объект создался
5) и после создания объекта спринг может его настраивать (инжектить поля) и поэтому если в конструкторе обращаемся к каким-то полям, их может ещё не быть, они могут не быть проинициализированы
6) поэтому можем написать init метод, в котором будет результат работы всех BPP.postProcessBeforeInitialization()


 <context:annotation-config> - загружает базовые BPP, который обработают аннотации из уже загруженных бинов. Новые бины не сканируются.
<context:component-scan> делает то же что и <context:annotation-config> ПЛЮС сканирует указанные пакеты, из которых регит бины в контекст.

