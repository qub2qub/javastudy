http://blog.bausov.pro/category/tests/

http://blog.bausov.pro/tdd-bdd-tests/
1) Тестирование при TDD и BDD 23.11.2015
TDD (или test-driven development) — подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код и только потом его реализация. TDD — процесс итеративный. Добавляя в класс что то новое, вы сначала пишите тест на новый функционал и только потом создаёте минимальное количество кода, реализующее нужное поведение. Ни строчкой больше, ни меньше. Добившись успешного прохождения теста, можно задуматься о качестве кода и сделать его рефакторинг.

Следуя TDD, вы получаете следующие преимущества:
— ваш код полностью покрыт тестами;
— cоздавая тесты до написания кода класса, вы заранее задумаетесь об его использовании, что положительно скажется как на качестве внешнего интерфейса класса, так и на архитектуре проекта в целом;
— хорошие тесты могут легко заменить документацию, т.к. наглядно демонстрируют использование трестируемого кода.

BDD (или behavior-driven development) — расширение подхода TDD к разработке и тестированию, при котором особое внимание уделяется поведению системы/модуля в терминах бизнеса(заказчика). Как правило, такие тесты иллюстрируют и тестируют различные сценарии, которые интересны непосредственно клиенту системы. В связи с этим при составлении таких тестов часто используется фреймворки, обладающие синтаксисом, обеспечивающим читаемость тестов не только программистом, но и представителями заказчика:

describe("Video", () => {
	it("should return video title", () => expect(video.getTitle()).toBe(TEST_TITLE));
	it("should return video bitrate", () => expect(video.getBitrate()).toBe(TEST_BITRATE));
});

Если TDD используется для написания тестов программистами для программистов, BDD-тесты могут быть написаны, например, техническими менеджерами или тестировщиками, что делает возможным их использование не только при формальной TDD-разработке, но и при составлении компонентных тестов, а также при формализации требований к системе.

Компонентные тесты, использующие синтаксические конструкции BDD, как правило, тестируют внешний интерфейс модуля и не обращают внимания на его внутреннюю реализацию. Такие тесты могут быть написаны непосредственно после согласования внешнего интерфейса системы, тем самым формализовав требования к системе и процесс финального тестирования. Наличие компонентных тестов, полностью покрывающих функционал системы позволяет безболезненно изменять ее внутреннюю реализацию. В связи с этим время жизни таких компонентных тестов может значительно превышать время жизни юнит-тестов, покрывающих код отдельных составляющих модуля: внутренние архитектура и реализация могут измениться, что приведёт к замене и юнит-тестов.

К компонентным и формализующим BDD тестам уже не может быть применён итеративный подход TDD. Сами тесты могут не быть такими атомарными и реализация, необходимая для их выполнения, не всегда тривиальна.

2) http://blog.bausov.pro/tests-types/
Виды тестирования программного обеспечения 21.01.2016
По видам тестирование кода можно разделить на следующие группы:
— Unit-тесты;
— Компонентные тесты;
— Интеграционные тесты;
— Приемочные тесты;
— Регрессионные тесты;
— Системные тесты.
Модульные тесты (Unit-тесты)

Unit-тест тестирует определенную функцию класса. Именно об этих тестах этого типа чаще всего идет речь при разработке по методологиям TDD(test-drive development) и BDD(behaviour-driven development). При составлении unit-тестов необходимо свести к минимуму их зависимость от кода и функционала не связанных с тестируемыми. Такая необходимость часто оказывает влияние на архитектуру системы. Это влияние чаще всего является положительным — продуманные интерфейсы, четкие контракты и ответственность составляющих систему подмодулей. Однако, в некоторых случаях желание тестировать изолированные логические конструкции приводит к излишнему усложнению — например, порождению большого количества логических слоёв, которые созданы только ради удобства тестирования. Unit-тестами должен быть покрыт весь важный функционал, а, в идеале, и весь код. Unit-тесты пишутся разработчиком, осуществляющим непосредственное кодирование.
Компонентные тесты

Компонентными являются тесты, покрывающие внешний интерфейс модуля, формализующие требования к его функционалу и трестирующие бизнес-логику модуля в целом. Компонентные тесты могут быть разработаны на стадии согласования внешнего интерфейса модуля и его проектирования. Для описания компонентных тестов удобны синтаксические конструкции BDD. Приведем пример, рассмотрим модуль авторизации, назначение которого авторизовать пользователя тем или иным способом, отправив данные на сервер и обработав ответ. Компонентным для такого модуля будет, например, тест, который проверит, что при вызове метода авторизации по email будет осуществлен запрос на сервер с соответствующими параметрами. Внутренняя реализация модуля авторизации может быть любой и включать в себя набор классов, реализующих бизнес-логику на различных уровнях. Все эти составляющие в свою очередь могут быть покрыты unit-тестами. Время жизни компонентных тестов может значительно превышать время жизни тестов, покрывающих функционал составляющих модуль классов. Компонентные тесты очень полезны при рефакторингах модуля, когда требования к его общему функционалу остаются прежними, а его внутренняя архитектура подвергается переработке.
Интеграционные тесты

Интеграционными называются тесты, проверяющие взаимодействие двух и более модулей системы. Такие тесты призваны обеспечить контроль совместимости компонентов системы при изменениях не только их внешних интерфейсов, но, иногда, и их внутренней логики.
Приемочные тесты

Приемочные тесты призваны автоматизировать тестирование системы на предмет соответствия ожиданиям заказчика. Как правило, такие тесты создаются тестировщиками после согласования требований. Такие тесты тестируют различные пользовательские сценарии и могут быть завязаны, например, на интерфейс приложения. В случае, если система представляет собой модуль или библиотеку для использования в программном коде, приемочные тесты по своему характеру будут очень схожи с компонентными тестами и могут заменить их.
Регрессионные тесты

Для предотвращения повторного появления ошибки в будущем можно создать тест, осуществляющий проверку случая, вызывающего ошибку. Тесты такого типа называются регрессионными. Регрессионным может быть как unit-тест, так и компонентный.
Системные тесты

Тесты данного вида предназначены для тестирования системы в целом — ее внешнего интерфейса, взаимодействия с внешним окружением. Системные тесты схожи с компонентными и приемочными и отличаются от них только масштабом тестируемой системы.

3) http://blog.bausov.pro/dummy-stub-mock/
Dummy, Stub, и Mock 19.04.2016


При тестировании мы частно прибегаем к замене внешних зависимостей трестируемого кода тестовыми объектами. Назначение этих объектов может варьироваться от теста к тесту. Реализация одних тестовых кейсов требует дополнительного контроля по отношению к тестовому объекту, другие ожидают от них какого то стандартного поведения. Но несмотря ни на что, интерфейсы тестового и реального объектов должны совпадать.

В зависимости от возможностей тестового объекта его можно отнести к одному из трёх типов — dummy, stub или mock.

Dummy — самый простой и базовый тестовый объект, реализующий интерфейс минимально совместимый с интерфейсом реального объекта. Код такого тестового объекта не содержит никакой логики вообще. Как правило dummy-объекты могут заменить реальные только в тех тестовых кейсах, в которых обращение к тестовому объекту не имеет значения или просто отсутствует. Например, мы тестируем модуль, с двумя зависимостями и рассматриваем его взаимодействие с первой. В таких кейсах в качестве второй зависимости может быть передан dummy-объект.

В качестве примера рассмотрим dummy простейшего объекта запроса, реализующего следующий интерфейс (здесь и далее будет использоваться синтаксис TypeScript):

interface IRequest {
	execute():JQueryPromise<void>;
}

тогда код dummy-запроса мог бы выглядеть так:

class RequestDummy implements IRequest {
	public execute():JQueryPromise<void> {
		return undefined;
	}
}

Очевидно, код трестируемого модуля не сможет использовать подобный объект запроса, однако dummy реализует минимальный интерфейс для того, чтобы компилятор не выдал ошибок несоответствия типов.

Stub — заглушка — тестовый объект, частично реализующий логику реального объекта на уровне «валидные данные на входе — валидные на выходе». Как правило, код заглушки содержит тривиальную логику, имитирующую работу нескольких методов реального объекта. Сам stub может быть получен наследованием соответствующего класса dummy и переопределением его методов.

Код, реализующий stub для примера, описанного выше, выглядит так:

class RequestStub implements IRequest {
	public execute():JQueryPromise<void> {
		return $.when();
	}
}

При использовании в качестве тестового объекта такой stub симулирует успешное выполнение запроса.

Mock — самый сложный тип тестового объекта. Наряду с логикой имитации поведения реального объекта так же содержит код, реализующий функционал контроля доступа к тем или иным методам, а также состоянию объекта в целом. По сравнению с реальным объектом mock может обладать расширенным интерфейсом, предназначенным для контроля его внутреннего состояния и получения статистики в процессе выполнения теста. Как правило, именно моковые объекты являются местом сосредоточения велосипедов и костылей в коде тестов, что негативно влияет на читаемость и понятность тестов.

Код, реализующий mock в нашем примере, может выглядеть, например так:

class RequestMock implements IRequest {
	public execute():JQueryPromise<void> {
		return this.deferred.promise();
	}

	public resolve():void {
		this.deferred.resolve();
	}

	public reject():void {
		this.deferred.reject();
	}

	private deferred:JQueryDeferred<void> = $.Deferred<void>();
}

Как видно из примера, интерфейс и функционал тестового объекта обогатился методами, позволяющими контролировать результат выполнения запроса.

Итак, мы рассмотрели классификацию тестовых объектов. В следующей статье на эту темы мы рассмотрим подход к созданию тестовых объектов с использованием библиотеки для описания тестов Jasmine.

4) http://blog.bausov.pro/private-methods-tests/
Тестирование приватных методов 19.10.2016


Часто между разработчиками возникают споры по поводу приемлемости тестирования приватных методов класса или использования их в тестах. С одной стороны, выгода от такого подхода кажется очевидной — можно отдельно протестировать сложную внутреннюю логику и добиться большего покрытия кода тестами. С другой стороны, все эти достоинства вызывают сомнения.

Отмечу, что под приватными методами класса в контексте этой статьи я понимаю методы, используемые только внутри класса и не обладающие ценностью для клиентов этого класса.

Тестирование приватных методов часто путают с тестированием по стратегии белого ящика, подразумевающей тестирование публичного интерфейса системы, при котором набор тестов, необходимых для полного покрытия функционала системы, разрабатывается с учетом её внутренней реализации.

В качестве недостатка такого подхода к тестированию часто отмечается, что использование приватных методов в тестах автоматически делает их публичными, что приводит к необоснованному распуханию внешнего интерфейса разрабатываемого класса/системы. Будь этот недостаток единственным, его можно было бы легко проигнорировать.

Тестирование приватных методов класса не ведёт к упрощению тестов и увеличению суммарного покрытию кода тестами. Наличие приватных методов в контексте, описанном выше, подразумевает также наличие другого приватного кода, использующего их. Тестирование этих методов по отдельности формально никак не скажется на сложности тестов необходимых для покрытия этого связующего кода.

Проблема очевидна и заключается в невозможности воздействовать на результат работы этих методов из вне. Получается, что наряду с тестированием приватных методов нам все равно потребуется покрыть тестами весь связующий код, что сводит пользу от их тестирования практически на нет.

Здесь стоит отметить, что сложность и количество тестов иногда можно уменьшить осуществив декомпозицию тестируемого класса и тестирование его компонентов-зависимостей по отдельности.

5) http://blog.bausov.pro/agile-age-tests/
Тестирование в эпоху Agile 29.01.2016


В последнее время я много писал о тестировании, TDD и BDD, их достоинствах, недостатках, давал полезные и не очень советы — в общем пытался формализовать своё отношение к тестированию кода. В очередной раз задумавшись о роли тестирования, поймал себя на мысли о том, почему же меня внезапно стал так интересовать этот вопрос.

В последнее время мне не раз приходилось рефакторить код продукта, разработка которого велась и ведётся по системе agile (в народе «тяп-ляп и в продакшен»). Слово «agile» на русский язык переводится как проворный. В отношение одноименного подхода к разработке «agile» перевели как «гибкий», мотивировав использование этого перевода негативным оттенком слова «проворный». Маркетинг в чистом виде. А ведь agile действительно является гибким с негативным оттенком — в agile-методологиях, как правило, отсутствует система управления и формализации требований, что со временем превращает поддержку проекта в кошмар.

Если при первичной разработке продукта все выглядит более менее сносно — память свежа и всегда можно найти человека, обладающего информацией о той или иной фиче (замена процессов формализации личным общением еще работает), то с течением времени ситуация меняется. Состав команды, поддерживающей продукт и продолжающей его разработку, постепенно меняется, заказчики отдельных фич перестают существовать физически, а для поддержки остаётся код, требования к функционалу которого разбросаны в десятках тикетов и описаны на коленке.

В один прекрасный момент выясняется, что код одного из модулей бизнес-логики изжил себя морально и требует немедленного рефакторинга с последующим внедрением новых фич. В принципе, ничего не стоит переписать модуль, если знать, что он делает и что должен делать. Однако, при отсутствии документированных требований узнать, что же должен делать модуль, не всегда легко. Код остается в прежнем виде и только обрастает костылями — никто не желает брать на себя ответственность за весь функционал модуля и, решив насущную проблему самым простым способом, оставляет все как есть.

Как оказалось, в условиях отсутствия формализованных требований, тесты — единственный островок надежды понять и не сломать то, что делает код. При любом подходе к тестированию нужно стараться описать все требования к коду на языке тестов, ведь в условиях гибкой разработки вам, возможно, не раз придётся переписывать этот код с нуля.

6) http://blog.bausov.pro/tdd-best-practices/
О граблях и тестах: дублирование кода 16.01.2016

Часто при написании тестов разработчики придерживаются подхода DRY, при котором они стремятся свести на нет дублирование кода. Дублирование кода, конечно, практика плохая, но при написании тестов подходом DRY не стоит злоупотреблять. Код тестов не должен обладать сложной архитектурой, ведь в таком случае разработчик, изменяющий существующий или добавляющий новый тест, потратит дополнительное время на то, чтобы разобраться как функционирует сам тест.

Если вы все таки выделили логику однообразных тестов в отдельную функцию, не следует помещать синтаксические конструкции фреймворка для тестирования, отвечающие за структуру тестового кейса в тело данной функции. Приведу пример:

Неправильно

testSomething("does not matter how to define an array", [1, 2, 3], new Array(1, 2, 3));

function testSomething(description:string, expected_value:SomeValue, actual_value:SomeValue) {
	it(description, () => expect(actual_value).toEquals(expected_value));
}

Код теста, приведенный выше, обладает нестандартной структурой, что плохо сказывается на его читаемости. Многие интегрированные среды разработки при падении такого теста укажут на it в теле функции, а не на конкретный вызов testSomething в коде.

Правильно

it("does not matter how to define an array", () => testSomething([1, 2, 3], new Array(1, 2, 3))); 

function testSomething(expected_value:SomeValue, actual_value:SomeValue) {
	expect(actual_value).toEquals(expected_value);
}

Независимо от типа Unit-теста, необходимо стремиться к его простоте и читаемости, поэтому не стоит злоупотреблять большим количеством проверяемых утверждений на один тест. В идеале, на один тест должна приходиться проверка одного утверждения. В случаях, когда одной проверкой тест не ограничивается, стоит задуматься как о качестве теста, так и кода, который этот тест тестирует.

7) http://blog.bausov.pro/tdd-design/
TDD и проектирование во время кодирования 20.12.2015


Несмотря на все достоинства TDD подхода к разработке, бывают ситуации, в которых TDD может быть не эффективным. TDD лёгок в применении только в тех случаях, когда программист четко представляет что именно ему нужно реализовать, а это возможно либо при разработке небольших классов, либо при достаточном предварительном проектировании разрабатываемой подсистемы.

В реальности отдельная стадия проектирования часто отсутствует и разработка архитектуры подсистемы ложится на плечи разработчика, непосредственно создающего её код. В таких случаях проектирование происходит итеративно и параллельно кодированию. При таком подходе, архитектура подсистемы может заметно эволюционировать в процессе разработки, что в свою очередь сильно сказывается как на самом характере составляющих подсистему модулей, так и на их интерфейсах.

Разработка по TDD в такой ситуации делает необходимым постоянный рефакторинг не только кода подсистемы, но и кода тестов. Очевидно, что в таких случаях подход по TDD не является эффективным — программист тратит лишние время, силы и нервы. Именно поэтому, Переходить к разработке по TDD лучше только после проектирования системы, а в нашем примере после создания каркаса проекта и согласования интерфейсов внутренних составляющих. По завершению данной стадии подсистема уже может обладать значительным функционалом, который требуется покрыть тестами пост фактум. При добавлении кода реализующего новый и уточняющего старый функционал уже можно использовать TDD.

8) http://blog.bausov.pro/tdd-requirements-formalization/
TDD и формализация требований 20.12.2015


Не так давно в посте Тестирование при TDD и BDD я писал о достоинствах TDD (test-driven development) подхода к разработке, однако, несмотря на все перечисленное, заставить себя следовать ему не всегда легко. В этой заметке, я опишу один из подходов к разработке по TDD, который поможет использовать TDD на практике.

К тестам прежде всего следует относиться как к формализованным требованиям к разрабатываемому модулю. Это значит, что к разработке конкретного класса можно подойти с точки зрения формализации требований к его функционалу в синтаксисе тестов.

Рассмотрим простой пример. Для обозначения сигнатур методов я буду использовать синтаксис Typescript. Допустим, нам необходимо реализовать класс PostList, реализующий коллекцию статей. Статья Post определяется ее содержимым, датой добавления, рейтингом полезности, а также, языком локализации. В свою очередь, коллекция должна уметь возвращать список всех статей, отсортированных по дате добавления (например, методом getPosts():Post[]), а также список статей на определенном языке и отсортированный по пользовательскому рейтингу (getPostsByLocalization(lang:Lang):Post[]). В качестве исходных данных при создании коллекции мы используем, например, JSON с соответствующими данными о статьях. Тогда в терминах тестов, требования к классу будут выглядеть примерно так:

describe("PostList", () => {
	describe("getPosts", () => {
		it("возвращает список всех статей, отсортированный по дате добавления", () => {});
	});
	describe("getPostsByLocalization", () => {
		it("возвращает только статьи, язык которых соответствует переданному в качестве параметра", () => {});
		it("возвращает список, отсортированный по рейтингу пользователя", () => {});
	});
});

Несмотря на то, что приведенная в качестве примера заготовка для тестов не содержит кода самих тестов как таковых, она дает четкое представление о том, что именно нам нужно реализовать. Добавляя тест за тестом и реализуя соответствующий функционал, мы будем уверены, что реализовали именно то, что хотели, а комментарии к кейсам тестов четко говорят о том, чего мы хотели. Формализуя все требования к классу подобным образом можно предотвратить потери в функционале при последующих рефакторингах реализации класса.

9) http://blog.bausov.pro/web-interface-auto-tests-benefits/
Что дает автоматическое тестирование интерфейса сайта 12.05.2015


Автоматическое тестирование интерфейса веб сайта при помощи систем, таких как Selenium, позволяют не только значительно сократить время и расходы на повторное тестирование, но и выявить ряд проблем, незаметных с первого взгляда.

В отличие от живого специалиста по тестированию робот(так мы для краткости будем называть программное обеспечение, при помощи которого производится тестирование) как правило лишен человеческой логики и терпения. При этом можно выделить две важные черты:

1). для работа существование элемента на странице равносильно возможности его использования;
2). робот не станет дожидаться результата дольше явно отведенного на это времени;
3). с роботом не поспоришь;

Первый пункт диктует принцип отзывчивости интерфейса — отображаются только инициализированные элементы управления. Приведу пример. В одной из компаний, в которых я работал, робот использовался для тестирования витрины интернет магазина. Робот ждал загрузки страницы и должен был кликнуть на пункт меню, инициализация которого происходила по событию загрузки документа. Все было в порядке до тех пор, пока в один прекрасный момент администрация офиса не захотела ограничить доступ к ряду ресурсов интернет, в список которых попали некоторые партнеры, счетчики которых были установлены на сайте компании. В результате браузер Firefox, в котором производилось тестирование кидал событие загрузки страницы с достаточно большой задержкой и инициализация интерфейса происходила не сразу. Робот же кликал на пункт меню, какое то время ждал положенного результата и заваливал тест. Можно подумать, что проблема заключалась в плохом доступе в интернет. Но такие ограничения очень типичны для многих компаний, а следовательно. К тому же, какое отношение счетчики и имеют к инициализации интерфейса? Таким образ тестирование при помощи робота, позволило выявить просчеты в архитектуре интерфейса, заметить, которые другими способами довольно сложно. Что касается бага, описанного в примере, то для человека, занимающегося разработкой под веб, он останется практически незаметным, — я, например, редко взаимодействую со страницей до тех пор пока индикатор загрузки страницы не исчезнет. И здесь преимущество робота очевидны, он имитирует поведение эталонного нетерпеливого пользователя.

Во-вторых, задав максимальное время ожидания выполнения тех или иных действий на сайте, можно реализовать проверку требований по скорости загрузки/отзывчивости веб-сайта. Такой подход позволит выявить огрехи в работе не только интерфейса, но и бекэнда, например, если Ajax запрос перестал отвечать в положенное время, очевидно, есть какие то проблемы в сети или на стороне сервера. Ограничивая подключение к интернет по скорости можно также выявить проблемы, которые используют клиенты при медленном соединении.

В-третьих, провалившиеся тесты — документированное доказательство наличия проблемы. Многократное автоматическое повторение тестов позволит выявить проблему достаточно быстро, даже если условия её возникновения достаточно неоднозначны.

10) http://blog.bausov.pro/auto-tests-best-practices/
Авто-тесты интерфейсов. Best practices 16.03.2016

Частой распространённой ошибкой при автоматизированном тестировании интерфейсов приложений независимо от используемого инструмента является практически полное отсутствие повторного использования кода. Каждый тест представляет из себя гигантский листинг последовательных действий, результатом которых становится не только проверка определённого тестового кейса, но и ряд вспомогательных операций для перевода приложения в состояние, в котором возможно выполнение этого кейса.

Рассмотрим простой пример. Допустим, нам нужно протестировать цепочку оформления заказа в интернет магазине. Чаще всего Приложение нельзя привести в нужное состояние вот так из коробки, поэтому тестировщик сначала добавит несколько товаров в корзину и оформит заказ. Авто-тест, воспроизводящий подобный сценарий должен повторить все эти операции. Очевидно, что ценным непосредственно для теста будет только код, описывающий действия пользователя в корзине. Остальной код носит исключительно вспомогательный характер. Допустим теперь, что оформить заказ можно как зарегистрированным, так и незарегистрированным пользователем. Т.е. Теперь у нас есть кейс, в котором мы добавляем товар в корзину, авторизуемся, и оформляем заказ, а тест, его реализующий, теперь содержит уже два вспомогательных сценария — добавления в корзину и авторизации. Именно эти сценарии — отличные кандидаты на переиспользование, ведь добавлять товары и авторизовываться нам может потребоваться и для реализации других тестовых кейсов. Теперь в случае изменения последовательности действий, необходимых, например, для того, чтобы авторизоваться, нам потребуется поправить только наш сценарий авторизации.

Отличным подходом к организации автоматизированных тестов интерфейсов является шаблон PageObject, позволяющий описывать тестовые сценарии на более высоком уровне абстракции в терминах страниц и действий доступных для выполнения на данной странице. При таком подходе, тесты оперируют с абстрактными объектами страниц и не завязаны на конкретную реализацию пользовательского интерфейса, его дизайн и верстку. При использовании шаблона PageObject изменение дизайна и верстки страниц потребует внесения изменений только во внутреннюю реализацию объекта страницы, и не затронет тестовые сценарии, оперирующие данной страницей. Описанные достоинства шаблона PageObject позволяют использовать одни и те же тесты, например, при тестировании пользовательских интерфейсов, предназначенных для различных устройств и разрешений экранов, что очень удобно.

Независимо от подхода к тестированию пользовательских интерфейсов стоит помнить, тесты пользовательских сценариев прежде всего не о вёрстке страницы, а о действиях пользователя на странице, и вся логика, осуществляющая проекцию этих действий на разметку страницы, должна быть инкапсулирована вне кода теста.
