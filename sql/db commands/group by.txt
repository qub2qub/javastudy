http://www.sql-tutorial.ru/ru/book_group_by_clause.html
 Предложение GROUP BY

Предложение GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM). 

Если GROUP BY отсутствует, и используются агрегатные функции, то все столбцы с именами, упомянутыми в SELECT, должны быть включены в агрегатные функции, и эти функции будут применяться ко всему набору строк, которые удовлетворяют предикату запроса.
В противном случае (GROUP BY присутствует) все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть указаны в предложении GROUP BY. 

    В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах.
После чего к каждой группе будут применены агрегатные функции. 
Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, то есть при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.

Если при наличии предложения GROUP BY, в предложении SELECT отсутствуют агрегатные функции, то запрос просто вернет по одной строке из каждой группы. Эту возможность, наряду с ключевым словом DISTINCT, можно использовать для исключения дубликатов строк в результирующем наборе.

SELECT model, code FROM comp.pc
GROUP BY model, code ORDER BY model;

SELECT model FROM comp.pc;
SELECT distinct model FROM comp.pc;
SELECT * FROM comp.pc;
SELECT * FROM comp.pc
WHERE speed = 500
ORDER BY  code;
--   HAVING speed = 500;

Рассмотрим простой пример:

SELECT
  model,
  COUNT(model) AS qty_model,
  AVG(price)   AS avg_price
FROM comp.pc
GROUP BY model;

или 2-х уровневая группировка:
SELECT
  model, speed,
  COUNT(model) AS qty_model,
  AVG(price)   AS avg_price
FROM comp.pc
GROUP BY model, speed;

В этом запросе для каждой модели ПК определяется их количество и средняя стоимость. 
Все строки с одинаковыми значениями model (номер модели) образуют группу, и на выходе SELECT вычисляются количество значений и средняя цена для каждой группы. 
Результатом выполнения запроса будет следующая таблица

1121    	3    	850
1232    	4    	425
1233    	3    	843,333333333333
1260    	1    	350

Если бы в SELECT присутствовал столбец с датой, то можно было бы вычислять эти показатели для каждой конкретной даты.
Для этого нужно добавить дату в качестве группирующего столбца, и тогда агрегатные функции вычислялись бы для каждой комбинации значений {модель, дата}.

Существует несколько определенных правил выполнения агрегатных функций.

     Если в результате выполнения запроса не получено ни одной строки (или ни одной строки для данной группы), то исходные данные для вычисления любой из агрегатных функций отсутствуют. 
     В этом случае результатом выполнения функций COUNT будет нуль, а результатом всех других функций — NULL.
    Данное свойство может дать не всегда очевидный результат. Рассмотрим, например, такой запрос:

SELECT 1 a
WHERE
  EXISTS(SELECT MAX(price)
         FROM comp.pc
         WHERE price < 0);
<-- Подзапрос в предикате EXISTS возвращает одну строку с NULL в качестве значения столбца. 
Поэтому, несмотря на то, что ПК с отрицательными ценами нет в базе данных, запрос в примере вернет 1.
   Аргумент агрегатной функции не может сам содержать агрегатные функции (функция от функции). То есть в простом запросе (без подзапросов) нельзя, скажем, получить максимум средних значений.

Результат выполнения функции COUNT есть целое число (INTEGER). Другие агрегатные функции наследуют типы данных обрабатываемых значений.
   Если при выполнении функции SUM будет получен результат, превышающий максимально возможное значение для используемого типа данных, возникает ошибка.

Итак, агрегатные функции, включенные в предложение SELECT запроса, не содержащего предложения GROUP BY, исполняются над всеми результирующими строками этого запроса. 
Если же запрос содержит предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляют группу, и агрегатные функции выполняются для каждой группы отдельно.

-- разный порядок группировки -- будут разные результаты
-- а может и нет.
SELECT model, speed, COUNT(model) AS qty_model, AVG(price) AS avg_price
FROM comp.pc GROUP BY model, speed ORDER BY avg_price;

SELECT model, speed, COUNT(model) AS qty_model, AVG(price) AS avg_price
FROM comp.pc GROUP BY speed, model ORDER BY avg_price;